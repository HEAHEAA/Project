var zT = Object.defineProperty;
var BT = (i, t, e) => t in i ? zT(i, t, {enumerable: !0, configurable: !0, writable: !0, value: e}) : i[t] = e;
var z = (i, t, e) => (BT(i, typeof t != "symbol" ? t + "" : t, e), e);
(function () {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]')) n(s);
    new MutationObserver(s => {
        for (const r of s) if (r.type === "childList") for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }).observe(document, {childList: !0, subtree: !0});

    function e(s) {
        const r = {};
        return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r
    }

    function n(s) {
        if (s.ep) return;
        s.ep = !0;
        const r = e(s);
        fetch(s.href, r)
    }
})();
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Hd = "149", _o = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2},
    yo = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3}, Bw = 0, Ug = 1, kw = 2, kT = 3, UT = 0, Ym = 1, Xm = 2,
    Ra = 3, Fi = 0, xs = 1, Ci = 2, GT = 2, ar = 0, Or = 1, Rc = 2, Gg = 3, Vg = 4, Uw = 5, vo = 100, Gw = 101,
    Vw = 102, Hg = 103, $g = 104, Hw = 200, $w = 201, Ww = 202, qw = 203, Zm = 204, jm = 205, Yw = 206, Xw = 207,
    Zw = 208, jw = 209, Kw = 210, Jw = 0, Qw = 1, tb = 2, rd = 3, eb = 4, nb = 5, sb = 6, ib = 7, hh = 0, rb = 1,
    ob = 2, Pi = 0, ab = 1, lb = 2, cb = 3, hb = 4, ub = 5, $d = 300, Br = 301, kr = 302, Lc = 303, Nc = 304, El = 306,
    Ur = 1e3, kn = 1001, el = 1002, sn = 1003, Oc = 1004, VT = 1004, Ba = 1005, HT = 1005, Qe = 1006, Wd = 1007,
    $T = 1007, zi = 1008, WT = 1008, Gr = 1009, db = 1010, fb = 1011, Km = 1012, pb = 1013, Lr = 1014, ir = 1015,
    nl = 1016, gb = 1017, mb = 1018, Ro = 1020, _b = 1021, Os = 1023, yb = 1024, xb = 1025, Dr = 1026, Bo = 1027,
    vb = 1028, wb = 1029, bb = 1030, Eb = 1031, Sb = 1033, qu = 33776, Yu = 33777, Xu = 33778, Zu = 33779, Wg = 35840,
    qg = 35841, Yg = 35842, Xg = 35843, Mb = 36196, Zg = 37492, jg = 37496, Kg = 37808, Jg = 37809, Qg = 37810,
    tm = 37811, em = 37812, nm = 37813, sm = 37814, im = 37815, rm = 37816, om = 37817, am = 37818, lm = 37819,
    cm = 37820, hm = 37821, ju = 36492, Tb = 36283, um = 36284, dm = 36285, fm = 36286, Ib = 2200, Ab = 2201, Cb = 2202,
    sl = 2300, ko = 2301, Ku = 2302, Mo = 2400, To = 2401, Dc = 2402, qd = 2500, Jm = 2501, Pb = 0, Qm = 1, od = 2,
    Vr = 3e3, Ee = 3001, Rb = 3200, Lb = 3201, Xr = 0, Nb = 1, qT = "", ii = "srgb", il = "srgb-linear", YT = 0,
    Ju = 7680, XT = 7681, ZT = 7682, jT = 7683, KT = 34055, JT = 34056, QT = 5386, tI = 512, eI = 513, nI = 514,
    sI = 515, iI = 516, rI = 517, oI = 518, Ob = 519, Fc = 35044, aI = 35048, lI = 35040, cI = 35045, hI = 35049,
    uI = 35041, dI = 35046, fI = 35050, pI = 35042, gI = "100", pm = "300 es", ad = 1035;
let Gi = class {
    addEventListener(t, e) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e)
    }

    hasEventListener(t, e) {
        if (this._listeners === void 0) return !1;
        const n = this._listeners;
        return n[t] !== void 0 && n[t].indexOf(e) !== -1
    }

    removeEventListener(t, e) {
        if (this._listeners === void 0) return;
        const s = this._listeners[t];
        if (s !== void 0) {
            const r = s.indexOf(e);
            r !== -1 && s.splice(r, 1)
        }
    }

    dispatchEvent(t) {
        if (this._listeners === void 0) return;
        const n = this._listeners[t.type];
        if (n !== void 0) {
            t.target = this;
            const s = n.slice(0);
            for (let r = 0, o = s.length; r < o; r++) s[r].call(this, t);
            t.target = null
        }
    }
};
const $n = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let fy = 1234567;
const Lo = Math.PI / 180, zc = 180 / Math.PI;

function zs() {
    const i = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0,
        n = Math.random() * 4294967295 | 0;
    return ($n[i & 255] + $n[i >> 8 & 255] + $n[i >> 16 & 255] + $n[i >> 24 & 255] + "-" + $n[t & 255] + $n[t >> 8 & 255] + "-" + $n[t >> 16 & 15 | 64] + $n[t >> 24 & 255] + "-" + $n[e & 63 | 128] + $n[e >> 8 & 255] + "-" + $n[e >> 16 & 255] + $n[e >> 24 & 255] + $n[n & 255] + $n[n >> 8 & 255] + $n[n >> 16 & 255] + $n[n >> 24 & 255]).toLowerCase()
}

function un(i, t, e) {
    return Math.max(t, Math.min(e, i))
}

function t0(i, t) {
    return (i % t + t) % t
}

function mI(i, t, e, n, s) {
    return n + (i - t) * (s - n) / (e - t)
}

function _I(i, t, e) {
    return i !== t ? (e - i) / (t - i) : 0
}

function Ec(i, t, e) {
    return (1 - e) * i + e * t
}

function yI(i, t, e, n) {
    return Ec(i, t, 1 - Math.exp(-e * n))
}

function xI(i, t = 1) {
    return t - Math.abs(t0(i, t * 2) - t)
}

function vI(i, t, e) {
    return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * (3 - 2 * i))
}

function wI(i, t, e) {
    return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * i * (i * (i * 6 - 15) + 10))
}

function bI(i, t) {
    return i + Math.floor(Math.random() * (t - i + 1))
}

function EI(i, t) {
    return i + Math.random() * (t - i)
}

function SI(i) {
    return i * (.5 - Math.random())
}

function MI(i) {
    i !== void 0 && (fy = i);
    let t = fy += 1831565813;
    return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296
}

function TI(i) {
    return i * Lo
}

function II(i) {
    return i * zc
}

function gm(i) {
    return (i & i - 1) === 0 && i !== 0
}

function Db(i) {
    return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
}

function ld(i) {
    return Math.pow(2, Math.floor(Math.log(i) / Math.LN2))
}

function AI(i, t, e, n, s) {
    const r = Math.cos, o = Math.sin, a = r(e / 2), l = o(e / 2), c = r((t + n) / 2), h = o((t + n) / 2),
        u = r((t - n) / 2), d = o((t - n) / 2), f = r((n - t) / 2), g = o((n - t) / 2);
    switch (s) {
        case"XYX":
            i.set(a * h, l * u, l * d, a * c);
            break;
        case"YZY":
            i.set(l * d, a * h, l * u, a * c);
            break;
        case"ZXZ":
            i.set(l * u, l * d, a * h, a * c);
            break;
        case"XZX":
            i.set(a * h, l * g, l * f, a * c);
            break;
        case"YXY":
            i.set(l * f, a * h, l * g, a * c);
            break;
        case"ZYZ":
            i.set(l * g, l * f, a * h, a * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s)
    }
}

function rr(i, t) {
    switch (t.constructor) {
        case Float32Array:
            return i;
        case Uint16Array:
            return i / 65535;
        case Uint8Array:
            return i / 255;
        case Int16Array:
            return Math.max(i / 32767, -1);
        case Int8Array:
            return Math.max(i / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function Ve(i, t) {
    switch (t.constructor) {
        case Float32Array:
            return i;
        case Uint16Array:
            return Math.round(i * 65535);
        case Uint8Array:
            return Math.round(i * 255);
        case Int16Array:
            return Math.round(i * 32767);
        case Int8Array:
            return Math.round(i * 127);
        default:
            throw new Error("Invalid component type.")
    }
}

var Fb = Object.freeze({
    __proto__: null,
    DEG2RAD: Lo,
    RAD2DEG: zc,
    ceilPowerOfTwo: Db,
    clamp: un,
    damp: yI,
    degToRad: TI,
    denormalize: rr,
    euclideanModulo: t0,
    floorPowerOfTwo: ld,
    generateUUID: zs,
    inverseLerp: _I,
    isPowerOfTwo: gm,
    lerp: Ec,
    mapLinear: mI,
    normalize: Ve,
    pingpong: xI,
    radToDeg: II,
    randFloat: EI,
    randFloatSpread: SI,
    randInt: bI,
    seededRandom: MI,
    setQuaternionFromProperEuler: AI,
    smootherstep: wI,
    smoothstep: vI
});

class j {
    constructor(t = 0, e = 0) {
        j.prototype.isVector2 = !0, this.x = t, this.y = e
    }

    get width() {
        return this.x
    }

    set width(t) {
        this.x = t
    }

    get height() {
        return this.y
    }

    set height(t) {
        this.y = t
    }

    set(t, e) {
        return this.x = t, this.y = e, this
    }

    setScalar(t) {
        return this.x = t, this.y = t, this
    }

    setX(t) {
        return this.x = t, this
    }

    setY(t) {
        return this.y = t, this
    }

    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }

    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
        }
    }

    clone() {
        return new this.constructor(this.x, this.y)
    }

    copy(t) {
        return this.x = t.x, this.y = t.y, this
    }

    add(t) {
        return this.x += t.x, this.y += t.y, this
    }

    addScalar(t) {
        return this.x += t, this.y += t, this
    }

    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this
    }

    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this
    }

    sub(t) {
        return this.x -= t.x, this.y -= t.y, this
    }

    subScalar(t) {
        return this.x -= t, this.y -= t, this
    }

    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this
    }

    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this
    }

    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this
    }

    divide(t) {
        return this.x /= t.x, this.y /= t.y, this
    }

    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }

    applyMatrix3(t) {
        const e = this.x, n = this.y, s = t.elements;
        return this.x = s[0] * e + s[3] * n + s[6], this.y = s[1] * e + s[4] * n + s[7], this
    }

    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
    }

    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
    }

    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
    }

    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
    }

    clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }

    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }

    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }

    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }

    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
    }

    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }

    dot(t) {
        return this.x * t.x + this.y * t.y
    }

    cross(t) {
        return this.x * t.y - this.y * t.x
    }

    lengthSq() {
        return this.x * this.x + this.y * this.y
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }

    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }

    normalize() {
        return this.divideScalar(this.length() || 1)
    }

    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }

    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }

    distanceToSquared(t) {
        const e = this.x - t.x, n = this.y - t.y;
        return e * e + n * n
    }

    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }

    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }

    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
    }

    lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
    }

    equals(t) {
        return t.x === this.x && t.y === this.y
    }

    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this
    }

    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t
    }

    fromBufferAttribute(t, e) {
        return this.x = t.getX(e), this.y = t.getY(e), this
    }

    rotateAround(t, e) {
        const n = Math.cos(e), s = Math.sin(e), r = this.x - t.x, o = this.y - t.y;
        return this.x = r * n - o * s + t.x, this.y = r * s + o * n + t.y, this
    }

    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }

    * [Symbol.iterator]() {
        yield this.x, yield this.y
    }
}

class ds {
    constructor() {
        ds.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }

    set(t, e, n, s, r, o, a, l, c) {
        const h = this.elements;
        return h[0] = t, h[1] = s, h[2] = a, h[3] = e, h[4] = r, h[5] = l, h[6] = n, h[7] = o, h[8] = c, this
    }

    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }

    copy(t) {
        const e = this.elements, n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
    }

    extractBasis(t, e, n) {
        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
    }

    setFromMatrix4(t) {
        const e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    }

    multiply(t) {
        return this.multiplyMatrices(this, t)
    }

    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }

    multiplyMatrices(t, e) {
        const n = t.elements, s = e.elements, r = this.elements, o = n[0], a = n[3], l = n[6], c = n[1], h = n[4],
            u = n[7], d = n[2], f = n[5], g = n[8], m = s[0], p = s[3], _ = s[6], x = s[1], y = s[4], v = s[7],
            w = s[2], E = s[5], S = s[8];
        return r[0] = o * m + a * x + l * w, r[3] = o * p + a * y + l * E, r[6] = o * _ + a * v + l * S, r[1] = c * m + h * x + u * w, r[4] = c * p + h * y + u * E, r[7] = c * _ + h * v + u * S, r[2] = d * m + f * x + g * w, r[5] = d * p + f * y + g * E, r[8] = d * _ + f * v + g * S, this
    }

    multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
    }

    determinant() {
        const t = this.elements, e = t[0], n = t[1], s = t[2], r = t[3], o = t[4], a = t[5], l = t[6], c = t[7],
            h = t[8];
        return e * o * h - e * a * c - n * r * h + n * a * l + s * r * c - s * o * l
    }

    invert() {
        const t = this.elements, e = t[0], n = t[1], s = t[2], r = t[3], o = t[4], a = t[5], l = t[6], c = t[7],
            h = t[8], u = h * o - a * c, d = a * l - h * r, f = c * r - o * l, g = e * u + n * d + s * f;
        if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m = 1 / g;
        return t[0] = u * m, t[1] = (s * c - h * n) * m, t[2] = (a * n - s * o) * m, t[3] = d * m, t[4] = (h * e - s * l) * m, t[5] = (s * r - a * e) * m, t[6] = f * m, t[7] = (n * l - c * e) * m, t[8] = (o * e - n * r) * m, this
    }

    transpose() {
        let t;
        const e = this.elements;
        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
    }

    getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose()
    }

    transposeIntoArray(t) {
        const e = this.elements;
        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
    }

    setUvTransform(t, e, n, s, r, o, a) {
        const l = Math.cos(r), c = Math.sin(r);
        return this.set(n * l, n * c, -n * (l * o + c * a) + o + t, -s * c, s * l, -s * (-c * o + l * a) + a + e, 0, 0, 1), this
    }

    scale(t, e) {
        return this.premultiply(pp.makeScale(t, e)), this
    }

    rotate(t) {
        return this.premultiply(pp.makeRotation(-t)), this
    }

    translate(t, e) {
        return this.premultiply(pp.makeTranslation(t, e)), this
    }

    makeTranslation(t, e) {
        return this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
    }

    makeRotation(t) {
        const e = Math.cos(t), n = Math.sin(t);
        return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
    }

    makeScale(t, e) {
        return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
    }

    equals(t) {
        const e = this.elements, n = t.elements;
        for (let s = 0; s < 9; s++) if (e[s] !== n[s]) return !1;
        return !0
    }

    fromArray(t, e = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this
    }

    toArray(t = [], e = 0) {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
    }

    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}

const pp = new ds;

function zb(i) {
    for (let t = i.length - 1; t >= 0; --t) if (i[t] >= 65535) return !0;
    return !1
}

const CI = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};

function La(i, t) {
    return new CI[i](t)
}

function Bc(i) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", i)
}

function No(i) {
    return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4)
}

function Qu(i) {
    return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055
}

const gp = {[ii]: {[il]: No}, [il]: {[ii]: Qu}}, Wn = {
    legacyMode: !0, get workingColorSpace() {
        return il
    }, set workingColorSpace(i) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    }, convert: function (i, t, e) {
        if (this.legacyMode || t === e || !t || !e) return i;
        if (gp[t] && gp[t][e] !== void 0) {
            const n = gp[t][e];
            return i.r = n(i.r), i.g = n(i.g), i.b = n(i.b), i
        }
        throw new Error("Unsupported color space conversion.")
    }, fromWorkingColorSpace: function (i, t) {
        return this.convert(i, this.workingColorSpace, t)
    }, toWorkingColorSpace: function (i, t) {
        return this.convert(i, t, this.workingColorSpace)
    }
}, Bb = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, wn = {r: 0, g: 0, b: 0}, Qs = {h: 0, s: 0, l: 0}, Uh = {h: 0, s: 0, l: 0};

function mp(i, t, e) {
    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + (t - i) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? i + (t - i) * 6 * (2 / 3 - e) : i
}

function Gh(i, t) {
    return t.r = i.r, t.g = i.g, t.b = i.b, t
}

let pt = class {
    constructor(t, e, n) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, e === void 0 && n === void 0 ? this.set(t) : this.setRGB(t, e, n)
    }

    set(t) {
        return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this
    }

    setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this
    }

    setHex(t, e = ii) {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Wn.toWorkingColorSpace(this, e), this
    }

    setRGB(t, e, n, s = Wn.workingColorSpace) {
        return this.r = t, this.g = e, this.b = n, Wn.toWorkingColorSpace(this, s), this
    }

    setHSL(t, e, n, s = Wn.workingColorSpace) {
        if (t = t0(t, 1), e = un(e, 0, 1), n = un(n, 0, 1), e === 0) this.r = this.g = this.b = n; else {
            const r = n <= .5 ? n * (1 + e) : n + e - n * e, o = 2 * n - r;
            this.r = mp(o, r, t + 1 / 3), this.g = mp(o, r, t), this.b = mp(o, r, t - 1 / 3)
        }
        return Wn.toWorkingColorSpace(this, s), this
    }

    setStyle(t, e = ii) {
        function n(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
        }

        let s;
        if (s = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
            let r;
            const o = s[1], a = s[2];
            switch (o) {
                case"rgb":
                case"rgba":
                    if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, Wn.toWorkingColorSpace(this, e), n(r[4]), this;
                    if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, Wn.toWorkingColorSpace(this, e), n(r[4]), this;
                    break;
                case"hsl":
                case"hsla":
                    if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                        const l = parseFloat(r[1]) / 360, c = parseFloat(r[2]) / 100, h = parseFloat(r[3]) / 100;
                        return n(r[4]), this.setHSL(l, c, h, e)
                    }
                    break
            }
        } else if (s = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const r = s[1], o = r.length;
            if (o === 3) return this.r = parseInt(r.charAt(0) + r.charAt(0), 16) / 255, this.g = parseInt(r.charAt(1) + r.charAt(1), 16) / 255, this.b = parseInt(r.charAt(2) + r.charAt(2), 16) / 255, Wn.toWorkingColorSpace(this, e), this;
            if (o === 6) return this.r = parseInt(r.charAt(0) + r.charAt(1), 16) / 255, this.g = parseInt(r.charAt(2) + r.charAt(3), 16) / 255, this.b = parseInt(r.charAt(4) + r.charAt(5), 16) / 255, Wn.toWorkingColorSpace(this, e), this
        }
        return t && t.length > 0 ? this.setColorName(t, e) : this
    }

    setColorName(t, e = ii) {
        const n = Bb[t.toLowerCase()];
        return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
    }

    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }

    copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this
    }

    copySRGBToLinear(t) {
        return this.r = No(t.r), this.g = No(t.g), this.b = No(t.b), this
    }

    copyLinearToSRGB(t) {
        return this.r = Qu(t.r), this.g = Qu(t.g), this.b = Qu(t.b), this
    }

    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }

    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }

    getHex(t = ii) {
        return Wn.fromWorkingColorSpace(Gh(this, wn), t), un(wn.r * 255, 0, 255) << 16 ^ un(wn.g * 255, 0, 255) << 8 ^ un(wn.b * 255, 0, 255) << 0
    }

    getHexString(t = ii) {
        return ("000000" + this.getHex(t).toString(16)).slice(-6)
    }

    getHSL(t, e = Wn.workingColorSpace) {
        Wn.fromWorkingColorSpace(Gh(this, wn), e);
        const n = wn.r, s = wn.g, r = wn.b, o = Math.max(n, s, r), a = Math.min(n, s, r);
        let l, c;
        const h = (a + o) / 2;
        if (a === o) l = 0, c = 0; else {
            const u = o - a;
            switch (c = h <= .5 ? u / (o + a) : u / (2 - o - a), o) {
                case n:
                    l = (s - r) / u + (s < r ? 6 : 0);
                    break;
                case s:
                    l = (r - n) / u + 2;
                    break;
                case r:
                    l = (n - s) / u + 4;
                    break
            }
            l /= 6
        }
        return t.h = l, t.s = c, t.l = h, t
    }

    getRGB(t, e = Wn.workingColorSpace) {
        return Wn.fromWorkingColorSpace(Gh(this, wn), e), t.r = wn.r, t.g = wn.g, t.b = wn.b, t
    }

    getStyle(t = ii) {
        return Wn.fromWorkingColorSpace(Gh(this, wn), t), t !== ii ? `color(${t} ${wn.r} ${wn.g} ${wn.b})` : `rgb(${wn.r * 255 | 0},${wn.g * 255 | 0},${wn.b * 255 | 0})`
    }

    offsetHSL(t, e, n) {
        return this.getHSL(Qs), Qs.h += t, Qs.s += e, Qs.l += n, this.setHSL(Qs.h, Qs.s, Qs.l), this
    }

    add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this
    }

    addColors(t, e) {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
    }

    addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this
    }

    sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }

    multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }

    multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this
    }

    lerp(t, e) {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
    }

    lerpColors(t, e, n) {
        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
    }

    lerpHSL(t, e) {
        this.getHSL(Qs), t.getHSL(Uh);
        const n = Ec(Qs.h, Uh.h, e), s = Ec(Qs.s, Uh.s, e), r = Ec(Qs.l, Uh.l, e);
        return this.setHSL(n, s, r), this
    }

    equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b
    }

    fromArray(t, e = 0) {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
    }

    toArray(t = [], e = 0) {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
    }

    fromBufferAttribute(t, e) {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
    }

    toJSON() {
        return this.getHex()
    }

    * [Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
};
pt.NAMES = Bb;
let na;

class e0 {
    static getDataURL(t) {
        if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t; else {
            na === void 0 && (na = Bc("canvas")), na.width = t.width, na.height = t.height;
            const n = na.getContext("2d");
            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = na
        }
        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
    }

    static sRGBToLinear(t) {
        if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
            const e = Bc("canvas");
            e.width = t.width, e.height = t.height;
            const n = e.getContext("2d");
            n.drawImage(t, 0, 0, t.width, t.height);
            const s = n.getImageData(0, 0, t.width, t.height), r = s.data;
            for (let o = 0; o < r.length; o++) r[o] = No(r[o] / 255) * 255;
            return n.putImageData(s, 0, 0), e
        } else if (t.data) {
            const e = t.data.slice(0);
            for (let n = 0; n < e.length; n++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(No(e[n] / 255) * 255) : e[n] = No(e[n]);
            return {data: e, width: t.width, height: t.height}
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
    }
}

class Io {
    constructor(t = null) {
        this.isSource = !0, this.uuid = zs(), this.data = t, this.version = 0
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }

    toJSON(t) {
        const e = t === void 0 || typeof t == "string";
        if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
        const n = {uuid: this.uuid, url: ""}, s = this.data;
        if (s !== null) {
            let r;
            if (Array.isArray(s)) {
                r = [];
                for (let o = 0, a = s.length; o < a; o++) s[o].isDataTexture ? r.push(_p(s[o].image)) : r.push(_p(s[o]))
            } else r = _p(s);
            n.url = r
        }
        return e || (t.images[this.uuid] = n), n
    }
}

function _p(i) {
    return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? e0.getDataURL(i) : i.data ? {
        data: Array.from(i.data),
        width: i.width,
        height: i.height,
        type: i.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}

let PI = 0, Sn = class td extends Gi {
    constructor(t = td.DEFAULT_IMAGE, e = td.DEFAULT_MAPPING, n = kn, s = kn, r = Qe, o = zi, a = Os, l = Gr, c = td.DEFAULT_ANISOTROPY, h = Vr) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {value: PI++}), this.uuid = zs(), this.name = "", this.source = new Io(t), this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = s, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new j(0, 0), this.repeat = new j(1, 1), this.center = new j(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ds, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
    }

    get image() {
        return this.source.data
    }

    set image(t) {
        this.source.data = t
    }

    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
    }

    toJSON(t) {
        const e = t === void 0 || typeof t == "string";
        if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
        const n = {
            metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }

    transformUv(t) {
        if (this.mapping !== $d) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
            case Ur:
                t.x = t.x - Math.floor(t.x);
                break;
            case kn:
                t.x = t.x < 0 ? 0 : 1;
                break;
            case el:
                Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                break
        }
        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
            case Ur:
                t.y = t.y - Math.floor(t.y);
                break;
            case kn:
                t.y = t.y < 0 ? 0 : 1;
                break;
            case el:
                Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                break
        }
        return this.flipY && (t.y = 1 - t.y), t
    }

    set needsUpdate(t) {
        t === !0 && (this.version++, this.source.needsUpdate = !0)
    }
};
Sn.DEFAULT_IMAGE = null;
Sn.DEFAULT_MAPPING = $d;
Sn.DEFAULT_ANISOTROPY = 1;

class Fe {
    constructor(t = 0, e = 0, n = 0, s = 1) {
        Fe.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = s
    }

    get width() {
        return this.z
    }

    set width(t) {
        this.z = t
    }

    get height() {
        return this.w
    }

    set height(t) {
        this.w = t
    }

    set(t, e, n, s) {
        return this.x = t, this.y = e, this.z = n, this.w = s, this
    }

    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this
    }

    setX(t) {
        return this.x = t, this
    }

    setY(t) {
        return this.y = t, this
    }

    setZ(t) {
        return this.z = t, this
    }

    setW(t) {
        return this.w = t, this
    }

    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }

    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
        }
    }

    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }

    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this
    }

    add(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
    }

    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this
    }

    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
    }

    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
    }

    sub(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
    }

    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }

    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
    }

    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
    }

    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }

    applyMatrix4(t) {
        const e = this.x, n = this.y, s = this.z, r = this.w, o = t.elements;
        return this.x = o[0] * e + o[4] * n + o[8] * s + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * s + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * s + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * s + o[15] * r, this
    }

    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }

    setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
    }

    setAxisAngleFromRotationMatrix(t) {
        let e, n, s, r;
        const l = t.elements, c = l[0], h = l[4], u = l[8], d = l[1], f = l[5], g = l[9], m = l[2], p = l[6], _ = l[10];
        if (Math.abs(h - d) < .01 && Math.abs(u - m) < .01 && Math.abs(g - p) < .01) {
            if (Math.abs(h + d) < .1 && Math.abs(u + m) < .1 && Math.abs(g + p) < .1 && Math.abs(c + f + _ - 3) < .1) return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const y = (c + 1) / 2, v = (f + 1) / 2, w = (_ + 1) / 2, E = (h + d) / 4, S = (u + m) / 4, b = (g + p) / 4;
            return y > v && y > w ? y < .01 ? (n = 0, s = .707106781, r = .707106781) : (n = Math.sqrt(y), s = E / n, r = S / n) : v > w ? v < .01 ? (n = .707106781, s = 0, r = .707106781) : (s = Math.sqrt(v), n = E / s, r = b / s) : w < .01 ? (n = .707106781, s = .707106781, r = 0) : (r = Math.sqrt(w), n = S / r, s = b / r), this.set(n, s, r, e), this
        }
        let x = Math.sqrt((p - g) * (p - g) + (u - m) * (u - m) + (d - h) * (d - h));
        return Math.abs(x) < .001 && (x = 1), this.x = (p - g) / x, this.y = (u - m) / x, this.z = (d - h) / x, this.w = Math.acos((c + f + _ - 1) / 2), this
    }

    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }

    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }

    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
    }

    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
    }

    clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }

    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }

    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }

    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }

    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
    }

    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }

    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }

    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }

    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }

    normalize() {
        return this.divideScalar(this.length() || 1)
    }

    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }

    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
    }

    lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
    }

    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }

    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
    }

    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
    }

    fromBufferAttribute(t, e) {
        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
    }

    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }

    * [Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}

class fs extends Gi {
    constructor(t = 1, e = 1, n = {}) {
        super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new Fe(0, 0, t, e), this.scissorTest = !1, this.viewport = new Fe(0, 0, t, e);
        const s = {width: t, height: e, depth: 1};
        this.texture = new Sn(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Qe, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0
    }

    setSize(t, e, n = 1) {
        (this.width !== t || this.height !== e || this.depth !== n) && (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
        const e = Object.assign({}, t.texture.image);
        return this.texture.source = new Io(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }
}

class Yd extends Sn {
    constructor(t = null, e = 1, n = 1, s = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: t,
            width: e,
            height: n,
            depth: s
        }, this.magFilter = sn, this.minFilter = sn, this.wrapR = kn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}

class RI extends fs {
    constructor(t = 1, e = 1, n = 1) {
        super(t, e), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new Yd(null, t, e, n), this.texture.isRenderTargetTexture = !0
    }
}

class n0 extends Sn {
    constructor(t = null, e = 1, n = 1, s = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: t,
            width: e,
            height: n,
            depth: s
        }, this.magFilter = sn, this.minFilter = sn, this.wrapR = kn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}

class LI extends fs {
    constructor(t = 1, e = 1, n = 1) {
        super(t, e), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new n0(null, t, e, n), this.texture.isRenderTargetTexture = !0
    }
}

class NI extends fs {
    constructor(t = 1, e = 1, n = 1, s = {}) {
        super(t, e, s), this.isWebGLMultipleRenderTargets = !0;
        const r = this.texture;
        this.texture = [];
        for (let o = 0; o < n; o++) this.texture[o] = r.clone(), this.texture[o].isRenderTargetTexture = !0
    }

    setSize(t, e, n = 1) {
        if (this.width !== t || this.height !== e || this.depth !== n) {
            this.width = t, this.height = e, this.depth = n;
            for (let s = 0, r = this.texture.length; s < r; s++) this.texture[s].image.width = t, this.texture[s].image.height = e, this.texture[s].image.depth = n;
            this.dispose()
        }
        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
    }

    copy(t) {
        this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.texture.length = 0;
        for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone(), this.texture[e].isRenderTargetTexture = !0;
        return this
    }
}

let On = class {
    constructor(t = 0, e = 0, n = 0, s = 1) {
        this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = s
    }

    static slerpFlat(t, e, n, s, r, o, a) {
        let l = n[s + 0], c = n[s + 1], h = n[s + 2], u = n[s + 3];
        const d = r[o + 0], f = r[o + 1], g = r[o + 2], m = r[o + 3];
        if (a === 0) {
            t[e + 0] = l, t[e + 1] = c, t[e + 2] = h, t[e + 3] = u;
            return
        }
        if (a === 1) {
            t[e + 0] = d, t[e + 1] = f, t[e + 2] = g, t[e + 3] = m;
            return
        }
        if (u !== m || l !== d || c !== f || h !== g) {
            let p = 1 - a;
            const _ = l * d + c * f + h * g + u * m, x = _ >= 0 ? 1 : -1, y = 1 - _ * _;
            if (y > Number.EPSILON) {
                const w = Math.sqrt(y), E = Math.atan2(w, _ * x);
                p = Math.sin(p * E) / w, a = Math.sin(a * E) / w
            }
            const v = a * x;
            if (l = l * p + d * v, c = c * p + f * v, h = h * p + g * v, u = u * p + m * v, p === 1 - a) {
                const w = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
                l *= w, c *= w, h *= w, u *= w
            }
        }
        t[e] = l, t[e + 1] = c, t[e + 2] = h, t[e + 3] = u
    }

    static multiplyQuaternionsFlat(t, e, n, s, r, o) {
        const a = n[s], l = n[s + 1], c = n[s + 2], h = n[s + 3], u = r[o], d = r[o + 1], f = r[o + 2], g = r[o + 3];
        return t[e] = a * g + h * u + l * f - c * d, t[e + 1] = l * g + h * d + c * u - a * f, t[e + 2] = c * g + h * f + a * d - l * u, t[e + 3] = h * g - a * u - l * d - c * f, t
    }

    get x() {
        return this._x
    }

    set x(t) {
        this._x = t, this._onChangeCallback()
    }

    get y() {
        return this._y
    }

    set y(t) {
        this._y = t, this._onChangeCallback()
    }

    get z() {
        return this._z
    }

    set z(t) {
        this._z = t, this._onChangeCallback()
    }

    get w() {
        return this._w
    }

    set w(t) {
        this._w = t, this._onChangeCallback()
    }

    set(t, e, n, s) {
        return this._x = t, this._y = e, this._z = n, this._w = s, this._onChangeCallback(), this
    }

    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }

    copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
    }

    setFromEuler(t, e) {
        const n = t._x, s = t._y, r = t._z, o = t._order, a = Math.cos, l = Math.sin, c = a(n / 2), h = a(s / 2),
            u = a(r / 2), d = l(n / 2), f = l(s / 2), g = l(r / 2);
        switch (o) {
            case"XYZ":
                this._x = d * h * u + c * f * g, this._y = c * f * u - d * h * g, this._z = c * h * g + d * f * u, this._w = c * h * u - d * f * g;
                break;
            case"YXZ":
                this._x = d * h * u + c * f * g, this._y = c * f * u - d * h * g, this._z = c * h * g - d * f * u, this._w = c * h * u + d * f * g;
                break;
            case"ZXY":
                this._x = d * h * u - c * f * g, this._y = c * f * u + d * h * g, this._z = c * h * g + d * f * u, this._w = c * h * u - d * f * g;
                break;
            case"ZYX":
                this._x = d * h * u - c * f * g, this._y = c * f * u + d * h * g, this._z = c * h * g - d * f * u, this._w = c * h * u + d * f * g;
                break;
            case"YZX":
                this._x = d * h * u + c * f * g, this._y = c * f * u + d * h * g, this._z = c * h * g - d * f * u, this._w = c * h * u - d * f * g;
                break;
            case"XZY":
                this._x = d * h * u - c * f * g, this._y = c * f * u - d * h * g, this._z = c * h * g + d * f * u, this._w = c * h * u + d * f * g;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return e !== !1 && this._onChangeCallback(), this
    }

    setFromAxisAngle(t, e) {
        const n = e / 2, s = Math.sin(n);
        return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(n), this._onChangeCallback(), this
    }

    setFromRotationMatrix(t) {
        const e = t.elements, n = e[0], s = e[4], r = e[8], o = e[1], a = e[5], l = e[9], c = e[2], h = e[6], u = e[10],
            d = n + a + u;
        if (d > 0) {
            const f = .5 / Math.sqrt(d + 1);
            this._w = .25 / f, this._x = (h - l) * f, this._y = (r - c) * f, this._z = (o - s) * f
        } else if (n > a && n > u) {
            const f = 2 * Math.sqrt(1 + n - a - u);
            this._w = (h - l) / f, this._x = .25 * f, this._y = (s + o) / f, this._z = (r + c) / f
        } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - n - u);
            this._w = (r - c) / f, this._x = (s + o) / f, this._y = .25 * f, this._z = (l + h) / f
        } else {
            const f = 2 * Math.sqrt(1 + u - n - a);
            this._w = (o - s) / f, this._x = (r + c) / f, this._y = (l + h) / f, this._z = .25 * f
        }
        return this._onChangeCallback(), this
    }

    setFromUnitVectors(t, e) {
        let n = t.dot(e) + 1;
        return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
    }

    angleTo(t) {
        return 2 * Math.acos(Math.abs(un(this.dot(t), -1, 1)))
    }

    rotateTowards(t, e) {
        const n = this.angleTo(t);
        if (n === 0) return this;
        const s = Math.min(1, e / n);
        return this.slerp(t, s), this
    }

    identity() {
        return this.set(0, 0, 0, 1)
    }

    invert() {
        return this.conjugate()
    }

    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }

    dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }

    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }

    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }

    normalize() {
        let t = this.length();
        return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
    }

    multiply(t) {
        return this.multiplyQuaternions(this, t)
    }

    premultiply(t) {
        return this.multiplyQuaternions(t, this)
    }

    multiplyQuaternions(t, e) {
        const n = t._x, s = t._y, r = t._z, o = t._w, a = e._x, l = e._y, c = e._z, h = e._w;
        return this._x = n * h + o * a + s * c - r * l, this._y = s * h + o * l + r * a - n * c, this._z = r * h + o * c + n * l - s * a, this._w = o * h - n * a - s * l - r * c, this._onChangeCallback(), this
    }

    slerp(t, e) {
        if (e === 0) return this;
        if (e === 1) return this.copy(t);
        const n = this._x, s = this._y, r = this._z, o = this._w;
        let a = o * t._w + n * t._x + s * t._y + r * t._z;
        if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = s, this._z = r, this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const f = 1 - e;
            return this._w = f * o + e * this._w, this._x = f * n + e * this._x, this._y = f * s + e * this._y, this._z = f * r + e * this._z, this.normalize(), this._onChangeCallback(), this
        }
        const c = Math.sqrt(l), h = Math.atan2(c, a), u = Math.sin((1 - e) * h) / c, d = Math.sin(e * h) / c;
        return this._w = o * u + this._w * d, this._x = n * u + this._x * d, this._y = s * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this
    }

    slerpQuaternions(t, e, n) {
        return this.copy(t).slerp(e, n)
    }

    random() {
        const t = Math.random(), e = Math.sqrt(1 - t), n = Math.sqrt(t), s = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random();
        return this.set(e * Math.cos(s), n * Math.sin(r), n * Math.cos(r), e * Math.sin(s))
    }

    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }

    fromArray(t, e = 0) {
        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
    }

    toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
    }

    fromBufferAttribute(t, e) {
        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
    }

    _onChange(t) {
        return this._onChangeCallback = t, this
    }

    _onChangeCallback() {
    }

    * [Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}, C = class kb {
    constructor(t = 0, e = 0, n = 0) {
        kb.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
    }

    set(t, e, n) {
        return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this
    }

    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this
    }

    setX(t) {
        return this.x = t, this
    }

    setY(t) {
        return this.y = t, this
    }

    setZ(t) {
        return this.z = t, this
    }

    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }

    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
        }
    }

    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }

    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
    }

    add(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this
    }

    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this
    }

    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
    }

    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
    }

    sub(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
    }

    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this
    }

    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
    }

    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
    }

    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this
    }

    multiplyVectors(t, e) {
        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
    }

    applyEuler(t) {
        return this.applyQuaternion(py.setFromEuler(t))
    }

    applyAxisAngle(t, e) {
        return this.applyQuaternion(py.setFromAxisAngle(t, e))
    }

    applyMatrix3(t) {
        const e = this.x, n = this.y, s = this.z, r = t.elements;
        return this.x = r[0] * e + r[3] * n + r[6] * s, this.y = r[1] * e + r[4] * n + r[7] * s, this.z = r[2] * e + r[5] * n + r[8] * s, this
    }

    applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize()
    }

    applyMatrix4(t) {
        const e = this.x, n = this.y, s = this.z, r = t.elements, o = 1 / (r[3] * e + r[7] * n + r[11] * s + r[15]);
        return this.x = (r[0] * e + r[4] * n + r[8] * s + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * s + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * s + r[14]) * o, this
    }

    applyQuaternion(t) {
        const e = this.x, n = this.y, s = this.z, r = t.x, o = t.y, a = t.z, l = t.w, c = l * e + o * s - a * n,
            h = l * n + a * e - r * s, u = l * s + r * n - o * e, d = -r * e - o * n - a * s;
        return this.x = c * l + d * -r + h * -a - u * -o, this.y = h * l + d * -o + u * -r - c * -a, this.z = u * l + d * -a + c * -o - h * -r, this
    }

    project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }

    unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }

    transformDirection(t) {
        const e = this.x, n = this.y, s = this.z, r = t.elements;
        return this.x = r[0] * e + r[4] * n + r[8] * s, this.y = r[1] * e + r[5] * n + r[9] * s, this.z = r[2] * e + r[6] * n + r[10] * s, this.normalize()
    }

    divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
    }

    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }

    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
    }

    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
    }

    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
    }

    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
    }

    clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }

    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }

    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }

    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }

    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }

    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }

    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z
    }

    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }

    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }

    normalize() {
        return this.divideScalar(this.length() || 1)
    }

    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }

    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
    }

    lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
    }

    cross(t) {
        return this.crossVectors(this, t)
    }

    crossVectors(t, e) {
        const n = t.x, s = t.y, r = t.z, o = e.x, a = e.y, l = e.z;
        return this.x = s * l - r * a, this.y = r * o - n * l, this.z = n * a - s * o, this
    }

    projectOnVector(t) {
        const e = t.lengthSq();
        if (e === 0) return this.set(0, 0, 0);
        const n = t.dot(this) / e;
        return this.copy(t).multiplyScalar(n)
    }

    projectOnPlane(t) {
        return yp.copy(this).projectOnVector(t), this.sub(yp)
    }

    reflect(t) {
        return this.sub(yp.copy(t).multiplyScalar(2 * this.dot(t)))
    }

    angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (e === 0) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(un(n, -1, 1))
    }

    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }

    distanceToSquared(t) {
        const e = this.x - t.x, n = this.y - t.y, s = this.z - t.z;
        return e * e + n * n + s * s
    }

    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }

    setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }

    setFromSphericalCoords(t, e, n) {
        const s = Math.sin(e) * t;
        return this.x = s * Math.sin(n), this.y = Math.cos(e) * t, this.z = s * Math.cos(n), this
    }

    setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }

    setFromCylindricalCoords(t, e, n) {
        return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
    }

    setFromMatrixPosition(t) {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this
    }

    setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(),
            s = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = n, this.z = s, this
    }

    setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, e * 4)
    }

    setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, e * 3)
    }

    setFromEuler(t) {
        return this.x = t._x, this.y = t._y, this.z = t._z, this
    }

    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z
    }

    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
    }

    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
    }

    fromBufferAttribute(t, e) {
        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
    }

    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }

    randomDirection() {
        const t = (Math.random() - .5) * 2, e = Math.random() * Math.PI * 2, n = Math.sqrt(1 - t ** 2);
        return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
    }

    * [Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
};
const yp = new C, py = new On;

class fi {
    constructor(t = new C(1 / 0, 1 / 0, 1 / 0), e = new C(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = t, this.max = e
    }

    set(t, e) {
        return this.min.copy(t), this.max.copy(e), this
    }

    setFromArray(t) {
        let e = 1 / 0, n = 1 / 0, s = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0;
        for (let l = 0, c = t.length; l < c; l += 3) {
            const h = t[l], u = t[l + 1], d = t[l + 2];
            h < e && (e = h), u < n && (n = u), d < s && (s = d), h > r && (r = h), u > o && (o = u), d > a && (a = d)
        }
        return this.min.set(e, n, s), this.max.set(r, o, a), this
    }

    setFromBufferAttribute(t) {
        let e = 1 / 0, n = 1 / 0, s = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0;
        for (let l = 0, c = t.count; l < c; l++) {
            const h = t.getX(l), u = t.getY(l), d = t.getZ(l);
            h < e && (e = h), u < n && (n = u), d < s && (s = d), h > r && (r = h), u > o && (o = u), d > a && (a = d)
        }
        return this.min.set(e, n, s), this.max.set(r, o, a), this
    }

    setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this
    }

    setFromCenterAndSize(t, e) {
        const n = so.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
    }

    setFromObject(t, e = !1) {
        return this.makeEmpty(), this.expandByObject(t, e)
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
    }

    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }

    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }

    getCenter(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }

    getSize(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }

    expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
    }

    expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
    }

    expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
    }

    expandByObject(t, e = !1) {
        t.updateWorldMatrix(!1, !1);
        const n = t.geometry;
        if (n !== void 0) if (e && n.attributes != null && n.attributes.position !== void 0) {
            const r = n.attributes.position;
            for (let o = 0, a = r.count; o < a; o++) so.fromBufferAttribute(r, o).applyMatrix4(t.matrixWorld), this.expandByPoint(so)
        } else n.boundingBox === null && n.computeBoundingBox(), xp.copy(n.boundingBox), xp.applyMatrix4(t.matrixWorld), this.union(xp);
        const s = t.children;
        for (let r = 0, o = s.length; r < o; r++) this.expandByObject(s[r], e);
        return this
    }

    containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
    }

    containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }

    getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }

    intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
    }

    intersectsSphere(t) {
        return this.clampPoint(t.center, so), so.distanceToSquared(t.center) <= t.radius * t.radius
    }

    intersectsPlane(t) {
        let e, n;
        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
    }

    intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(Hl), Vh.subVectors(this.max, Hl), sa.subVectors(t.a, Hl), ia.subVectors(t.b, Hl), ra.subVectors(t.c, Hl), gr.subVectors(ia, sa), mr.subVectors(ra, ia), io.subVectors(sa, ra);
        let e = [0, -gr.z, gr.y, 0, -mr.z, mr.y, 0, -io.z, io.y, gr.z, 0, -gr.x, mr.z, 0, -mr.x, io.z, 0, -io.x, -gr.y, gr.x, 0, -mr.y, mr.x, 0, -io.y, io.x, 0];
        return !vp(e, sa, ia, ra, Vh) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !vp(e, sa, ia, ra, Vh)) ? !1 : (Hh.crossVectors(gr, mr), e = [Hh.x, Hh.y, Hh.z], vp(e, sa, ia, ra, Vh))
    }

    clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max)
    }

    distanceToPoint(t) {
        return so.copy(t).clamp(this.min, this.max).sub(t).length()
    }

    getBoundingSphere(t) {
        return this.getCenter(t.center), t.radius = this.getSize(so).length() * .5, t
    }

    intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }

    union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
    }

    applyMatrix4(t) {
        return this.isEmpty() ? this : (qi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), qi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), qi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), qi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), qi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), qi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), qi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), qi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(qi), this)
    }

    translate(t) {
        return this.min.add(t), this.max.add(t), this
    }

    equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
    }
}

const qi = [new C, new C, new C, new C, new C, new C, new C, new C], so = new C, xp = new fi, sa = new C, ia = new C,
    ra = new C, gr = new C, mr = new C, io = new C, Hl = new C, Vh = new C, Hh = new C, ro = new C;

function vp(i, t, e, n, s) {
    for (let r = 0, o = i.length - 3; r <= o; r += 3) {
        ro.fromArray(i, r);
        const a = s.x * Math.abs(ro.x) + s.y * Math.abs(ro.y) + s.z * Math.abs(ro.z), l = t.dot(ro), c = e.dot(ro),
            h = n.dot(ro);
        if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1
    }
    return !0
}

const OI = new fi, $l = new C, wp = new C;

class Zr {
    constructor(t = new C, e = -1) {
        this.center = t, this.radius = e
    }

    set(t, e) {
        return this.center.copy(t), this.radius = e, this
    }

    setFromPoints(t, e) {
        const n = this.center;
        e !== void 0 ? n.copy(e) : OI.setFromPoints(t).getCenter(n);
        let s = 0;
        for (let r = 0, o = t.length; r < o; r++) s = Math.max(s, n.distanceToSquared(t[r]));
        return this.radius = Math.sqrt(s), this
    }

    copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this
    }

    isEmpty() {
        return this.radius < 0
    }

    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }

    containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius
    }

    distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius
    }

    intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e
    }

    intersectsBox(t) {
        return t.intersectsSphere(this)
    }

    intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }

    clampPoint(t, e) {
        const n = this.center.distanceToSquared(t);
        return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
    }

    getBoundingBox(t) {
        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    }

    applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
    }

    translate(t) {
        return this.center.add(t), this
    }

    expandByPoint(t) {
        if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
        $l.subVectors(t, this.center);
        const e = $l.lengthSq();
        if (e > this.radius * this.radius) {
            const n = Math.sqrt(e), s = (n - this.radius) * .5;
            this.center.addScaledVector($l, s / n), this.radius += s
        }
        return this
    }

    union(t) {
        return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (wp.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint($l.copy(t.center).add(wp)), this.expandByPoint($l.copy(t.center).sub(wp))), this)
    }

    equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

const Yi = new C, bp = new C, $h = new C, _r = new C, Ep = new C, Wh = new C, Sp = new C;

class uh {
    constructor(t = new C, e = new C(0, 0, -1)) {
        this.origin = t, this.direction = e
    }

    set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this
    }

    copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }

    at(t, e) {
        return e.copy(this.direction).multiplyScalar(t).add(this.origin)
    }

    lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this
    }

    recast(t) {
        return this.origin.copy(this.at(t, Yi)), this
    }

    closestPointToPoint(t, e) {
        e.subVectors(t, this.origin);
        const n = e.dot(this.direction);
        return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
    }

    distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t))
    }

    distanceSqToPoint(t) {
        const e = Yi.subVectors(t, this.origin).dot(this.direction);
        return e < 0 ? this.origin.distanceToSquared(t) : (Yi.copy(this.direction).multiplyScalar(e).add(this.origin), Yi.distanceToSquared(t))
    }

    distanceSqToSegment(t, e, n, s) {
        bp.copy(t).add(e).multiplyScalar(.5), $h.copy(e).sub(t).normalize(), _r.copy(this.origin).sub(bp);
        const r = t.distanceTo(e) * .5, o = -this.direction.dot($h), a = _r.dot(this.direction), l = -_r.dot($h),
            c = _r.lengthSq(), h = Math.abs(1 - o * o);
        let u, d, f, g;
        if (h > 0) if (u = o * l - a, d = o * a - l, g = r * h, u >= 0) if (d >= -g) if (d <= g) {
            const m = 1 / h;
            u *= m, d *= m, f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c
        } else d = r, u = Math.max(0, -(o * d + a)), f = -u * u + d * (d + 2 * l) + c; else d = -r, u = Math.max(0, -(o * d + a)), f = -u * u + d * (d + 2 * l) + c; else d <= -g ? (u = Math.max(0, -(-o * r + a)), d = u > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -u * u + d * (d + 2 * l) + c) : d <= g ? (u = 0, d = Math.min(Math.max(-r, -l), r), f = d * (d + 2 * l) + c) : (u = Math.max(0, -(o * r + a)), d = u > 0 ? r : Math.min(Math.max(-r, -l), r), f = -u * u + d * (d + 2 * l) + c); else d = o > 0 ? -r : r, u = Math.max(0, -(o * d + a)), f = -u * u + d * (d + 2 * l) + c;
        return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), s && s.copy($h).multiplyScalar(d).add(bp), f
    }

    intersectSphere(t, e) {
        Yi.subVectors(t.center, this.origin);
        const n = Yi.dot(this.direction), s = Yi.dot(Yi) - n * n, r = t.radius * t.radius;
        if (s > r) return null;
        const o = Math.sqrt(r - s), a = n - o, l = n + o;
        return a < 0 && l < 0 ? null : a < 0 ? this.at(l, e) : this.at(a, e)
    }

    intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }

    distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null
    }

    intersectPlane(t, e) {
        const n = this.distanceToPlane(t);
        return n === null ? null : this.at(n, e)
    }

    intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        return e === 0 || t.normal.dot(this.direction) * e < 0
    }

    intersectBox(t, e) {
        let n, s, r, o, a, l;
        const c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
        return c >= 0 ? (n = (t.min.x - d.x) * c, s = (t.max.x - d.x) * c) : (n = (t.max.x - d.x) * c, s = (t.min.x - d.x) * c), h >= 0 ? (r = (t.min.y - d.y) * h, o = (t.max.y - d.y) * h) : (r = (t.max.y - d.y) * h, o = (t.min.y - d.y) * h), n > o || r > s || ((r > n || isNaN(n)) && (n = r), (o < s || isNaN(s)) && (s = o), u >= 0 ? (a = (t.min.z - d.z) * u, l = (t.max.z - d.z) * u) : (a = (t.max.z - d.z) * u, l = (t.min.z - d.z) * u), n > l || a > s) || ((a > n || n !== n) && (n = a), (l < s || s !== s) && (s = l), s < 0) ? null : this.at(n >= 0 ? n : s, e)
    }

    intersectsBox(t) {
        return this.intersectBox(t, Yi) !== null
    }

    intersectTriangle(t, e, n, s, r) {
        Ep.subVectors(e, t), Wh.subVectors(n, t), Sp.crossVectors(Ep, Wh);
        let o = this.direction.dot(Sp), a;
        if (o > 0) {
            if (s) return null;
            a = 1
        } else if (o < 0) a = -1, o = -o; else return null;
        _r.subVectors(this.origin, t);
        const l = a * this.direction.dot(Wh.crossVectors(_r, Wh));
        if (l < 0) return null;
        const c = a * this.direction.dot(Ep.cross(_r));
        if (c < 0 || l + c > o) return null;
        const h = -a * _r.dot(Sp);
        return h < 0 ? null : this.at(h / o, r)
    }

    applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    }

    equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

let Yt = class mm {
    constructor() {
        mm.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }

    set(t, e, n, s, r, o, a, l, c, h, u, d, f, g, m, p) {
        const _ = this.elements;
        return _[0] = t, _[4] = e, _[8] = n, _[12] = s, _[1] = r, _[5] = o, _[9] = a, _[13] = l, _[2] = c, _[6] = h, _[10] = u, _[14] = d, _[3] = f, _[7] = g, _[11] = m, _[15] = p, this
    }

    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }

    clone() {
        return new mm().fromArray(this.elements)
    }

    copy(t) {
        const e = this.elements, n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
    }

    copyPosition(t) {
        const e = this.elements, n = t.elements;
        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
    }

    setFromMatrix3(t) {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
    }

    extractBasis(t, e, n) {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
    }

    makeBasis(t, e, n) {
        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
    }

    extractRotation(t) {
        const e = this.elements, n = t.elements, s = 1 / oa.setFromMatrixColumn(t, 0).length(),
            r = 1 / oa.setFromMatrixColumn(t, 1).length(), o = 1 / oa.setFromMatrixColumn(t, 2).length();
        return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }

    makeRotationFromEuler(t) {
        const e = this.elements, n = t.x, s = t.y, r = t.z, o = Math.cos(n), a = Math.sin(n), l = Math.cos(s),
            c = Math.sin(s), h = Math.cos(r), u = Math.sin(r);
        if (t.order === "XYZ") {
            const d = o * h, f = o * u, g = a * h, m = a * u;
            e[0] = l * h, e[4] = -l * u, e[8] = c, e[1] = f + g * c, e[5] = d - m * c, e[9] = -a * l, e[2] = m - d * c, e[6] = g + f * c, e[10] = o * l
        } else if (t.order === "YXZ") {
            const d = l * h, f = l * u, g = c * h, m = c * u;
            e[0] = d + m * a, e[4] = g * a - f, e[8] = o * c, e[1] = o * u, e[5] = o * h, e[9] = -a, e[2] = f * a - g, e[6] = m + d * a, e[10] = o * l
        } else if (t.order === "ZXY") {
            const d = l * h, f = l * u, g = c * h, m = c * u;
            e[0] = d - m * a, e[4] = -o * u, e[8] = g + f * a, e[1] = f + g * a, e[5] = o * h, e[9] = m - d * a, e[2] = -o * c, e[6] = a, e[10] = o * l
        } else if (t.order === "ZYX") {
            const d = o * h, f = o * u, g = a * h, m = a * u;
            e[0] = l * h, e[4] = g * c - f, e[8] = d * c + m, e[1] = l * u, e[5] = m * c + d, e[9] = f * c - g, e[2] = -c, e[6] = a * l, e[10] = o * l
        } else if (t.order === "YZX") {
            const d = o * l, f = o * c, g = a * l, m = a * c;
            e[0] = l * h, e[4] = m - d * u, e[8] = g * u + f, e[1] = u, e[5] = o * h, e[9] = -a * h, e[2] = -c * h, e[6] = f * u + g, e[10] = d - m * u
        } else if (t.order === "XZY") {
            const d = o * l, f = o * c, g = a * l, m = a * c;
            e[0] = l * h, e[4] = -u, e[8] = c * h, e[1] = d * u + m, e[5] = o * h, e[9] = f * u - g, e[2] = g * u - f, e[6] = a * h, e[10] = m * u + d
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }

    makeRotationFromQuaternion(t) {
        return this.compose(DI, t, FI)
    }

    lookAt(t, e, n) {
        const s = this.elements;
        return Is.subVectors(t, e), Is.lengthSq() === 0 && (Is.z = 1), Is.normalize(), yr.crossVectors(n, Is), yr.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Is.x += 1e-4 : Is.z += 1e-4, Is.normalize(), yr.crossVectors(n, Is)), yr.normalize(), qh.crossVectors(Is, yr), s[0] = yr.x, s[4] = qh.x, s[8] = Is.x, s[1] = yr.y, s[5] = qh.y, s[9] = Is.y, s[2] = yr.z, s[6] = qh.z, s[10] = Is.z, this
    }

    multiply(t) {
        return this.multiplyMatrices(this, t)
    }

    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }

    multiplyMatrices(t, e) {
        const n = t.elements, s = e.elements, r = this.elements, o = n[0], a = n[4], l = n[8], c = n[12], h = n[1],
            u = n[5], d = n[9], f = n[13], g = n[2], m = n[6], p = n[10], _ = n[14], x = n[3], y = n[7], v = n[11],
            w = n[15], E = s[0], S = s[4], b = s[8], M = s[12], I = s[1], N = s[5], B = s[9], D = s[13], L = s[2],
            k = s[6], G = s[10], Q = s[14], q = s[3], at = s[7], lt = s[11], wt = s[15];
        return r[0] = o * E + a * I + l * L + c * q, r[4] = o * S + a * N + l * k + c * at, r[8] = o * b + a * B + l * G + c * lt, r[12] = o * M + a * D + l * Q + c * wt, r[1] = h * E + u * I + d * L + f * q, r[5] = h * S + u * N + d * k + f * at, r[9] = h * b + u * B + d * G + f * lt, r[13] = h * M + u * D + d * Q + f * wt, r[2] = g * E + m * I + p * L + _ * q, r[6] = g * S + m * N + p * k + _ * at, r[10] = g * b + m * B + p * G + _ * lt, r[14] = g * M + m * D + p * Q + _ * wt, r[3] = x * E + y * I + v * L + w * q, r[7] = x * S + y * N + v * k + w * at, r[11] = x * b + y * B + v * G + w * lt, r[15] = x * M + y * D + v * Q + w * wt, this
    }

    multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
    }

    determinant() {
        const t = this.elements, e = t[0], n = t[4], s = t[8], r = t[12], o = t[1], a = t[5], l = t[9], c = t[13],
            h = t[2], u = t[6], d = t[10], f = t[14], g = t[3], m = t[7], p = t[11], _ = t[15];
        return g * (+r * l * u - s * c * u - r * a * d + n * c * d + s * a * f - n * l * f) + m * (+e * l * f - e * c * d + r * o * d - s * o * f + s * c * h - r * l * h) + p * (+e * c * u - e * a * f - r * o * u + n * o * f + r * a * h - n * c * h) + _ * (-s * a * h - e * l * u + e * a * d + s * o * u - n * o * d + n * l * h)
    }

    transpose() {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
    }

    setPosition(t, e, n) {
        const s = this.elements;
        return t.isVector3 ? (s[12] = t.x, s[13] = t.y, s[14] = t.z) : (s[12] = t, s[13] = e, s[14] = n), this
    }

    invert() {
        const t = this.elements, e = t[0], n = t[1], s = t[2], r = t[3], o = t[4], a = t[5], l = t[6], c = t[7],
            h = t[8], u = t[9], d = t[10], f = t[11], g = t[12], m = t[13], p = t[14], _ = t[15],
            x = u * p * c - m * d * c + m * l * f - a * p * f - u * l * _ + a * d * _,
            y = g * d * c - h * p * c - g * l * f + o * p * f + h * l * _ - o * d * _,
            v = h * m * c - g * u * c + g * a * f - o * m * f - h * a * _ + o * u * _,
            w = g * u * l - h * m * l - g * a * d + o * m * d + h * a * p - o * u * p,
            E = e * x + n * y + s * v + r * w;
        if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / E;
        return t[0] = x * S, t[1] = (m * d * r - u * p * r - m * s * f + n * p * f + u * s * _ - n * d * _) * S, t[2] = (a * p * r - m * l * r + m * s * c - n * p * c - a * s * _ + n * l * _) * S, t[3] = (u * l * r - a * d * r - u * s * c + n * d * c + a * s * f - n * l * f) * S, t[4] = y * S, t[5] = (h * p * r - g * d * r + g * s * f - e * p * f - h * s * _ + e * d * _) * S, t[6] = (g * l * r - o * p * r - g * s * c + e * p * c + o * s * _ - e * l * _) * S, t[7] = (o * d * r - h * l * r + h * s * c - e * d * c - o * s * f + e * l * f) * S, t[8] = v * S, t[9] = (g * u * r - h * m * r - g * n * f + e * m * f + h * n * _ - e * u * _) * S, t[10] = (o * m * r - g * a * r + g * n * c - e * m * c - o * n * _ + e * a * _) * S, t[11] = (h * a * r - o * u * r - h * n * c + e * u * c + o * n * f - e * a * f) * S, t[12] = w * S, t[13] = (h * m * s - g * u * s + g * n * d - e * m * d - h * n * p + e * u * p) * S, t[14] = (g * a * s - o * m * s - g * n * l + e * m * l + o * n * p - e * a * p) * S, t[15] = (o * u * s - h * a * s + h * n * l - e * u * l - o * n * d + e * a * d) * S, this
    }

    scale(t) {
        const e = this.elements, n = t.x, s = t.y, r = t.z;
        return e[0] *= n, e[4] *= s, e[8] *= r, e[1] *= n, e[5] *= s, e[9] *= r, e[2] *= n, e[6] *= s, e[10] *= r, e[3] *= n, e[7] *= s, e[11] *= r, this
    }

    getMaxScaleOnAxis() {
        const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, s))
    }

    makeTranslation(t, e, n) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
    }

    makeRotationX(t) {
        const e = Math.cos(t), n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
    }

    makeRotationY(t) {
        const e = Math.cos(t), n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
    }

    makeRotationZ(t) {
        const e = Math.cos(t), n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }

    makeRotationAxis(t, e) {
        const n = Math.cos(e), s = Math.sin(e), r = 1 - n, o = t.x, a = t.y, l = t.z, c = r * o, h = r * a;
        return this.set(c * o + n, c * a - s * l, c * l + s * a, 0, c * a + s * l, h * a + n, h * l - s * o, 0, c * l - s * a, h * l + s * o, r * l * l + n, 0, 0, 0, 0, 1), this
    }

    makeScale(t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
    }

    makeShear(t, e, n, s, r, o) {
        return this.set(1, n, r, 0, t, 1, o, 0, e, s, 1, 0, 0, 0, 0, 1), this
    }

    compose(t, e, n) {
        const s = this.elements, r = e._x, o = e._y, a = e._z, l = e._w, c = r + r, h = o + o, u = a + a, d = r * c,
            f = r * h, g = r * u, m = o * h, p = o * u, _ = a * u, x = l * c, y = l * h, v = l * u, w = n.x, E = n.y,
            S = n.z;
        return s[0] = (1 - (m + _)) * w, s[1] = (f + v) * w, s[2] = (g - y) * w, s[3] = 0, s[4] = (f - v) * E, s[5] = (1 - (d + _)) * E, s[6] = (p + x) * E, s[7] = 0, s[8] = (g + y) * S, s[9] = (p - x) * S, s[10] = (1 - (d + m)) * S, s[11] = 0, s[12] = t.x, s[13] = t.y, s[14] = t.z, s[15] = 1, this
    }

    decompose(t, e, n) {
        const s = this.elements;
        let r = oa.set(s[0], s[1], s[2]).length();
        const o = oa.set(s[4], s[5], s[6]).length(), a = oa.set(s[8], s[9], s[10]).length();
        this.determinant() < 0 && (r = -r), t.x = s[12], t.y = s[13], t.z = s[14], ti.copy(this);
        const c = 1 / r, h = 1 / o, u = 1 / a;
        return ti.elements[0] *= c, ti.elements[1] *= c, ti.elements[2] *= c, ti.elements[4] *= h, ti.elements[5] *= h, ti.elements[6] *= h, ti.elements[8] *= u, ti.elements[9] *= u, ti.elements[10] *= u, e.setFromRotationMatrix(ti), n.x = r, n.y = o, n.z = a, this
    }

    makePerspective(t, e, n, s, r, o) {
        const a = this.elements, l = 2 * r / (e - t), c = 2 * r / (n - s), h = (e + t) / (e - t), u = (n + s) / (n - s),
            d = -(o + r) / (o - r), f = -2 * o * r / (o - r);
        return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
    }

    makeOrthographic(t, e, n, s, r, o) {
        const a = this.elements, l = 1 / (e - t), c = 1 / (n - s), h = 1 / (o - r), u = (e + t) * l, d = (n + s) * c,
            f = (o + r) * h;
        return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
    }

    equals(t) {
        const e = this.elements, n = t.elements;
        for (let s = 0; s < 16; s++) if (e[s] !== n[s]) return !1;
        return !0
    }

    fromArray(t, e = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this
    }

    toArray(t = [], e = 0) {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
    }
};
const oa = new C, ti = new Yt, DI = new C(0, 0, 0), FI = new C(1, 1, 1), yr = new C, qh = new C, Is = new C,
    gy = new Yt, my = new On;
let s0 = class Ub {
    constructor(t = 0, e = 0, n = 0, s = Ub.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = s
    }

    get x() {
        return this._x
    }

    set x(t) {
        this._x = t, this._onChangeCallback()
    }

    get y() {
        return this._y
    }

    set y(t) {
        this._y = t, this._onChangeCallback()
    }

    get z() {
        return this._z
    }

    set z(t) {
        this._z = t, this._onChangeCallback()
    }

    get order() {
        return this._order
    }

    set order(t) {
        this._order = t, this._onChangeCallback()
    }

    set(t, e, n, s = this._order) {
        return this._x = t, this._y = e, this._z = n, this._order = s, this._onChangeCallback(), this
    }

    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }

    copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
    }

    setFromRotationMatrix(t, e = this._order, n = !0) {
        const s = t.elements, r = s[0], o = s[4], a = s[8], l = s[1], c = s[5], h = s[9], u = s[2], d = s[6], f = s[10];
        switch (e) {
            case"XYZ":
                this._y = Math.asin(un(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(d, c), this._z = 0);
                break;
            case"YXZ":
                this._x = Math.asin(-un(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r), this._z = 0);
                break;
            case"ZXY":
                this._x = Math.asin(un(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
                break;
            case"ZYX":
                this._y = Math.asin(-un(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
                break;
            case"YZX":
                this._z = Math.asin(un(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, f));
                break;
            case"XZY":
                this._z = Math.asin(-un(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
        }
        return this._order = e, n === !0 && this._onChangeCallback(), this
    }

    setFromQuaternion(t, e, n) {
        return gy.makeRotationFromQuaternion(t), this.setFromRotationMatrix(gy, e, n)
    }

    setFromVector3(t, e = this._order) {
        return this.set(t.x, t.y, t.z, e)
    }

    reorder(t) {
        return my.setFromEuler(this), this.setFromQuaternion(my, t)
    }

    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }

    fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this
    }

    toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
    }

    _onChange(t) {
        return this._onChangeCallback = t, this
    }

    _onChangeCallback() {
    }

    * [Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
};
s0.DEFAULT_ORDER = "XYZ";

class Xd {
    constructor() {
        this.mask = 1
    }

    set(t) {
        this.mask = (1 << t | 0) >>> 0
    }

    enable(t) {
        this.mask |= 1 << t | 0
    }

    enableAll() {
        this.mask = -1
    }

    toggle(t) {
        this.mask ^= 1 << t | 0
    }

    disable(t) {
        this.mask &= ~(1 << t | 0)
    }

    disableAll() {
        this.mask = 0
    }

    test(t) {
        return (this.mask & t.mask) !== 0
    }

    isEnabled(t) {
        return (this.mask & (1 << t | 0)) !== 0
    }
}

let zI = 0;
const _y = new C, aa = new On, Xi = new Yt, Yh = new C, Wl = new C, BI = new C, kI = new On, yy = new C(1, 0, 0),
    xy = new C(0, 1, 0), vy = new C(0, 0, 1), UI = {type: "added"}, wy = {type: "removed"};

class re extends Gi {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {value: zI++}), this.uuid = zs(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = re.DEFAULT_UP.clone();
        const t = new C, e = new s0, n = new On, s = new C(1, 1, 1);

        function r() {
            n.setFromEuler(e, !1)
        }

        function o() {
            e.setFromQuaternion(n, void 0, !1)
        }

        e._onChange(r), n._onChange(o), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {configurable: !0, enumerable: !0, value: e},
            quaternion: {configurable: !0, enumerable: !0, value: n},
            scale: {configurable: !0, enumerable: !0, value: s},
            modelViewMatrix: {value: new Yt},
            normalMatrix: {value: new ds}
        }), this.matrix = new Yt, this.matrixWorld = new Yt, this.matrixAutoUpdate = re.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = re.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Xd, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }

    onBeforeRender() {
    }

    onAfterRender() {
    }

    applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }

    applyQuaternion(t) {
        return this.quaternion.premultiply(t), this
    }

    setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e)
    }

    setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0)
    }

    setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t)
    }

    setRotationFromQuaternion(t) {
        this.quaternion.copy(t)
    }

    rotateOnAxis(t, e) {
        return aa.setFromAxisAngle(t, e), this.quaternion.multiply(aa), this
    }

    rotateOnWorldAxis(t, e) {
        return aa.setFromAxisAngle(t, e), this.quaternion.premultiply(aa), this
    }

    rotateX(t) {
        return this.rotateOnAxis(yy, t)
    }

    rotateY(t) {
        return this.rotateOnAxis(xy, t)
    }

    rotateZ(t) {
        return this.rotateOnAxis(vy, t)
    }

    translateOnAxis(t, e) {
        return _y.copy(t).applyQuaternion(this.quaternion), this.position.add(_y.multiplyScalar(e)), this
    }

    translateX(t) {
        return this.translateOnAxis(yy, t)
    }

    translateY(t) {
        return this.translateOnAxis(xy, t)
    }

    translateZ(t) {
        return this.translateOnAxis(vy, t)
    }

    localToWorld(t) {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
    }

    worldToLocal(t) {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Xi.copy(this.matrixWorld).invert())
    }

    lookAt(t, e, n) {
        t.isVector3 ? Yh.copy(t) : Yh.set(t, e, n);
        const s = this.parent;
        this.updateWorldMatrix(!0, !1), Wl.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Xi.lookAt(Wl, Yh, this.up) : Xi.lookAt(Yh, Wl, this.up), this.quaternion.setFromRotationMatrix(Xi), s && (Xi.extractRotation(s.matrixWorld), aa.setFromRotationMatrix(Xi), this.quaternion.premultiply(aa.invert()))
    }

    add(t) {
        if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(UI)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
    }

    remove(t) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
            return this
        }
        const e = this.children.indexOf(t);
        return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(wy)), this
    }

    removeFromParent() {
        const t = this.parent;
        return t !== null && t.remove(this), this
    }

    clear() {
        for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            e.parent = null, e.dispatchEvent(wy)
        }
        return this.children.length = 0, this
    }

    attach(t) {
        return this.updateWorldMatrix(!0, !1), Xi.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), Xi.multiply(t.parent.matrixWorld)), t.applyMatrix4(Xi), this.add(t), t.updateWorldMatrix(!1, !0), this
    }

    getObjectById(t) {
        return this.getObjectByProperty("id", t)
    }

    getObjectByName(t) {
        return this.getObjectByProperty("name", t)
    }

    getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let n = 0, s = this.children.length; n < s; n++) {
            const o = this.children[n].getObjectByProperty(t, e);
            if (o !== void 0) return o
        }
    }

    getObjectsByProperty(t, e) {
        let n = [];
        this[t] === e && n.push(this);
        for (let s = 0, r = this.children.length; s < r; s++) {
            const o = this.children[s].getObjectsByProperty(t, e);
            o.length > 0 && (n = n.concat(o))
        }
        return n
    }

    getWorldPosition(t) {
        return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    }

    getWorldQuaternion(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wl, t, BI), t
    }

    getWorldScale(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wl, kI, t), t
    }

    getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize()
    }

    raycast() {
    }

    traverse(t) {
        t(this);
        const e = this.children;
        for (let n = 0, s = e.length; n < s; n++) e[n].traverse(t)
    }

    traverseVisible(t) {
        if (this.visible === !1) return;
        t(this);
        const e = this.children;
        for (let n = 0, s = e.length; n < s; n++) e[n].traverseVisible(t)
    }

    traverseAncestors(t) {
        const e = this.parent;
        e !== null && (t(e), e.traverseAncestors(t))
    }

    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }

    updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
        const e = this.children;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            (r.matrixWorldAutoUpdate === !0 || t === !0) && r.updateMatrixWorld(t)
        }
    }

    updateWorldMatrix(t, e) {
        const n = this.parent;
        if (t === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
            const s = this.children;
            for (let r = 0, o = s.length; r < o; r++) {
                const a = s[r];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }

    toJSON(t) {
        const e = t === void 0 || typeof t == "string", n = {};
        e && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, n.metadata = {version: 4.5, type: "Object", generator: "Object3D.toJSON"});
        const s = {};
        s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON()));

        function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid
        }

        if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
            s.geometry = r(t.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l)) for (let c = 0, h = l.length; c < h; c++) {
                    const u = l[c];
                    r(t.shapes, u)
                } else r(t.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(t.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const a = [];
            for (let l = 0, c = this.material.length; l < c; l++) a.push(r(t.materials, this.material[l]));
            s.material = a
        } else s.material = r(t.materials, this.material);
        if (this.children.length > 0) {
            s.children = [];
            for (let a = 0; a < this.children.length; a++) s.children.push(this.children[a].toJSON(t).object)
        }
        if (this.animations.length > 0) {
            s.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                s.animations.push(r(t.animations, l))
            }
        }
        if (e) {
            const a = o(t.geometries), l = o(t.materials), c = o(t.textures), h = o(t.images), u = o(t.shapes),
                d = o(t.skeletons), f = o(t.animations), g = o(t.nodes);
            a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), u.length > 0 && (n.shapes = u), d.length > 0 && (n.skeletons = d), f.length > 0 && (n.animations = f), g.length > 0 && (n.nodes = g)
        }
        return n.object = s, n;

        function o(a) {
            const l = [];
            for (const c in a) {
                const h = a[c];
                delete h.metadata, l.push(h)
            }
            return l
        }
    }

    clone(t) {
        return new this.constructor().copy(this, t)
    }

    copy(t, e = !0) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0) for (let n = 0; n < t.children.length; n++) {
            const s = t.children[n];
            this.add(s.clone())
        }
        return this
    }
}

re.DEFAULT_UP = new C(0, 1, 0);
re.DEFAULT_MATRIX_AUTO_UPDATE = !0;
re.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ei = new C, Zi = new C, Mp = new C, ji = new C, la = new C, ca = new C, by = new C, Tp = new C, Ip = new C,
    Ap = new C;
let Oo = class Ca {
    constructor(t = new C, e = new C, n = new C) {
        this.a = t, this.b = e, this.c = n
    }

    static getNormal(t, e, n, s) {
        s.subVectors(n, e), ei.subVectors(t, e), s.cross(ei);
        const r = s.lengthSq();
        return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0)
    }

    static getBarycoord(t, e, n, s, r) {
        ei.subVectors(s, e), Zi.subVectors(n, e), Mp.subVectors(t, e);
        const o = ei.dot(ei), a = ei.dot(Zi), l = ei.dot(Mp), c = Zi.dot(Zi), h = Zi.dot(Mp), u = o * c - a * a;
        if (u === 0) return r.set(-2, -1, -1);
        const d = 1 / u, f = (c * l - a * h) * d, g = (o * h - a * l) * d;
        return r.set(1 - f - g, g, f)
    }

    static containsPoint(t, e, n, s) {
        return this.getBarycoord(t, e, n, s, ji), ji.x >= 0 && ji.y >= 0 && ji.x + ji.y <= 1
    }

    static getUV(t, e, n, s, r, o, a, l) {
        return this.getBarycoord(t, e, n, s, ji), l.set(0, 0), l.addScaledVector(r, ji.x), l.addScaledVector(o, ji.y), l.addScaledVector(a, ji.z), l
    }

    static isFrontFacing(t, e, n, s) {
        return ei.subVectors(n, e), Zi.subVectors(t, e), ei.cross(Zi).dot(s) < 0
    }

    set(t, e, n) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
    }

    setFromPointsAndIndices(t, e, n, s) {
        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[s]), this
    }

    setFromAttributeAndIndices(t, e, n, s) {
        return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, s), this
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    }

    getArea() {
        return ei.subVectors(this.c, this.b), Zi.subVectors(this.a, this.b), ei.cross(Zi).length() * .5
    }

    getMidpoint(t) {
        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }

    getNormal(t) {
        return Ca.getNormal(this.a, this.b, this.c, t)
    }

    getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c)
    }

    getBarycoord(t, e) {
        return Ca.getBarycoord(t, this.a, this.b, this.c, e)
    }

    getUV(t, e, n, s, r) {
        return Ca.getUV(t, this.a, this.b, this.c, e, n, s, r)
    }

    containsPoint(t) {
        return Ca.containsPoint(t, this.a, this.b, this.c)
    }

    isFrontFacing(t) {
        return Ca.isFrontFacing(this.a, this.b, this.c, t)
    }

    intersectsBox(t) {
        return t.intersectsTriangle(this)
    }

    closestPointToPoint(t, e) {
        const n = this.a, s = this.b, r = this.c;
        let o, a;
        la.subVectors(s, n), ca.subVectors(r, n), Tp.subVectors(t, n);
        const l = la.dot(Tp), c = ca.dot(Tp);
        if (l <= 0 && c <= 0) return e.copy(n);
        Ip.subVectors(t, s);
        const h = la.dot(Ip), u = ca.dot(Ip);
        if (h >= 0 && u <= h) return e.copy(s);
        const d = l * u - h * c;
        if (d <= 0 && l >= 0 && h <= 0) return o = l / (l - h), e.copy(n).addScaledVector(la, o);
        Ap.subVectors(t, r);
        const f = la.dot(Ap), g = ca.dot(Ap);
        if (g >= 0 && f <= g) return e.copy(r);
        const m = f * c - l * g;
        if (m <= 0 && c >= 0 && g <= 0) return a = c / (c - g), e.copy(n).addScaledVector(ca, a);
        const p = h * g - f * u;
        if (p <= 0 && u - h >= 0 && f - g >= 0) return by.subVectors(r, s), a = (u - h) / (u - h + (f - g)), e.copy(s).addScaledVector(by, a);
        const _ = 1 / (p + m + d);
        return o = m * _, a = d * _, e.copy(n).addScaledVector(la, o).addScaledVector(ca, a)
    }

    equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
}, GI = 0, En = class extends Gi {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {value: GI++}), this.uuid = zs(), this.name = "", this.type = "Material", this.blending = Or, this.side = Fi, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = Zm, this.blendDst = jm, this.blendEquation = vo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = rd, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Ob, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ju, this.stencilZFail = Ju, this.stencilZPass = Ju, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }

    get alphaTest() {
        return this._alphaTest
    }

    set alphaTest(t) {
        this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
    }

    onBuild() {
    }

    onBeforeRender() {
    }

    onBeforeCompile() {
    }

    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }

    setValues(t) {
        if (t !== void 0) for (const e in t) {
            const n = t[e];
            if (n === void 0) {
                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                continue
            }
            const s = this[e];
            if (s === void 0) {
                console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
                continue
            }
            s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[e] = n
        }
    }

    toJSON(t) {
        const e = t === void 0 || typeof t == "string";
        e && (t = {textures: {}, images: {}});
        const n = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};
        n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Or && (n.blending = this.blending), this.side !== Fi && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);

        function s(r) {
            const o = [];
            for (const a in r) {
                const l = r[a];
                delete l.metadata, o.push(l)
            }
            return o
        }

        if (e) {
            const r = s(t.textures), o = s(t.images);
            r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o)
        }
        return n
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const e = t.clippingPlanes;
        let n = null;
        if (e !== null) {
            const s = e.length;
            n = new Array(s);
            for (let r = 0; r !== s; ++r) n[r] = e[r].clone()
        }
        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }
};

class rn extends En {
    constructor(t) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new pt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = hh, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
    }
}

const mn = new C, Xh = new j;

class ae {
    constructor(t, e, n = !1) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = Fc, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    onUploadCallback() {
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }

    setUsage(t) {
        return this.usage = t, this
    }

    copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
    }

    copyAt(t, e, n) {
        t *= this.itemSize, n *= e.itemSize;
        for (let s = 0, r = this.itemSize; s < r; s++) this.array[t + s] = e.array[n + s];
        return this
    }

    copyArray(t) {
        return this.array.set(t), this
    }

    applyMatrix3(t) {
        if (this.itemSize === 2) for (let e = 0, n = this.count; e < n; e++) Xh.fromBufferAttribute(this, e), Xh.applyMatrix3(t), this.setXY(e, Xh.x, Xh.y); else if (this.itemSize === 3) for (let e = 0, n = this.count; e < n; e++) mn.fromBufferAttribute(this, e), mn.applyMatrix3(t), this.setXYZ(e, mn.x, mn.y, mn.z);
        return this
    }

    applyMatrix4(t) {
        for (let e = 0, n = this.count; e < n; e++) mn.fromBufferAttribute(this, e), mn.applyMatrix4(t), this.setXYZ(e, mn.x, mn.y, mn.z);
        return this
    }

    applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++) mn.fromBufferAttribute(this, e), mn.applyNormalMatrix(t), this.setXYZ(e, mn.x, mn.y, mn.z);
        return this
    }

    transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++) mn.fromBufferAttribute(this, e), mn.transformDirection(t), this.setXYZ(e, mn.x, mn.y, mn.z);
        return this
    }

    set(t, e = 0) {
        return this.array.set(t, e), this
    }

    getX(t) {
        let e = this.array[t * this.itemSize];
        return this.normalized && (e = rr(e, this.array)), e
    }

    setX(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.array[t * this.itemSize] = e, this
    }

    getY(t) {
        let e = this.array[t * this.itemSize + 1];
        return this.normalized && (e = rr(e, this.array)), e
    }

    setY(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.array[t * this.itemSize + 1] = e, this
    }

    getZ(t) {
        let e = this.array[t * this.itemSize + 2];
        return this.normalized && (e = rr(e, this.array)), e
    }

    setZ(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.array[t * this.itemSize + 2] = e, this
    }

    getW(t) {
        let e = this.array[t * this.itemSize + 3];
        return this.normalized && (e = rr(e, this.array)), e
    }

    setW(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.array[t * this.itemSize + 3] = e, this
    }

    setXY(t, e, n) {
        return t *= this.itemSize, this.normalized && (e = Ve(e, this.array), n = Ve(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
    }

    setXYZ(t, e, n, s) {
        return t *= this.itemSize, this.normalized && (e = Ve(e, this.array), n = Ve(n, this.array), s = Ve(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = s, this
    }

    setXYZW(t, e, n, s, r) {
        return t *= this.itemSize, this.normalized && (e = Ve(e, this.array), n = Ve(n, this.array), s = Ve(s, this.array), r = Ve(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = s, this.array[t + 3] = r, this
    }

    onUpload(t) {
        return this.onUploadCallback = t, this
    }

    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }

    toJSON() {
        const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (t.name = this.name), this.usage !== Fc && (t.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (t.updateRange = this.updateRange), t
    }

    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }

    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }

    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }

    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}

class VI extends ae {
    constructor(t, e, n) {
        super(new Int8Array(t), e, n)
    }
}

class HI extends ae {
    constructor(t, e, n) {
        super(new Uint8Array(t), e, n)
    }
}

class $I extends ae {
    constructor(t, e, n) {
        super(new Uint8ClampedArray(t), e, n)
    }
}

class WI extends ae {
    constructor(t, e, n) {
        super(new Int16Array(t), e, n)
    }
}

class i0 extends ae {
    constructor(t, e, n) {
        super(new Uint16Array(t), e, n)
    }
}

class qI extends ae {
    constructor(t, e, n) {
        super(new Int32Array(t), e, n)
    }
}

class r0 extends ae {
    constructor(t, e, n) {
        super(new Uint32Array(t), e, n)
    }
}

class YI extends ae {
    constructor(t, e, n) {
        super(new Uint16Array(t), e, n), this.isFloat16BufferAttribute = !0
    }
}

class Ct extends ae {
    constructor(t, e, n) {
        super(new Float32Array(t), e, n)
    }
}

class XI extends ae {
    constructor(t, e, n) {
        super(new Float64Array(t), e, n)
    }
}

let ZI = 0;
const Vs = new Yt, Cp = new re, ha = new C, As = new fi, ql = new fi, Pn = new C;

class Xt extends Gi {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {value: ZI++}), this.uuid = zs(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }

    getIndex() {
        return this.index
    }

    setIndex(t) {
        return Array.isArray(t) ? this.index = new (zb(t) ? r0 : i0)(t, 1) : this.index = t, this
    }

    getAttribute(t) {
        return this.attributes[t]
    }

    setAttribute(t, e) {
        return this.attributes[t] = e, this
    }

    deleteAttribute(t) {
        return delete this.attributes[t], this
    }

    hasAttribute(t) {
        return this.attributes[t] !== void 0
    }

    addGroup(t, e, n = 0) {
        this.groups.push({start: t, count: e, materialIndex: n})
    }

    clearGroups() {
        this.groups = []
    }

    setDrawRange(t, e) {
        this.drawRange.start = t, this.drawRange.count = e
    }

    applyMatrix4(t) {
        const e = this.attributes.position;
        e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const r = new ds().getNormalMatrix(t);
            n.applyNormalMatrix(r), n.needsUpdate = !0
        }
        const s = this.attributes.tangent;
        return s !== void 0 && (s.transformDirection(t), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }

    applyQuaternion(t) {
        return Vs.makeRotationFromQuaternion(t), this.applyMatrix4(Vs), this
    }

    rotateX(t) {
        return Vs.makeRotationX(t), this.applyMatrix4(Vs), this
    }

    rotateY(t) {
        return Vs.makeRotationY(t), this.applyMatrix4(Vs), this
    }

    rotateZ(t) {
        return Vs.makeRotationZ(t), this.applyMatrix4(Vs), this
    }

    translate(t, e, n) {
        return Vs.makeTranslation(t, e, n), this.applyMatrix4(Vs), this
    }

    scale(t, e, n) {
        return Vs.makeScale(t, e, n), this.applyMatrix4(Vs), this
    }

    lookAt(t) {
        return Cp.lookAt(t), Cp.updateMatrix(), this.applyMatrix4(Cp.matrix), this
    }

    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(ha).negate(), this.translate(ha.x, ha.y, ha.z), this
    }

    setFromPoints(t) {
        const e = [];
        for (let n = 0, s = t.length; n < s; n++) {
            const r = t[n];
            e.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new Ct(e, 3)), this
    }

    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new fi);
        const t = this.attributes.position, e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new C(-1 / 0, -1 / 0, -1 / 0), new C(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (t !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(t), e) for (let n = 0, s = e.length; n < s; n++) {
                const r = e[n];
                As.setFromBufferAttribute(r), this.morphTargetsRelative ? (Pn.addVectors(this.boundingBox.min, As.min), this.boundingBox.expandByPoint(Pn), Pn.addVectors(this.boundingBox.max, As.max), this.boundingBox.expandByPoint(Pn)) : (this.boundingBox.expandByPoint(As.min), this.boundingBox.expandByPoint(As.max))
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }

    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Zr);
        const t = this.attributes.position, e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new C, 1 / 0);
            return
        }
        if (t) {
            const n = this.boundingSphere.center;
            if (As.setFromBufferAttribute(t), e) for (let r = 0, o = e.length; r < o; r++) {
                const a = e[r];
                ql.setFromBufferAttribute(a), this.morphTargetsRelative ? (Pn.addVectors(As.min, ql.min), As.expandByPoint(Pn), Pn.addVectors(As.max, ql.max), As.expandByPoint(Pn)) : (As.expandByPoint(ql.min), As.expandByPoint(ql.max))
            }
            As.getCenter(n);
            let s = 0;
            for (let r = 0, o = t.count; r < o; r++) Pn.fromBufferAttribute(t, r), s = Math.max(s, n.distanceToSquared(Pn));
            if (e) for (let r = 0, o = e.length; r < o; r++) {
                const a = e[r], l = this.morphTargetsRelative;
                for (let c = 0, h = a.count; c < h; c++) Pn.fromBufferAttribute(a, c), l && (ha.fromBufferAttribute(t, c), Pn.add(ha)), s = Math.max(s, n.distanceToSquared(Pn))
            }
            this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }

    computeTangents() {
        const t = this.index, e = this.attributes;
        if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = t.array, s = e.position.array, r = e.normal.array, o = e.uv.array, a = s.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ae(new Float32Array(4 * a), 4));
        const l = this.getAttribute("tangent").array, c = [], h = [];
        for (let I = 0; I < a; I++) c[I] = new C, h[I] = new C;
        const u = new C, d = new C, f = new C, g = new j, m = new j, p = new j, _ = new C, x = new C;

        function y(I, N, B) {
            u.fromArray(s, I * 3), d.fromArray(s, N * 3), f.fromArray(s, B * 3), g.fromArray(o, I * 2), m.fromArray(o, N * 2), p.fromArray(o, B * 2), d.sub(u), f.sub(u), m.sub(g), p.sub(g);
            const D = 1 / (m.x * p.y - p.x * m.y);
            isFinite(D) && (_.copy(d).multiplyScalar(p.y).addScaledVector(f, -m.y).multiplyScalar(D), x.copy(f).multiplyScalar(m.x).addScaledVector(d, -p.x).multiplyScalar(D), c[I].add(_), c[N].add(_), c[B].add(_), h[I].add(x), h[N].add(x), h[B].add(x))
        }

        let v = this.groups;
        v.length === 0 && (v = [{start: 0, count: n.length}]);
        for (let I = 0, N = v.length; I < N; ++I) {
            const B = v[I], D = B.start, L = B.count;
            for (let k = D, G = D + L; k < G; k += 3) y(n[k + 0], n[k + 1], n[k + 2])
        }
        const w = new C, E = new C, S = new C, b = new C;

        function M(I) {
            S.fromArray(r, I * 3), b.copy(S);
            const N = c[I];
            w.copy(N), w.sub(S.multiplyScalar(S.dot(N))).normalize(), E.crossVectors(b, N);
            const D = E.dot(h[I]) < 0 ? -1 : 1;
            l[I * 4] = w.x, l[I * 4 + 1] = w.y, l[I * 4 + 2] = w.z, l[I * 4 + 3] = D
        }

        for (let I = 0, N = v.length; I < N; ++I) {
            const B = v[I], D = B.start, L = B.count;
            for (let k = D, G = D + L; k < G; k += 3) M(n[k + 0]), M(n[k + 1]), M(n[k + 2])
        }
    }

    computeVertexNormals() {
        const t = this.index, e = this.getAttribute("position");
        if (e !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0) n = new ae(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n); else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
            const s = new C, r = new C, o = new C, a = new C, l = new C, c = new C, h = new C, u = new C;
            if (t) for (let d = 0, f = t.count; d < f; d += 3) {
                const g = t.getX(d + 0), m = t.getX(d + 1), p = t.getX(d + 2);
                s.fromBufferAttribute(e, g), r.fromBufferAttribute(e, m), o.fromBufferAttribute(e, p), h.subVectors(o, r), u.subVectors(s, r), h.cross(u), a.fromBufferAttribute(n, g), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, p), a.add(h), l.add(h), c.add(h), n.setXYZ(g, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(p, c.x, c.y, c.z)
            } else for (let d = 0, f = e.count; d < f; d += 3) s.fromBufferAttribute(e, d + 0), r.fromBufferAttribute(e, d + 1), o.fromBufferAttribute(e, d + 2), h.subVectors(o, r), u.subVectors(s, r), h.cross(u), n.setXYZ(d + 0, h.x, h.y, h.z), n.setXYZ(d + 1, h.x, h.y, h.z), n.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(), n.needsUpdate = !0
        }
    }

    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
    }

    normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, n = t.count; e < n; e++) Pn.fromBufferAttribute(t, e), Pn.normalize(), t.setXYZ(e, Pn.x, Pn.y, Pn.z)
    }

    toNonIndexed() {
        function t(a, l) {
            const c = a.array, h = a.itemSize, u = a.normalized, d = new c.constructor(l.length * h);
            let f = 0, g = 0;
            for (let m = 0, p = l.length; m < p; m++) {
                a.isInterleavedBufferAttribute ? f = l[m] * a.data.stride + a.offset : f = l[m] * h;
                for (let _ = 0; _ < h; _++) d[g++] = c[f++]
            }
            return new ae(d, h, u)
        }

        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e = new Xt, n = this.index.array, s = this.attributes;
        for (const a in s) {
            const l = s[a], c = t(l, n);
            e.setAttribute(a, c)
        }
        const r = this.morphAttributes;
        for (const a in r) {
            const l = [], c = r[a];
            for (let h = 0, u = c.length; h < u; h++) {
                const d = c[h], f = t(d, n);
                l.push(f)
            }
            e.morphAttributes[a] = l
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            e.addGroup(c.start, c.count, c.materialIndex)
        }
        return e
    }

    toJSON() {
        const t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
        if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (t[c] = l[c]);
            return t
        }
        t.data = {attributes: {}};
        const e = this.index;
        e !== null && (t.data.index = {type: e.array.constructor.name, array: Array.prototype.slice.call(e.array)});
        const n = this.attributes;
        for (const l in n) {
            const c = n[l];
            t.data.attributes[l] = c.toJSON(t.data)
        }
        const s = {};
        let r = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l], h = [];
            for (let u = 0, d = c.length; u < d; u++) {
                const f = c[u];
                h.push(f.toJSON(t.data))
            }
            h.length > 0 && (s[l] = h, r = !0)
        }
        r && (t.data.morphAttributes = s, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (t.data.boundingSphere = {center: a.center.toArray(), radius: a.radius}), t
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e = {};
        this.name = t.name;
        const n = t.index;
        n !== null && this.setIndex(n.clone(e));
        const s = t.attributes;
        for (const c in s) {
            const h = s[c];
            this.setAttribute(c, h.clone(e))
        }
        const r = t.morphAttributes;
        for (const c in r) {
            const h = [], u = r[c];
            for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(e));
            this.morphAttributes[c] = h
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const o = t.groups;
        for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex)
        }
        const a = t.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = t.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, t.parameters !== void 0 && (this.parameters = Object.assign({}, t.parameters)), this
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }
}

const Ey = new Yt, ua = new uh, Pp = new Zr, Yl = new C, Xl = new C, Zl = new C, Rp = new C, Zh = new C, jh = new j,
    Kh = new j, Jh = new j, Lp = new C, Qh = new C;

class ge extends re {
    constructor(t = new Xt, e = new rn) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
    }

    copy(t, e) {
        return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
    }

    updateMorphTargets() {
        const e = this.geometry.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
            const s = e[n[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let r = 0, o = s.length; r < o; r++) {
                    const a = s[r].name || String(r);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                }
            }
        }
    }

    getVertexPosition(t, e) {
        const n = this.geometry, s = n.attributes.position, r = n.morphAttributes.position, o = n.morphTargetsRelative;
        e.fromBufferAttribute(s, t);
        const a = this.morphTargetInfluences;
        if (r && a) {
            Zh.set(0, 0, 0);
            for (let l = 0, c = r.length; l < c; l++) {
                const h = a[l], u = r[l];
                h !== 0 && (Rp.fromBufferAttribute(u, t), o ? Zh.addScaledVector(Rp, h) : Zh.addScaledVector(Rp.sub(e), h))
            }
            e.add(Zh)
        }
        return this.isSkinnedMesh && this.boneTransform(t, e), e
    }

    raycast(t, e) {
        const n = this.geometry, s = this.material, r = this.matrixWorld;
        if (s === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), Pp.copy(n.boundingSphere), Pp.applyMatrix4(r), t.ray.intersectsSphere(Pp) === !1) || (Ey.copy(r).invert(), ua.copy(t.ray).applyMatrix4(Ey), n.boundingBox !== null && ua.intersectsBox(n.boundingBox) === !1)) return;
        let o;
        const a = n.index, l = n.attributes.position, c = n.attributes.uv, h = n.attributes.uv2, u = n.groups,
            d = n.drawRange;
        if (a !== null) if (Array.isArray(s)) for (let f = 0, g = u.length; f < g; f++) {
            const m = u[f], p = s[m.materialIndex], _ = Math.max(m.start, d.start),
                x = Math.min(a.count, Math.min(m.start + m.count, d.start + d.count));
            for (let y = _, v = x; y < v; y += 3) {
                const w = a.getX(y), E = a.getX(y + 1), S = a.getX(y + 2);
                o = tu(this, p, t, ua, c, h, w, E, S), o && (o.faceIndex = Math.floor(y / 3), o.face.materialIndex = m.materialIndex, e.push(o))
            }
        } else {
            const f = Math.max(0, d.start), g = Math.min(a.count, d.start + d.count);
            for (let m = f, p = g; m < p; m += 3) {
                const _ = a.getX(m), x = a.getX(m + 1), y = a.getX(m + 2);
                o = tu(this, s, t, ua, c, h, _, x, y), o && (o.faceIndex = Math.floor(m / 3), e.push(o))
            }
        } else if (l !== void 0) if (Array.isArray(s)) for (let f = 0, g = u.length; f < g; f++) {
            const m = u[f], p = s[m.materialIndex], _ = Math.max(m.start, d.start),
                x = Math.min(l.count, Math.min(m.start + m.count, d.start + d.count));
            for (let y = _, v = x; y < v; y += 3) {
                const w = y, E = y + 1, S = y + 2;
                o = tu(this, p, t, ua, c, h, w, E, S), o && (o.faceIndex = Math.floor(y / 3), o.face.materialIndex = m.materialIndex, e.push(o))
            }
        } else {
            const f = Math.max(0, d.start), g = Math.min(l.count, d.start + d.count);
            for (let m = f, p = g; m < p; m += 3) {
                const _ = m, x = m + 1, y = m + 2;
                o = tu(this, s, t, ua, c, h, _, x, y), o && (o.faceIndex = Math.floor(m / 3), e.push(o))
            }
        }
    }
}

function jI(i, t, e, n, s, r, o, a) {
    let l;
    if (t.side === xs ? l = n.intersectTriangle(o, r, s, !0, a) : l = n.intersectTriangle(s, r, o, t.side === Fi, a), l === null) return null;
    Qh.copy(a), Qh.applyMatrix4(i.matrixWorld);
    const c = e.ray.origin.distanceTo(Qh);
    return c < e.near || c > e.far ? null : {distance: c, point: Qh.clone(), object: i}
}

function tu(i, t, e, n, s, r, o, a, l) {
    i.getVertexPosition(o, Yl), i.getVertexPosition(a, Xl), i.getVertexPosition(l, Zl);
    const c = jI(i, t, e, n, Yl, Xl, Zl, Lp);
    if (c) {
        s && (jh.fromBufferAttribute(s, o), Kh.fromBufferAttribute(s, a), Jh.fromBufferAttribute(s, l), c.uv = Oo.getUV(Lp, Yl, Xl, Zl, jh, Kh, Jh, new j)), r && (jh.fromBufferAttribute(r, o), Kh.fromBufferAttribute(r, a), Jh.fromBufferAttribute(r, l), c.uv2 = Oo.getUV(Lp, Yl, Xl, Zl, jh, Kh, Jh, new j));
        const h = {a: o, b: a, c: l, normal: new C, materialIndex: 0};
        Oo.getNormal(Yl, Xl, Zl, h.normal), c.face = h
    }
    return c
}

class Vi extends Xt {
    constructor(t = 1, e = 1, n = 1, s = 1, r = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: s,
            heightSegments: r,
            depthSegments: o
        };
        const a = this;
        s = Math.floor(s), r = Math.floor(r), o = Math.floor(o);
        const l = [], c = [], h = [], u = [];
        let d = 0, f = 0;
        g("z", "y", "x", -1, -1, n, e, t, o, r, 0), g("z", "y", "x", 1, -1, n, e, -t, o, r, 1), g("x", "z", "y", 1, 1, t, n, e, s, o, 2), g("x", "z", "y", 1, -1, t, n, -e, s, o, 3), g("x", "y", "z", 1, -1, t, e, n, s, r, 4), g("x", "y", "z", -1, -1, t, e, -n, s, r, 5), this.setIndex(l), this.setAttribute("position", new Ct(c, 3)), this.setAttribute("normal", new Ct(h, 3)), this.setAttribute("uv", new Ct(u, 2));

        function g(m, p, _, x, y, v, w, E, S, b, M) {
            const I = v / S, N = w / b, B = v / 2, D = w / 2, L = E / 2, k = S + 1, G = b + 1;
            let Q = 0, q = 0;
            const at = new C;
            for (let lt = 0; lt < G; lt++) {
                const wt = lt * N - D;
                for (let W = 0; W < k; W++) {
                    const st = W * I - B;
                    at[m] = st * x, at[p] = wt * y, at[_] = L, c.push(at.x, at.y, at.z), at[m] = 0, at[p] = 0, at[_] = E > 0 ? 1 : -1, h.push(at.x, at.y, at.z), u.push(W / S), u.push(1 - lt / b), Q += 1
                }
            }
            for (let lt = 0; lt < b; lt++) for (let wt = 0; wt < S; wt++) {
                const W = d + wt + k * lt, st = d + wt + k * (lt + 1), gt = d + (wt + 1) + k * (lt + 1),
                    mt = d + (wt + 1) + k * lt;
                l.push(W, st, mt), l.push(st, gt, mt), q += 6
            }
            a.addGroup(f, q, M), f += q, d += Q
        }
    }

    static fromJSON(t) {
        return new Vi(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
    }
}

function rl(i) {
    const t = {};
    for (const e in i) {
        t[e] = {};
        for (const n in i[e]) {
            const s = i[e][n];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? t[e][n] = s.clone() : Array.isArray(s) ? t[e][n] = s.slice() : t[e][n] = s
        }
    }
    return t
}

function ss(i) {
    const t = {};
    for (let e = 0; e < i.length; e++) {
        const n = rl(i[e]);
        for (const s in n) t[s] = n[s]
    }
    return t
}

function KI(i) {
    const t = [];
    for (let e = 0; e < i.length; e++) t.push(i[e].clone());
    return t
}

function Gb(i) {
    return i.getRenderTarget() === null && i.outputEncoding === Ee ? ii : il
}

const kc = {clone: rl, merge: ss};
var JI = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, QI = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;

class jn extends En {
    constructor(t) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = JI, this.fragmentShader = QI, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = rl(t.uniforms), this.uniformsGroups = KI(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
    }

    toJSON(t) {
        const e = super.toJSON(t);
        e.glslVersion = this.glslVersion, e.uniforms = {};
        for (const s in this.uniforms) {
            const o = this.uniforms[s].value;
            o && o.isTexture ? e.uniforms[s] = {
                type: "t",
                value: o.toJSON(t).uuid
            } : o && o.isColor ? e.uniforms[s] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? e.uniforms[s] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? e.uniforms[s] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? e.uniforms[s] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? e.uniforms[s] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? e.uniforms[s] = {type: "m4", value: o.toArray()} : e.uniforms[s] = {value: o}
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        const n = {};
        for (const s in this.extensions) this.extensions[s] === !0 && (n[s] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e
    }
}

class Zd extends re {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Yt, this.projectionMatrix = new Yt, this.projectionMatrixInverse = new Yt
    }

    copy(t, e) {
        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
    }

    getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize()
    }

    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }

    updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

class bn extends Zd {
    constructor(t = 50, e = 1, n = .1, s = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    copy(t, e) {
        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
    }

    setFocalLength(t) {
        const e = .5 * this.getFilmHeight() / t;
        this.fov = zc * 2 * Math.atan(e), this.updateProjectionMatrix()
    }

    getFocalLength() {
        const t = Math.tan(Lo * .5 * this.fov);
        return .5 * this.getFilmHeight() / t
    }

    getEffectiveFOV() {
        return zc * 2 * Math.atan(Math.tan(Lo * .5 * this.fov) / this.zoom)
    }

    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }

    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }

    setViewOffset(t, e, n, s, r, o) {
        this.aspect = t / e, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
    }

    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }

    updateProjectionMatrix() {
        const t = this.near;
        let e = t * Math.tan(Lo * .5 * this.fov) / this.zoom, n = 2 * e, s = this.aspect * n, r = -.5 * s;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth, c = o.fullHeight;
            r += o.offsetX * s / l, e -= o.offsetY * n / c, s *= o.width / l, n *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }

    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
    }
}

const da = -90, fa = 1;

class Vb extends re {
    constructor(t, e, n) {
        super(), this.type = "CubeCamera", this.renderTarget = n;
        const s = new bn(da, fa, t, e);
        s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(1, 0, 0), this.add(s);
        const r = new bn(da, fa, t, e);
        r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), this.add(r);
        const o = new bn(da, fa, t, e);
        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(0, 1, 0), this.add(o);
        const a = new bn(da, fa, t, e);
        a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a);
        const l = new bn(da, fa, t, e);
        l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
        const c = new bn(da, fa, t, e);
        c.layers = this.layers, c.up.set(0, 1, 0), c.lookAt(0, 0, -1), this.add(c)
    }

    update(t, e) {
        this.parent === null && this.updateMatrixWorld();
        const n = this.renderTarget, [s, r, o, a, l, c] = this.children, h = t.getRenderTarget(), u = t.toneMapping,
            d = t.xr.enabled;
        t.toneMapping = Pi, t.xr.enabled = !1;
        const f = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, s), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, l), n.texture.generateMipmaps = f, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(h), t.toneMapping = u, t.xr.enabled = d, n.texture.needsPMREMUpdate = !0
    }
}

class dh extends Sn {
    constructor(t, e, n, s, r, o, a, l, c, h) {
        t = t !== void 0 ? t : [], e = e !== void 0 ? e : Br, super(t, e, n, s, r, o, a, l, c, h), this.isCubeTexture = !0, this.flipY = !1
    }

    get images() {
        return this.image
    }

    set images(t) {
        this.image = t
    }
}

class Hb extends fs {
    constructor(t = 1, e = {}) {
        super(t, t, e), this.isWebGLCubeRenderTarget = !0;
        const n = {width: t, height: t, depth: 1}, s = [n, n, n, n, n, n];
        this.texture = new dh(s, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : Qe
    }

    fromEquirectangularTexture(t, e) {
        this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
        const n = {
            uniforms: {tEquirect: {value: null}}, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }, s = new Vi(5, 5, 5), r = new jn({
            name: "CubemapFromEquirect",
            uniforms: rl(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: xs,
            blending: ar
        });
        r.uniforms.tEquirect.value = e;
        const o = new ge(s, r), a = e.minFilter;
        return e.minFilter === zi && (e.minFilter = Qe), new Vb(1, 10, this).update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
    }

    clear(t, e, n, s) {
        const r = t.getRenderTarget();
        for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, n, s);
        t.setRenderTarget(r)
    }
}

const Np = new C, tA = new C, eA = new ds;
let er = class {
    constructor(t = new C(1, 0, 0), e = 0) {
        this.isPlane = !0, this.normal = t, this.constant = e
    }

    set(t, e) {
        return this.normal.copy(t), this.constant = e, this
    }

    setComponents(t, e, n, s) {
        return this.normal.set(t, e, n), this.constant = s, this
    }

    setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
    }

    setFromCoplanarPoints(t, e, n) {
        const s = Np.subVectors(n, e).cross(tA.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(s, t), this
    }

    copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this
    }

    normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this
    }

    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }

    distanceToPoint(t) {
        return this.normal.dot(t) + this.constant
    }

    distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius
    }

    projectPoint(t, e) {
        return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
    }

    intersectLine(t, e) {
        const n = t.delta(Np), s = this.normal.dot(n);
        if (s === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
        const r = -(t.start.dot(this.normal) + this.constant) / s;
        return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
    }

    intersectsLine(t) {
        const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
        return e < 0 && n > 0 || n < 0 && e > 0
    }

    intersectsBox(t) {
        return t.intersectsPlane(this)
    }

    intersectsSphere(t) {
        return t.intersectsPlane(this)
    }

    coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant)
    }

    applyMatrix4(t, e) {
        const n = e || eA.getNormalMatrix(t), s = this.coplanarPoint(Np).applyMatrix4(t),
            r = this.normal.applyMatrix3(n).normalize();
        return this.constant = -s.dot(r), this
    }

    translate(t) {
        return this.constant -= t.dot(this.normal), this
    }

    equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant
    }

    clone() {
        return new this.constructor().copy(this)
    }
};
const pa = new Zr, eu = new C;

class jd {
    constructor(t = new er, e = new er, n = new er, s = new er, r = new er, o = new er) {
        this.planes = [t, e, n, s, r, o]
    }

    set(t, e, n, s, r, o) {
        const a = this.planes;
        return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(s), a[4].copy(r), a[5].copy(o), this
    }

    copy(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this
    }

    setFromProjectionMatrix(t) {
        const e = this.planes, n = t.elements, s = n[0], r = n[1], o = n[2], a = n[3], l = n[4], c = n[5], h = n[6],
            u = n[7], d = n[8], f = n[9], g = n[10], m = n[11], p = n[12], _ = n[13], x = n[14], y = n[15];
        return e[0].setComponents(a - s, u - l, m - d, y - p).normalize(), e[1].setComponents(a + s, u + l, m + d, y + p).normalize(), e[2].setComponents(a + r, u + c, m + f, y + _).normalize(), e[3].setComponents(a - r, u - c, m - f, y - _).normalize(), e[4].setComponents(a - o, u - h, m - g, y - x).normalize(), e[5].setComponents(a + o, u + h, m + g, y + x).normalize(), this
    }

    intersectsObject(t) {
        const e = t.geometry;
        return e.boundingSphere === null && e.computeBoundingSphere(), pa.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(pa)
    }

    intersectsSprite(t) {
        return pa.center.set(0, 0, 0), pa.radius = .7071067811865476, pa.applyMatrix4(t.matrixWorld), this.intersectsSphere(pa)
    }

    intersectsSphere(t) {
        const e = this.planes, n = t.center, s = -t.radius;
        for (let r = 0; r < 6; r++) if (e[r].distanceToPoint(n) < s) return !1;
        return !0
    }

    intersectsBox(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) {
            const s = e[n];
            if (eu.x = s.normal.x > 0 ? t.max.x : t.min.x, eu.y = s.normal.y > 0 ? t.max.y : t.min.y, eu.z = s.normal.z > 0 ? t.max.z : t.min.z, s.distanceToPoint(eu) < 0) return !1
        }
        return !0
    }

    containsPoint(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
        return !0
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

function $b() {
    let i = null, t = !1, e = null, n = null;

    function s(r, o) {
        e(r, o), n = i.requestAnimationFrame(s)
    }

    return {
        start: function () {
            t !== !0 && e !== null && (n = i.requestAnimationFrame(s), t = !0)
        }, stop: function () {
            i.cancelAnimationFrame(n), t = !1
        }, setAnimationLoop: function (r) {
            e = r
        }, setContext: function (r) {
            i = r
        }
    }
}

function nA(i, t) {
    const e = t.isWebGL2, n = new WeakMap;

    function s(c, h) {
        const u = c.array, d = c.usage, f = i.createBuffer();
        i.bindBuffer(h, f), i.bufferData(h, u, d), c.onUploadCallback();
        let g;
        if (u instanceof Float32Array) g = 5126; else if (u instanceof Uint16Array) if (c.isFloat16BufferAttribute) if (e) g = 5131; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else g = 5123; else if (u instanceof Int16Array) g = 5122; else if (u instanceof Uint32Array) g = 5125; else if (u instanceof Int32Array) g = 5124; else if (u instanceof Int8Array) g = 5120; else if (u instanceof Uint8Array) g = 5121; else if (u instanceof Uint8ClampedArray) g = 5121; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
        return {buffer: f, type: g, bytesPerElement: u.BYTES_PER_ELEMENT, version: c.version}
    }

    function r(c, h, u) {
        const d = h.array, f = h.updateRange;
        i.bindBuffer(u, c), f.count === -1 ? i.bufferSubData(u, 0, d) : (e ? i.bufferSubData(u, f.offset * d.BYTES_PER_ELEMENT, d, f.offset, f.count) : i.bufferSubData(u, f.offset * d.BYTES_PER_ELEMENT, d.subarray(f.offset, f.offset + f.count)), f.count = -1), h.onUploadCallback()
    }

    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data), n.get(c)
    }

    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        const h = n.get(c);
        h && (i.deleteBuffer(h.buffer), n.delete(c))
    }

    function l(c, h) {
        if (c.isGLBufferAttribute) {
            const d = n.get(c);
            (!d || d.version < c.version) && n.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        const u = n.get(c);
        u === void 0 ? n.set(c, s(c, h)) : u.version < c.version && (r(u.buffer, c, h), u.version = c.version)
    }

    return {get: o, remove: a, update: l}
}

class Sl extends Xt {
    constructor(t = 1, e = 1, n = 1, s = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: s
        };
        const r = t / 2, o = e / 2, a = Math.floor(n), l = Math.floor(s), c = a + 1, h = l + 1, u = t / a, d = e / l,
            f = [], g = [], m = [], p = [];
        for (let _ = 0; _ < h; _++) {
            const x = _ * d - o;
            for (let y = 0; y < c; y++) {
                const v = y * u - r;
                g.push(v, -x, 0), m.push(0, 0, 1), p.push(y / a), p.push(1 - _ / l)
            }
        }
        for (let _ = 0; _ < l; _++) for (let x = 0; x < a; x++) {
            const y = x + c * _, v = x + c * (_ + 1), w = x + 1 + c * (_ + 1), E = x + 1 + c * _;
            f.push(y, v, E), f.push(v, w, E)
        }
        this.setIndex(f), this.setAttribute("position", new Ct(g, 3)), this.setAttribute("normal", new Ct(m, 3)), this.setAttribute("uv", new Ct(p, 2))
    }

    static fromJSON(t) {
        return new Sl(t.width, t.height, t.widthSegments, t.heightSegments)
    }
}

var sA = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, iA = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, rA = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, oA = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aA = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, lA = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, cA = "vec3 transformed = vec3( position );", hA = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, uA = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, dA = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, fA = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, pA = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, gA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, mA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, _A = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, yA = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, xA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, vA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, wA = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, bA = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, EA = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, SA = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, MA = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, TA = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, IA = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, AA = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, CA = "gl_FragColor = linearToOutputTexel( gl_FragColor );", PA = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, RA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, LA = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, NA = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, OA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, DA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, FA = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, zA = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, BA = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, kA = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, UA = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, GA = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, VA = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, HA = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, $A = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, WA = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, qA = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, YA = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, XA = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, ZA = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, jA = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, KA = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, JA = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, QA = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, t2 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, e2 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, n2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, s2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, i2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, r2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, o2 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, a2 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, l2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, c2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, h2 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, u2 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, d2 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, f2 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, p2 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, g2 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, m2 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, _2 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, y2 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, x2 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, v2 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, w2 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, b2 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, E2 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, S2 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, M2 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, T2 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, I2 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, A2 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, C2 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, P2 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, R2 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, L2 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, N2 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, O2 = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, D2 = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, F2 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, z2 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, B2 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, k2 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, U2 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, G2 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, V2 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, H2 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, $2 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, W2 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, q2 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, Y2 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, X2 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, Z2 = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, j2 = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, K2 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, J2 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, Q2 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, tC = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const eC = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, nC = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, sC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, iC = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, rC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, oC = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, aC = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, lC = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, cC = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, hC = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, uC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, dC = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, fC = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, pC = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, gC = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, mC = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _C = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, yC = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xC = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, vC = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wC = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, bC = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, EC = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, SC = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, MC = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, TC = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, IC = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, AC = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, CC = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, PC = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, RC = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, LC = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, NC = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, OC = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Qt = {
    alphamap_fragment: sA,
    alphamap_pars_fragment: iA,
    alphatest_fragment: rA,
    alphatest_pars_fragment: oA,
    aomap_fragment: aA,
    aomap_pars_fragment: lA,
    begin_vertex: cA,
    beginnormal_vertex: hA,
    bsdfs: uA,
    iridescence_fragment: dA,
    bumpmap_pars_fragment: fA,
    clipping_planes_fragment: pA,
    clipping_planes_pars_fragment: gA,
    clipping_planes_pars_vertex: mA,
    clipping_planes_vertex: _A,
    color_fragment: yA,
    color_pars_fragment: xA,
    color_pars_vertex: vA,
    color_vertex: wA,
    common: bA,
    cube_uv_reflection_fragment: EA,
    defaultnormal_vertex: SA,
    displacementmap_pars_vertex: MA,
    displacementmap_vertex: TA,
    emissivemap_fragment: IA,
    emissivemap_pars_fragment: AA,
    encodings_fragment: CA,
    encodings_pars_fragment: PA,
    envmap_fragment: RA,
    envmap_common_pars_fragment: LA,
    envmap_pars_fragment: NA,
    envmap_pars_vertex: OA,
    envmap_physical_pars_fragment: qA,
    envmap_vertex: DA,
    fog_vertex: FA,
    fog_pars_vertex: zA,
    fog_fragment: BA,
    fog_pars_fragment: kA,
    gradientmap_pars_fragment: UA,
    lightmap_fragment: GA,
    lightmap_pars_fragment: VA,
    lights_lambert_fragment: HA,
    lights_lambert_pars_fragment: $A,
    lights_pars_begin: WA,
    lights_toon_fragment: YA,
    lights_toon_pars_fragment: XA,
    lights_phong_fragment: ZA,
    lights_phong_pars_fragment: jA,
    lights_physical_fragment: KA,
    lights_physical_pars_fragment: JA,
    lights_fragment_begin: QA,
    lights_fragment_maps: t2,
    lights_fragment_end: e2,
    logdepthbuf_fragment: n2,
    logdepthbuf_pars_fragment: s2,
    logdepthbuf_pars_vertex: i2,
    logdepthbuf_vertex: r2,
    map_fragment: o2,
    map_pars_fragment: a2,
    map_particle_fragment: l2,
    map_particle_pars_fragment: c2,
    metalnessmap_fragment: h2,
    metalnessmap_pars_fragment: u2,
    morphcolor_vertex: d2,
    morphnormal_vertex: f2,
    morphtarget_pars_vertex: p2,
    morphtarget_vertex: g2,
    normal_fragment_begin: m2,
    normal_fragment_maps: _2,
    normal_pars_fragment: y2,
    normal_pars_vertex: x2,
    normal_vertex: v2,
    normalmap_pars_fragment: w2,
    clearcoat_normal_fragment_begin: b2,
    clearcoat_normal_fragment_maps: E2,
    clearcoat_pars_fragment: S2,
    iridescence_pars_fragment: M2,
    output_fragment: T2,
    packing: I2,
    premultiplied_alpha_fragment: A2,
    project_vertex: C2,
    dithering_fragment: P2,
    dithering_pars_fragment: R2,
    roughnessmap_fragment: L2,
    roughnessmap_pars_fragment: N2,
    shadowmap_pars_fragment: O2,
    shadowmap_pars_vertex: D2,
    shadowmap_vertex: F2,
    shadowmask_pars_fragment: z2,
    skinbase_vertex: B2,
    skinning_pars_vertex: k2,
    skinning_vertex: U2,
    skinnormal_vertex: G2,
    specularmap_fragment: V2,
    specularmap_pars_fragment: H2,
    tonemapping_fragment: $2,
    tonemapping_pars_fragment: W2,
    transmission_fragment: q2,
    transmission_pars_fragment: Y2,
    uv_pars_fragment: X2,
    uv_pars_vertex: Z2,
    uv_vertex: j2,
    uv2_pars_fragment: K2,
    uv2_pars_vertex: J2,
    uv2_vertex: Q2,
    worldpos_vertex: tC,
    background_vert: eC,
    background_frag: nC,
    backgroundCube_vert: sC,
    backgroundCube_frag: iC,
    cube_vert: rC,
    cube_frag: oC,
    depth_vert: aC,
    depth_frag: lC,
    distanceRGBA_vert: cC,
    distanceRGBA_frag: hC,
    equirect_vert: uC,
    equirect_frag: dC,
    linedashed_vert: fC,
    linedashed_frag: pC,
    meshbasic_vert: gC,
    meshbasic_frag: mC,
    meshlambert_vert: _C,
    meshlambert_frag: yC,
    meshmatcap_vert: xC,
    meshmatcap_frag: vC,
    meshnormal_vert: wC,
    meshnormal_frag: bC,
    meshphong_vert: EC,
    meshphong_frag: SC,
    meshphysical_vert: MC,
    meshphysical_frag: TC,
    meshtoon_vert: IC,
    meshtoon_frag: AC,
    points_vert: CC,
    points_frag: PC,
    shadow_vert: RC,
    shadow_frag: LC,
    sprite_vert: NC,
    sprite_frag: OC
}, xt = {
    common: {
        diffuse: {value: new pt(16777215)},
        opacity: {value: 1},
        map: {value: null},
        uvTransform: {value: new ds},
        uv2Transform: {value: new ds},
        alphaMap: {value: null},
        alphaTest: {value: 0}
    },
    specularmap: {specularMap: {value: null}},
    envmap: {
        envMap: {value: null},
        flipEnvMap: {value: -1},
        reflectivity: {value: 1},
        ior: {value: 1.5},
        refractionRatio: {value: .98}
    },
    aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
    lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
    emissivemap: {emissiveMap: {value: null}},
    bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
    normalmap: {normalMap: {value: null}, normalScale: {value: new j(1, 1)}},
    displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}},
    roughnessmap: {roughnessMap: {value: null}},
    metalnessmap: {metalnessMap: {value: null}},
    gradientmap: {gradientMap: {value: null}},
    fog: {fogDensity: {value: 25e-5}, fogNear: {value: 1}, fogFar: {value: 2e3}, fogColor: {value: new pt(16777215)}},
    lights: {
        ambientLightColor: {value: []},
        lightProbe: {value: []},
        directionalLights: {value: [], properties: {direction: {}, color: {}}},
        directionalLightShadows: {
            value: [],
            properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
        },
        directionalShadowMap: {value: []},
        directionalShadowMatrix: {value: []},
        spotLights: {
            value: [],
            properties: {color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}}
        },
        spotLightShadows: {
            value: [],
            properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
        },
        spotLightMap: {value: []},
        spotShadowMap: {value: []},
        spotLightMatrix: {value: []},
        pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}},
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {value: []},
        pointShadowMatrix: {value: []},
        hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
        rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}},
        ltc_1: {value: null},
        ltc_2: {value: null}
    },
    points: {
        diffuse: {value: new pt(16777215)},
        opacity: {value: 1},
        size: {value: 1},
        scale: {value: 1},
        map: {value: null},
        alphaMap: {value: null},
        alphaTest: {value: 0},
        uvTransform: {value: new ds}
    },
    sprite: {
        diffuse: {value: new pt(16777215)},
        opacity: {value: 1},
        center: {value: new j(.5, .5)},
        rotation: {value: 0},
        map: {value: null},
        alphaMap: {value: null},
        alphaTest: {value: 0},
        uvTransform: {value: new ds}
    }
}, ai = {
    basic: {
        uniforms: ss([xt.common, xt.specularmap, xt.envmap, xt.aomap, xt.lightmap, xt.fog]),
        vertexShader: Qt.meshbasic_vert,
        fragmentShader: Qt.meshbasic_frag
    },
    lambert: {
        uniforms: ss([xt.common, xt.specularmap, xt.envmap, xt.aomap, xt.lightmap, xt.emissivemap, xt.bumpmap, xt.normalmap, xt.displacementmap, xt.fog, xt.lights, {emissive: {value: new pt(0)}}]),
        vertexShader: Qt.meshlambert_vert,
        fragmentShader: Qt.meshlambert_frag
    },
    phong: {
        uniforms: ss([xt.common, xt.specularmap, xt.envmap, xt.aomap, xt.lightmap, xt.emissivemap, xt.bumpmap, xt.normalmap, xt.displacementmap, xt.fog, xt.lights, {
            emissive: {value: new pt(0)},
            specular: {value: new pt(1118481)},
            shininess: {value: 30}
        }]), vertexShader: Qt.meshphong_vert, fragmentShader: Qt.meshphong_frag
    },
    standard: {
        uniforms: ss([xt.common, xt.envmap, xt.aomap, xt.lightmap, xt.emissivemap, xt.bumpmap, xt.normalmap, xt.displacementmap, xt.roughnessmap, xt.metalnessmap, xt.fog, xt.lights, {
            emissive: {value: new pt(0)},
            roughness: {value: 1},
            metalness: {value: 0},
            envMapIntensity: {value: 1}
        }]), vertexShader: Qt.meshphysical_vert, fragmentShader: Qt.meshphysical_frag
    },
    toon: {
        uniforms: ss([xt.common, xt.aomap, xt.lightmap, xt.emissivemap, xt.bumpmap, xt.normalmap, xt.displacementmap, xt.gradientmap, xt.fog, xt.lights, {emissive: {value: new pt(0)}}]),
        vertexShader: Qt.meshtoon_vert,
        fragmentShader: Qt.meshtoon_frag
    },
    matcap: {
        uniforms: ss([xt.common, xt.bumpmap, xt.normalmap, xt.displacementmap, xt.fog, {matcap: {value: null}}]),
        vertexShader: Qt.meshmatcap_vert,
        fragmentShader: Qt.meshmatcap_frag
    },
    points: {uniforms: ss([xt.points, xt.fog]), vertexShader: Qt.points_vert, fragmentShader: Qt.points_frag},
    dashed: {
        uniforms: ss([xt.common, xt.fog, {scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}}]),
        vertexShader: Qt.linedashed_vert,
        fragmentShader: Qt.linedashed_frag
    },
    depth: {uniforms: ss([xt.common, xt.displacementmap]), vertexShader: Qt.depth_vert, fragmentShader: Qt.depth_frag},
    normal: {
        uniforms: ss([xt.common, xt.bumpmap, xt.normalmap, xt.displacementmap, {opacity: {value: 1}}]),
        vertexShader: Qt.meshnormal_vert,
        fragmentShader: Qt.meshnormal_frag
    },
    sprite: {uniforms: ss([xt.sprite, xt.fog]), vertexShader: Qt.sprite_vert, fragmentShader: Qt.sprite_frag},
    background: {
        uniforms: {uvTransform: {value: new ds}, t2D: {value: null}, backgroundIntensity: {value: 1}},
        vertexShader: Qt.background_vert,
        fragmentShader: Qt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {value: null},
            flipEnvMap: {value: -1},
            backgroundBlurriness: {value: 0},
            backgroundIntensity: {value: 1}
        }, vertexShader: Qt.backgroundCube_vert, fragmentShader: Qt.backgroundCube_frag
    },
    cube: {
        uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
        vertexShader: Qt.cube_vert,
        fragmentShader: Qt.cube_frag
    },
    equirect: {uniforms: {tEquirect: {value: null}}, vertexShader: Qt.equirect_vert, fragmentShader: Qt.equirect_frag},
    distanceRGBA: {
        uniforms: ss([xt.common, xt.displacementmap, {
            referencePosition: {value: new C},
            nearDistance: {value: 1},
            farDistance: {value: 1e3}
        }]), vertexShader: Qt.distanceRGBA_vert, fragmentShader: Qt.distanceRGBA_frag
    },
    shadow: {
        uniforms: ss([xt.lights, xt.fog, {color: {value: new pt(0)}, opacity: {value: 1}}]),
        vertexShader: Qt.shadow_vert,
        fragmentShader: Qt.shadow_frag
    }
};
ai.physical = {
    uniforms: ss([ai.standard.uniforms, {
        clearcoat: {value: 0},
        clearcoatMap: {value: null},
        clearcoatRoughness: {value: 0},
        clearcoatRoughnessMap: {value: null},
        clearcoatNormalScale: {value: new j(1, 1)},
        clearcoatNormalMap: {value: null},
        iridescence: {value: 0},
        iridescenceMap: {value: null},
        iridescenceIOR: {value: 1.3},
        iridescenceThicknessMinimum: {value: 100},
        iridescenceThicknessMaximum: {value: 400},
        iridescenceThicknessMap: {value: null},
        sheen: {value: 0},
        sheenColor: {value: new pt(0)},
        sheenColorMap: {value: null},
        sheenRoughness: {value: 1},
        sheenRoughnessMap: {value: null},
        transmission: {value: 0},
        transmissionMap: {value: null},
        transmissionSamplerSize: {value: new j},
        transmissionSamplerMap: {value: null},
        thickness: {value: 0},
        thicknessMap: {value: null},
        attenuationDistance: {value: 0},
        attenuationColor: {value: new pt(0)},
        specularIntensity: {value: 1},
        specularIntensityMap: {value: null},
        specularColor: {value: new pt(1, 1, 1)},
        specularColorMap: {value: null}
    }]), vertexShader: Qt.meshphysical_vert, fragmentShader: Qt.meshphysical_frag
};
const nu = {r: 0, b: 0, g: 0};

function DC(i, t, e, n, s, r, o) {
    const a = new pt(0);
    let l = r === !0 ? 0 : 1, c, h, u = null, d = 0, f = null;

    function g(p, _) {
        let x = !1, y = _.isScene === !0 ? _.background : null;
        y && y.isTexture && (y = (_.backgroundBlurriness > 0 ? e : t).get(y));
        const v = i.xr, w = v.getSession && v.getSession();
        w && w.environmentBlendMode === "additive" && (y = null), y === null ? m(a, l) : y && y.isColor && (m(y, 1), x = !0), (i.autoClear || x) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), y && (y.isCubeTexture || y.mapping === El) ? (h === void 0 && (h = new ge(new Vi(1, 1, 1), new jn({
            name: "BackgroundCubeMaterial",
            uniforms: rl(ai.backgroundCube.uniforms),
            vertexShader: ai.backgroundCube.vertexShader,
            fragmentShader: ai.backgroundCube.fragmentShader,
            side: xs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function (E, S, b) {
            this.matrixWorld.copyPosition(b.matrixWorld)
        }, Object.defineProperty(h.material, "envMap", {
            get: function () {
                return this.uniforms.envMap.value
            }
        }), s.update(h)), h.material.uniforms.envMap.value = y, h.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, h.material.toneMapped = y.encoding !== Ee, (u !== y || d !== y.version || f !== i.toneMapping) && (h.material.needsUpdate = !0, u = y, d = y.version, f = i.toneMapping), h.layers.enableAll(), p.unshift(h, h.geometry, h.material, 0, 0, null)) : y && y.isTexture && (c === void 0 && (c = new ge(new Sl(2, 2), new jn({
            name: "BackgroundMaterial",
            uniforms: rl(ai.background.uniforms),
            vertexShader: ai.background.vertexShader,
            fragmentShader: ai.background.fragmentShader,
            side: Fi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function () {
                return this.uniforms.t2D.value
            }
        }), s.update(c)), c.material.uniforms.t2D.value = y, c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, c.material.toneMapped = y.encoding !== Ee, y.matrixAutoUpdate === !0 && y.updateMatrix(), c.material.uniforms.uvTransform.value.copy(y.matrix), (u !== y || d !== y.version || f !== i.toneMapping) && (c.material.needsUpdate = !0, u = y, d = y.version, f = i.toneMapping), c.layers.enableAll(), p.unshift(c, c.geometry, c.material, 0, 0, null))
    }

    function m(p, _) {
        p.getRGB(nu, Gb(i)), n.buffers.color.setClear(nu.r, nu.g, nu.b, _, o)
    }

    return {
        getClearColor: function () {
            return a
        }, setClearColor: function (p, _ = 1) {
            a.set(p), l = _, m(a, l)
        }, getClearAlpha: function () {
            return l
        }, setClearAlpha: function (p) {
            l = p, m(a, l)
        }, render: g
    }
}

function FC(i, t, e, n) {
    const s = i.getParameter(34921), r = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
        o = n.isWebGL2 || r !== null, a = {}, l = p(null);
    let c = l, h = !1;

    function u(L, k, G, Q, q) {
        let at = !1;
        if (o) {
            const lt = m(Q, G, k);
            c !== lt && (c = lt, f(c.object)), at = _(L, Q, G, q), at && x(L, Q, G, q)
        } else {
            const lt = k.wireframe === !0;
            (c.geometry !== Q.id || c.program !== G.id || c.wireframe !== lt) && (c.geometry = Q.id, c.program = G.id, c.wireframe = lt, at = !0)
        }
        q !== null && e.update(q, 34963), (at || h) && (h = !1, b(L, k, G, Q), q !== null && i.bindBuffer(34963, e.get(q).buffer))
    }

    function d() {
        return n.isWebGL2 ? i.createVertexArray() : r.createVertexArrayOES()
    }

    function f(L) {
        return n.isWebGL2 ? i.bindVertexArray(L) : r.bindVertexArrayOES(L)
    }

    function g(L) {
        return n.isWebGL2 ? i.deleteVertexArray(L) : r.deleteVertexArrayOES(L)
    }

    function m(L, k, G) {
        const Q = G.wireframe === !0;
        let q = a[L.id];
        q === void 0 && (q = {}, a[L.id] = q);
        let at = q[k.id];
        at === void 0 && (at = {}, q[k.id] = at);
        let lt = at[Q];
        return lt === void 0 && (lt = p(d()), at[Q] = lt), lt
    }

    function p(L) {
        const k = [], G = [], Q = [];
        for (let q = 0; q < s; q++) k[q] = 0, G[q] = 0, Q[q] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: k,
            enabledAttributes: G,
            attributeDivisors: Q,
            object: L,
            attributes: {},
            index: null
        }
    }

    function _(L, k, G, Q) {
        const q = c.attributes, at = k.attributes;
        let lt = 0;
        const wt = G.getAttributes();
        for (const W in wt) if (wt[W].location >= 0) {
            const gt = q[W];
            let mt = at[W];
            if (mt === void 0 && (W === "instanceMatrix" && L.instanceMatrix && (mt = L.instanceMatrix), W === "instanceColor" && L.instanceColor && (mt = L.instanceColor)), gt === void 0 || gt.attribute !== mt || mt && gt.data !== mt.data) return !0;
            lt++
        }
        return c.attributesNum !== lt || c.index !== Q
    }

    function x(L, k, G, Q) {
        const q = {}, at = k.attributes;
        let lt = 0;
        const wt = G.getAttributes();
        for (const W in wt) if (wt[W].location >= 0) {
            let gt = at[W];
            gt === void 0 && (W === "instanceMatrix" && L.instanceMatrix && (gt = L.instanceMatrix), W === "instanceColor" && L.instanceColor && (gt = L.instanceColor));
            const mt = {};
            mt.attribute = gt, gt && gt.data && (mt.data = gt.data), q[W] = mt, lt++
        }
        c.attributes = q, c.attributesNum = lt, c.index = Q
    }

    function y() {
        const L = c.newAttributes;
        for (let k = 0, G = L.length; k < G; k++) L[k] = 0
    }

    function v(L) {
        w(L, 0)
    }

    function w(L, k) {
        const G = c.newAttributes, Q = c.enabledAttributes, q = c.attributeDivisors;
        G[L] = 1, Q[L] === 0 && (i.enableVertexAttribArray(L), Q[L] = 1), q[L] !== k && ((n.isWebGL2 ? i : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](L, k), q[L] = k)
    }

    function E() {
        const L = c.newAttributes, k = c.enabledAttributes;
        for (let G = 0, Q = k.length; G < Q; G++) k[G] !== L[G] && (i.disableVertexAttribArray(G), k[G] = 0)
    }

    function S(L, k, G, Q, q, at) {
        n.isWebGL2 === !0 && (G === 5124 || G === 5125) ? i.vertexAttribIPointer(L, k, G, q, at) : i.vertexAttribPointer(L, k, G, Q, q, at)
    }

    function b(L, k, G, Q) {
        if (n.isWebGL2 === !1 && (L.isInstancedMesh || Q.isInstancedBufferGeometry) && t.get("ANGLE_instanced_arrays") === null) return;
        y();
        const q = Q.attributes, at = G.getAttributes(), lt = k.defaultAttributeValues;
        for (const wt in at) {
            const W = at[wt];
            if (W.location >= 0) {
                let st = q[wt];
                if (st === void 0 && (wt === "instanceMatrix" && L.instanceMatrix && (st = L.instanceMatrix), wt === "instanceColor" && L.instanceColor && (st = L.instanceColor)), st !== void 0) {
                    const gt = st.normalized, mt = st.itemSize, Y = e.get(st);
                    if (Y === void 0) continue;
                    const Ut = Y.buffer, Rt = Y.type, Nt = Y.bytesPerElement;
                    if (st.isInterleavedBufferAttribute) {
                        const vt = st.data, ee = vt.stride, nt = st.offset;
                        if (vt.isInstancedInterleavedBuffer) {
                            for (let et = 0; et < W.locationSize; et++) w(W.location + et, vt.meshPerAttribute);
                            L.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = vt.meshPerAttribute * vt.count)
                        } else for (let et = 0; et < W.locationSize; et++) v(W.location + et);
                        i.bindBuffer(34962, Ut);
                        for (let et = 0; et < W.locationSize; et++) S(W.location + et, mt / W.locationSize, Rt, gt, ee * Nt, (nt + mt / W.locationSize * et) * Nt)
                    } else {
                        if (st.isInstancedBufferAttribute) {
                            for (let vt = 0; vt < W.locationSize; vt++) w(W.location + vt, st.meshPerAttribute);
                            L.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = st.meshPerAttribute * st.count)
                        } else for (let vt = 0; vt < W.locationSize; vt++) v(W.location + vt);
                        i.bindBuffer(34962, Ut);
                        for (let vt = 0; vt < W.locationSize; vt++) S(W.location + vt, mt / W.locationSize, Rt, gt, mt * Nt, mt / W.locationSize * vt * Nt)
                    }
                } else if (lt !== void 0) {
                    const gt = lt[wt];
                    if (gt !== void 0) switch (gt.length) {
                        case 2:
                            i.vertexAttrib2fv(W.location, gt);
                            break;
                        case 3:
                            i.vertexAttrib3fv(W.location, gt);
                            break;
                        case 4:
                            i.vertexAttrib4fv(W.location, gt);
                            break;
                        default:
                            i.vertexAttrib1fv(W.location, gt)
                    }
                }
            }
        }
        E()
    }

    function M() {
        B();
        for (const L in a) {
            const k = a[L];
            for (const G in k) {
                const Q = k[G];
                for (const q in Q) g(Q[q].object), delete Q[q];
                delete k[G]
            }
            delete a[L]
        }
    }

    function I(L) {
        if (a[L.id] === void 0) return;
        const k = a[L.id];
        for (const G in k) {
            const Q = k[G];
            for (const q in Q) g(Q[q].object), delete Q[q];
            delete k[G]
        }
        delete a[L.id]
    }

    function N(L) {
        for (const k in a) {
            const G = a[k];
            if (G[L.id] === void 0) continue;
            const Q = G[L.id];
            for (const q in Q) g(Q[q].object), delete Q[q];
            delete G[L.id]
        }
    }

    function B() {
        D(), h = !0, c !== l && (c = l, f(c.object))
    }

    function D() {
        l.geometry = null, l.program = null, l.wireframe = !1
    }

    return {
        setup: u,
        reset: B,
        resetDefaultState: D,
        dispose: M,
        releaseStatesOfGeometry: I,
        releaseStatesOfProgram: N,
        initAttributes: y,
        enableAttribute: v,
        disableUnusedAttributes: E
    }
}

function zC(i, t, e, n) {
    const s = n.isWebGL2;
    let r;

    function o(c) {
        r = c
    }

    function a(c, h) {
        i.drawArrays(r, c, h), e.update(h, r, 1)
    }

    function l(c, h, u) {
        if (u === 0) return;
        let d, f;
        if (s) d = i, f = "drawArraysInstanced"; else if (d = t.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", d === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        d[f](r, c, h, u), e.update(h, r, u)
    }

    this.setMode = o, this.render = a, this.renderInstances = l
}

function BC(i, t, e) {
    let n;

    function s() {
        if (n !== void 0) return n;
        if (t.has("EXT_texture_filter_anisotropic") === !0) {
            const S = t.get("EXT_texture_filter_anisotropic");
            n = i.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else n = 0;
        return n
    }

    function r(S) {
        if (S === "highp") {
            if (i.getShaderPrecisionFormat(35633, 36338).precision > 0 && i.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            S = "mediump"
        }
        return S === "mediump" && i.getShaderPrecisionFormat(35633, 36337).precision > 0 && i.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }

    const o = typeof WebGL2RenderingContext < "u" && i instanceof WebGL2RenderingContext;
    let a = e.precision !== void 0 ? e.precision : "highp";
    const l = r(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
    const c = o || t.has("WEBGL_draw_buffers"), h = e.logarithmicDepthBuffer === !0, u = i.getParameter(34930),
        d = i.getParameter(35660), f = i.getParameter(3379), g = i.getParameter(34076), m = i.getParameter(34921),
        p = i.getParameter(36347), _ = i.getParameter(36348), x = i.getParameter(36349), y = d > 0,
        v = o || t.has("OES_texture_float"), w = y && v, E = o ? i.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: s,
        getMaxPrecision: r,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: u,
        maxVertexTextures: d,
        maxTextureSize: f,
        maxCubemapSize: g,
        maxAttributes: m,
        maxVertexUniforms: p,
        maxVaryings: _,
        maxFragmentUniforms: x,
        vertexTextures: y,
        floatFragmentTextures: v,
        floatVertexTextures: w,
        maxSamples: E
    }
}

function kC(i) {
    const t = this;
    let e = null, n = 0, s = !1, r = !1;
    const o = new er, a = new ds, l = {value: null, needsUpdate: !1};
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (u, d) {
        const f = u.length !== 0 || d || n !== 0 || s;
        return s = d, n = u.length, f
    }, this.beginShadows = function () {
        r = !0, h(null)
    }, this.endShadows = function () {
        r = !1
    }, this.setGlobalState = function (u, d) {
        e = h(u, d, 0)
    }, this.setState = function (u, d, f) {
        const g = u.clippingPlanes, m = u.clipIntersection, p = u.clipShadows, _ = i.get(u);
        if (!s || g === null || g.length === 0 || r && !p) r ? h(null) : c(); else {
            const x = r ? 0 : n, y = x * 4;
            let v = _.clippingState || null;
            l.value = v, v = h(g, d, y, f);
            for (let w = 0; w !== y; ++w) v[w] = e[w];
            _.clippingState = v, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += x
        }
    };

    function c() {
        l.value !== e && (l.value = e, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
    }

    function h(u, d, f, g) {
        const m = u !== null ? u.length : 0;
        let p = null;
        if (m !== 0) {
            if (p = l.value, g !== !0 || p === null) {
                const _ = f + m * 4, x = d.matrixWorldInverse;
                a.getNormalMatrix(x), (p === null || p.length < _) && (p = new Float32Array(_));
                for (let y = 0, v = f; y !== m; ++y, v += 4) o.copy(u[y]).applyMatrix4(x, a), o.normal.toArray(p, v), p[v + 3] = o.constant
            }
            l.value = p, l.needsUpdate = !0
        }
        return t.numPlanes = m, t.numIntersection = 0, p
    }
}

function UC(i) {
    let t = new WeakMap;

    function e(o, a) {
        return a === Lc ? o.mapping = Br : a === Nc && (o.mapping = kr), o
    }

    function n(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === Lc || a === Nc) if (t.has(o)) {
                const l = t.get(o).texture;
                return e(l, o.mapping)
            } else {
                const l = o.image;
                if (l && l.height > 0) {
                    const c = new Hb(l.height / 2);
                    return c.fromEquirectangularTexture(i, o), t.set(o, c), o.addEventListener("dispose", s), e(c.texture, o.mapping)
                } else return null
            }
        }
        return o
    }

    function s(o) {
        const a = o.target;
        a.removeEventListener("dispose", s);
        const l = t.get(a);
        l !== void 0 && (t.delete(a), l.dispose())
    }

    function r() {
        t = new WeakMap
    }

    return {get: n, dispose: r}
}

class Ml extends Zd {
    constructor(t = -1, e = 1, n = 1, s = -1, r = .1, o = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = s, this.near = r, this.far = o, this.updateProjectionMatrix()
    }

    copy(t, e) {
        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this
    }

    setViewOffset(t, e, n, s, r, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = s, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
    }

    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }

    updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
        let r = n - t, o = n + t, a = s + e, l = s - e;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += c * this.view.offsetX, o = r + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }

    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e
    }
}

const Na = 4, Sy = [.125, .215, .35, .446, .526, .582], wo = 20, Op = new Ml, My = new pt;
let Dp = null;
const xo = (1 + Math.sqrt(5)) / 2, ga = 1 / xo,
    Ty = [new C(1, 1, 1), new C(-1, 1, 1), new C(1, 1, -1), new C(-1, 1, -1), new C(0, xo, ga), new C(0, xo, -ga), new C(ga, 0, xo), new C(-ga, 0, xo), new C(xo, ga, 0), new C(-xo, ga, 0)];

class _m {
    constructor(t) {
        this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }

    fromScene(t, e = 0, n = .1, s = 100) {
        Dp = this._renderer.getRenderTarget(), this._setSize(256);
        const r = this._allocateTargets();
        return r.depthBuffer = !0, this._sceneToCubeUV(t, n, s, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
    }

    fromEquirectangular(t, e = null) {
        return this._fromTexture(t, e)
    }

    fromCubemap(t, e = null) {
        return this._fromTexture(t, e)
    }

    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Cy(), this._compileMaterial(this._cubemapMaterial))
    }

    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = Ay(), this._compileMaterial(this._equirectMaterial))
    }

    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }

    _setSize(t) {
        this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
    }

    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
    }

    _cleanup(t) {
        this._renderer.setRenderTarget(Dp), t.scissorTest = !1, su(t, 0, 0, t.width, t.height)
    }

    _fromTexture(t, e) {
        t.mapping === Br || t.mapping === kr ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Dp = this._renderer.getRenderTarget();
        const n = e || this._allocateTargets();
        return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
    }

    _allocateTargets() {
        const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = {
            magFilter: Qe,
            minFilter: Qe,
            generateMipmaps: !1,
            type: nl,
            format: Os,
            encoding: Vr,
            depthBuffer: !1
        }, s = Iy(t, e, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Iy(t, e, n);
            const {_lodMax: r} = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = GC(r)), this._blurMaterial = VC(r, t, e)
        }
        return s
    }

    _compileMaterial(t) {
        const e = new ge(this._lodPlanes[0], t);
        this._renderer.compile(e, Op)
    }

    _sceneToCubeUV(t, e, n, s) {
        const a = new bn(90, 1, e, n), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], h = this._renderer,
            u = h.autoClear, d = h.toneMapping;
        h.getClearColor(My), h.toneMapping = Pi, h.autoClear = !1;
        const f = new rn({name: "PMREM.Background", side: xs, depthWrite: !1, depthTest: !1}), g = new ge(new Vi, f);
        let m = !1;
        const p = t.background;
        p ? p.isColor && (f.color.copy(p), t.background = null, m = !0) : (f.color.copy(My), m = !0);
        for (let _ = 0; _ < 6; _++) {
            const x = _ % 3;
            x === 0 ? (a.up.set(0, l[_], 0), a.lookAt(c[_], 0, 0)) : x === 1 ? (a.up.set(0, 0, l[_]), a.lookAt(0, c[_], 0)) : (a.up.set(0, l[_], 0), a.lookAt(0, 0, c[_]));
            const y = this._cubeSize;
            su(s, x * y, _ > 2 ? y : 0, y, y), h.setRenderTarget(s), m && h.render(g, a), h.render(t, a)
        }
        g.geometry.dispose(), g.material.dispose(), h.toneMapping = d, h.autoClear = u, t.background = p
    }

    _textureToCubeUV(t, e) {
        const n = this._renderer, s = t.mapping === Br || t.mapping === kr;
        s ? (this._cubemapMaterial === null && (this._cubemapMaterial = Cy()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Ay());
        const r = s ? this._cubemapMaterial : this._equirectMaterial, o = new ge(this._lodPlanes[0], r), a = r.uniforms;
        a.envMap.value = t;
        const l = this._cubeSize;
        su(e, 0, 0, 3 * l, 2 * l), n.setRenderTarget(e), n.render(o, Op)
    }

    _applyPMREM(t) {
        const e = this._renderer, n = e.autoClear;
        e.autoClear = !1;
        for (let s = 1; s < this._lodPlanes.length; s++) {
            const r = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]),
                o = Ty[(s - 1) % Ty.length];
            this._blur(t, s - 1, s, r, o)
        }
        e.autoClear = n
    }

    _blur(t, e, n, s, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(t, o, e, n, s, "latitudinal", r), this._halfBlur(o, t, n, n, s, "longitudinal", r)
    }

    _halfBlur(t, e, n, s, r, o, a) {
        const l = this._renderer, c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const h = 3, u = new ge(this._lodPlanes[s], c), d = c.uniforms, f = this._sizeLods[n] - 1,
            g = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * wo - 1), m = r / g,
            p = isFinite(r) ? 1 + Math.floor(h * m) : wo;
        p > wo && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${wo}`);
        const _ = [];
        let x = 0;
        for (let S = 0; S < wo; ++S) {
            const b = S / m, M = Math.exp(-b * b / 2);
            _.push(M), S === 0 ? x += M : S < p && (x += 2 * M)
        }
        for (let S = 0; S < _.length; S++) _[S] = _[S] / x;
        d.envMap.value = t.texture, d.samples.value = p, d.weights.value = _, d.latitudinal.value = o === "latitudinal", a && (d.poleAxis.value = a);
        const {_lodMax: y} = this;
        d.dTheta.value = g, d.mipInt.value = y - n;
        const v = this._sizeLods[s], w = 3 * v * (s > y - Na ? s - y + Na : 0), E = 4 * (this._cubeSize - v);
        su(e, w, E, 3 * v, 2 * v), l.setRenderTarget(e), l.render(u, Op)
    }
}

function GC(i) {
    const t = [], e = [], n = [];
    let s = i;
    const r = i - Na + 1 + Sy.length;
    for (let o = 0; o < r; o++) {
        const a = Math.pow(2, s);
        e.push(a);
        let l = 1 / a;
        o > i - Na ? l = Sy[o - i + Na - 1] : o === 0 && (l = 0), n.push(l);
        const c = 1 / (a - 2), h = -c, u = 1 + c, d = [h, h, u, h, u, u, h, h, u, u, h, u], f = 6, g = 6, m = 3, p = 2,
            _ = 1, x = new Float32Array(m * g * f), y = new Float32Array(p * g * f), v = new Float32Array(_ * g * f);
        for (let E = 0; E < f; E++) {
            const S = E % 3 * 2 / 3 - 1, b = E > 2 ? 0 : -1,
                M = [S, b, 0, S + 2 / 3, b, 0, S + 2 / 3, b + 1, 0, S, b, 0, S + 2 / 3, b + 1, 0, S, b + 1, 0];
            x.set(M, m * g * E), y.set(d, p * g * E);
            const I = [E, E, E, E, E, E];
            v.set(I, _ * g * E)
        }
        const w = new Xt;
        w.setAttribute("position", new ae(x, m)), w.setAttribute("uv", new ae(y, p)), w.setAttribute("faceIndex", new ae(v, _)), t.push(w), s > Na && s--
    }
    return {lodPlanes: t, sizeLods: e, sigmas: n}
}

function Iy(i, t, e) {
    const n = new fs(i, t, e);
    return n.texture.mapping = El, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
}

function su(i, t, e, n, s) {
    i.viewport.set(t, e, n, s), i.scissor.set(t, e, n, s)
}

function VC(i, t, e) {
    const n = new Float32Array(wo), s = new C(0, 1, 0);
    return new jn({
        name: "SphericalGaussianBlur",
        defines: {n: wo, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / e, CUBEUV_MAX_MIP: `${i}.0`},
        uniforms: {
            envMap: {value: null},
            samples: {value: 1},
            weights: {value: n},
            latitudinal: {value: !1},
            dTheta: {value: 0},
            mipInt: {value: 0},
            poleAxis: {value: s}
        },
        vertexShader: o0(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: ar,
        depthTest: !1,
        depthWrite: !1
    })
}

function Ay() {
    return new jn({
        name: "EquirectangularToCubeUV", uniforms: {envMap: {value: null}}, vertexShader: o0(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: ar, depthTest: !1, depthWrite: !1
    })
}

function Cy() {
    return new jn({
        name: "CubemapToCubeUV",
        uniforms: {envMap: {value: null}, flipEnvMap: {value: -1}},
        vertexShader: o0(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: ar,
        depthTest: !1,
        depthWrite: !1
    })
}

function o0() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function HC(i) {
    let t = new WeakMap, e = null;

    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping, c = l === Lc || l === Nc, h = l === Br || l === kr;
            if (c || h) if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                a.needsPMREMUpdate = !1;
                let u = t.get(a);
                return e === null && (e = new _m(i)), u = c ? e.fromEquirectangular(a, u) : e.fromCubemap(a, u), t.set(a, u), u.texture
            } else {
                if (t.has(a)) return t.get(a).texture;
                {
                    const u = a.image;
                    if (c && u && u.height > 0 || h && u && s(u)) {
                        e === null && (e = new _m(i));
                        const d = c ? e.fromEquirectangular(a) : e.fromCubemap(a);
                        return t.set(a, d), a.addEventListener("dispose", r), d.texture
                    } else return null
                }
            }
        }
        return a
    }

    function s(a) {
        let l = 0;
        const c = 6;
        for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
        return l === c
    }

    function r(a) {
        const l = a.target;
        l.removeEventListener("dispose", r);
        const c = t.get(l);
        c !== void 0 && (t.delete(l), c.dispose())
    }

    function o() {
        t = new WeakMap, e !== null && (e.dispose(), e = null)
    }

    return {get: n, dispose: o}
}

function $C(i) {
    const t = {};

    function e(n) {
        if (t[n] !== void 0) return t[n];
        let s;
        switch (n) {
            case"WEBGL_depth_texture":
                s = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case"EXT_texture_filter_anisotropic":
                s = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case"WEBGL_compressed_texture_s3tc":
                s = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case"WEBGL_compressed_texture_pvrtc":
                s = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                s = i.getExtension(n)
        }
        return t[n] = s, s
    }

    return {
        has: function (n) {
            return e(n) !== null
        }, init: function (n) {
            n.isWebGL2 ? e("EXT_color_buffer_float") : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture")
        }, get: function (n) {
            const s = e(n);
            return s === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), s
        }
    }
}

function WC(i, t, e, n) {
    const s = {}, r = new WeakMap;

    function o(u) {
        const d = u.target;
        d.index !== null && t.remove(d.index);
        for (const g in d.attributes) t.remove(d.attributes[g]);
        d.removeEventListener("dispose", o), delete s[d.id];
        const f = r.get(d);
        f && (t.remove(f), r.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, e.memory.geometries--
    }

    function a(u, d) {
        return s[d.id] === !0 || (d.addEventListener("dispose", o), s[d.id] = !0, e.memory.geometries++), d
    }

    function l(u) {
        const d = u.attributes;
        for (const g in d) t.update(d[g], 34962);
        const f = u.morphAttributes;
        for (const g in f) {
            const m = f[g];
            for (let p = 0, _ = m.length; p < _; p++) t.update(m[p], 34962)
        }
    }

    function c(u) {
        const d = [], f = u.index, g = u.attributes.position;
        let m = 0;
        if (f !== null) {
            const x = f.array;
            m = f.version;
            for (let y = 0, v = x.length; y < v; y += 3) {
                const w = x[y + 0], E = x[y + 1], S = x[y + 2];
                d.push(w, E, E, S, S, w)
            }
        } else {
            const x = g.array;
            m = g.version;
            for (let y = 0, v = x.length / 3 - 1; y < v; y += 3) {
                const w = y + 0, E = y + 1, S = y + 2;
                d.push(w, E, E, S, S, w)
            }
        }
        const p = new (zb(d) ? r0 : i0)(d, 1);
        p.version = m;
        const _ = r.get(u);
        _ && t.remove(_), r.set(u, p)
    }

    function h(u) {
        const d = r.get(u);
        if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u)
        } else c(u);
        return r.get(u)
    }

    return {get: a, update: l, getWireframeAttribute: h}
}

function qC(i, t, e, n) {
    const s = n.isWebGL2;
    let r;

    function o(d) {
        r = d
    }

    let a, l;

    function c(d) {
        a = d.type, l = d.bytesPerElement
    }

    function h(d, f) {
        i.drawElements(r, f, a, d * l), e.update(f, r, 1)
    }

    function u(d, f, g) {
        if (g === 0) return;
        let m, p;
        if (s) m = i, p = "drawElementsInstanced"; else if (m = t.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", m === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        m[p](r, f, a, d * l, g), e.update(f, r, g)
    }

    this.setMode = o, this.setIndex = c, this.render = h, this.renderInstances = u
}

function YC(i) {
    const t = {geometries: 0, textures: 0}, e = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};

    function n(r, o, a) {
        switch (e.calls++, o) {
            case 4:
                e.triangles += a * (r / 3);
                break;
            case 1:
                e.lines += a * (r / 2);
                break;
            case 3:
                e.lines += a * (r - 1);
                break;
            case 2:
                e.lines += a * r;
                break;
            case 0:
                e.points += a * r;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break
        }
    }

    function s() {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
    }

    return {memory: t, render: e, programs: null, autoReset: !0, reset: s, update: n}
}

function XC(i, t) {
    return i[0] - t[0]
}

function ZC(i, t) {
    return Math.abs(t[1]) - Math.abs(i[1])
}

function jC(i, t, e) {
    const n = {}, s = new Float32Array(8), r = new WeakMap, o = new Fe, a = [];
    for (let c = 0; c < 8; c++) a[c] = [c, 0];

    function l(c, h, u, d) {
        const f = c.morphTargetInfluences;
        if (t.isWebGL2 === !0) {
            const m = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color,
                p = m !== void 0 ? m.length : 0;
            let _ = r.get(h);
            if (_ === void 0 || _.count !== p) {
                let G = function () {
                    L.dispose(), r.delete(h), h.removeEventListener("dispose", G)
                };
                var g = G;
                _ !== void 0 && _.texture.dispose();
                const v = h.morphAttributes.position !== void 0, w = h.morphAttributes.normal !== void 0,
                    E = h.morphAttributes.color !== void 0, S = h.morphAttributes.position || [],
                    b = h.morphAttributes.normal || [], M = h.morphAttributes.color || [];
                let I = 0;
                v === !0 && (I = 1), w === !0 && (I = 2), E === !0 && (I = 3);
                let N = h.attributes.position.count * I, B = 1;
                N > t.maxTextureSize && (B = Math.ceil(N / t.maxTextureSize), N = t.maxTextureSize);
                const D = new Float32Array(N * B * 4 * p), L = new Yd(D, N, B, p);
                L.type = ir, L.needsUpdate = !0;
                const k = I * 4;
                for (let Q = 0; Q < p; Q++) {
                    const q = S[Q], at = b[Q], lt = M[Q], wt = N * B * 4 * Q;
                    for (let W = 0; W < q.count; W++) {
                        const st = W * k;
                        v === !0 && (o.fromBufferAttribute(q, W), D[wt + st + 0] = o.x, D[wt + st + 1] = o.y, D[wt + st + 2] = o.z, D[wt + st + 3] = 0), w === !0 && (o.fromBufferAttribute(at, W), D[wt + st + 4] = o.x, D[wt + st + 5] = o.y, D[wt + st + 6] = o.z, D[wt + st + 7] = 0), E === !0 && (o.fromBufferAttribute(lt, W), D[wt + st + 8] = o.x, D[wt + st + 9] = o.y, D[wt + st + 10] = o.z, D[wt + st + 11] = lt.itemSize === 4 ? o.w : 1)
                    }
                }
                _ = {count: p, texture: L, size: new j(N, B)}, r.set(h, _), h.addEventListener("dispose", G)
            }
            let x = 0;
            for (let v = 0; v < f.length; v++) x += f[v];
            const y = h.morphTargetsRelative ? 1 : 1 - x;
            d.getUniforms().setValue(i, "morphTargetBaseInfluence", y), d.getUniforms().setValue(i, "morphTargetInfluences", f), d.getUniforms().setValue(i, "morphTargetsTexture", _.texture, e), d.getUniforms().setValue(i, "morphTargetsTextureSize", _.size)
        } else {
            const m = f === void 0 ? 0 : f.length;
            let p = n[h.id];
            if (p === void 0 || p.length !== m) {
                p = [];
                for (let w = 0; w < m; w++) p[w] = [w, 0];
                n[h.id] = p
            }
            for (let w = 0; w < m; w++) {
                const E = p[w];
                E[0] = w, E[1] = f[w]
            }
            p.sort(ZC);
            for (let w = 0; w < 8; w++) w < m && p[w][1] ? (a[w][0] = p[w][0], a[w][1] = p[w][1]) : (a[w][0] = Number.MAX_SAFE_INTEGER, a[w][1] = 0);
            a.sort(XC);
            const _ = h.morphAttributes.position, x = h.morphAttributes.normal;
            let y = 0;
            for (let w = 0; w < 8; w++) {
                const E = a[w], S = E[0], b = E[1];
                S !== Number.MAX_SAFE_INTEGER && b ? (_ && h.getAttribute("morphTarget" + w) !== _[S] && h.setAttribute("morphTarget" + w, _[S]), x && h.getAttribute("morphNormal" + w) !== x[S] && h.setAttribute("morphNormal" + w, x[S]), s[w] = b, y += b) : (_ && h.hasAttribute("morphTarget" + w) === !0 && h.deleteAttribute("morphTarget" + w), x && h.hasAttribute("morphNormal" + w) === !0 && h.deleteAttribute("morphNormal" + w), s[w] = 0)
            }
            const v = h.morphTargetsRelative ? 1 : 1 - y;
            d.getUniforms().setValue(i, "morphTargetBaseInfluence", v), d.getUniforms().setValue(i, "morphTargetInfluences", s)
        }
    }

    return {update: l}
}

function KC(i, t, e, n) {
    let s = new WeakMap;

    function r(l) {
        const c = n.render.frame, h = l.geometry, u = t.get(l, h);
        return s.get(u) !== c && (t.update(u), s.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), e.update(l.instanceMatrix, 34962), l.instanceColor !== null && e.update(l.instanceColor, 34962)), u
    }

    function o() {
        s = new WeakMap
    }

    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a), e.remove(c.instanceMatrix), c.instanceColor !== null && e.remove(c.instanceColor)
    }

    return {update: r, dispose: o}
}

const Wb = new Sn, qb = new Yd, Yb = new n0, Xb = new dh, Py = [], Ry = [], Ly = new Float32Array(16),
    Ny = new Float32Array(9), Oy = new Float32Array(4);

function Tl(i, t, e) {
    const n = i[0];
    if (n <= 0 || n > 0) return i;
    const s = t * e;
    let r = Py[s];
    if (r === void 0 && (r = new Float32Array(s), Py[s] = r), t !== 0) {
        n.toArray(r, 0);
        for (let o = 1, a = 0; o !== t; ++o) a += e, i[o].toArray(r, a)
    }
    return r
}

function Mn(i, t) {
    if (i.length !== t.length) return !1;
    for (let e = 0, n = i.length; e < n; e++) if (i[e] !== t[e]) return !1;
    return !0
}

function Tn(i, t) {
    for (let e = 0, n = t.length; e < n; e++) i[e] = t[e]
}

function Kd(i, t) {
    let e = Ry[t];
    e === void 0 && (e = new Int32Array(t), Ry[t] = e);
    for (let n = 0; n !== t; ++n) e[n] = i.allocateTextureUnit();
    return e
}

function JC(i, t) {
    const e = this.cache;
    e[0] !== t && (i.uniform1f(this.addr, t), e[0] = t)
}

function QC(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y); else {
        if (Mn(e, t)) return;
        i.uniform2fv(this.addr, t), Tn(e, t)
    }
}

function tP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z); else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (i.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b); else {
        if (Mn(e, t)) return;
        i.uniform3fv(this.addr, t), Tn(e, t)
    }
}

function eP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w); else {
        if (Mn(e, t)) return;
        i.uniform4fv(this.addr, t), Tn(e, t)
    }
}

function nP(i, t) {
    const e = this.cache, n = t.elements;
    if (n === void 0) {
        if (Mn(e, t)) return;
        i.uniformMatrix2fv(this.addr, !1, t), Tn(e, t)
    } else {
        if (Mn(e, n)) return;
        Oy.set(n), i.uniformMatrix2fv(this.addr, !1, Oy), Tn(e, n)
    }
}

function sP(i, t) {
    const e = this.cache, n = t.elements;
    if (n === void 0) {
        if (Mn(e, t)) return;
        i.uniformMatrix3fv(this.addr, !1, t), Tn(e, t)
    } else {
        if (Mn(e, n)) return;
        Ny.set(n), i.uniformMatrix3fv(this.addr, !1, Ny), Tn(e, n)
    }
}

function iP(i, t) {
    const e = this.cache, n = t.elements;
    if (n === void 0) {
        if (Mn(e, t)) return;
        i.uniformMatrix4fv(this.addr, !1, t), Tn(e, t)
    } else {
        if (Mn(e, n)) return;
        Ly.set(n), i.uniformMatrix4fv(this.addr, !1, Ly), Tn(e, n)
    }
}

function rP(i, t) {
    const e = this.cache;
    e[0] !== t && (i.uniform1i(this.addr, t), e[0] = t)
}

function oP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y); else {
        if (Mn(e, t)) return;
        i.uniform2iv(this.addr, t), Tn(e, t)
    }
}

function aP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z); else {
        if (Mn(e, t)) return;
        i.uniform3iv(this.addr, t), Tn(e, t)
    }
}

function lP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w); else {
        if (Mn(e, t)) return;
        i.uniform4iv(this.addr, t), Tn(e, t)
    }
}

function cP(i, t) {
    const e = this.cache;
    e[0] !== t && (i.uniform1ui(this.addr, t), e[0] = t)
}

function hP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y); else {
        if (Mn(e, t)) return;
        i.uniform2uiv(this.addr, t), Tn(e, t)
    }
}

function uP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z); else {
        if (Mn(e, t)) return;
        i.uniform3uiv(this.addr, t), Tn(e, t)
    }
}

function dP(i, t) {
    const e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w); else {
        if (Mn(e, t)) return;
        i.uniform4uiv(this.addr, t), Tn(e, t)
    }
}

function fP(i, t, e) {
    const n = this.cache, s = e.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), e.setTexture2D(t || Wb, s)
}

function pP(i, t, e) {
    const n = this.cache, s = e.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), e.setTexture3D(t || Yb, s)
}

function gP(i, t, e) {
    const n = this.cache, s = e.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), e.setTextureCube(t || Xb, s)
}

function mP(i, t, e) {
    const n = this.cache, s = e.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s), n[0] = s), e.setTexture2DArray(t || qb, s)
}

function _P(i) {
    switch (i) {
        case 5126:
            return JC;
        case 35664:
            return QC;
        case 35665:
            return tP;
        case 35666:
            return eP;
        case 35674:
            return nP;
        case 35675:
            return sP;
        case 35676:
            return iP;
        case 5124:
        case 35670:
            return rP;
        case 35667:
        case 35671:
            return oP;
        case 35668:
        case 35672:
            return aP;
        case 35669:
        case 35673:
            return lP;
        case 5125:
            return cP;
        case 36294:
            return hP;
        case 36295:
            return uP;
        case 36296:
            return dP;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return fP;
        case 35679:
        case 36299:
        case 36307:
            return pP;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return gP;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return mP
    }
}

function yP(i, t) {
    i.uniform1fv(this.addr, t)
}

function xP(i, t) {
    const e = Tl(t, this.size, 2);
    i.uniform2fv(this.addr, e)
}

function vP(i, t) {
    const e = Tl(t, this.size, 3);
    i.uniform3fv(this.addr, e)
}

function wP(i, t) {
    const e = Tl(t, this.size, 4);
    i.uniform4fv(this.addr, e)
}

function bP(i, t) {
    const e = Tl(t, this.size, 4);
    i.uniformMatrix2fv(this.addr, !1, e)
}

function EP(i, t) {
    const e = Tl(t, this.size, 9);
    i.uniformMatrix3fv(this.addr, !1, e)
}

function SP(i, t) {
    const e = Tl(t, this.size, 16);
    i.uniformMatrix4fv(this.addr, !1, e)
}

function MP(i, t) {
    i.uniform1iv(this.addr, t)
}

function TP(i, t) {
    i.uniform2iv(this.addr, t)
}

function IP(i, t) {
    i.uniform3iv(this.addr, t)
}

function AP(i, t) {
    i.uniform4iv(this.addr, t)
}

function CP(i, t) {
    i.uniform1uiv(this.addr, t)
}

function PP(i, t) {
    i.uniform2uiv(this.addr, t)
}

function RP(i, t) {
    i.uniform3uiv(this.addr, t)
}

function LP(i, t) {
    i.uniform4uiv(this.addr, t)
}

function NP(i, t, e) {
    const n = this.cache, s = t.length, r = Kd(e, s);
    Mn(n, r) || (i.uniform1iv(this.addr, r), Tn(n, r));
    for (let o = 0; o !== s; ++o) e.setTexture2D(t[o] || Wb, r[o])
}

function OP(i, t, e) {
    const n = this.cache, s = t.length, r = Kd(e, s);
    Mn(n, r) || (i.uniform1iv(this.addr, r), Tn(n, r));
    for (let o = 0; o !== s; ++o) e.setTexture3D(t[o] || Yb, r[o])
}

function DP(i, t, e) {
    const n = this.cache, s = t.length, r = Kd(e, s);
    Mn(n, r) || (i.uniform1iv(this.addr, r), Tn(n, r));
    for (let o = 0; o !== s; ++o) e.setTextureCube(t[o] || Xb, r[o])
}

function FP(i, t, e) {
    const n = this.cache, s = t.length, r = Kd(e, s);
    Mn(n, r) || (i.uniform1iv(this.addr, r), Tn(n, r));
    for (let o = 0; o !== s; ++o) e.setTexture2DArray(t[o] || qb, r[o])
}

function zP(i) {
    switch (i) {
        case 5126:
            return yP;
        case 35664:
            return xP;
        case 35665:
            return vP;
        case 35666:
            return wP;
        case 35674:
            return bP;
        case 35675:
            return EP;
        case 35676:
            return SP;
        case 5124:
        case 35670:
            return MP;
        case 35667:
        case 35671:
            return TP;
        case 35668:
        case 35672:
            return IP;
        case 35669:
        case 35673:
            return AP;
        case 5125:
            return CP;
        case 36294:
            return PP;
        case 36295:
            return RP;
        case 36296:
            return LP;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return NP;
        case 35679:
        case 36299:
        case 36307:
            return OP;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return DP;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return FP
    }
}

class BP {
    constructor(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.setValue = _P(e.type)
    }
}

class kP {
    constructor(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = zP(e.type)
    }
}

class UP {
    constructor(t) {
        this.id = t, this.seq = [], this.map = {}
    }

    setValue(t, e, n) {
        const s = this.seq;
        for (let r = 0, o = s.length; r !== o; ++r) {
            const a = s[r];
            a.setValue(t, e[a.id], n)
        }
    }
}

const Fp = /(\w+)(\])?(\[|\.)?/g;

function Dy(i, t) {
    i.seq.push(t), i.map[t.id] = t
}

function GP(i, t, e) {
    const n = i.name, s = n.length;
    for (Fp.lastIndex = 0; ;) {
        const r = Fp.exec(n), o = Fp.lastIndex;
        let a = r[1];
        const l = r[2] === "]", c = r[3];
        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === s) {
            Dy(e, c === void 0 ? new BP(a, i, t) : new kP(a, i, t));
            break
        } else {
            let u = e.map[a];
            u === void 0 && (u = new UP(a), Dy(e, u)), e = u
        }
    }
}

class ed {
    constructor(t, e) {
        this.seq = [], this.map = {};
        const n = t.getProgramParameter(e, 35718);
        for (let s = 0; s < n; ++s) {
            const r = t.getActiveUniform(e, s), o = t.getUniformLocation(e, r.name);
            GP(r, o, this)
        }
    }

    setValue(t, e, n, s) {
        const r = this.map[e];
        r !== void 0 && r.setValue(t, n, s)
    }

    setOptional(t, e, n) {
        const s = e[n];
        s !== void 0 && this.setValue(t, n, s)
    }

    static upload(t, e, n, s) {
        for (let r = 0, o = e.length; r !== o; ++r) {
            const a = e[r], l = n[a.id];
            l.needsUpdate !== !1 && a.setValue(t, l.value, s)
        }
    }

    static seqWithValue(t, e) {
        const n = [];
        for (let s = 0, r = t.length; s !== r; ++s) {
            const o = t[s];
            o.id in e && n.push(o)
        }
        return n
    }
}

function Fy(i, t, e) {
    const n = i.createShader(t);
    return i.shaderSource(n, e), i.compileShader(n), n
}

let VP = 0;

function HP(i, t) {
    const e = i.split(`
`), n = [], s = Math.max(t - 6, 0), r = Math.min(t + 6, e.length);
    for (let o = s; o < r; o++) {
        const a = o + 1;
        n.push(`${a === t ? ">" : " "} ${a}: ${e[o]}`)
    }
    return n.join(`
`)
}

function $P(i) {
    switch (i) {
        case Vr:
            return ["Linear", "( value )"];
        case Ee:
            return ["sRGB", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", i), ["Linear", "( value )"]
    }
}

function zy(i, t, e) {
    const n = i.getShaderParameter(t, 35713), s = i.getShaderInfoLog(t).trim();
    if (n && s === "") return "";
    const r = /ERROR: 0:(\d+)/.exec(s);
    if (r) {
        const o = parseInt(r[1]);
        return e.toUpperCase() + `

` + s + `

` + HP(i.getShaderSource(t), o)
    } else return s
}

function WP(i, t) {
    const e = $P(t);
    return "vec4 " + i + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }"
}

function qP(i, t) {
    let e;
    switch (t) {
        case ab:
            e = "Linear";
            break;
        case lb:
            e = "Reinhard";
            break;
        case cb:
            e = "OptimizedCineon";
            break;
        case hb:
            e = "ACESFilmic";
            break;
        case ub:
            e = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear"
    }
    return "vec3 " + i + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
}

function YP(i) {
    return [i.extensionDerivatives || i.envMapCubeUVHeight || i.bumpMap || i.tangentSpaceNormalMap || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(gc).join(`
`)
}

function XP(i) {
    const t = [];
    for (const e in i) {
        const n = i[e];
        n !== !1 && t.push("#define " + e + " " + n)
    }
    return t.join(`
`)
}

function ZP(i, t) {
    const e = {}, n = i.getProgramParameter(t, 35721);
    for (let s = 0; s < n; s++) {
        const r = i.getActiveAttrib(t, s), o = r.name;
        let a = 1;
        r.type === 35674 && (a = 2), r.type === 35675 && (a = 3), r.type === 35676 && (a = 4), e[o] = {
            type: r.type,
            location: i.getAttribLocation(t, o),
            locationSize: a
        }
    }
    return e
}

function gc(i) {
    return i !== ""
}

function By(i, t) {
    const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
    return i.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
}

function ky(i, t) {
    return i.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
}

const jP = /^[ \t]*#include +<([\w\d./]+)>/gm;

function ym(i) {
    return i.replace(jP, KP)
}

function KP(i, t) {
    const e = Qt[t];
    if (e === void 0) throw new Error("Can not resolve #include <" + t + ">");
    return ym(e)
}

const JP = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function Uy(i) {
    return i.replace(JP, QP)
}

function QP(i, t, e, n) {
    let s = "";
    for (let r = parseInt(t); r < parseInt(e); r++) s += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return s
}

function Gy(i) {
    let t = "precision " + i.precision + ` float;
precision ` + i.precision + " int;";
    return i.precision === "highp" ? t += `
#define HIGH_PRECISION` : i.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (t += `
#define LOW_PRECISION`), t
}

function tR(i) {
    let t = "SHADOWMAP_TYPE_BASIC";
    return i.shadowMapType === Ym ? t = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === Xm ? t = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === Ra && (t = "SHADOWMAP_TYPE_VSM"), t
}

function eR(i) {
    let t = "ENVMAP_TYPE_CUBE";
    if (i.envMap) switch (i.envMapMode) {
        case Br:
        case kr:
            t = "ENVMAP_TYPE_CUBE";
            break;
        case El:
            t = "ENVMAP_TYPE_CUBE_UV";
            break
    }
    return t
}

function nR(i) {
    let t = "ENVMAP_MODE_REFLECTION";
    if (i.envMap) switch (i.envMapMode) {
        case kr:
            t = "ENVMAP_MODE_REFRACTION";
            break
    }
    return t
}

function sR(i) {
    let t = "ENVMAP_BLENDING_NONE";
    if (i.envMap) switch (i.combine) {
        case hh:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case rb:
            t = "ENVMAP_BLENDING_MIX";
            break;
        case ob:
            t = "ENVMAP_BLENDING_ADD";
            break
    }
    return t
}

function iR(i) {
    const t = i.envMapCubeUVHeight;
    if (t === null) return null;
    const e = Math.log2(t) - 2, n = 1 / t;
    return {texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: n, maxMip: e}
}

function rR(i, t, e, n) {
    const s = i.getContext(), r = e.defines;
    let o = e.vertexShader, a = e.fragmentShader;
    const l = tR(e), c = eR(e), h = nR(e), u = sR(e), d = iR(e), f = e.isWebGL2 ? "" : YP(e), g = XP(r),
        m = s.createProgram();
    let p, _, x = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
    e.isRawShaderMaterial ? (p = [g].filter(gc).join(`
`), p.length > 0 && (p += `
`), _ = [f, g].filter(gc).join(`
`), _.length > 0 && (_ += `
`)) : (p = [Gy(e), "#define SHADER_NAME " + e.shaderName, g, e.instancing ? "#define USE_INSTANCING" : "", e.instancingColor ? "#define USE_INSTANCING_COLOR" : "", e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + h : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.displacementMap && e.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", e.morphColors && e.isWebGL2 ? "#define USE_MORPHCOLORS" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(gc).join(`
`), _ = [f, Gy(e), "#define SHADER_NAME " + e.shaderName, g, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + c : "", e.envMap ? "#define " + h : "", e.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoat ? "#define USE_CLEARCOAT" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescence ? "#define USE_IRIDESCENCE" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaTest ? "#define USE_ALPHATEST" : "", e.sheen ? "#define USE_SHEEN" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.gradientMap ? "#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", e.toneMapping !== Pi ? "#define TONE_MAPPING" : "", e.toneMapping !== Pi ? Qt.tonemapping_pars_fragment : "", e.toneMapping !== Pi ? qP("toneMapping", e.toneMapping) : "", e.dithering ? "#define DITHERING" : "", e.opaque ? "#define OPAQUE" : "", Qt.encodings_pars_fragment, WP("linearToOutputTexel", e.outputEncoding), e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", `
`].filter(gc).join(`
`)), o = ym(o), o = By(o, e), o = ky(o, e), a = ym(a), a = By(a, e), a = ky(a, e), o = Uy(o), a = Uy(a), e.isWebGL2 && e.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, p = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + p, _ = ["#define varying in", e.glslVersion === pm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", e.glslVersion === pm ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + _);
    const y = x + p + o, v = x + _ + a, w = Fy(s, 35633, y), E = Fy(s, 35632, v);
    if (s.attachShader(m, w), s.attachShader(m, E), e.index0AttributeName !== void 0 ? s.bindAttribLocation(m, 0, e.index0AttributeName) : e.morphTargets === !0 && s.bindAttribLocation(m, 0, "position"), s.linkProgram(m), i.debug.checkShaderErrors) {
        const M = s.getProgramInfoLog(m).trim(), I = s.getShaderInfoLog(w).trim(), N = s.getShaderInfoLog(E).trim();
        let B = !0, D = !0;
        if (s.getProgramParameter(m, 35714) === !1) {
            B = !1;
            const L = zy(s, w, "vertex"), k = zy(s, E, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(m, 35715) + `

Program Info Log: ` + M + `
` + L + `
` + k)
        } else M !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", M) : (I === "" || N === "") && (D = !1);
        D && (this.diagnostics = {
            runnable: B,
            programLog: M,
            vertexShader: {log: I, prefix: p},
            fragmentShader: {log: N, prefix: _}
        })
    }
    s.deleteShader(w), s.deleteShader(E);
    let S;
    this.getUniforms = function () {
        return S === void 0 && (S = new ed(s, m)), S
    };
    let b;
    return this.getAttributes = function () {
        return b === void 0 && (b = ZP(s, m)), b
    }, this.destroy = function () {
        n.releaseStatesOfProgram(this), s.deleteProgram(m), this.program = void 0
    }, this.name = e.shaderName, this.id = VP++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = w, this.fragmentShader = E, this
}

let oR = 0;

class aR {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }

    update(t) {
        const e = t.vertexShader, n = t.fragmentShader, s = this._getShaderStage(e), r = this._getShaderStage(n),
            o = this._getShaderCacheForMaterial(t);
        return o.has(s) === !1 && (o.add(s), s.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this
    }

    remove(t) {
        const e = this.materialCache.get(t);
        for (const n of e) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(t), this
    }

    getVertexShaderID(t) {
        return this._getShaderStage(t.vertexShader).id
    }

    getFragmentShaderID(t) {
        return this._getShaderStage(t.fragmentShader).id
    }

    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }

    _getShaderCacheForMaterial(t) {
        const e = this.materialCache;
        let n = e.get(t);
        return n === void 0 && (n = new Set, e.set(t, n)), n
    }

    _getShaderStage(t) {
        const e = this.shaderCache;
        let n = e.get(t);
        return n === void 0 && (n = new lR(t), e.set(t, n)), n
    }
}

class lR {
    constructor(t) {
        this.id = oR++, this.code = t, this.usedTimes = 0
    }
}

function cR(i, t, e, n, s, r, o) {
    const a = new Xd, l = new aR, c = [], h = s.isWebGL2, u = s.logarithmicDepthBuffer, d = s.vertexTextures;
    let f = s.precision;
    const g = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function m(b, M, I, N, B) {
        const D = N.fog, L = B.geometry, k = b.isMeshStandardMaterial ? N.environment : null,
            G = (b.isMeshStandardMaterial ? e : t).get(b.envMap || k),
            Q = G && G.mapping === El ? G.image.height : null, q = g[b.type];
        b.precision !== null && (f = s.getMaxPrecision(b.precision), f !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", f, "instead."));
        const at = L.morphAttributes.position || L.morphAttributes.normal || L.morphAttributes.color,
            lt = at !== void 0 ? at.length : 0;
        let wt = 0;
        L.morphAttributes.position !== void 0 && (wt = 1), L.morphAttributes.normal !== void 0 && (wt = 2), L.morphAttributes.color !== void 0 && (wt = 3);
        let W, st, gt, mt;
        if (q) {
            const ee = ai[q];
            W = ee.vertexShader, st = ee.fragmentShader
        } else W = b.vertexShader, st = b.fragmentShader, l.update(b), gt = l.getVertexShaderID(b), mt = l.getFragmentShaderID(b);
        const Y = i.getRenderTarget(), Ut = b.alphaTest > 0, Rt = b.clearcoat > 0, Nt = b.iridescence > 0;
        return {
            isWebGL2: h,
            shaderID: q,
            shaderName: b.type,
            vertexShader: W,
            fragmentShader: st,
            defines: b.defines,
            customVertexShaderID: gt,
            customFragmentShaderID: mt,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: f,
            instancing: B.isInstancedMesh === !0,
            instancingColor: B.isInstancedMesh === !0 && B.instanceColor !== null,
            supportsVertexTextures: d,
            outputEncoding: Y === null ? i.outputEncoding : Y.isXRRenderTarget === !0 ? Y.texture.encoding : Vr,
            map: !!b.map,
            matcap: !!b.matcap,
            envMap: !!G,
            envMapMode: G && G.mapping,
            envMapCubeUVHeight: Q,
            lightMap: !!b.lightMap,
            aoMap: !!b.aoMap,
            emissiveMap: !!b.emissiveMap,
            bumpMap: !!b.bumpMap,
            normalMap: !!b.normalMap,
            objectSpaceNormalMap: b.normalMapType === Nb,
            tangentSpaceNormalMap: b.normalMapType === Xr,
            decodeVideoTexture: !!b.map && b.map.isVideoTexture === !0 && b.map.encoding === Ee,
            clearcoat: Rt,
            clearcoatMap: Rt && !!b.clearcoatMap,
            clearcoatRoughnessMap: Rt && !!b.clearcoatRoughnessMap,
            clearcoatNormalMap: Rt && !!b.clearcoatNormalMap,
            iridescence: Nt,
            iridescenceMap: Nt && !!b.iridescenceMap,
            iridescenceThicknessMap: Nt && !!b.iridescenceThicknessMap,
            displacementMap: !!b.displacementMap,
            roughnessMap: !!b.roughnessMap,
            metalnessMap: !!b.metalnessMap,
            specularMap: !!b.specularMap,
            specularIntensityMap: !!b.specularIntensityMap,
            specularColorMap: !!b.specularColorMap,
            opaque: b.transparent === !1 && b.blending === Or,
            alphaMap: !!b.alphaMap,
            alphaTest: Ut,
            gradientMap: !!b.gradientMap,
            sheen: b.sheen > 0,
            sheenColorMap: !!b.sheenColorMap,
            sheenRoughnessMap: !!b.sheenRoughnessMap,
            transmission: b.transmission > 0,
            transmissionMap: !!b.transmissionMap,
            thicknessMap: !!b.thicknessMap,
            combine: b.combine,
            vertexTangents: !!b.normalMap && !!L.attributes.tangent,
            vertexColors: b.vertexColors,
            vertexAlphas: b.vertexColors === !0 && !!L.attributes.color && L.attributes.color.itemSize === 4,
            vertexUvs: !!b.map || !!b.bumpMap || !!b.normalMap || !!b.specularMap || !!b.alphaMap || !!b.emissiveMap || !!b.roughnessMap || !!b.metalnessMap || !!b.clearcoatMap || !!b.clearcoatRoughnessMap || !!b.clearcoatNormalMap || !!b.iridescenceMap || !!b.iridescenceThicknessMap || !!b.displacementMap || !!b.transmissionMap || !!b.thicknessMap || !!b.specularIntensityMap || !!b.specularColorMap || !!b.sheenColorMap || !!b.sheenRoughnessMap,
            uvsVertexOnly: !(b.map || b.bumpMap || b.normalMap || b.specularMap || b.alphaMap || b.emissiveMap || b.roughnessMap || b.metalnessMap || b.clearcoatNormalMap || b.iridescenceMap || b.iridescenceThicknessMap || b.transmission > 0 || b.transmissionMap || b.thicknessMap || b.specularIntensityMap || b.specularColorMap || b.sheen > 0 || b.sheenColorMap || b.sheenRoughnessMap) && !!b.displacementMap,
            fog: !!D,
            useFog: b.fog === !0,
            fogExp2: D && D.isFogExp2,
            flatShading: !!b.flatShading,
            sizeAttenuation: b.sizeAttenuation,
            logarithmicDepthBuffer: u,
            skinning: B.isSkinnedMesh === !0,
            morphTargets: L.morphAttributes.position !== void 0,
            morphNormals: L.morphAttributes.normal !== void 0,
            morphColors: L.morphAttributes.color !== void 0,
            morphTargetsCount: lt,
            morphTextureStride: wt,
            numDirLights: M.directional.length,
            numPointLights: M.point.length,
            numSpotLights: M.spot.length,
            numSpotLightMaps: M.spotLightMap.length,
            numRectAreaLights: M.rectArea.length,
            numHemiLights: M.hemi.length,
            numDirLightShadows: M.directionalShadowMap.length,
            numPointLightShadows: M.pointShadowMap.length,
            numSpotLightShadows: M.spotShadowMap.length,
            numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: i.shadowMap.enabled && I.length > 0,
            shadowMapType: i.shadowMap.type,
            toneMapping: b.toneMapped ? i.toneMapping : Pi,
            physicallyCorrectLights: i.physicallyCorrectLights,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === Ci,
            flipSided: b.side === xs,
            useDepthPacking: !!b.depthPacking,
            depthPacking: b.depthPacking || 0,
            index0AttributeName: b.index0AttributeName,
            extensionDerivatives: b.extensions && b.extensions.derivatives,
            extensionFragDepth: b.extensions && b.extensions.fragDepth,
            extensionDrawBuffers: b.extensions && b.extensions.drawBuffers,
            extensionShaderTextureLOD: b.extensions && b.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: h || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: h || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: b.customProgramCacheKey()
        }
    }

    function p(b) {
        const M = [];
        if (b.shaderID ? M.push(b.shaderID) : (M.push(b.customVertexShaderID), M.push(b.customFragmentShaderID)), b.defines !== void 0) for (const I in b.defines) M.push(I), M.push(b.defines[I]);
        return b.isRawShaderMaterial === !1 && (_(M, b), x(M, b), M.push(i.outputEncoding)), M.push(b.customProgramCacheKey), M.join()
    }

    function _(b, M) {
        b.push(M.precision), b.push(M.outputEncoding), b.push(M.envMapMode), b.push(M.envMapCubeUVHeight), b.push(M.combine), b.push(M.vertexUvs), b.push(M.fogExp2), b.push(M.sizeAttenuation), b.push(M.morphTargetsCount), b.push(M.morphAttributeCount), b.push(M.numDirLights), b.push(M.numPointLights), b.push(M.numSpotLights), b.push(M.numSpotLightMaps), b.push(M.numHemiLights), b.push(M.numRectAreaLights), b.push(M.numDirLightShadows), b.push(M.numPointLightShadows), b.push(M.numSpotLightShadows), b.push(M.numSpotLightShadowsWithMaps), b.push(M.shadowMapType), b.push(M.toneMapping), b.push(M.numClippingPlanes), b.push(M.numClipIntersection), b.push(M.depthPacking)
    }

    function x(b, M) {
        a.disableAll(), M.isWebGL2 && a.enable(0), M.supportsVertexTextures && a.enable(1), M.instancing && a.enable(2), M.instancingColor && a.enable(3), M.map && a.enable(4), M.matcap && a.enable(5), M.envMap && a.enable(6), M.lightMap && a.enable(7), M.aoMap && a.enable(8), M.emissiveMap && a.enable(9), M.bumpMap && a.enable(10), M.normalMap && a.enable(11), M.objectSpaceNormalMap && a.enable(12), M.tangentSpaceNormalMap && a.enable(13), M.clearcoat && a.enable(14), M.clearcoatMap && a.enable(15), M.clearcoatRoughnessMap && a.enable(16), M.clearcoatNormalMap && a.enable(17), M.iridescence && a.enable(18), M.iridescenceMap && a.enable(19), M.iridescenceThicknessMap && a.enable(20), M.displacementMap && a.enable(21), M.specularMap && a.enable(22), M.roughnessMap && a.enable(23), M.metalnessMap && a.enable(24), M.gradientMap && a.enable(25), M.alphaMap && a.enable(26), M.alphaTest && a.enable(27), M.vertexColors && a.enable(28), M.vertexAlphas && a.enable(29), M.vertexUvs && a.enable(30), M.vertexTangents && a.enable(31), M.uvsVertexOnly && a.enable(32), b.push(a.mask), a.disableAll(), M.fog && a.enable(0), M.useFog && a.enable(1), M.flatShading && a.enable(2), M.logarithmicDepthBuffer && a.enable(3), M.skinning && a.enable(4), M.morphTargets && a.enable(5), M.morphNormals && a.enable(6), M.morphColors && a.enable(7), M.premultipliedAlpha && a.enable(8), M.shadowMapEnabled && a.enable(9), M.physicallyCorrectLights && a.enable(10), M.doubleSided && a.enable(11), M.flipSided && a.enable(12), M.useDepthPacking && a.enable(13), M.dithering && a.enable(14), M.specularIntensityMap && a.enable(15), M.specularColorMap && a.enable(16), M.transmission && a.enable(17), M.transmissionMap && a.enable(18), M.thicknessMap && a.enable(19), M.sheen && a.enable(20), M.sheenColorMap && a.enable(21), M.sheenRoughnessMap && a.enable(22), M.decodeVideoTexture && a.enable(23), M.opaque && a.enable(24), b.push(a.mask)
    }

    function y(b) {
        const M = g[b.type];
        let I;
        if (M) {
            const N = ai[M];
            I = kc.clone(N.uniforms)
        } else I = b.uniforms;
        return I
    }

    function v(b, M) {
        let I;
        for (let N = 0, B = c.length; N < B; N++) {
            const D = c[N];
            if (D.cacheKey === M) {
                I = D, ++I.usedTimes;
                break
            }
        }
        return I === void 0 && (I = new rR(i, M, b, r), c.push(I)), I
    }

    function w(b) {
        if (--b.usedTimes === 0) {
            const M = c.indexOf(b);
            c[M] = c[c.length - 1], c.pop(), b.destroy()
        }
    }

    function E(b) {
        l.remove(b)
    }

    function S() {
        l.dispose()
    }

    return {
        getParameters: m,
        getProgramCacheKey: p,
        getUniforms: y,
        acquireProgram: v,
        releaseProgram: w,
        releaseShaderCache: E,
        programs: c,
        dispose: S
    }
}

function hR() {
    let i = new WeakMap;

    function t(r) {
        let o = i.get(r);
        return o === void 0 && (o = {}, i.set(r, o)), o
    }

    function e(r) {
        i.delete(r)
    }

    function n(r, o, a) {
        i.get(r)[o] = a
    }

    function s() {
        i = new WeakMap
    }

    return {get: t, remove: e, update: n, dispose: s}
}

function uR(i, t) {
    return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.material.id !== t.material.id ? i.material.id - t.material.id : i.z !== t.z ? i.z - t.z : i.id - t.id
}

function Vy(i, t) {
    return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.z !== t.z ? t.z - i.z : i.id - t.id
}

function Hy() {
    const i = [];
    let t = 0;
    const e = [], n = [], s = [];

    function r() {
        t = 0, e.length = 0, n.length = 0, s.length = 0
    }

    function o(u, d, f, g, m, p) {
        let _ = i[t];
        return _ === void 0 ? (_ = {
            id: u.id,
            object: u,
            geometry: d,
            material: f,
            groupOrder: g,
            renderOrder: u.renderOrder,
            z: m,
            group: p
        }, i[t] = _) : (_.id = u.id, _.object = u, _.geometry = d, _.material = f, _.groupOrder = g, _.renderOrder = u.renderOrder, _.z = m, _.group = p), t++, _
    }

    function a(u, d, f, g, m, p) {
        const _ = o(u, d, f, g, m, p);
        f.transmission > 0 ? n.push(_) : f.transparent === !0 ? s.push(_) : e.push(_)
    }

    function l(u, d, f, g, m, p) {
        const _ = o(u, d, f, g, m, p);
        f.transmission > 0 ? n.unshift(_) : f.transparent === !0 ? s.unshift(_) : e.unshift(_)
    }

    function c(u, d) {
        e.length > 1 && e.sort(u || uR), n.length > 1 && n.sort(d || Vy), s.length > 1 && s.sort(d || Vy)
    }

    function h() {
        for (let u = t, d = i.length; u < d; u++) {
            const f = i[u];
            if (f.id === null) break;
            f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null
        }
    }

    return {opaque: e, transmissive: n, transparent: s, init: r, push: a, unshift: l, finish: h, sort: c}
}

function dR() {
    let i = new WeakMap;

    function t(n, s) {
        const r = i.get(n);
        let o;
        return r === void 0 ? (o = new Hy, i.set(n, [o])) : s >= r.length ? (o = new Hy, r.push(o)) : o = r[s], o
    }

    function e() {
        i = new WeakMap
    }

    return {get: t, dispose: e}
}

function fR() {
    const i = {};
    return {
        get: function (t) {
            if (i[t.id] !== void 0) return i[t.id];
            let e;
            switch (t.type) {
                case"DirectionalLight":
                    e = {direction: new C, color: new pt};
                    break;
                case"SpotLight":
                    e = {
                        position: new C,
                        direction: new C,
                        color: new pt,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case"PointLight":
                    e = {position: new C, color: new pt, distance: 0, decay: 0};
                    break;
                case"HemisphereLight":
                    e = {direction: new C, skyColor: new pt, groundColor: new pt};
                    break;
                case"RectAreaLight":
                    e = {color: new pt, position: new C, halfWidth: new C, halfHeight: new C};
                    break
            }
            return i[t.id] = e, e
        }
    }
}

function pR() {
    const i = {};
    return {
        get: function (t) {
            if (i[t.id] !== void 0) return i[t.id];
            let e;
            switch (t.type) {
                case"DirectionalLight":
                    e = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new j};
                    break;
                case"SpotLight":
                    e = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new j};
                    break;
                case"PointLight":
                    e = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new j,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break
            }
            return i[t.id] = e, e
        }
    }
}

let gR = 0;

function mR(i, t) {
    return (t.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (i.map ? 1 : 0)
}

function _R(i, t) {
    const e = new fR, n = pR(), s = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let h = 0; h < 9; h++) s.probe.push(new C);
    const r = new C, o = new Yt, a = new Yt;

    function l(h, u) {
        let d = 0, f = 0, g = 0;
        for (let N = 0; N < 9; N++) s.probe[N].set(0, 0, 0);
        let m = 0, p = 0, _ = 0, x = 0, y = 0, v = 0, w = 0, E = 0, S = 0, b = 0;
        h.sort(mR);
        const M = u !== !0 ? Math.PI : 1;
        for (let N = 0, B = h.length; N < B; N++) {
            const D = h[N], L = D.color, k = D.intensity, G = D.distance,
                Q = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
            if (D.isAmbientLight) d += L.r * k * M, f += L.g * k * M, g += L.b * k * M; else if (D.isLightProbe) for (let q = 0; q < 9; q++) s.probe[q].addScaledVector(D.sh.coefficients[q], k); else if (D.isDirectionalLight) {
                const q = e.get(D);
                if (q.color.copy(D.color).multiplyScalar(D.intensity * M), D.castShadow) {
                    const at = D.shadow, lt = n.get(D);
                    lt.shadowBias = at.bias, lt.shadowNormalBias = at.normalBias, lt.shadowRadius = at.radius, lt.shadowMapSize = at.mapSize, s.directionalShadow[m] = lt, s.directionalShadowMap[m] = Q, s.directionalShadowMatrix[m] = D.shadow.matrix, v++
                }
                s.directional[m] = q, m++
            } else if (D.isSpotLight) {
                const q = e.get(D);
                q.position.setFromMatrixPosition(D.matrixWorld), q.color.copy(L).multiplyScalar(k * M), q.distance = G, q.coneCos = Math.cos(D.angle), q.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), q.decay = D.decay, s.spot[_] = q;
                const at = D.shadow;
                if (D.map && (s.spotLightMap[S] = D.map, S++, at.updateMatrices(D), D.castShadow && b++), s.spotLightMatrix[_] = at.matrix, D.castShadow) {
                    const lt = n.get(D);
                    lt.shadowBias = at.bias, lt.shadowNormalBias = at.normalBias, lt.shadowRadius = at.radius, lt.shadowMapSize = at.mapSize, s.spotShadow[_] = lt, s.spotShadowMap[_] = Q, E++
                }
                _++
            } else if (D.isRectAreaLight) {
                const q = e.get(D);
                q.color.copy(L).multiplyScalar(k), q.halfWidth.set(D.width * .5, 0, 0), q.halfHeight.set(0, D.height * .5, 0), s.rectArea[x] = q, x++
            } else if (D.isPointLight) {
                const q = e.get(D);
                if (q.color.copy(D.color).multiplyScalar(D.intensity * M), q.distance = D.distance, q.decay = D.decay, D.castShadow) {
                    const at = D.shadow, lt = n.get(D);
                    lt.shadowBias = at.bias, lt.shadowNormalBias = at.normalBias, lt.shadowRadius = at.radius, lt.shadowMapSize = at.mapSize, lt.shadowCameraNear = at.camera.near, lt.shadowCameraFar = at.camera.far, s.pointShadow[p] = lt, s.pointShadowMap[p] = Q, s.pointShadowMatrix[p] = D.shadow.matrix, w++
                }
                s.point[p] = q, p++
            } else if (D.isHemisphereLight) {
                const q = e.get(D);
                q.skyColor.copy(D.color).multiplyScalar(k * M), q.groundColor.copy(D.groundColor).multiplyScalar(k * M), s.hemi[y] = q, y++
            }
        }
        x > 0 && (t.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (s.rectAreaLTC1 = xt.LTC_FLOAT_1, s.rectAreaLTC2 = xt.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (s.rectAreaLTC1 = xt.LTC_HALF_1, s.rectAreaLTC2 = xt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), s.ambient[0] = d, s.ambient[1] = f, s.ambient[2] = g;
        const I = s.hash;
        (I.directionalLength !== m || I.pointLength !== p || I.spotLength !== _ || I.rectAreaLength !== x || I.hemiLength !== y || I.numDirectionalShadows !== v || I.numPointShadows !== w || I.numSpotShadows !== E || I.numSpotMaps !== S) && (s.directional.length = m, s.spot.length = _, s.rectArea.length = x, s.point.length = p, s.hemi.length = y, s.directionalShadow.length = v, s.directionalShadowMap.length = v, s.pointShadow.length = w, s.pointShadowMap.length = w, s.spotShadow.length = E, s.spotShadowMap.length = E, s.directionalShadowMatrix.length = v, s.pointShadowMatrix.length = w, s.spotLightMatrix.length = E + S - b, s.spotLightMap.length = S, s.numSpotLightShadowsWithMaps = b, I.directionalLength = m, I.pointLength = p, I.spotLength = _, I.rectAreaLength = x, I.hemiLength = y, I.numDirectionalShadows = v, I.numPointShadows = w, I.numSpotShadows = E, I.numSpotMaps = S, s.version = gR++)
    }

    function c(h, u) {
        let d = 0, f = 0, g = 0, m = 0, p = 0;
        const _ = u.matrixWorldInverse;
        for (let x = 0, y = h.length; x < y; x++) {
            const v = h[x];
            if (v.isDirectionalLight) {
                const w = s.directional[d];
                w.direction.setFromMatrixPosition(v.matrixWorld), r.setFromMatrixPosition(v.target.matrixWorld), w.direction.sub(r), w.direction.transformDirection(_), d++
            } else if (v.isSpotLight) {
                const w = s.spot[g];
                w.position.setFromMatrixPosition(v.matrixWorld), w.position.applyMatrix4(_), w.direction.setFromMatrixPosition(v.matrixWorld), r.setFromMatrixPosition(v.target.matrixWorld), w.direction.sub(r), w.direction.transformDirection(_), g++
            } else if (v.isRectAreaLight) {
                const w = s.rectArea[m];
                w.position.setFromMatrixPosition(v.matrixWorld), w.position.applyMatrix4(_), a.identity(), o.copy(v.matrixWorld), o.premultiply(_), a.extractRotation(o), w.halfWidth.set(v.width * .5, 0, 0), w.halfHeight.set(0, v.height * .5, 0), w.halfWidth.applyMatrix4(a), w.halfHeight.applyMatrix4(a), m++
            } else if (v.isPointLight) {
                const w = s.point[f];
                w.position.setFromMatrixPosition(v.matrixWorld), w.position.applyMatrix4(_), f++
            } else if (v.isHemisphereLight) {
                const w = s.hemi[p];
                w.direction.setFromMatrixPosition(v.matrixWorld), w.direction.transformDirection(_), p++
            }
        }
    }

    return {setup: l, setupView: c, state: s}
}

function $y(i, t) {
    const e = new _R(i, t), n = [], s = [];

    function r() {
        n.length = 0, s.length = 0
    }

    function o(u) {
        n.push(u)
    }

    function a(u) {
        s.push(u)
    }

    function l(u) {
        e.setup(n, u)
    }

    function c(u) {
        e.setupView(n, u)
    }

    return {
        init: r,
        state: {lightsArray: n, shadowsArray: s, lights: e},
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    }
}

function yR(i, t) {
    let e = new WeakMap;

    function n(r, o = 0) {
        const a = e.get(r);
        let l;
        return a === void 0 ? (l = new $y(i, t), e.set(r, [l])) : o >= a.length ? (l = new $y(i, t), a.push(l)) : l = a[o], l
    }

    function s() {
        e = new WeakMap
    }

    return {get: n, dispose: s}
}

class a0 extends En {
    constructor(t) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Rb, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }
}

class l0 extends En {
    constructor(t) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new C, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }
}

const xR = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, vR = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function wR(i, t, e) {
    let n = new jd;
    const s = new j, r = new j, o = new Fe, a = new a0({depthPacking: Lb}), l = new l0, c = {}, h = e.maxTextureSize,
        u = {[Fi]: xs, [xs]: Fi, [Ci]: Ci}, d = new jn({
            defines: {VSM_SAMPLES: 8},
            uniforms: {shadow_pass: {value: null}, resolution: {value: new j}, radius: {value: 4}},
            vertexShader: xR,
            fragmentShader: vR
        }), f = d.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const g = new Xt;
    g.setAttribute("position", new ae(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const m = new ge(g, d), p = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Ym, this.render = function (v, w, E) {
        if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || v.length === 0) return;
        const S = i.getRenderTarget(), b = i.getActiveCubeFace(), M = i.getActiveMipmapLevel(), I = i.state;
        I.setBlending(ar), I.buffers.color.setClear(1, 1, 1, 1), I.buffers.depth.setTest(!0), I.setScissorTest(!1);
        for (let N = 0, B = v.length; N < B; N++) {
            const D = v[N], L = D.shadow;
            if (L === void 0) {
                console.warn("THREE.WebGLShadowMap:", D, "has no shadow.");
                continue
            }
            if (L.autoUpdate === !1 && L.needsUpdate === !1) continue;
            s.copy(L.mapSize);
            const k = L.getFrameExtents();
            if (s.multiply(k), r.copy(L.mapSize), (s.x > h || s.y > h) && (s.x > h && (r.x = Math.floor(h / k.x), s.x = r.x * k.x, L.mapSize.x = r.x), s.y > h && (r.y = Math.floor(h / k.y), s.y = r.y * k.y, L.mapSize.y = r.y)), L.map === null) {
                const Q = this.type !== Ra ? {minFilter: sn, magFilter: sn} : {};
                L.map = new fs(s.x, s.y, Q), L.map.texture.name = D.name + ".shadowMap", L.camera.updateProjectionMatrix()
            }
            i.setRenderTarget(L.map), i.clear();
            const G = L.getViewportCount();
            for (let Q = 0; Q < G; Q++) {
                const q = L.getViewport(Q);
                o.set(r.x * q.x, r.y * q.y, r.x * q.z, r.y * q.w), I.viewport(o), L.updateMatrices(D, Q), n = L.getFrustum(), y(w, E, L.camera, D, this.type)
            }
            L.isPointLightShadow !== !0 && this.type === Ra && _(L, E), L.needsUpdate = !1
        }
        p.needsUpdate = !1, i.setRenderTarget(S, b, M)
    };

    function _(v, w) {
        const E = t.update(m);
        d.defines.VSM_SAMPLES !== v.blurSamples && (d.defines.VSM_SAMPLES = v.blurSamples, f.defines.VSM_SAMPLES = v.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), v.mapPass === null && (v.mapPass = new fs(s.x, s.y)), d.uniforms.shadow_pass.value = v.map.texture, d.uniforms.resolution.value = v.mapSize, d.uniforms.radius.value = v.radius, i.setRenderTarget(v.mapPass), i.clear(), i.renderBufferDirect(w, null, E, d, m, null), f.uniforms.shadow_pass.value = v.mapPass.texture, f.uniforms.resolution.value = v.mapSize, f.uniforms.radius.value = v.radius, i.setRenderTarget(v.map), i.clear(), i.renderBufferDirect(w, null, E, f, m, null)
    }

    function x(v, w, E, S, b, M) {
        let I = null;
        const N = E.isPointLight === !0 ? v.customDistanceMaterial : v.customDepthMaterial;
        if (N !== void 0) I = N; else if (I = E.isPointLight === !0 ? l : a, i.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
            const B = I.uuid, D = w.uuid;
            let L = c[B];
            L === void 0 && (L = {}, c[B] = L);
            let k = L[D];
            k === void 0 && (k = I.clone(), L[D] = k), I = k
        }
        return I.visible = w.visible, I.wireframe = w.wireframe, M === Ra ? I.side = w.shadowSide !== null ? w.shadowSide : w.side : I.side = w.shadowSide !== null ? w.shadowSide : u[w.side], I.alphaMap = w.alphaMap, I.alphaTest = w.alphaTest, I.map = w.map, I.clipShadows = w.clipShadows, I.clippingPlanes = w.clippingPlanes, I.clipIntersection = w.clipIntersection, I.displacementMap = w.displacementMap, I.displacementScale = w.displacementScale, I.displacementBias = w.displacementBias, I.wireframeLinewidth = w.wireframeLinewidth, I.linewidth = w.linewidth, E.isPointLight === !0 && I.isMeshDistanceMaterial === !0 && (I.referencePosition.setFromMatrixPosition(E.matrixWorld), I.nearDistance = S, I.farDistance = b), I
    }

    function y(v, w, E, S, b) {
        if (v.visible === !1) return;
        if (v.layers.test(w.layers) && (v.isMesh || v.isLine || v.isPoints) && (v.castShadow || v.receiveShadow && b === Ra) && (!v.frustumCulled || n.intersectsObject(v))) {
            v.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, v.matrixWorld);
            const N = t.update(v), B = v.material;
            if (Array.isArray(B)) {
                const D = N.groups;
                for (let L = 0, k = D.length; L < k; L++) {
                    const G = D[L], Q = B[G.materialIndex];
                    if (Q && Q.visible) {
                        const q = x(v, Q, S, E.near, E.far, b);
                        i.renderBufferDirect(E, null, N, q, v, G)
                    }
                }
            } else if (B.visible) {
                const D = x(v, B, S, E.near, E.far, b);
                i.renderBufferDirect(E, null, N, D, v, null)
            }
        }
        const I = v.children;
        for (let N = 0, B = I.length; N < B; N++) y(I[N], w, E, S, b)
    }
}

function bR(i, t, e) {
    const n = e.isWebGL2;

    function s() {
        let U = !1;
        const K = new Fe;
        let ut = null;
        const Tt = new Fe(0, 0, 0, 0);
        return {
            setMask: function (zt) {
                ut !== zt && !U && (i.colorMask(zt, zt, zt, zt), ut = zt)
            }, setLocked: function (zt) {
                U = zt
            }, setClear: function (zt, Ae, An, Hn, Qr) {
                Qr === !0 && (zt *= Hn, Ae *= Hn, An *= Hn), K.set(zt, Ae, An, Hn), Tt.equals(K) === !1 && (i.clearColor(zt, Ae, An, Hn), Tt.copy(K))
            }, reset: function () {
                U = !1, ut = null, Tt.set(-1, 0, 0, 0)
            }
        }
    }

    function r() {
        let U = !1, K = null, ut = null, Tt = null;
        return {
            setTest: function (zt) {
                zt ? Ut(2929) : Rt(2929)
            }, setMask: function (zt) {
                K !== zt && !U && (i.depthMask(zt), K = zt)
            }, setFunc: function (zt) {
                if (ut !== zt) {
                    switch (zt) {
                        case Jw:
                            i.depthFunc(512);
                            break;
                        case Qw:
                            i.depthFunc(519);
                            break;
                        case tb:
                            i.depthFunc(513);
                            break;
                        case rd:
                            i.depthFunc(515);
                            break;
                        case eb:
                            i.depthFunc(514);
                            break;
                        case nb:
                            i.depthFunc(518);
                            break;
                        case sb:
                            i.depthFunc(516);
                            break;
                        case ib:
                            i.depthFunc(517);
                            break;
                        default:
                            i.depthFunc(515)
                    }
                    ut = zt
                }
            }, setLocked: function (zt) {
                U = zt
            }, setClear: function (zt) {
                Tt !== zt && (i.clearDepth(zt), Tt = zt)
            }, reset: function () {
                U = !1, K = null, ut = null, Tt = null
            }
        }
    }

    function o() {
        let U = !1, K = null, ut = null, Tt = null, zt = null, Ae = null, An = null, Hn = null, Qr = null;
        return {
            setTest: function (Ze) {
                U || (Ze ? Ut(2960) : Rt(2960))
            }, setMask: function (Ze) {
                K !== Ze && !U && (i.stencilMask(Ze), K = Ze)
            }, setFunc: function (Ze, $i, Gs) {
                (ut !== Ze || Tt !== $i || zt !== Gs) && (i.stencilFunc(Ze, $i, Gs), ut = Ze, Tt = $i, zt = Gs)
            }, setOp: function (Ze, $i, Gs) {
                (Ae !== Ze || An !== $i || Hn !== Gs) && (i.stencilOp(Ze, $i, Gs), Ae = Ze, An = $i, Hn = Gs)
            }, setLocked: function (Ze) {
                U = Ze
            }, setClear: function (Ze) {
                Qr !== Ze && (i.clearStencil(Ze), Qr = Ze)
            }, reset: function () {
                U = !1, K = null, ut = null, Tt = null, zt = null, Ae = null, An = null, Hn = null, Qr = null
            }
        }
    }

    const a = new s, l = new r, c = new o, h = new WeakMap, u = new WeakMap;
    let d = {}, f = {}, g = new WeakMap, m = [], p = null, _ = !1, x = null, y = null, v = null, w = null, E = null,
        S = null, b = null, M = !1, I = null, N = null, B = null, D = null, L = null;
    const k = i.getParameter(35661);
    let G = !1, Q = 0;
    const q = i.getParameter(7938);
    q.indexOf("WebGL") !== -1 ? (Q = parseFloat(/^WebGL (\d)/.exec(q)[1]), G = Q >= 1) : q.indexOf("OpenGL ES") !== -1 && (Q = parseFloat(/^OpenGL ES (\d)/.exec(q)[1]), G = Q >= 2);
    let at = null, lt = {};
    const wt = i.getParameter(3088), W = i.getParameter(2978), st = new Fe().fromArray(wt), gt = new Fe().fromArray(W);

    function mt(U, K, ut) {
        const Tt = new Uint8Array(4), zt = i.createTexture();
        i.bindTexture(U, zt), i.texParameteri(U, 10241, 9728), i.texParameteri(U, 10240, 9728);
        for (let Ae = 0; Ae < ut; Ae++) i.texImage2D(K + Ae, 0, 6408, 1, 1, 0, 6408, 5121, Tt);
        return zt
    }

    const Y = {};
    Y[3553] = mt(3553, 3553, 1), Y[34067] = mt(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), Ut(2929), l.setFunc(rd), _t(!1), qt(Ug), Ut(2884), ft(ar);

    function Ut(U) {
        d[U] !== !0 && (i.enable(U), d[U] = !0)
    }

    function Rt(U) {
        d[U] !== !1 && (i.disable(U), d[U] = !1)
    }

    function Nt(U, K) {
        return f[U] !== K ? (i.bindFramebuffer(U, K), f[U] = K, n && (U === 36009 && (f[36160] = K), U === 36160 && (f[36009] = K)), !0) : !1
    }

    function vt(U, K) {
        let ut = m, Tt = !1;
        if (U) if (ut = g.get(K), ut === void 0 && (ut = [], g.set(K, ut)), U.isWebGLMultipleRenderTargets) {
            const zt = U.texture;
            if (ut.length !== zt.length || ut[0] !== 36064) {
                for (let Ae = 0, An = zt.length; Ae < An; Ae++) ut[Ae] = 36064 + Ae;
                ut.length = zt.length, Tt = !0
            }
        } else ut[0] !== 36064 && (ut[0] = 36064, Tt = !0); else ut[0] !== 1029 && (ut[0] = 1029, Tt = !0);
        Tt && (e.isWebGL2 ? i.drawBuffers(ut) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(ut))
    }

    function ee(U) {
        return p !== U ? (i.useProgram(U), p = U, !0) : !1
    }

    const nt = {[vo]: 32774, [Gw]: 32778, [Vw]: 32779};
    if (n) nt[Hg] = 32775, nt[$g] = 32776; else {
        const U = t.get("EXT_blend_minmax");
        U !== null && (nt[Hg] = U.MIN_EXT, nt[$g] = U.MAX_EXT)
    }
    const et = {
        [Hw]: 0,
        [$w]: 1,
        [Ww]: 768,
        [Zm]: 770,
        [Kw]: 776,
        [Zw]: 774,
        [Yw]: 772,
        [qw]: 769,
        [jm]: 771,
        [jw]: 775,
        [Xw]: 773
    };

    function ft(U, K, ut, Tt, zt, Ae, An, Hn) {
        if (U === ar) {
            _ === !0 && (Rt(3042), _ = !1);
            return
        }
        if (_ === !1 && (Ut(3042), _ = !0), U !== Uw) {
            if (U !== x || Hn !== M) {
                if ((y !== vo || E !== vo) && (i.blendEquation(32774), y = vo, E = vo), Hn) switch (U) {
                    case Or:
                        i.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case Rc:
                        i.blendFunc(1, 1);
                        break;
                    case Gg:
                        i.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case Vg:
                        i.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", U);
                        break
                } else switch (U) {
                    case Or:
                        i.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case Rc:
                        i.blendFunc(770, 1);
                        break;
                    case Gg:
                        i.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case Vg:
                        i.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", U);
                        break
                }
                v = null, w = null, S = null, b = null, x = U, M = Hn
            }
            return
        }
        zt = zt || K, Ae = Ae || ut, An = An || Tt, (K !== y || zt !== E) && (i.blendEquationSeparate(nt[K], nt[zt]), y = K, E = zt), (ut !== v || Tt !== w || Ae !== S || An !== b) && (i.blendFuncSeparate(et[ut], et[Tt], et[Ae], et[An]), v = ut, w = Tt, S = Ae, b = An), x = U, M = !1
    }

    function Pt(U, K) {
        U.side === Ci ? Rt(2884) : Ut(2884);
        let ut = U.side === xs;
        K && (ut = !ut), _t(ut), U.blending === Or && U.transparent === !1 ? ft(ar) : ft(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.premultipliedAlpha), l.setFunc(U.depthFunc), l.setTest(U.depthTest), l.setMask(U.depthWrite), a.setMask(U.colorWrite);
        const Tt = U.stencilWrite;
        c.setTest(Tt), Tt && (c.setMask(U.stencilWriteMask), c.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask), c.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)), Gt(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits), U.alphaToCoverage === !0 ? Ut(32926) : Rt(32926)
    }

    function _t(U) {
        I !== U && (U ? i.frontFace(2304) : i.frontFace(2305), I = U)
    }

    function qt(U) {
        U !== Bw ? (Ut(2884), U !== N && (U === Ug ? i.cullFace(1029) : U === kw ? i.cullFace(1028) : i.cullFace(1032))) : Rt(2884), N = U
    }

    function Vt(U) {
        U !== B && (G && i.lineWidth(U), B = U)
    }

    function Gt(U, K, ut) {
        U ? (Ut(32823), (D !== K || L !== ut) && (i.polygonOffset(K, ut), D = K, L = ut)) : Rt(32823)
    }

    function ke(U) {
        U ? Ut(3089) : Rt(3089)
    }

    function ve(U) {
        U === void 0 && (U = 33984 + k - 1), at !== U && (i.activeTexture(U), at = U)
    }

    function R(U, K, ut) {
        ut === void 0 && (at === null ? ut = 33984 + k - 1 : ut = at);
        let Tt = lt[ut];
        Tt === void 0 && (Tt = {
            type: void 0,
            texture: void 0
        }, lt[ut] = Tt), (Tt.type !== U || Tt.texture !== K) && (at !== ut && (i.activeTexture(ut), at = ut), i.bindTexture(U, K || Y[U]), Tt.type = U, Tt.texture = K)
    }

    function A() {
        const U = lt[at];
        U !== void 0 && U.type !== void 0 && (i.bindTexture(U.type, null), U.type = void 0, U.texture = void 0)
    }

    function X() {
        try {
            i.compressedTexImage2D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function ht() {
        try {
            i.compressedTexImage3D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function dt() {
        try {
            i.texSubImage2D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function bt() {
        try {
            i.texSubImage3D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function Wt() {
        try {
            i.compressedTexSubImage2D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function O() {
        try {
            i.compressedTexSubImage3D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function V() {
        try {
            i.texStorage2D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function Et() {
        try {
            i.texStorage3D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function It() {
        try {
            i.texImage2D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function Mt() {
        try {
            i.texImage3D.apply(i, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }

    function Ft(U) {
        st.equals(U) === !1 && (i.scissor(U.x, U.y, U.z, U.w), st.copy(U))
    }

    function Ot(U) {
        gt.equals(U) === !1 && (i.viewport(U.x, U.y, U.z, U.w), gt.copy(U))
    }

    function oe(U, K) {
        let ut = u.get(K);
        ut === void 0 && (ut = new WeakMap, u.set(K, ut));
        let Tt = ut.get(U);
        Tt === void 0 && (Tt = i.getUniformBlockIndex(K, U.name), ut.set(U, Tt))
    }

    function ce(U, K) {
        const Tt = u.get(K).get(U);
        h.get(K) !== Tt && (i.uniformBlockBinding(K, Tt, U.__bindingPointIndex), h.set(K, Tt))
    }

    function Ue() {
        i.disable(3042), i.disable(2884), i.disable(2929), i.disable(32823), i.disable(3089), i.disable(2960), i.disable(32926), i.blendEquation(32774), i.blendFunc(1, 0), i.blendFuncSeparate(1, 0, 1, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(513), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(519, 0, 4294967295), i.stencilOp(7680, 7680, 7680), i.clearStencil(0), i.cullFace(1029), i.frontFace(2305), i.polygonOffset(0, 0), i.activeTexture(33984), i.bindFramebuffer(36160, null), n === !0 && (i.bindFramebuffer(36009, null), i.bindFramebuffer(36008, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), d = {}, at = null, lt = {}, f = {}, g = new WeakMap, m = [], p = null, _ = !1, x = null, y = null, v = null, w = null, E = null, S = null, b = null, M = !1, I = null, N = null, B = null, D = null, L = null, st.set(0, 0, i.canvas.width, i.canvas.height), gt.set(0, 0, i.canvas.width, i.canvas.height), a.reset(), l.reset(), c.reset()
    }

    return {
        buffers: {color: a, depth: l, stencil: c},
        enable: Ut,
        disable: Rt,
        bindFramebuffer: Nt,
        drawBuffers: vt,
        useProgram: ee,
        setBlending: ft,
        setMaterial: Pt,
        setFlipSided: _t,
        setCullFace: qt,
        setLineWidth: Vt,
        setPolygonOffset: Gt,
        setScissorTest: ke,
        activeTexture: ve,
        bindTexture: R,
        unbindTexture: A,
        compressedTexImage2D: X,
        compressedTexImage3D: ht,
        texImage2D: It,
        texImage3D: Mt,
        updateUBOMapping: oe,
        uniformBlockBinding: ce,
        texStorage2D: V,
        texStorage3D: Et,
        texSubImage2D: dt,
        texSubImage3D: bt,
        compressedTexSubImage2D: Wt,
        compressedTexSubImage3D: O,
        scissor: Ft,
        viewport: Ot,
        reset: Ue
    }
}

function ER(i, t, e, n, s, r, o) {
    const a = s.isWebGL2, l = s.maxTextures, c = s.maxCubemapSize, h = s.maxTextureSize, u = s.maxSamples,
        d = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
        f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), g = new WeakMap;
    let m;
    const p = new WeakMap;
    let _ = !1;
    try {
        _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch {
    }

    function x(R, A) {
        return _ ? new OffscreenCanvas(R, A) : Bc("canvas")
    }

    function y(R, A, X, ht) {
        let dt = 1;
        if ((R.width > ht || R.height > ht) && (dt = ht / Math.max(R.width, R.height)), dt < 1 || A === !0) if (typeof HTMLImageElement < "u" && R instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && R instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && R instanceof ImageBitmap) {
            const bt = A ? ld : Math.floor, Wt = bt(dt * R.width), O = bt(dt * R.height);
            m === void 0 && (m = x(Wt, O));
            const V = X ? x(Wt, O) : m;
            return V.width = Wt, V.height = O, V.getContext("2d").drawImage(R, 0, 0, Wt, O), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + R.width + "x" + R.height + ") to (" + Wt + "x" + O + ")."), V
        } else return "data" in R && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + R.width + "x" + R.height + ")."), R;
        return R
    }

    function v(R) {
        return gm(R.width) && gm(R.height)
    }

    function w(R) {
        return a ? !1 : R.wrapS !== kn || R.wrapT !== kn || R.minFilter !== sn && R.minFilter !== Qe
    }

    function E(R, A) {
        return R.generateMipmaps && A && R.minFilter !== sn && R.minFilter !== Qe
    }

    function S(R) {
        i.generateMipmap(R)
    }

    function b(R, A, X, ht, dt = !1) {
        if (a === !1) return A;
        if (R !== null) {
            if (i[R] !== void 0) return i[R];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + R + "'")
        }
        let bt = A;
        return A === 6403 && (X === 5126 && (bt = 33326), X === 5131 && (bt = 33325), X === 5121 && (bt = 33321)), A === 33319 && (X === 5126 && (bt = 33328), X === 5131 && (bt = 33327), X === 5121 && (bt = 33323)), A === 6408 && (X === 5126 && (bt = 34836), X === 5131 && (bt = 34842), X === 5121 && (bt = ht === Ee && dt === !1 ? 35907 : 32856), X === 32819 && (bt = 32854), X === 32820 && (bt = 32855)), (bt === 33325 || bt === 33326 || bt === 33327 || bt === 33328 || bt === 34842 || bt === 34836) && t.get("EXT_color_buffer_float"), bt
    }

    function M(R, A, X) {
        return E(R, X) === !0 || R.isFramebufferTexture && R.minFilter !== sn && R.minFilter !== Qe ? Math.log2(Math.max(A.width, A.height)) + 1 : R.mipmaps !== void 0 && R.mipmaps.length > 0 ? R.mipmaps.length : R.isCompressedTexture && Array.isArray(R.image) ? A.mipmaps.length : 1
    }

    function I(R) {
        return R === sn || R === Oc || R === Ba ? 9728 : 9729
    }

    function N(R) {
        const A = R.target;
        A.removeEventListener("dispose", N), D(A), A.isVideoTexture && g.delete(A)
    }

    function B(R) {
        const A = R.target;
        A.removeEventListener("dispose", B), k(A)
    }

    function D(R) {
        const A = n.get(R);
        if (A.__webglInit === void 0) return;
        const X = R.source, ht = p.get(X);
        if (ht) {
            const dt = ht[A.__cacheKey];
            dt.usedTimes--, dt.usedTimes === 0 && L(R), Object.keys(ht).length === 0 && p.delete(X)
        }
        n.remove(R)
    }

    function L(R) {
        const A = n.get(R);
        i.deleteTexture(A.__webglTexture);
        const X = R.source, ht = p.get(X);
        delete ht[A.__cacheKey], o.memory.textures--
    }

    function k(R) {
        const A = R.texture, X = n.get(R), ht = n.get(A);
        if (ht.__webglTexture !== void 0 && (i.deleteTexture(ht.__webglTexture), o.memory.textures--), R.depthTexture && R.depthTexture.dispose(), R.isWebGLCubeRenderTarget) for (let dt = 0; dt < 6; dt++) i.deleteFramebuffer(X.__webglFramebuffer[dt]), X.__webglDepthbuffer && i.deleteRenderbuffer(X.__webglDepthbuffer[dt]); else {
            if (i.deleteFramebuffer(X.__webglFramebuffer), X.__webglDepthbuffer && i.deleteRenderbuffer(X.__webglDepthbuffer), X.__webglMultisampledFramebuffer && i.deleteFramebuffer(X.__webglMultisampledFramebuffer), X.__webglColorRenderbuffer) for (let dt = 0; dt < X.__webglColorRenderbuffer.length; dt++) X.__webglColorRenderbuffer[dt] && i.deleteRenderbuffer(X.__webglColorRenderbuffer[dt]);
            X.__webglDepthRenderbuffer && i.deleteRenderbuffer(X.__webglDepthRenderbuffer)
        }
        if (R.isWebGLMultipleRenderTargets) for (let dt = 0, bt = A.length; dt < bt; dt++) {
            const Wt = n.get(A[dt]);
            Wt.__webglTexture && (i.deleteTexture(Wt.__webglTexture), o.memory.textures--), n.remove(A[dt])
        }
        n.remove(A), n.remove(R)
    }

    let G = 0;

    function Q() {
        G = 0
    }

    function q() {
        const R = G;
        return R >= l && console.warn("THREE.WebGLTextures: Trying to use " + R + " texture units while this GPU supports only " + l), G += 1, R
    }

    function at(R) {
        const A = [];
        return A.push(R.wrapS), A.push(R.wrapT), A.push(R.wrapR || 0), A.push(R.magFilter), A.push(R.minFilter), A.push(R.anisotropy), A.push(R.internalFormat), A.push(R.format), A.push(R.type), A.push(R.generateMipmaps), A.push(R.premultiplyAlpha), A.push(R.flipY), A.push(R.unpackAlignment), A.push(R.encoding), A.join()
    }

    function lt(R, A) {
        const X = n.get(R);
        if (R.isVideoTexture && ke(R), R.isRenderTargetTexture === !1 && R.version > 0 && X.__version !== R.version) {
            const ht = R.image;
            if (ht === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (ht.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else {
                Rt(X, R, A);
                return
            }
        }
        e.bindTexture(3553, X.__webglTexture, 33984 + A)
    }

    function wt(R, A) {
        const X = n.get(R);
        if (R.version > 0 && X.__version !== R.version) {
            Rt(X, R, A);
            return
        }
        e.bindTexture(35866, X.__webglTexture, 33984 + A)
    }

    function W(R, A) {
        const X = n.get(R);
        if (R.version > 0 && X.__version !== R.version) {
            Rt(X, R, A);
            return
        }
        e.bindTexture(32879, X.__webglTexture, 33984 + A)
    }

    function st(R, A) {
        const X = n.get(R);
        if (R.version > 0 && X.__version !== R.version) {
            Nt(X, R, A);
            return
        }
        e.bindTexture(34067, X.__webglTexture, 33984 + A)
    }

    const gt = {[Ur]: 10497, [kn]: 33071, [el]: 33648},
        mt = {[sn]: 9728, [Oc]: 9984, [Ba]: 9986, [Qe]: 9729, [Wd]: 9985, [zi]: 9987};

    function Y(R, A, X) {
        if (X ? (i.texParameteri(R, 10242, gt[A.wrapS]), i.texParameteri(R, 10243, gt[A.wrapT]), (R === 32879 || R === 35866) && i.texParameteri(R, 32882, gt[A.wrapR]), i.texParameteri(R, 10240, mt[A.magFilter]), i.texParameteri(R, 10241, mt[A.minFilter])) : (i.texParameteri(R, 10242, 33071), i.texParameteri(R, 10243, 33071), (R === 32879 || R === 35866) && i.texParameteri(R, 32882, 33071), (A.wrapS !== kn || A.wrapT !== kn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(R, 10240, I(A.magFilter)), i.texParameteri(R, 10241, I(A.minFilter)), A.minFilter !== sn && A.minFilter !== Qe && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), t.has("EXT_texture_filter_anisotropic") === !0) {
            const ht = t.get("EXT_texture_filter_anisotropic");
            if (A.magFilter === sn || A.minFilter !== Ba && A.minFilter !== zi || A.type === ir && t.has("OES_texture_float_linear") === !1 || a === !1 && A.type === nl && t.has("OES_texture_half_float_linear") === !1) return;
            (A.anisotropy > 1 || n.get(A).__currentAnisotropy) && (i.texParameterf(R, ht.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(A.anisotropy, s.getMaxAnisotropy())), n.get(A).__currentAnisotropy = A.anisotropy)
        }
    }

    function Ut(R, A) {
        let X = !1;
        R.__webglInit === void 0 && (R.__webglInit = !0, A.addEventListener("dispose", N));
        const ht = A.source;
        let dt = p.get(ht);
        dt === void 0 && (dt = {}, p.set(ht, dt));
        const bt = at(A);
        if (bt !== R.__cacheKey) {
            dt[bt] === void 0 && (dt[bt] = {
                texture: i.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, X = !0), dt[bt].usedTimes++;
            const Wt = dt[R.__cacheKey];
            Wt !== void 0 && (dt[R.__cacheKey].usedTimes--, Wt.usedTimes === 0 && L(A)), R.__cacheKey = bt, R.__webglTexture = dt[bt].texture
        }
        return X
    }

    function Rt(R, A, X) {
        let ht = 3553;
        (A.isDataArrayTexture || A.isCompressedArrayTexture) && (ht = 35866), A.isData3DTexture && (ht = 32879);
        const dt = Ut(R, A), bt = A.source;
        e.bindTexture(ht, R.__webglTexture, 33984 + X);
        const Wt = n.get(bt);
        if (bt.version !== Wt.__version || dt === !0) {
            e.activeTexture(33984 + X), i.pixelStorei(37440, A.flipY), i.pixelStorei(37441, A.premultiplyAlpha), i.pixelStorei(3317, A.unpackAlignment), i.pixelStorei(37443, 0);
            const O = w(A) && v(A.image) === !1;
            let V = y(A.image, O, !1, h);
            V = ve(A, V);
            const Et = v(V) || a, It = r.convert(A.format, A.encoding);
            let Mt = r.convert(A.type), Ft = b(A.internalFormat, It, Mt, A.encoding, A.isVideoTexture);
            Y(ht, A, Et);
            let Ot;
            const oe = A.mipmaps, ce = a && A.isVideoTexture !== !0, Ue = Wt.__version === void 0 || dt === !0,
                U = M(A, V, Et);
            if (A.isDepthTexture) Ft = 6402, a ? A.type === ir ? Ft = 36012 : A.type === Lr ? Ft = 33190 : A.type === Ro ? Ft = 35056 : Ft = 33189 : A.type === ir && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), A.format === Dr && Ft === 6402 && A.type !== Km && A.type !== Lr && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), A.type = Lr, Mt = r.convert(A.type)), A.format === Bo && Ft === 6402 && (Ft = 34041, A.type !== Ro && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), A.type = Ro, Mt = r.convert(A.type))), Ue && (ce ? e.texStorage2D(3553, 1, Ft, V.width, V.height) : e.texImage2D(3553, 0, Ft, V.width, V.height, 0, It, Mt, null)); else if (A.isDataTexture) if (oe.length > 0 && Et) {
                ce && Ue && e.texStorage2D(3553, U, Ft, oe[0].width, oe[0].height);
                for (let K = 0, ut = oe.length; K < ut; K++) Ot = oe[K], ce ? e.texSubImage2D(3553, K, 0, 0, Ot.width, Ot.height, It, Mt, Ot.data) : e.texImage2D(3553, K, Ft, Ot.width, Ot.height, 0, It, Mt, Ot.data);
                A.generateMipmaps = !1
            } else ce ? (Ue && e.texStorage2D(3553, U, Ft, V.width, V.height), e.texSubImage2D(3553, 0, 0, 0, V.width, V.height, It, Mt, V.data)) : e.texImage2D(3553, 0, Ft, V.width, V.height, 0, It, Mt, V.data); else if (A.isCompressedTexture) if (A.isCompressedArrayTexture) {
                ce && Ue && e.texStorage3D(35866, U, Ft, oe[0].width, oe[0].height, V.depth);
                for (let K = 0, ut = oe.length; K < ut; K++) Ot = oe[K], A.format !== Os ? It !== null ? ce ? e.compressedTexSubImage3D(35866, K, 0, 0, 0, Ot.width, Ot.height, V.depth, It, Ot.data, 0, 0) : e.compressedTexImage3D(35866, K, Ft, Ot.width, Ot.height, V.depth, 0, Ot.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ce ? e.texSubImage3D(35866, K, 0, 0, 0, Ot.width, Ot.height, V.depth, It, Mt, Ot.data) : e.texImage3D(35866, K, Ft, Ot.width, Ot.height, V.depth, 0, It, Mt, Ot.data)
            } else {
                ce && Ue && e.texStorage2D(3553, U, Ft, oe[0].width, oe[0].height);
                for (let K = 0, ut = oe.length; K < ut; K++) Ot = oe[K], A.format !== Os ? It !== null ? ce ? e.compressedTexSubImage2D(3553, K, 0, 0, Ot.width, Ot.height, It, Ot.data) : e.compressedTexImage2D(3553, K, Ft, Ot.width, Ot.height, 0, Ot.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ce ? e.texSubImage2D(3553, K, 0, 0, Ot.width, Ot.height, It, Mt, Ot.data) : e.texImage2D(3553, K, Ft, Ot.width, Ot.height, 0, It, Mt, Ot.data)
            } else if (A.isDataArrayTexture) ce ? (Ue && e.texStorage3D(35866, U, Ft, V.width, V.height, V.depth), e.texSubImage3D(35866, 0, 0, 0, 0, V.width, V.height, V.depth, It, Mt, V.data)) : e.texImage3D(35866, 0, Ft, V.width, V.height, V.depth, 0, It, Mt, V.data); else if (A.isData3DTexture) ce ? (Ue && e.texStorage3D(32879, U, Ft, V.width, V.height, V.depth), e.texSubImage3D(32879, 0, 0, 0, 0, V.width, V.height, V.depth, It, Mt, V.data)) : e.texImage3D(32879, 0, Ft, V.width, V.height, V.depth, 0, It, Mt, V.data); else if (A.isFramebufferTexture) {
                if (Ue) if (ce) e.texStorage2D(3553, U, Ft, V.width, V.height); else {
                    let K = V.width, ut = V.height;
                    for (let Tt = 0; Tt < U; Tt++) e.texImage2D(3553, Tt, Ft, K, ut, 0, It, Mt, null), K >>= 1, ut >>= 1
                }
            } else if (oe.length > 0 && Et) {
                ce && Ue && e.texStorage2D(3553, U, Ft, oe[0].width, oe[0].height);
                for (let K = 0, ut = oe.length; K < ut; K++) Ot = oe[K], ce ? e.texSubImage2D(3553, K, 0, 0, It, Mt, Ot) : e.texImage2D(3553, K, Ft, It, Mt, Ot);
                A.generateMipmaps = !1
            } else ce ? (Ue && e.texStorage2D(3553, U, Ft, V.width, V.height), e.texSubImage2D(3553, 0, 0, 0, It, Mt, V)) : e.texImage2D(3553, 0, Ft, It, Mt, V);
            E(A, Et) && S(ht), Wt.__version = bt.version, A.onUpdate && A.onUpdate(A)
        }
        R.__version = A.version
    }

    function Nt(R, A, X) {
        if (A.image.length !== 6) return;
        const ht = Ut(R, A), dt = A.source;
        e.bindTexture(34067, R.__webglTexture, 33984 + X);
        const bt = n.get(dt);
        if (dt.version !== bt.__version || ht === !0) {
            e.activeTexture(33984 + X), i.pixelStorei(37440, A.flipY), i.pixelStorei(37441, A.premultiplyAlpha), i.pixelStorei(3317, A.unpackAlignment), i.pixelStorei(37443, 0);
            const Wt = A.isCompressedTexture || A.image[0].isCompressedTexture,
                O = A.image[0] && A.image[0].isDataTexture, V = [];
            for (let K = 0; K < 6; K++) !Wt && !O ? V[K] = y(A.image[K], !1, !0, c) : V[K] = O ? A.image[K].image : A.image[K], V[K] = ve(A, V[K]);
            const Et = V[0], It = v(Et) || a, Mt = r.convert(A.format, A.encoding), Ft = r.convert(A.type),
                Ot = b(A.internalFormat, Mt, Ft, A.encoding), oe = a && A.isVideoTexture !== !0,
                ce = bt.__version === void 0 || ht === !0;
            let Ue = M(A, Et, It);
            Y(34067, A, It);
            let U;
            if (Wt) {
                oe && ce && e.texStorage2D(34067, Ue, Ot, Et.width, Et.height);
                for (let K = 0; K < 6; K++) {
                    U = V[K].mipmaps;
                    for (let ut = 0; ut < U.length; ut++) {
                        const Tt = U[ut];
                        A.format !== Os ? Mt !== null ? oe ? e.compressedTexSubImage2D(34069 + K, ut, 0, 0, Tt.width, Tt.height, Mt, Tt.data) : e.compressedTexImage2D(34069 + K, ut, Ot, Tt.width, Tt.height, 0, Tt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : oe ? e.texSubImage2D(34069 + K, ut, 0, 0, Tt.width, Tt.height, Mt, Ft, Tt.data) : e.texImage2D(34069 + K, ut, Ot, Tt.width, Tt.height, 0, Mt, Ft, Tt.data)
                    }
                }
            } else {
                U = A.mipmaps, oe && ce && (U.length > 0 && Ue++, e.texStorage2D(34067, Ue, Ot, V[0].width, V[0].height));
                for (let K = 0; K < 6; K++) if (O) {
                    oe ? e.texSubImage2D(34069 + K, 0, 0, 0, V[K].width, V[K].height, Mt, Ft, V[K].data) : e.texImage2D(34069 + K, 0, Ot, V[K].width, V[K].height, 0, Mt, Ft, V[K].data);
                    for (let ut = 0; ut < U.length; ut++) {
                        const zt = U[ut].image[K].image;
                        oe ? e.texSubImage2D(34069 + K, ut + 1, 0, 0, zt.width, zt.height, Mt, Ft, zt.data) : e.texImage2D(34069 + K, ut + 1, Ot, zt.width, zt.height, 0, Mt, Ft, zt.data)
                    }
                } else {
                    oe ? e.texSubImage2D(34069 + K, 0, 0, 0, Mt, Ft, V[K]) : e.texImage2D(34069 + K, 0, Ot, Mt, Ft, V[K]);
                    for (let ut = 0; ut < U.length; ut++) {
                        const Tt = U[ut];
                        oe ? e.texSubImage2D(34069 + K, ut + 1, 0, 0, Mt, Ft, Tt.image[K]) : e.texImage2D(34069 + K, ut + 1, Ot, Mt, Ft, Tt.image[K])
                    }
                }
            }
            E(A, It) && S(34067), bt.__version = dt.version, A.onUpdate && A.onUpdate(A)
        }
        R.__version = A.version
    }

    function vt(R, A, X, ht, dt) {
        const bt = r.convert(X.format, X.encoding), Wt = r.convert(X.type), O = b(X.internalFormat, bt, Wt, X.encoding);
        n.get(A).__hasExternalTextures || (dt === 32879 || dt === 35866 ? e.texImage3D(dt, 0, O, A.width, A.height, A.depth, 0, bt, Wt, null) : e.texImage2D(dt, 0, O, A.width, A.height, 0, bt, Wt, null)), e.bindFramebuffer(36160, R), Gt(A) ? d.framebufferTexture2DMultisampleEXT(36160, ht, dt, n.get(X).__webglTexture, 0, Vt(A)) : (dt === 3553 || dt >= 34069 && dt <= 34074) && i.framebufferTexture2D(36160, ht, dt, n.get(X).__webglTexture, 0), e.bindFramebuffer(36160, null)
    }

    function ee(R, A, X) {
        if (i.bindRenderbuffer(36161, R), A.depthBuffer && !A.stencilBuffer) {
            let ht = 33189;
            if (X || Gt(A)) {
                const dt = A.depthTexture;
                dt && dt.isDepthTexture && (dt.type === ir ? ht = 36012 : dt.type === Lr && (ht = 33190));
                const bt = Vt(A);
                Gt(A) ? d.renderbufferStorageMultisampleEXT(36161, bt, ht, A.width, A.height) : i.renderbufferStorageMultisample(36161, bt, ht, A.width, A.height)
            } else i.renderbufferStorage(36161, ht, A.width, A.height);
            i.framebufferRenderbuffer(36160, 36096, 36161, R)
        } else if (A.depthBuffer && A.stencilBuffer) {
            const ht = Vt(A);
            X && Gt(A) === !1 ? i.renderbufferStorageMultisample(36161, ht, 35056, A.width, A.height) : Gt(A) ? d.renderbufferStorageMultisampleEXT(36161, ht, 35056, A.width, A.height) : i.renderbufferStorage(36161, 34041, A.width, A.height), i.framebufferRenderbuffer(36160, 33306, 36161, R)
        } else {
            const ht = A.isWebGLMultipleRenderTargets === !0 ? A.texture : [A.texture];
            for (let dt = 0; dt < ht.length; dt++) {
                const bt = ht[dt], Wt = r.convert(bt.format, bt.encoding), O = r.convert(bt.type),
                    V = b(bt.internalFormat, Wt, O, bt.encoding), Et = Vt(A);
                X && Gt(A) === !1 ? i.renderbufferStorageMultisample(36161, Et, V, A.width, A.height) : Gt(A) ? d.renderbufferStorageMultisampleEXT(36161, Et, V, A.width, A.height) : i.renderbufferStorage(36161, V, A.width, A.height)
            }
        }
        i.bindRenderbuffer(36161, null)
    }

    function nt(R, A) {
        if (A && A.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (e.bindFramebuffer(36160, R), !(A.depthTexture && A.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!n.get(A.depthTexture).__webglTexture || A.depthTexture.image.width !== A.width || A.depthTexture.image.height !== A.height) && (A.depthTexture.image.width = A.width, A.depthTexture.image.height = A.height, A.depthTexture.needsUpdate = !0), lt(A.depthTexture, 0);
        const ht = n.get(A.depthTexture).__webglTexture, dt = Vt(A);
        if (A.depthTexture.format === Dr) Gt(A) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ht, 0, dt) : i.framebufferTexture2D(36160, 36096, 3553, ht, 0); else if (A.depthTexture.format === Bo) Gt(A) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ht, 0, dt) : i.framebufferTexture2D(36160, 33306, 3553, ht, 0); else throw new Error("Unknown depthTexture format")
    }

    function et(R) {
        const A = n.get(R), X = R.isWebGLCubeRenderTarget === !0;
        if (R.depthTexture && !A.__autoAllocateDepthBuffer) {
            if (X) throw new Error("target.depthTexture not supported in Cube render targets");
            nt(A.__webglFramebuffer, R)
        } else if (X) {
            A.__webglDepthbuffer = [];
            for (let ht = 0; ht < 6; ht++) e.bindFramebuffer(36160, A.__webglFramebuffer[ht]), A.__webglDepthbuffer[ht] = i.createRenderbuffer(), ee(A.__webglDepthbuffer[ht], R, !1)
        } else e.bindFramebuffer(36160, A.__webglFramebuffer), A.__webglDepthbuffer = i.createRenderbuffer(), ee(A.__webglDepthbuffer, R, !1);
        e.bindFramebuffer(36160, null)
    }

    function ft(R, A, X) {
        const ht = n.get(R);
        A !== void 0 && vt(ht.__webglFramebuffer, R, R.texture, 36064, 3553), X !== void 0 && et(R)
    }

    function Pt(R) {
        const A = R.texture, X = n.get(R), ht = n.get(A);
        R.addEventListener("dispose", B), R.isWebGLMultipleRenderTargets !== !0 && (ht.__webglTexture === void 0 && (ht.__webglTexture = i.createTexture()), ht.__version = A.version, o.memory.textures++);
        const dt = R.isWebGLCubeRenderTarget === !0, bt = R.isWebGLMultipleRenderTargets === !0, Wt = v(R) || a;
        if (dt) {
            X.__webglFramebuffer = [];
            for (let O = 0; O < 6; O++) X.__webglFramebuffer[O] = i.createFramebuffer()
        } else {
            if (X.__webglFramebuffer = i.createFramebuffer(), bt) if (s.drawBuffers) {
                const O = R.texture;
                for (let V = 0, Et = O.length; V < Et; V++) {
                    const It = n.get(O[V]);
                    It.__webglTexture === void 0 && (It.__webglTexture = i.createTexture(), o.memory.textures++)
                }
            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && R.samples > 0 && Gt(R) === !1) {
                const O = bt ? A : [A];
                X.__webglMultisampledFramebuffer = i.createFramebuffer(), X.__webglColorRenderbuffer = [], e.bindFramebuffer(36160, X.__webglMultisampledFramebuffer);
                for (let V = 0; V < O.length; V++) {
                    const Et = O[V];
                    X.__webglColorRenderbuffer[V] = i.createRenderbuffer(), i.bindRenderbuffer(36161, X.__webglColorRenderbuffer[V]);
                    const It = r.convert(Et.format, Et.encoding), Mt = r.convert(Et.type),
                        Ft = b(Et.internalFormat, It, Mt, Et.encoding, R.isXRRenderTarget === !0), Ot = Vt(R);
                    i.renderbufferStorageMultisample(36161, Ot, Ft, R.width, R.height), i.framebufferRenderbuffer(36160, 36064 + V, 36161, X.__webglColorRenderbuffer[V])
                }
                i.bindRenderbuffer(36161, null), R.depthBuffer && (X.__webglDepthRenderbuffer = i.createRenderbuffer(), ee(X.__webglDepthRenderbuffer, R, !0)), e.bindFramebuffer(36160, null)
            }
        }
        if (dt) {
            e.bindTexture(34067, ht.__webglTexture), Y(34067, A, Wt);
            for (let O = 0; O < 6; O++) vt(X.__webglFramebuffer[O], R, A, 36064, 34069 + O);
            E(A, Wt) && S(34067), e.unbindTexture()
        } else if (bt) {
            const O = R.texture;
            for (let V = 0, Et = O.length; V < Et; V++) {
                const It = O[V], Mt = n.get(It);
                e.bindTexture(3553, Mt.__webglTexture), Y(3553, It, Wt), vt(X.__webglFramebuffer, R, It, 36064 + V, 3553), E(It, Wt) && S(3553)
            }
            e.unbindTexture()
        } else {
            let O = 3553;
            (R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) && (a ? O = R.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), e.bindTexture(O, ht.__webglTexture), Y(O, A, Wt), vt(X.__webglFramebuffer, R, A, 36064, O), E(A, Wt) && S(O), e.unbindTexture()
        }
        R.depthBuffer && et(R)
    }

    function _t(R) {
        const A = v(R) || a, X = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture];
        for (let ht = 0, dt = X.length; ht < dt; ht++) {
            const bt = X[ht];
            if (E(bt, A)) {
                const Wt = R.isWebGLCubeRenderTarget ? 34067 : 3553, O = n.get(bt).__webglTexture;
                e.bindTexture(Wt, O), S(Wt), e.unbindTexture()
            }
        }
    }

    function qt(R) {
        if (a && R.samples > 0 && Gt(R) === !1) {
            const A = R.isWebGLMultipleRenderTargets ? R.texture : [R.texture], X = R.width, ht = R.height;
            let dt = 16384;
            const bt = [], Wt = R.stencilBuffer ? 33306 : 36096, O = n.get(R),
                V = R.isWebGLMultipleRenderTargets === !0;
            if (V) for (let Et = 0; Et < A.length; Et++) e.bindFramebuffer(36160, O.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Et, 36161, null), e.bindFramebuffer(36160, O.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Et, 3553, null, 0);
            e.bindFramebuffer(36008, O.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, O.__webglFramebuffer);
            for (let Et = 0; Et < A.length; Et++) {
                bt.push(36064 + Et), R.depthBuffer && bt.push(Wt);
                const It = O.__ignoreDepthValues !== void 0 ? O.__ignoreDepthValues : !1;
                if (It === !1 && (R.depthBuffer && (dt |= 256), R.stencilBuffer && (dt |= 1024)), V && i.framebufferRenderbuffer(36008, 36064, 36161, O.__webglColorRenderbuffer[Et]), It === !0 && (i.invalidateFramebuffer(36008, [Wt]), i.invalidateFramebuffer(36009, [Wt])), V) {
                    const Mt = n.get(A[Et]).__webglTexture;
                    i.framebufferTexture2D(36009, 36064, 3553, Mt, 0)
                }
                i.blitFramebuffer(0, 0, X, ht, 0, 0, X, ht, dt, 9728), f && i.invalidateFramebuffer(36008, bt)
            }
            if (e.bindFramebuffer(36008, null), e.bindFramebuffer(36009, null), V) for (let Et = 0; Et < A.length; Et++) {
                e.bindFramebuffer(36160, O.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Et, 36161, O.__webglColorRenderbuffer[Et]);
                const It = n.get(A[Et]).__webglTexture;
                e.bindFramebuffer(36160, O.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Et, 3553, It, 0)
            }
            e.bindFramebuffer(36009, O.__webglMultisampledFramebuffer)
        }
    }

    function Vt(R) {
        return Math.min(u, R.samples)
    }

    function Gt(R) {
        const A = n.get(R);
        return a && R.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && A.__useRenderToTexture !== !1
    }

    function ke(R) {
        const A = o.render.frame;
        g.get(R) !== A && (g.set(R, A), R.update())
    }

    function ve(R, A) {
        const X = R.encoding, ht = R.format, dt = R.type;
        return R.isCompressedTexture === !0 || R.isVideoTexture === !0 || R.format === ad || X !== Vr && (X === Ee ? a === !1 ? t.has("EXT_sRGB") === !0 && ht === Os ? (R.format = ad, R.minFilter = Qe, R.generateMipmaps = !1) : A = e0.sRGBToLinear(A) : (ht !== Os || dt !== Gr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", X)), A
    }

    this.allocateTextureUnit = q, this.resetTextureUnits = Q, this.setTexture2D = lt, this.setTexture2DArray = wt, this.setTexture3D = W, this.setTextureCube = st, this.rebindTextures = ft, this.setupRenderTarget = Pt, this.updateRenderTargetMipmap = _t, this.updateMultisampleRenderTarget = qt, this.setupDepthRenderbuffer = et, this.setupFrameBufferTexture = vt, this.useMultisampledRTT = Gt
}

function Zb(i, t, e) {
    const n = e.isWebGL2;

    function s(r, o = null) {
        let a;
        if (r === Gr) return 5121;
        if (r === gb) return 32819;
        if (r === mb) return 32820;
        if (r === db) return 5120;
        if (r === fb) return 5122;
        if (r === Km) return 5123;
        if (r === pb) return 5124;
        if (r === Lr) return 5125;
        if (r === ir) return 5126;
        if (r === nl) return n ? 5131 : (a = t.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
        if (r === _b) return 6406;
        if (r === Os) return 6408;
        if (r === yb) return 6409;
        if (r === xb) return 6410;
        if (r === Dr) return 6402;
        if (r === Bo) return 34041;
        if (r === ad) return a = t.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
        if (r === vb) return 6403;
        if (r === wb) return 36244;
        if (r === bb) return 33319;
        if (r === Eb) return 33320;
        if (r === Sb) return 36249;
        if (r === qu || r === Yu || r === Xu || r === Zu) if (o === Ee) if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
            if (r === qu) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (r === Yu) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (r === Xu) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (r === Zu) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else return null; else if (a = t.get("WEBGL_compressed_texture_s3tc"), a !== null) {
            if (r === qu) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (r === Yu) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (r === Xu) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (r === Zu) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else return null;
        if (r === Wg || r === qg || r === Yg || r === Xg) if (a = t.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
            if (r === Wg) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (r === qg) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (r === Yg) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (r === Xg) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        } else return null;
        if (r === Mb) return a = t.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (r === Zg || r === jg) if (a = t.get("WEBGL_compressed_texture_etc"), a !== null) {
            if (r === Zg) return o === Ee ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
            if (r === jg) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
        } else return null;
        if (r === Kg || r === Jg || r === Qg || r === tm || r === em || r === nm || r === sm || r === im || r === rm || r === om || r === am || r === lm || r === cm || r === hm) if (a = t.get("WEBGL_compressed_texture_astc"), a !== null) {
            if (r === Kg) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (r === Jg) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (r === Qg) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (r === tm) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (r === em) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (r === nm) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (r === sm) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (r === im) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (r === rm) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (r === om) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (r === am) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (r === lm) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (r === cm) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (r === hm) return o === Ee ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
        } else return null;
        if (r === ju) if (a = t.get("EXT_texture_compression_bptc"), a !== null) {
            if (r === ju) return o === Ee ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
        } else return null;
        if (r === Tb || r === um || r === dm || r === fm) if (a = t.get("EXT_texture_compression_rgtc"), a !== null) {
            if (r === ju) return a.COMPRESSED_RED_RGTC1_EXT;
            if (r === um) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (r === dm) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (r === fm) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
        } else return null;
        return r === Ro ? n ? 34042 : (a = t.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : i[r] !== void 0 ? i[r] : null
    }

    return {convert: s}
}

class jb extends bn {
    constructor(t = []) {
        super(), this.isArrayCamera = !0, this.cameras = t
    }
}

let or = class extends re {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
};
const SR = {type: "move"};

class zp {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }

    getHandSpace() {
        return this._hand === null && (this._hand = new or, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {pinching: !1}), this._hand
    }

    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new or, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new C, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new C), this._targetRay
    }

    getGripSpace() {
        return this._grip === null && (this._grip = new or, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new C, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new C), this._grip
    }

    dispatchEvent(t) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this
    }

    connect(t) {
        if (t && t.hand) {
            const e = this._hand;
            if (e) for (const n of t.hand.values()) this._getHandJoint(e, n)
        }
        return this.dispatchEvent({type: "connected", data: t}), this
    }

    disconnect(t) {
        return this.dispatchEvent({
            type: "disconnected",
            data: t
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }

    update(t, e, n) {
        let s = null, r = null, o = null;
        const a = this._targetRay, l = this._grip, c = this._hand;
        if (t && e.session.visibilityState !== "visible-blurred") {
            if (c && t.hand) {
                o = !0;
                for (const m of t.hand.values()) {
                    const p = e.getJointPose(m, n), _ = this._getHandJoint(c, m);
                    p !== null && (_.matrix.fromArray(p.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.jointRadius = p.radius), _.visible = p !== null
                }
                const h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"],
                    d = h.position.distanceTo(u.position), f = .02, g = .005;
                c.inputState.pinching && d > f + g ? (c.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this
                })) : !c.inputState.pinching && d <= f - g && (c.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this
                }))
            } else l !== null && t.gripSpace && (r = e.getPose(t.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (s = e.getPose(t.targetRaySpace, n), s === null && r !== null && (s = r), s !== null && (a.matrix.fromArray(s.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), s.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(s.linearVelocity)) : a.hasLinearVelocity = !1, s.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(s.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(SR)))
        }
        return a !== null && (a.visible = s !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this
    }

    _getHandJoint(t, e) {
        if (t.joints[e.jointName] === void 0) {
            const n = new or;
            n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
        }
        return t.joints[e.jointName]
    }
}

class Kb extends Sn {
    constructor(t, e, n, s, r, o, a, l, c, h) {
        if (h = h !== void 0 ? h : Dr, h !== Dr && h !== Bo) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        n === void 0 && h === Dr && (n = Lr), n === void 0 && h === Bo && (n = Ro), super(null, s, r, o, a, l, h, n, c), this.isDepthTexture = !0, this.image = {
            width: t,
            height: e
        }, this.magFilter = a !== void 0 ? a : sn, this.minFilter = l !== void 0 ? l : sn, this.flipY = !1, this.generateMipmaps = !1
    }
}

class MR extends Gi {
    constructor(t, e) {
        super();
        const n = this;
        let s = null, r = 1, o = null, a = "local-floor", l = 1, c = null, h = null, u = null, d = null, f = null,
            g = null;
        const m = e.getContextAttributes();
        let p = null, _ = null;
        const x = [], y = [], v = new Set, w = new Map, E = new bn;
        E.layers.enable(1), E.viewport = new Fe;
        const S = new bn;
        S.layers.enable(2), S.viewport = new Fe;
        const b = [E, S], M = new jb;
        M.layers.enable(1), M.layers.enable(2);
        let I = null, N = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (W) {
            let st = x[W];
            return st === void 0 && (st = new zp, x[W] = st), st.getTargetRaySpace()
        }, this.getControllerGrip = function (W) {
            let st = x[W];
            return st === void 0 && (st = new zp, x[W] = st), st.getGripSpace()
        }, this.getHand = function (W) {
            let st = x[W];
            return st === void 0 && (st = new zp, x[W] = st), st.getHandSpace()
        };

        function B(W) {
            const st = y.indexOf(W.inputSource);
            if (st === -1) return;
            const gt = x[st];
            gt !== void 0 && gt.dispatchEvent({type: W.type, data: W.inputSource})
        }

        function D() {
            s.removeEventListener("select", B), s.removeEventListener("selectstart", B), s.removeEventListener("selectend", B), s.removeEventListener("squeeze", B), s.removeEventListener("squeezestart", B), s.removeEventListener("squeezeend", B), s.removeEventListener("end", D), s.removeEventListener("inputsourceschange", L);
            for (let W = 0; W < x.length; W++) {
                const st = y[W];
                st !== null && (y[W] = null, x[W].disconnect(st))
            }
            I = null, N = null, t.setRenderTarget(p), f = null, d = null, u = null, s = null, _ = null, wt.stop(), n.isPresenting = !1, n.dispatchEvent({type: "sessionend"})
        }

        this.setFramebufferScaleFactor = function (W) {
            r = W, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function (W) {
            a = W, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function () {
            return c || o
        }, this.setReferenceSpace = function (W) {
            c = W
        }, this.getBaseLayer = function () {
            return d !== null ? d : f
        }, this.getBinding = function () {
            return u
        }, this.getFrame = function () {
            return g
        }, this.getSession = function () {
            return s
        }, this.setSession = async function (W) {
            if (s = W, s !== null) {
                if (p = t.getRenderTarget(), s.addEventListener("select", B), s.addEventListener("selectstart", B), s.addEventListener("selectend", B), s.addEventListener("squeeze", B), s.addEventListener("squeezestart", B), s.addEventListener("squeezeend", B), s.addEventListener("end", D), s.addEventListener("inputsourceschange", L), m.xrCompatible !== !0 && await e.makeXRCompatible(), s.renderState.layers === void 0 || t.capabilities.isWebGL2 === !1) {
                    const st = {
                        antialias: s.renderState.layers === void 0 ? m.antialias : !0,
                        alpha: m.alpha,
                        depth: m.depth,
                        stencil: m.stencil,
                        framebufferScaleFactor: r
                    };
                    f = new XRWebGLLayer(s, e, st), s.updateRenderState({baseLayer: f}), _ = new fs(f.framebufferWidth, f.framebufferHeight, {
                        format: Os,
                        type: Gr,
                        encoding: t.outputEncoding,
                        stencilBuffer: m.stencil
                    })
                } else {
                    let st = null, gt = null, mt = null;
                    m.depth && (mt = m.stencil ? 35056 : 33190, st = m.stencil ? Bo : Dr, gt = m.stencil ? Ro : Lr);
                    const Y = {colorFormat: 32856, depthFormat: mt, scaleFactor: r};
                    u = new XRWebGLBinding(s, e), d = u.createProjectionLayer(Y), s.updateRenderState({layers: [d]}), _ = new fs(d.textureWidth, d.textureHeight, {
                        format: Os,
                        type: Gr,
                        depthTexture: new Kb(d.textureWidth, d.textureHeight, gt, void 0, void 0, void 0, void 0, void 0, void 0, st),
                        stencilBuffer: m.stencil,
                        encoding: t.outputEncoding,
                        samples: m.antialias ? 4 : 0
                    });
                    const Ut = t.properties.get(_);
                    Ut.__ignoreDepthValues = d.ignoreDepthValues
                }
                _.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await s.requestReferenceSpace(a), wt.setContext(s), wt.start(), n.isPresenting = !0, n.dispatchEvent({type: "sessionstart"})
            }
        };

        function L(W) {
            for (let st = 0; st < W.removed.length; st++) {
                const gt = W.removed[st], mt = y.indexOf(gt);
                mt >= 0 && (y[mt] = null, x[mt].disconnect(gt))
            }
            for (let st = 0; st < W.added.length; st++) {
                const gt = W.added[st];
                let mt = y.indexOf(gt);
                if (mt === -1) {
                    for (let Ut = 0; Ut < x.length; Ut++) if (Ut >= y.length) {
                        y.push(gt), mt = Ut;
                        break
                    } else if (y[Ut] === null) {
                        y[Ut] = gt, mt = Ut;
                        break
                    }
                    if (mt === -1) break
                }
                const Y = x[mt];
                Y && Y.connect(gt)
            }
        }

        const k = new C, G = new C;

        function Q(W, st, gt) {
            k.setFromMatrixPosition(st.matrixWorld), G.setFromMatrixPosition(gt.matrixWorld);
            const mt = k.distanceTo(G), Y = st.projectionMatrix.elements, Ut = gt.projectionMatrix.elements,
                Rt = Y[14] / (Y[10] - 1), Nt = Y[14] / (Y[10] + 1), vt = (Y[9] + 1) / Y[5], ee = (Y[9] - 1) / Y[5],
                nt = (Y[8] - 1) / Y[0], et = (Ut[8] + 1) / Ut[0], ft = Rt * nt, Pt = Rt * et, _t = mt / (-nt + et),
                qt = _t * -nt;
            st.matrixWorld.decompose(W.position, W.quaternion, W.scale), W.translateX(qt), W.translateZ(_t), W.matrixWorld.compose(W.position, W.quaternion, W.scale), W.matrixWorldInverse.copy(W.matrixWorld).invert();
            const Vt = Rt + _t, Gt = Nt + _t, ke = ft - qt, ve = Pt + (mt - qt), R = vt * Nt / Gt * Vt,
                A = ee * Nt / Gt * Vt;
            W.projectionMatrix.makePerspective(ke, ve, R, A, Vt, Gt)
        }

        function q(W, st) {
            st === null ? W.matrixWorld.copy(W.matrix) : W.matrixWorld.multiplyMatrices(st.matrixWorld, W.matrix), W.matrixWorldInverse.copy(W.matrixWorld).invert()
        }

        this.updateCamera = function (W) {
            if (s === null) return;
            M.near = S.near = E.near = W.near, M.far = S.far = E.far = W.far, (I !== M.near || N !== M.far) && (s.updateRenderState({
                depthNear: M.near,
                depthFar: M.far
            }), I = M.near, N = M.far);
            const st = W.parent, gt = M.cameras;
            q(M, st);
            for (let Y = 0; Y < gt.length; Y++) q(gt[Y], st);
            M.matrixWorld.decompose(M.position, M.quaternion, M.scale), W.matrix.copy(M.matrix), W.matrix.decompose(W.position, W.quaternion, W.scale);
            const mt = W.children;
            for (let Y = 0, Ut = mt.length; Y < Ut; Y++) mt[Y].updateMatrixWorld(!0);
            gt.length === 2 ? Q(M, E, S) : M.projectionMatrix.copy(E.projectionMatrix)
        }, this.getCamera = function () {
            return M
        }, this.getFoveation = function () {
            if (!(d === null && f === null)) return l
        }, this.setFoveation = function (W) {
            l = W, d !== null && (d.fixedFoveation = W), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = W)
        }, this.getPlanes = function () {
            return v
        };
        let at = null;

        function lt(W, st) {
            if (h = st.getViewerPose(c || o), g = st, h !== null) {
                const gt = h.views;
                f !== null && (t.setRenderTargetFramebuffer(_, f.framebuffer), t.setRenderTarget(_));
                let mt = !1;
                gt.length !== M.cameras.length && (M.cameras.length = 0, mt = !0);
                for (let Y = 0; Y < gt.length; Y++) {
                    const Ut = gt[Y];
                    let Rt = null;
                    if (f !== null) Rt = f.getViewport(Ut); else {
                        const vt = u.getViewSubImage(d, Ut);
                        Rt = vt.viewport, Y === 0 && (t.setRenderTargetTextures(_, vt.colorTexture, d.ignoreDepthValues ? void 0 : vt.depthStencilTexture), t.setRenderTarget(_))
                    }
                    let Nt = b[Y];
                    Nt === void 0 && (Nt = new bn, Nt.layers.enable(Y), Nt.viewport = new Fe, b[Y] = Nt), Nt.matrix.fromArray(Ut.transform.matrix), Nt.projectionMatrix.fromArray(Ut.projectionMatrix), Nt.viewport.set(Rt.x, Rt.y, Rt.width, Rt.height), Y === 0 && M.matrix.copy(Nt.matrix), mt === !0 && M.cameras.push(Nt)
                }
            }
            for (let gt = 0; gt < x.length; gt++) {
                const mt = y[gt], Y = x[gt];
                mt !== null && Y !== void 0 && Y.update(mt, st, c || o)
            }
            if (at && at(W, st), st.detectedPlanes) {
                n.dispatchEvent({type: "planesdetected", data: st.detectedPlanes});
                let gt = null;
                for (const mt of v) st.detectedPlanes.has(mt) || (gt === null && (gt = []), gt.push(mt));
                if (gt !== null) for (const mt of gt) v.delete(mt), w.delete(mt), n.dispatchEvent({
                    type: "planeremoved",
                    data: mt
                });
                for (const mt of st.detectedPlanes) if (!v.has(mt)) v.add(mt), w.set(mt, st.lastChangedTime), n.dispatchEvent({
                    type: "planeadded",
                    data: mt
                }); else {
                    const Y = w.get(mt);
                    mt.lastChangedTime > Y && (w.set(mt, mt.lastChangedTime), n.dispatchEvent({
                        type: "planechanged",
                        data: mt
                    }))
                }
            }
            g = null
        }

        const wt = new $b;
        wt.setAnimationLoop(lt), this.setAnimationLoop = function (W) {
            at = W
        }, this.dispose = function () {
        }
    }
}

function TR(i, t) {
    function e(m, p) {
        p.color.getRGB(m.fogColor.value, Gb(i)), p.isFog ? (m.fogNear.value = p.near, m.fogFar.value = p.far) : p.isFogExp2 && (m.fogDensity.value = p.density)
    }

    function n(m, p, _, x, y) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(m, p) : p.isMeshToonMaterial ? (s(m, p), h(m, p)) : p.isMeshPhongMaterial ? (s(m, p), c(m, p)) : p.isMeshStandardMaterial ? (s(m, p), u(m, p), p.isMeshPhysicalMaterial && d(m, p, y)) : p.isMeshMatcapMaterial ? (s(m, p), f(m, p)) : p.isMeshDepthMaterial ? s(m, p) : p.isMeshDistanceMaterial ? (s(m, p), g(m, p)) : p.isMeshNormalMaterial ? s(m, p) : p.isLineBasicMaterial ? (r(m, p), p.isLineDashedMaterial && o(m, p)) : p.isPointsMaterial ? a(m, p, _, x) : p.isSpriteMaterial ? l(m, p) : p.isShadowMaterial ? (m.color.value.copy(p.color), m.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }

    function s(m, p) {
        m.opacity.value = p.opacity, p.color && m.diffuse.value.copy(p.color), p.emissive && m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (m.map.value = p.map), p.alphaMap && (m.alphaMap.value = p.alphaMap), p.bumpMap && (m.bumpMap.value = p.bumpMap, m.bumpScale.value = p.bumpScale, p.side === xs && (m.bumpScale.value *= -1)), p.displacementMap && (m.displacementMap.value = p.displacementMap, m.displacementScale.value = p.displacementScale, m.displacementBias.value = p.displacementBias), p.emissiveMap && (m.emissiveMap.value = p.emissiveMap), p.normalMap && (m.normalMap.value = p.normalMap, m.normalScale.value.copy(p.normalScale), p.side === xs && m.normalScale.value.negate()), p.specularMap && (m.specularMap.value = p.specularMap), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        const _ = t.get(p).envMap;
        if (_ && (m.envMap.value = _, m.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = p.reflectivity, m.ior.value = p.ior, m.refractionRatio.value = p.refractionRatio), p.lightMap) {
            m.lightMap.value = p.lightMap;
            const v = i.physicallyCorrectLights !== !0 ? Math.PI : 1;
            m.lightMapIntensity.value = p.lightMapIntensity * v
        }
        p.aoMap && (m.aoMap.value = p.aoMap, m.aoMapIntensity.value = p.aoMapIntensity);
        let x;
        p.map ? x = p.map : p.specularMap ? x = p.specularMap : p.displacementMap ? x = p.displacementMap : p.normalMap ? x = p.normalMap : p.bumpMap ? x = p.bumpMap : p.roughnessMap ? x = p.roughnessMap : p.metalnessMap ? x = p.metalnessMap : p.alphaMap ? x = p.alphaMap : p.emissiveMap ? x = p.emissiveMap : p.clearcoatMap ? x = p.clearcoatMap : p.clearcoatNormalMap ? x = p.clearcoatNormalMap : p.clearcoatRoughnessMap ? x = p.clearcoatRoughnessMap : p.iridescenceMap ? x = p.iridescenceMap : p.iridescenceThicknessMap ? x = p.iridescenceThicknessMap : p.specularIntensityMap ? x = p.specularIntensityMap : p.specularColorMap ? x = p.specularColorMap : p.transmissionMap ? x = p.transmissionMap : p.thicknessMap ? x = p.thicknessMap : p.sheenColorMap ? x = p.sheenColorMap : p.sheenRoughnessMap && (x = p.sheenRoughnessMap), x !== void 0 && (x.isWebGLRenderTarget && (x = x.texture), x.matrixAutoUpdate === !0 && x.updateMatrix(), m.uvTransform.value.copy(x.matrix));
        let y;
        p.aoMap ? y = p.aoMap : p.lightMap && (y = p.lightMap), y !== void 0 && (y.isWebGLRenderTarget && (y = y.texture), y.matrixAutoUpdate === !0 && y.updateMatrix(), m.uv2Transform.value.copy(y.matrix))
    }

    function r(m, p) {
        m.diffuse.value.copy(p.color), m.opacity.value = p.opacity
    }

    function o(m, p) {
        m.dashSize.value = p.dashSize, m.totalSize.value = p.dashSize + p.gapSize, m.scale.value = p.scale
    }

    function a(m, p, _, x) {
        m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.size.value = p.size * _, m.scale.value = x * .5, p.map && (m.map.value = p.map), p.alphaMap && (m.alphaMap.value = p.alphaMap), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        let y;
        p.map ? y = p.map : p.alphaMap && (y = p.alphaMap), y !== void 0 && (y.matrixAutoUpdate === !0 && y.updateMatrix(), m.uvTransform.value.copy(y.matrix))
    }

    function l(m, p) {
        m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.rotation.value = p.rotation, p.map && (m.map.value = p.map), p.alphaMap && (m.alphaMap.value = p.alphaMap), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        let _;
        p.map ? _ = p.map : p.alphaMap && (_ = p.alphaMap), _ !== void 0 && (_.matrixAutoUpdate === !0 && _.updateMatrix(), m.uvTransform.value.copy(_.matrix))
    }

    function c(m, p) {
        m.specular.value.copy(p.specular), m.shininess.value = Math.max(p.shininess, 1e-4)
    }

    function h(m, p) {
        p.gradientMap && (m.gradientMap.value = p.gradientMap)
    }

    function u(m, p) {
        m.roughness.value = p.roughness, m.metalness.value = p.metalness, p.roughnessMap && (m.roughnessMap.value = p.roughnessMap), p.metalnessMap && (m.metalnessMap.value = p.metalnessMap), t.get(p).envMap && (m.envMapIntensity.value = p.envMapIntensity)
    }

    function d(m, p, _) {
        m.ior.value = p.ior, p.sheen > 0 && (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), m.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap), p.sheenRoughnessMap && (m.sheenRoughnessMap.value = p.sheenRoughnessMap)), p.clearcoat > 0 && (m.clearcoat.value = p.clearcoat, m.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap), p.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap), p.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), m.clearcoatNormalMap.value = p.clearcoatNormalMap, p.side === xs && m.clearcoatNormalScale.value.negate())), p.iridescence > 0 && (m.iridescence.value = p.iridescence, m.iridescenceIOR.value = p.iridescenceIOR, m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (m.iridescenceMap.value = p.iridescenceMap), p.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = p.iridescenceThicknessMap)), p.transmission > 0 && (m.transmission.value = p.transmission, m.transmissionSamplerMap.value = _.texture, m.transmissionSamplerSize.value.set(_.width, _.height), p.transmissionMap && (m.transmissionMap.value = p.transmissionMap), m.thickness.value = p.thickness, p.thicknessMap && (m.thicknessMap.value = p.thicknessMap), m.attenuationDistance.value = p.attenuationDistance, m.attenuationColor.value.copy(p.attenuationColor)), m.specularIntensity.value = p.specularIntensity, m.specularColor.value.copy(p.specularColor), p.specularIntensityMap && (m.specularIntensityMap.value = p.specularIntensityMap), p.specularColorMap && (m.specularColorMap.value = p.specularColorMap)
    }

    function f(m, p) {
        p.matcap && (m.matcap.value = p.matcap)
    }

    function g(m, p) {
        m.referencePosition.value.copy(p.referencePosition), m.nearDistance.value = p.nearDistance, m.farDistance.value = p.farDistance
    }

    return {refreshFogUniforms: e, refreshMaterialUniforms: n}
}

function IR(i, t, e, n) {
    let s = {}, r = {}, o = [];
    const a = e.isWebGL2 ? i.getParameter(35375) : 0;

    function l(x, y) {
        const v = y.program;
        n.uniformBlockBinding(x, v)
    }

    function c(x, y) {
        let v = s[x.id];
        v === void 0 && (g(x), v = h(x), s[x.id] = v, x.addEventListener("dispose", p));
        const w = y.program;
        n.updateUBOMapping(x, w);
        const E = t.render.frame;
        r[x.id] !== E && (d(x), r[x.id] = E)
    }

    function h(x) {
        const y = u();
        x.__bindingPointIndex = y;
        const v = i.createBuffer(), w = x.__size, E = x.usage;
        return i.bindBuffer(35345, v), i.bufferData(35345, w, E), i.bindBuffer(35345, null), i.bindBufferBase(35345, y, v), v
    }

    function u() {
        for (let x = 0; x < a; x++) if (o.indexOf(x) === -1) return o.push(x), x;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }

    function d(x) {
        const y = s[x.id], v = x.uniforms, w = x.__cache;
        i.bindBuffer(35345, y);
        for (let E = 0, S = v.length; E < S; E++) {
            const b = v[E];
            if (f(b, E, w) === !0) {
                const M = b.__offset, I = Array.isArray(b.value) ? b.value : [b.value];
                let N = 0;
                for (let B = 0; B < I.length; B++) {
                    const D = I[B], L = m(D);
                    typeof D == "number" ? (b.__data[0] = D, i.bufferSubData(35345, M + N, b.__data)) : D.isMatrix3 ? (b.__data[0] = D.elements[0], b.__data[1] = D.elements[1], b.__data[2] = D.elements[2], b.__data[3] = D.elements[0], b.__data[4] = D.elements[3], b.__data[5] = D.elements[4], b.__data[6] = D.elements[5], b.__data[7] = D.elements[0], b.__data[8] = D.elements[6], b.__data[9] = D.elements[7], b.__data[10] = D.elements[8], b.__data[11] = D.elements[0]) : (D.toArray(b.__data, N), N += L.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                i.bufferSubData(35345, M, b.__data)
            }
        }
        i.bindBuffer(35345, null)
    }

    function f(x, y, v) {
        const w = x.value;
        if (v[y] === void 0) {
            if (typeof w == "number") v[y] = w; else {
                const E = Array.isArray(w) ? w : [w], S = [];
                for (let b = 0; b < E.length; b++) S.push(E[b].clone());
                v[y] = S
            }
            return !0
        } else if (typeof w == "number") {
            if (v[y] !== w) return v[y] = w, !0
        } else {
            const E = Array.isArray(v[y]) ? v[y] : [v[y]], S = Array.isArray(w) ? w : [w];
            for (let b = 0; b < E.length; b++) {
                const M = E[b];
                if (M.equals(S[b]) === !1) return M.copy(S[b]), !0
            }
        }
        return !1
    }

    function g(x) {
        const y = x.uniforms;
        let v = 0;
        const w = 16;
        let E = 0;
        for (let S = 0, b = y.length; S < b; S++) {
            const M = y[S], I = {boundary: 0, storage: 0}, N = Array.isArray(M.value) ? M.value : [M.value];
            for (let B = 0, D = N.length; B < D; B++) {
                const L = N[B], k = m(L);
                I.boundary += k.boundary, I.storage += k.storage
            }
            if (M.__data = new Float32Array(I.storage / Float32Array.BYTES_PER_ELEMENT), M.__offset = v, S > 0) {
                E = v % w;
                const B = w - E;
                E !== 0 && B - I.boundary < 0 && (v += w - E, M.__offset = v)
            }
            v += I.storage
        }
        return E = v % w, E > 0 && (v += w - E), x.__size = v, x.__cache = {}, this
    }

    function m(x) {
        const y = {boundary: 0, storage: 0};
        return typeof x == "number" ? (y.boundary = 4, y.storage = 4) : x.isVector2 ? (y.boundary = 8, y.storage = 8) : x.isVector3 || x.isColor ? (y.boundary = 16, y.storage = 12) : x.isVector4 ? (y.boundary = 16, y.storage = 16) : x.isMatrix3 ? (y.boundary = 48, y.storage = 48) : x.isMatrix4 ? (y.boundary = 64, y.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), y
    }

    function p(x) {
        const y = x.target;
        y.removeEventListener("dispose", p);
        const v = o.indexOf(y.__bindingPointIndex);
        o.splice(v, 1), i.deleteBuffer(s[y.id]), delete s[y.id], delete r[y.id]
    }

    function _() {
        for (const x in s) i.deleteBuffer(s[x]);
        o = [], s = {}, r = {}
    }

    return {bind: l, update: c, dispose: _}
}

function AR() {
    const i = Bc("canvas");
    return i.style.display = "block", i
}

function c0(i = {}) {
    this.isWebGLRenderer = !0;
    const t = i.canvas !== void 0 ? i.canvas : AR(), e = i.context !== void 0 ? i.context : null,
        n = i.depth !== void 0 ? i.depth : !0, s = i.stencil !== void 0 ? i.stencil : !0,
        r = i.antialias !== void 0 ? i.antialias : !1, o = i.premultipliedAlpha !== void 0 ? i.premultipliedAlpha : !0,
        a = i.preserveDrawingBuffer !== void 0 ? i.preserveDrawingBuffer : !1,
        l = i.powerPreference !== void 0 ? i.powerPreference : "default",
        c = i.failIfMajorPerformanceCaveat !== void 0 ? i.failIfMajorPerformanceCaveat : !1;
    let h;
    e !== null ? h = e.getContextAttributes().alpha : h = i.alpha !== void 0 ? i.alpha : !1;
    let u = null, d = null;
    const f = [], g = [];
    this.domElement = t, this.debug = {checkShaderErrors: !0}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Vr, this.physicallyCorrectLights = !1, this.toneMapping = Pi, this.toneMappingExposure = 1;
    const m = this;
    let p = !1, _ = 0, x = 0, y = null, v = -1, w = null;
    const E = new Fe, S = new Fe;
    let b = null, M = t.width, I = t.height, N = 1, B = null, D = null;
    const L = new Fe(0, 0, M, I), k = new Fe(0, 0, M, I);
    let G = !1;
    const Q = new jd;
    let q = !1, at = !1, lt = null;
    const wt = new Yt, W = new j, st = new C,
        gt = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0};

    function mt() {
        return y === null ? N : 1
    }

    let Y = e;

    function Ut(P, $) {
        for (let J = 0; J < P.length; J++) {
            const H = P[J], tt = t.getContext(H, $);
            if (tt !== null) return tt
        }
        return null
    }

    try {
        const P = {
            alpha: !0,
            depth: n,
            stencil: s,
            antialias: r,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c
        };
        if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Hd}`), t.addEventListener("webglcontextlost", Ft, !1), t.addEventListener("webglcontextrestored", Ot, !1), t.addEventListener("webglcontextcreationerror", oe, !1), Y === null) {
            const $ = ["webgl2", "webgl", "experimental-webgl"];
            if (m.isWebGL1Renderer === !0 && $.shift(), Y = Ut($, P), Y === null) throw Ut($) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        Y.getShaderPrecisionFormat === void 0 && (Y.getShaderPrecisionFormat = function () {
            return {rangeMin: 1, rangeMax: 1, precision: 1}
        })
    } catch (P) {
        throw console.error("THREE.WebGLRenderer: " + P.message), P
    }
    let Rt, Nt, vt, ee, nt, et, ft, Pt, _t, qt, Vt, Gt, ke, ve, R, A, X, ht, dt, bt, Wt, O, V, Et;

    function It() {
        Rt = new $C(Y), Nt = new BC(Y, Rt, i), Rt.init(Nt), O = new Zb(Y, Rt, Nt), vt = new bR(Y, Rt, Nt), ee = new YC, nt = new hR, et = new ER(Y, Rt, vt, nt, Nt, O, ee), ft = new UC(m), Pt = new HC(m), _t = new nA(Y, Nt), V = new FC(Y, Rt, _t, Nt), qt = new WC(Y, _t, ee, V), Vt = new KC(Y, qt, _t, ee), dt = new jC(Y, Nt, et), A = new kC(nt), Gt = new cR(m, ft, Pt, Rt, Nt, V, A), ke = new TR(m, nt), ve = new dR, R = new yR(Rt, Nt), ht = new DC(m, ft, Pt, vt, Vt, h, o), X = new wR(m, Vt, Nt), Et = new IR(Y, ee, Nt, vt), bt = new zC(Y, Rt, ee, Nt), Wt = new qC(Y, Rt, ee, Nt), ee.programs = Gt.programs, m.capabilities = Nt, m.extensions = Rt, m.properties = nt, m.renderLists = ve, m.shadowMap = X, m.state = vt, m.info = ee
    }

    It();
    const Mt = new MR(m, Y);
    this.xr = Mt, this.getContext = function () {
        return Y
    }, this.getContextAttributes = function () {
        return Y.getContextAttributes()
    }, this.forceContextLoss = function () {
        const P = Rt.get("WEBGL_lose_context");
        P && P.loseContext()
    }, this.forceContextRestore = function () {
        const P = Rt.get("WEBGL_lose_context");
        P && P.restoreContext()
    }, this.getPixelRatio = function () {
        return N
    }, this.setPixelRatio = function (P) {
        P !== void 0 && (N = P, this.setSize(M, I, !1))
    }, this.getSize = function (P) {
        return P.set(M, I)
    }, this.setSize = function (P, $, J) {
        if (Mt.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        M = P, I = $, t.width = Math.floor(P * N), t.height = Math.floor($ * N), J !== !1 && (t.style.width = P + "px", t.style.height = $ + "px"), this.setViewport(0, 0, P, $)
    }, this.getDrawingBufferSize = function (P) {
        return P.set(M * N, I * N).floor()
    }, this.setDrawingBufferSize = function (P, $, J) {
        M = P, I = $, N = J, t.width = Math.floor(P * J), t.height = Math.floor($ * J), this.setViewport(0, 0, P, $)
    }, this.getCurrentViewport = function (P) {
        return P.copy(E)
    }, this.getViewport = function (P) {
        return P.copy(L)
    }, this.setViewport = function (P, $, J, H) {
        P.isVector4 ? L.set(P.x, P.y, P.z, P.w) : L.set(P, $, J, H), vt.viewport(E.copy(L).multiplyScalar(N).floor())
    }, this.getScissor = function (P) {
        return P.copy(k)
    }, this.setScissor = function (P, $, J, H) {
        P.isVector4 ? k.set(P.x, P.y, P.z, P.w) : k.set(P, $, J, H), vt.scissor(S.copy(k).multiplyScalar(N).floor())
    }, this.getScissorTest = function () {
        return G
    }, this.setScissorTest = function (P) {
        vt.setScissorTest(G = P)
    }, this.setOpaqueSort = function (P) {
        B = P
    }, this.setTransparentSort = function (P) {
        D = P
    }, this.getClearColor = function (P) {
        return P.copy(ht.getClearColor())
    }, this.setClearColor = function () {
        ht.setClearColor.apply(ht, arguments)
    }, this.getClearAlpha = function () {
        return ht.getClearAlpha()
    }, this.setClearAlpha = function () {
        ht.setClearAlpha.apply(ht, arguments)
    }, this.clear = function (P = !0, $ = !0, J = !0) {
        let H = 0;
        P && (H |= 16384), $ && (H |= 256), J && (H |= 1024), Y.clear(H)
    }, this.clearColor = function () {
        this.clear(!0, !1, !1)
    }, this.clearDepth = function () {
        this.clear(!1, !0, !1)
    }, this.clearStencil = function () {
        this.clear(!1, !1, !0)
    }, this.dispose = function () {
        t.removeEventListener("webglcontextlost", Ft, !1), t.removeEventListener("webglcontextrestored", Ot, !1), t.removeEventListener("webglcontextcreationerror", oe, !1), ve.dispose(), R.dispose(), nt.dispose(), ft.dispose(), Pt.dispose(), Vt.dispose(), V.dispose(), Et.dispose(), Gt.dispose(), Mt.dispose(), Mt.removeEventListener("sessionstart", Tt), Mt.removeEventListener("sessionend", zt), lt && (lt.dispose(), lt = null), Ae.stop()
    };

    function Ft(P) {
        P.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), p = !0
    }

    function Ot() {
        console.log("THREE.WebGLRenderer: Context Restored."), p = !1;
        const P = ee.autoReset, $ = X.enabled, J = X.autoUpdate, H = X.needsUpdate, tt = X.type;
        It(), ee.autoReset = P, X.enabled = $, X.autoUpdate = J, X.needsUpdate = H, X.type = tt
    }

    function oe(P) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", P.statusMessage)
    }

    function ce(P) {
        const $ = P.target;
        $.removeEventListener("dispose", ce), Ue($)
    }

    function Ue(P) {
        U(P), nt.remove(P)
    }

    function U(P) {
        const $ = nt.get(P).programs;
        $ !== void 0 && ($.forEach(function (J) {
            Gt.releaseProgram(J)
        }), P.isShaderMaterial && Gt.releaseShaderCache(P))
    }

    this.renderBufferDirect = function (P, $, J, H, tt, Ht) {
        $ === null && ($ = gt);
        const Zt = tt.isMesh && tt.matrixWorld.determinant() < 0, se = NT(P, $, J, H, tt);
        vt.setMaterial(H, Zt);
        let ie = J.index, we = 1;
        H.wireframe === !0 && (ie = qt.getWireframeAttribute(J), we = 2);
        const he = J.drawRange, ue = J.attributes.position;
        let pn = he.start * we, Ms = (he.start + he.count) * we;
        Ht !== null && (pn = Math.max(pn, Ht.start * we), Ms = Math.min(Ms, (Ht.start + Ht.count) * we)), ie !== null ? (pn = Math.max(pn, 0), Ms = Math.min(Ms, ie.count)) : ue != null && (pn = Math.max(pn, 0), Ms = Math.min(Ms, ue.count));
        const Wi = Ms - pn;
        if (Wi < 0 || Wi === 1 / 0) return;
        V.setup(tt, H, se, J, ie);
        let to, gn = bt;
        if (ie !== null && (to = _t.get(ie), gn = Wt, gn.setIndex(to)), tt.isMesh) H.wireframe === !0 ? (vt.setLineWidth(H.wireframeLinewidth * mt()), gn.setMode(1)) : gn.setMode(4); else if (tt.isLine) {
            let de = H.linewidth;
            de === void 0 && (de = 1), vt.setLineWidth(de * mt()), tt.isLineSegments ? gn.setMode(1) : tt.isLineLoop ? gn.setMode(2) : gn.setMode(3)
        } else tt.isPoints ? gn.setMode(0) : tt.isSprite && gn.setMode(4);
        if (tt.isInstancedMesh) gn.renderInstances(pn, Wi, tt.count); else if (J.isInstancedBufferGeometry) {
            const de = J._maxInstanceCount !== void 0 ? J._maxInstanceCount : 1 / 0, hp = Math.min(J.instanceCount, de);
            gn.renderInstances(pn, Wi, hp)
        } else gn.render(pn, Wi)
    }, this.compile = function (P, $) {
        function J(H, tt, Ht) {
            H.transparent === !0 && H.side === Ci && H.forceSinglePass === !1 ? (H.side = xs, H.needsUpdate = !0, Gs(H, tt, Ht), H.side = Fi, H.needsUpdate = !0, Gs(H, tt, Ht), H.side = Ci) : Gs(H, tt, Ht)
        }

        d = R.get(P), d.init(), g.push(d), P.traverseVisible(function (H) {
            H.isLight && H.layers.test($.layers) && (d.pushLight(H), H.castShadow && d.pushShadow(H))
        }), d.setupLights(m.physicallyCorrectLights), P.traverse(function (H) {
            const tt = H.material;
            if (tt) if (Array.isArray(tt)) for (let Ht = 0; Ht < tt.length; Ht++) {
                const Zt = tt[Ht];
                J(Zt, P, H)
            } else J(tt, P, H)
        }), g.pop(), d = null
    };
    let K = null;

    function ut(P) {
        K && K(P)
    }

    function Tt() {
        Ae.stop()
    }

    function zt() {
        Ae.start()
    }

    const Ae = new $b;
    Ae.setAnimationLoop(ut), typeof self < "u" && Ae.setContext(self), this.setAnimationLoop = function (P) {
        K = P, Mt.setAnimationLoop(P), P === null ? Ae.stop() : Ae.start()
    }, Mt.addEventListener("sessionstart", Tt), Mt.addEventListener("sessionend", zt), this.render = function (P, $) {
        if ($ !== void 0 && $.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (p === !0) return;
        P.matrixWorldAutoUpdate === !0 && P.updateMatrixWorld(), $.parent === null && $.matrixWorldAutoUpdate === !0 && $.updateMatrixWorld(), Mt.enabled === !0 && Mt.isPresenting === !0 && (Mt.cameraAutoUpdate === !0 && Mt.updateCamera($), $ = Mt.getCamera()), P.isScene === !0 && P.onBeforeRender(m, P, $, y), d = R.get(P, g.length), d.init(), g.push(d), wt.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse), Q.setFromProjectionMatrix(wt), at = this.localClippingEnabled, q = A.init(this.clippingPlanes, at), u = ve.get(P, f.length), u.init(), f.push(u), An(P, $, 0, m.sortObjects), u.finish(), m.sortObjects === !0 && u.sort(B, D), q === !0 && A.beginShadows();
        const J = d.state.shadowsArray;
        if (X.render(J, P, $), q === !0 && A.endShadows(), this.info.autoReset === !0 && this.info.reset(), ht.render(u, P), d.setupLights(m.physicallyCorrectLights), $.isArrayCamera) {
            const H = $.cameras;
            for (let tt = 0, Ht = H.length; tt < Ht; tt++) {
                const Zt = H[tt];
                Hn(u, P, Zt, Zt.viewport)
            }
        } else Hn(u, P, $);
        y !== null && (et.updateMultisampleRenderTarget(y), et.updateRenderTargetMipmap(y)), P.isScene === !0 && P.onAfterRender(m, P, $), V.resetDefaultState(), v = -1, w = null, g.pop(), g.length > 0 ? d = g[g.length - 1] : d = null, f.pop(), f.length > 0 ? u = f[f.length - 1] : u = null
    };

    function An(P, $, J, H) {
        if (P.visible === !1) return;
        if (P.layers.test($.layers)) {
            if (P.isGroup) J = P.renderOrder; else if (P.isLOD) P.autoUpdate === !0 && P.update($); else if (P.isLight) d.pushLight(P), P.castShadow && d.pushShadow(P); else if (P.isSprite) {
                if (!P.frustumCulled || Q.intersectsSprite(P)) {
                    H && st.setFromMatrixPosition(P.matrixWorld).applyMatrix4(wt);
                    const Zt = Vt.update(P), se = P.material;
                    se.visible && u.push(P, Zt, se, J, st.z, null)
                }
            } else if ((P.isMesh || P.isLine || P.isPoints) && (P.isSkinnedMesh && P.skeleton.frame !== ee.render.frame && (P.skeleton.update(), P.skeleton.frame = ee.render.frame), !P.frustumCulled || Q.intersectsObject(P))) {
                H && st.setFromMatrixPosition(P.matrixWorld).applyMatrix4(wt);
                const Zt = Vt.update(P), se = P.material;
                if (Array.isArray(se)) {
                    const ie = Zt.groups;
                    for (let we = 0, he = ie.length; we < he; we++) {
                        const ue = ie[we], pn = se[ue.materialIndex];
                        pn && pn.visible && u.push(P, Zt, pn, J, st.z, ue)
                    }
                } else se.visible && u.push(P, Zt, se, J, st.z, null)
            }
        }
        const Ht = P.children;
        for (let Zt = 0, se = Ht.length; Zt < se; Zt++) An(Ht[Zt], $, J, H)
    }

    function Hn(P, $, J, H) {
        const tt = P.opaque, Ht = P.transmissive, Zt = P.transparent;
        d.setupLightsView(J), q === !0 && A.setGlobalState(m.clippingPlanes, J), Ht.length > 0 && Qr(tt, $, J), H && vt.viewport(E.copy(H)), tt.length > 0 && Ze(tt, $, J), Ht.length > 0 && Ze(Ht, $, J), Zt.length > 0 && Ze(Zt, $, J), vt.buffers.depth.setTest(!0), vt.buffers.depth.setMask(!0), vt.buffers.color.setMask(!0), vt.setPolygonOffset(!1)
    }

    function Qr(P, $, J) {
        const H = Nt.isWebGL2;
        lt === null && (lt = new fs(1, 1, {
            generateMipmaps: !0,
            type: Rt.has("EXT_color_buffer_half_float") ? nl : Gr,
            minFilter: zi,
            samples: H && r === !0 ? 4 : 0
        })), m.getDrawingBufferSize(W), H ? lt.setSize(W.x, W.y) : lt.setSize(ld(W.x), ld(W.y));
        const tt = m.getRenderTarget();
        m.setRenderTarget(lt), m.clear();
        const Ht = m.toneMapping;
        m.toneMapping = Pi, Ze(P, $, J), m.toneMapping = Ht, et.updateMultisampleRenderTarget(lt), et.updateRenderTargetMipmap(lt), m.setRenderTarget(tt)
    }

    function Ze(P, $, J) {
        const H = $.isScene === !0 ? $.overrideMaterial : null;
        for (let tt = 0, Ht = P.length; tt < Ht; tt++) {
            const Zt = P[tt], se = Zt.object, ie = Zt.geometry, we = H === null ? Zt.material : H, he = Zt.group;
            se.layers.test(J.layers) && $i(se, $, J, ie, we, he)
        }
    }

    function $i(P, $, J, H, tt, Ht) {
        P.onBeforeRender(m, $, J, H, tt, Ht), P.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, P.matrixWorld), P.normalMatrix.getNormalMatrix(P.modelViewMatrix), tt.onBeforeRender(m, $, J, H, P, Ht), tt.transparent === !0 && tt.side === Ci && tt.forceSinglePass === !1 ? (tt.side = xs, tt.needsUpdate = !0, m.renderBufferDirect(J, $, H, tt, P, Ht), tt.side = Fi, tt.needsUpdate = !0, m.renderBufferDirect(J, $, H, tt, P, Ht), tt.side = Ci) : m.renderBufferDirect(J, $, H, tt, P, Ht), P.onAfterRender(m, $, J, H, tt, Ht)
    }

    function Gs(P, $, J) {
        $.isScene !== !0 && ($ = gt);
        const H = nt.get(P), tt = d.state.lights, Ht = d.state.shadowsArray, Zt = tt.state.version,
            se = Gt.getParameters(P, tt.state, Ht, $, J), ie = Gt.getProgramCacheKey(se);
        let we = H.programs;
        H.environment = P.isMeshStandardMaterial ? $.environment : null, H.fog = $.fog, H.envMap = (P.isMeshStandardMaterial ? Pt : ft).get(P.envMap || H.environment), we === void 0 && (P.addEventListener("dispose", ce), we = new Map, H.programs = we);
        let he = we.get(ie);
        if (he !== void 0) {
            if (H.currentProgram === he && H.lightsStateVersion === Zt) return hy(P, se), he
        } else se.uniforms = Gt.getUniforms(P), P.onBuild(J, se, m), P.onBeforeCompile(se, m), he = Gt.acquireProgram(se, ie), we.set(ie, he), H.uniforms = se.uniforms;
        const ue = H.uniforms;
        (!P.isShaderMaterial && !P.isRawShaderMaterial || P.clipping === !0) && (ue.clippingPlanes = A.uniform), hy(P, se), H.needsLights = DT(P), H.lightsStateVersion = Zt, H.needsLights && (ue.ambientLightColor.value = tt.state.ambient, ue.lightProbe.value = tt.state.probe, ue.directionalLights.value = tt.state.directional, ue.directionalLightShadows.value = tt.state.directionalShadow, ue.spotLights.value = tt.state.spot, ue.spotLightShadows.value = tt.state.spotShadow, ue.rectAreaLights.value = tt.state.rectArea, ue.ltc_1.value = tt.state.rectAreaLTC1, ue.ltc_2.value = tt.state.rectAreaLTC2, ue.pointLights.value = tt.state.point, ue.pointLightShadows.value = tt.state.pointShadow, ue.hemisphereLights.value = tt.state.hemi, ue.directionalShadowMap.value = tt.state.directionalShadowMap, ue.directionalShadowMatrix.value = tt.state.directionalShadowMatrix, ue.spotShadowMap.value = tt.state.spotShadowMap, ue.spotLightMatrix.value = tt.state.spotLightMatrix, ue.spotLightMap.value = tt.state.spotLightMap, ue.pointShadowMap.value = tt.state.pointShadowMap, ue.pointShadowMatrix.value = tt.state.pointShadowMatrix);
        const pn = he.getUniforms(), Ms = ed.seqWithValue(pn.seq, ue);
        return H.currentProgram = he, H.uniformsList = Ms, he
    }

    function hy(P, $) {
        const J = nt.get(P);
        J.outputEncoding = $.outputEncoding, J.instancing = $.instancing, J.skinning = $.skinning, J.morphTargets = $.morphTargets, J.morphNormals = $.morphNormals, J.morphColors = $.morphColors, J.morphTargetsCount = $.morphTargetsCount, J.numClippingPlanes = $.numClippingPlanes, J.numIntersection = $.numClipIntersection, J.vertexAlphas = $.vertexAlphas, J.vertexTangents = $.vertexTangents, J.toneMapping = $.toneMapping
    }

    function NT(P, $, J, H, tt) {
        $.isScene !== !0 && ($ = gt), et.resetTextureUnits();
        const Ht = $.fog, Zt = H.isMeshStandardMaterial ? $.environment : null,
            se = y === null ? m.outputEncoding : y.isXRRenderTarget === !0 ? y.texture.encoding : Vr,
            ie = (H.isMeshStandardMaterial ? Pt : ft).get(H.envMap || Zt),
            we = H.vertexColors === !0 && !!J.attributes.color && J.attributes.color.itemSize === 4,
            he = !!H.normalMap && !!J.attributes.tangent, ue = !!J.morphAttributes.position,
            pn = !!J.morphAttributes.normal, Ms = !!J.morphAttributes.color, Wi = H.toneMapped ? m.toneMapping : Pi,
            to = J.morphAttributes.position || J.morphAttributes.normal || J.morphAttributes.color,
            gn = to !== void 0 ? to.length : 0, de = nt.get(H), hp = d.state.lights;
        if (q === !0 && (at === !0 || P !== w)) {
            const Ts = P === w && H.id === v;
            A.setState(H, P, Ts)
        }
        let Cn = !1;
        H.version === de.__version ? (de.needsLights && de.lightsStateVersion !== hp.state.version || de.outputEncoding !== se || tt.isInstancedMesh && de.instancing === !1 || !tt.isInstancedMesh && de.instancing === !0 || tt.isSkinnedMesh && de.skinning === !1 || !tt.isSkinnedMesh && de.skinning === !0 || de.envMap !== ie || H.fog === !0 && de.fog !== Ht || de.numClippingPlanes !== void 0 && (de.numClippingPlanes !== A.numPlanes || de.numIntersection !== A.numIntersection) || de.vertexAlphas !== we || de.vertexTangents !== he || de.morphTargets !== ue || de.morphNormals !== pn || de.morphColors !== Ms || de.toneMapping !== Wi || Nt.isWebGL2 === !0 && de.morphTargetsCount !== gn) && (Cn = !0) : (Cn = !0, de.__version = H.version);
        let eo = de.currentProgram;
        Cn === !0 && (eo = Gs(H, $, tt));
        let uy = !1, Vl = !1, up = !1;
        const Qn = eo.getUniforms(), no = de.uniforms;
        if (vt.useProgram(eo.program) && (uy = !0, Vl = !0, up = !0), H.id !== v && (v = H.id, Vl = !0), uy || w !== P) {
            if (Qn.setValue(Y, "projectionMatrix", P.projectionMatrix), Nt.logarithmicDepthBuffer && Qn.setValue(Y, "logDepthBufFC", 2 / (Math.log(P.far + 1) / Math.LN2)), w !== P && (w = P, Vl = !0, up = !0), H.isShaderMaterial || H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshStandardMaterial || H.envMap) {
                const Ts = Qn.map.cameraPosition;
                Ts !== void 0 && Ts.setValue(Y, st.setFromMatrixPosition(P.matrixWorld))
            }
            (H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshLambertMaterial || H.isMeshBasicMaterial || H.isMeshStandardMaterial || H.isShaderMaterial) && Qn.setValue(Y, "isOrthographic", P.isOrthographicCamera === !0), (H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshLambertMaterial || H.isMeshBasicMaterial || H.isMeshStandardMaterial || H.isShaderMaterial || H.isShadowMaterial || tt.isSkinnedMesh) && Qn.setValue(Y, "viewMatrix", P.matrixWorldInverse)
        }
        if (tt.isSkinnedMesh) {
            Qn.setOptional(Y, tt, "bindMatrix"), Qn.setOptional(Y, tt, "bindMatrixInverse");
            const Ts = tt.skeleton;
            Ts && (Nt.floatVertexTextures ? (Ts.boneTexture === null && Ts.computeBoneTexture(), Qn.setValue(Y, "boneTexture", Ts.boneTexture, et), Qn.setValue(Y, "boneTextureSize", Ts.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const dp = J.morphAttributes;
        if ((dp.position !== void 0 || dp.normal !== void 0 || dp.color !== void 0 && Nt.isWebGL2 === !0) && dt.update(tt, J, H, eo), (Vl || de.receiveShadow !== tt.receiveShadow) && (de.receiveShadow = tt.receiveShadow, Qn.setValue(Y, "receiveShadow", tt.receiveShadow)), H.isMeshGouraudMaterial && H.envMap !== null && (no.envMap.value = ie, no.flipEnvMap.value = ie.isCubeTexture && ie.isRenderTargetTexture === !1 ? -1 : 1), Vl && (Qn.setValue(Y, "toneMappingExposure", m.toneMappingExposure), de.needsLights && OT(no, up), Ht && H.fog === !0 && ke.refreshFogUniforms(no, Ht), ke.refreshMaterialUniforms(no, H, N, I, lt), ed.upload(Y, de.uniformsList, no, et)), H.isShaderMaterial && H.uniformsNeedUpdate === !0 && (ed.upload(Y, de.uniformsList, no, et), H.uniformsNeedUpdate = !1), H.isSpriteMaterial && Qn.setValue(Y, "center", tt.center), Qn.setValue(Y, "modelViewMatrix", tt.modelViewMatrix), Qn.setValue(Y, "normalMatrix", tt.normalMatrix), Qn.setValue(Y, "modelMatrix", tt.matrixWorld), H.isShaderMaterial || H.isRawShaderMaterial) {
            const Ts = H.uniformsGroups;
            for (let fp = 0, FT = Ts.length; fp < FT; fp++) if (Nt.isWebGL2) {
                const dy = Ts[fp];
                Et.update(dy, eo), Et.bind(dy, eo)
            } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return eo
    }

    function OT(P, $) {
        P.ambientLightColor.needsUpdate = $, P.lightProbe.needsUpdate = $, P.directionalLights.needsUpdate = $, P.directionalLightShadows.needsUpdate = $, P.pointLights.needsUpdate = $, P.pointLightShadows.needsUpdate = $, P.spotLights.needsUpdate = $, P.spotLightShadows.needsUpdate = $, P.rectAreaLights.needsUpdate = $, P.hemisphereLights.needsUpdate = $
    }

    function DT(P) {
        return P.isMeshLambertMaterial || P.isMeshToonMaterial || P.isMeshPhongMaterial || P.isMeshStandardMaterial || P.isShadowMaterial || P.isShaderMaterial && P.lights === !0
    }

    this.getActiveCubeFace = function () {
        return _
    }, this.getActiveMipmapLevel = function () {
        return x
    }, this.getRenderTarget = function () {
        return y
    }, this.setRenderTargetTextures = function (P, $, J) {
        nt.get(P.texture).__webglTexture = $, nt.get(P.depthTexture).__webglTexture = J;
        const H = nt.get(P);
        H.__hasExternalTextures = !0, H.__hasExternalTextures && (H.__autoAllocateDepthBuffer = J === void 0, H.__autoAllocateDepthBuffer || Rt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), H.__useRenderToTexture = !1))
    }, this.setRenderTargetFramebuffer = function (P, $) {
        const J = nt.get(P);
        J.__webglFramebuffer = $, J.__useDefaultFramebuffer = $ === void 0
    }, this.setRenderTarget = function (P, $ = 0, J = 0) {
        y = P, _ = $, x = J;
        let H = !0, tt = null, Ht = !1, Zt = !1;
        if (P) {
            const ie = nt.get(P);
            ie.__useDefaultFramebuffer !== void 0 ? (vt.bindFramebuffer(36160, null), H = !1) : ie.__webglFramebuffer === void 0 ? et.setupRenderTarget(P) : ie.__hasExternalTextures && et.rebindTextures(P, nt.get(P.texture).__webglTexture, nt.get(P.depthTexture).__webglTexture);
            const we = P.texture;
            (we.isData3DTexture || we.isDataArrayTexture || we.isCompressedArrayTexture) && (Zt = !0);
            const he = nt.get(P).__webglFramebuffer;
            P.isWebGLCubeRenderTarget ? (tt = he[$], Ht = !0) : Nt.isWebGL2 && P.samples > 0 && et.useMultisampledRTT(P) === !1 ? tt = nt.get(P).__webglMultisampledFramebuffer : tt = he, E.copy(P.viewport), S.copy(P.scissor), b = P.scissorTest
        } else E.copy(L).multiplyScalar(N).floor(), S.copy(k).multiplyScalar(N).floor(), b = G;
        if (vt.bindFramebuffer(36160, tt) && Nt.drawBuffers && H && vt.drawBuffers(P, tt), vt.viewport(E), vt.scissor(S), vt.setScissorTest(b), Ht) {
            const ie = nt.get(P.texture);
            Y.framebufferTexture2D(36160, 36064, 34069 + $, ie.__webglTexture, J)
        } else if (Zt) {
            const ie = nt.get(P.texture), we = $ || 0;
            Y.framebufferTextureLayer(36160, 36064, ie.__webglTexture, J || 0, we)
        }
        v = -1
    }, this.readRenderTargetPixels = function (P, $, J, H, tt, Ht, Zt) {
        if (!(P && P.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let se = nt.get(P).__webglFramebuffer;
        if (P.isWebGLCubeRenderTarget && Zt !== void 0 && (se = se[Zt]), se) {
            vt.bindFramebuffer(36160, se);
            try {
                const ie = P.texture, we = ie.format, he = ie.type;
                if (we !== Os && O.convert(we) !== Y.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const ue = he === nl && (Rt.has("EXT_color_buffer_half_float") || Nt.isWebGL2 && Rt.has("EXT_color_buffer_float"));
                if (he !== Gr && O.convert(he) !== Y.getParameter(35738) && !(he === ir && (Nt.isWebGL2 || Rt.has("OES_texture_float") || Rt.has("WEBGL_color_buffer_float"))) && !ue) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                $ >= 0 && $ <= P.width - H && J >= 0 && J <= P.height - tt && Y.readPixels($, J, H, tt, O.convert(we), O.convert(he), Ht)
            } finally {
                const ie = y !== null ? nt.get(y).__webglFramebuffer : null;
                vt.bindFramebuffer(36160, ie)
            }
        }
    }, this.copyFramebufferToTexture = function (P, $, J = 0) {
        const H = Math.pow(2, -J), tt = Math.floor($.image.width * H), Ht = Math.floor($.image.height * H);
        et.setTexture2D($, 0), Y.copyTexSubImage2D(3553, J, 0, 0, P.x, P.y, tt, Ht), vt.unbindTexture()
    }, this.copyTextureToTexture = function (P, $, J, H = 0) {
        const tt = $.image.width, Ht = $.image.height, Zt = O.convert(J.format), se = O.convert(J.type);
        et.setTexture2D(J, 0), Y.pixelStorei(37440, J.flipY), Y.pixelStorei(37441, J.premultiplyAlpha), Y.pixelStorei(3317, J.unpackAlignment), $.isDataTexture ? Y.texSubImage2D(3553, H, P.x, P.y, tt, Ht, Zt, se, $.image.data) : $.isCompressedTexture ? Y.compressedTexSubImage2D(3553, H, P.x, P.y, $.mipmaps[0].width, $.mipmaps[0].height, Zt, $.mipmaps[0].data) : Y.texSubImage2D(3553, H, P.x, P.y, Zt, se, $.image), H === 0 && J.generateMipmaps && Y.generateMipmap(3553), vt.unbindTexture()
    }, this.copyTextureToTexture3D = function (P, $, J, H, tt = 0) {
        if (m.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const Ht = P.max.x - P.min.x + 1, Zt = P.max.y - P.min.y + 1, se = P.max.z - P.min.z + 1,
            ie = O.convert(H.format), we = O.convert(H.type);
        let he;
        if (H.isData3DTexture) et.setTexture3D(H, 0), he = 32879; else if (H.isDataArrayTexture) et.setTexture2DArray(H, 0), he = 35866; else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        Y.pixelStorei(37440, H.flipY), Y.pixelStorei(37441, H.premultiplyAlpha), Y.pixelStorei(3317, H.unpackAlignment);
        const ue = Y.getParameter(3314), pn = Y.getParameter(32878), Ms = Y.getParameter(3316),
            Wi = Y.getParameter(3315), to = Y.getParameter(32877), gn = J.isCompressedTexture ? J.mipmaps[0] : J.image;
        Y.pixelStorei(3314, gn.width), Y.pixelStorei(32878, gn.height), Y.pixelStorei(3316, P.min.x), Y.pixelStorei(3315, P.min.y), Y.pixelStorei(32877, P.min.z), J.isDataTexture || J.isData3DTexture ? Y.texSubImage3D(he, tt, $.x, $.y, $.z, Ht, Zt, se, ie, we, gn.data) : J.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Y.compressedTexSubImage3D(he, tt, $.x, $.y, $.z, Ht, Zt, se, ie, gn.data)) : Y.texSubImage3D(he, tt, $.x, $.y, $.z, Ht, Zt, se, ie, we, gn), Y.pixelStorei(3314, ue), Y.pixelStorei(32878, pn), Y.pixelStorei(3316, Ms), Y.pixelStorei(3315, Wi), Y.pixelStorei(32877, to), tt === 0 && H.generateMipmaps && Y.generateMipmap(he), vt.unbindTexture()
    }, this.initTexture = function (P) {
        P.isCubeTexture ? et.setTextureCube(P, 0) : P.isData3DTexture ? et.setTexture3D(P, 0) : P.isDataArrayTexture || P.isCompressedArrayTexture ? et.setTexture2DArray(P, 0) : et.setTexture2D(P, 0), vt.unbindTexture()
    }, this.resetState = function () {
        _ = 0, x = 0, y = null, vt.reset(), V.reset()
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
}

class Jb extends c0 {
}

Jb.prototype.isWebGL1Renderer = !0;

class Jd {
    constructor(t, e = 25e-5) {
        this.isFogExp2 = !0, this.name = "", this.color = new pt(t), this.density = e
    }

    clone() {
        return new Jd(this.color, this.density)
    }

    toJSON() {
        return {type: "FogExp2", color: this.color.getHex(), density: this.density}
    }
}

class Qd {
    constructor(t, e = 1, n = 1e3) {
        this.isFog = !0, this.name = "", this.color = new pt(t), this.near = e, this.far = n
    }

    clone() {
        return new Qd(this.color, this.near, this.far)
    }

    toJSON() {
        return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
    }
}

class Sc extends re {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
    }

    copy(t, e) {
        return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }

    toJSON(t) {
        const e = super.toJSON(t);
        return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e
    }

    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
    }

    set autoUpdate(t) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = t
    }
}

class fh {
    constructor(t, e) {
        this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = Fc, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = zs()
    }

    onUploadCallback() {
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }

    setUsage(t) {
        return this.usage = t, this
    }

    copy(t) {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
    }

    copyAt(t, e, n) {
        t *= this.stride, n *= e.stride;
        for (let s = 0, r = this.stride; s < r; s++) this.array[t + s] = e.array[n + s];
        return this
    }

    set(t, e = 0) {
        return this.array.set(t, e), this
    }

    clone(t) {
        t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = zs()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
            n = new this.constructor(e, this.stride);
        return n.setUsage(this.usage), n
    }

    onUpload(t) {
        return this.onUploadCallback = t, this
    }

    toJSON(t) {
        return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = zs()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}

const ts = new C;

class Hr {
    constructor(t, e, n, s = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = s
    }

    get count() {
        return this.data.count
    }

    get array() {
        return this.data.array
    }

    set needsUpdate(t) {
        this.data.needsUpdate = t
    }

    applyMatrix4(t) {
        for (let e = 0, n = this.data.count; e < n; e++) ts.fromBufferAttribute(this, e), ts.applyMatrix4(t), this.setXYZ(e, ts.x, ts.y, ts.z);
        return this
    }

    applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++) ts.fromBufferAttribute(this, e), ts.applyNormalMatrix(t), this.setXYZ(e, ts.x, ts.y, ts.z);
        return this
    }

    transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++) ts.fromBufferAttribute(this, e), ts.transformDirection(t), this.setXYZ(e, ts.x, ts.y, ts.z);
        return this
    }

    setX(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
    }

    setY(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
    }

    setZ(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
    }

    setW(t, e) {
        return this.normalized && (e = Ve(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
    }

    getX(t) {
        let e = this.data.array[t * this.data.stride + this.offset];
        return this.normalized && (e = rr(e, this.array)), e
    }

    getY(t) {
        let e = this.data.array[t * this.data.stride + this.offset + 1];
        return this.normalized && (e = rr(e, this.array)), e
    }

    getZ(t) {
        let e = this.data.array[t * this.data.stride + this.offset + 2];
        return this.normalized && (e = rr(e, this.array)), e
    }

    getW(t) {
        let e = this.data.array[t * this.data.stride + this.offset + 3];
        return this.normalized && (e = rr(e, this.array)), e
    }

    setXY(t, e, n) {
        return t = t * this.data.stride + this.offset, this.normalized && (e = Ve(e, this.array), n = Ve(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
    }

    setXYZ(t, e, n, s) {
        return t = t * this.data.stride + this.offset, this.normalized && (e = Ve(e, this.array), n = Ve(n, this.array), s = Ve(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = s, this
    }

    setXYZW(t, e, n, s, r) {
        return t = t * this.data.stride + this.offset, this.normalized && (e = Ve(e, this.array), n = Ve(n, this.array), s = Ve(s, this.array), r = Ve(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = s, this.data.array[t + 3] = r, this
    }

    clone(t) {
        if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let n = 0; n < this.count; n++) {
                const s = n * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[s + r])
            }
            return new ae(new this.array.constructor(e), this.itemSize, this.normalized)
        } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Hr(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }

    toJSON(t) {
        if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let n = 0; n < this.count; n++) {
                const s = n * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[s + r])
            }
            return {itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized}
        } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}

class tf extends En {
    constructor(t) {
        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new pt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
    }
}

let ma;
const jl = new C, _a = new C, ya = new C, xa = new j, Kl = new j, Qb = new Yt, iu = new C, Jl = new C, ru = new C,
    Wy = new j, Bp = new j, qy = new j;

class tE extends re {
    constructor(t) {
        if (super(), this.isSprite = !0, this.type = "Sprite", ma === void 0) {
            ma = new Xt;
            const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                n = new fh(e, 5);
            ma.setIndex([0, 1, 2, 0, 2, 3]), ma.setAttribute("position", new Hr(n, 3, 0, !1)), ma.setAttribute("uv", new Hr(n, 2, 3, !1))
        }
        this.geometry = ma, this.material = t !== void 0 ? t : new tf, this.center = new j(.5, .5)
    }

    raycast(t, e) {
        t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _a.setFromMatrixScale(this.matrixWorld), Qb.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ya.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _a.multiplyScalar(-ya.z);
        const n = this.material.rotation;
        let s, r;
        n !== 0 && (r = Math.cos(n), s = Math.sin(n));
        const o = this.center;
        ou(iu.set(-.5, -.5, 0), ya, o, _a, s, r), ou(Jl.set(.5, -.5, 0), ya, o, _a, s, r), ou(ru.set(.5, .5, 0), ya, o, _a, s, r), Wy.set(0, 0), Bp.set(1, 0), qy.set(1, 1);
        let a = t.ray.intersectTriangle(iu, Jl, ru, !1, jl);
        if (a === null && (ou(Jl.set(-.5, .5, 0), ya, o, _a, s, r), Bp.set(0, 1), a = t.ray.intersectTriangle(iu, ru, Jl, !1, jl), a === null)) return;
        const l = t.ray.origin.distanceTo(jl);
        l < t.near || l > t.far || e.push({
            distance: l,
            point: jl.clone(),
            uv: Oo.getUV(jl, iu, Jl, ru, Wy, Bp, qy, new j),
            face: null,
            object: this
        })
    }

    copy(t, e) {
        return super.copy(t, e), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this
    }
}

function ou(i, t, e, n, s, r) {
    xa.subVectors(i, e).addScalar(.5).multiply(n), s !== void 0 ? (Kl.x = r * xa.x - s * xa.y, Kl.y = s * xa.x + r * xa.y) : Kl.copy(xa), i.copy(t), i.x += Kl.x, i.y += Kl.y, i.applyMatrix4(Qb)
}

const au = new C, Yy = new C;

class eE extends re {
    constructor() {
        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }, isLOD: {value: !0}
        }), this.autoUpdate = !0
    }

    copy(t) {
        super.copy(t, !1);
        const e = t.levels;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            this.addLevel(r.object.clone(), r.distance, r.hysteresis)
        }
        return this.autoUpdate = t.autoUpdate, this
    }

    addLevel(t, e = 0, n = 0) {
        e = Math.abs(e);
        const s = this.levels;
        let r;
        for (r = 0; r < s.length && !(e < s[r].distance); r++) ;
        return s.splice(r, 0, {distance: e, hysteresis: n, object: t}), this.add(t), this
    }

    getCurrentLevel() {
        return this._currentLevel
    }

    getObjectForDistance(t) {
        const e = this.levels;
        if (e.length > 0) {
            let n, s;
            for (n = 1, s = e.length; n < s; n++) {
                let r = e[n].distance;
                if (e[n].object.visible && (r -= r * e[n].hysteresis), t < r) break
            }
            return e[n - 1].object
        }
        return null
    }

    raycast(t, e) {
        if (this.levels.length > 0) {
            au.setFromMatrixPosition(this.matrixWorld);
            const s = t.ray.origin.distanceTo(au);
            this.getObjectForDistance(s).raycast(t, e)
        }
    }

    update(t) {
        const e = this.levels;
        if (e.length > 1) {
            au.setFromMatrixPosition(t.matrixWorld), Yy.setFromMatrixPosition(this.matrixWorld);
            const n = au.distanceTo(Yy) / t.zoom;
            e[0].object.visible = !0;
            let s, r;
            for (s = 1, r = e.length; s < r; s++) {
                let o = e[s].distance;
                if (e[s].object.visible && (o -= o * e[s].hysteresis), n >= o) e[s - 1].object.visible = !1, e[s].object.visible = !0; else break
            }
            for (this._currentLevel = s - 1; s < r; s++) e[s].object.visible = !1
        }
    }

    toJSON(t) {
        const e = super.toJSON(t);
        this.autoUpdate === !1 && (e.object.autoUpdate = !1), e.object.levels = [];
        const n = this.levels;
        for (let s = 0, r = n.length; s < r; s++) {
            const o = n[s];
            e.object.levels.push({object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis})
        }
        return e
    }
}

const Xy = new C, Zy = new Fe, jy = new Fe, CR = new C, Ky = new Yt;

class h0 extends ge {
    constructor(t, e) {
        super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Yt, this.bindMatrixInverse = new Yt
    }

    copy(t, e) {
        return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
    }

    bind(t, e) {
        this.skeleton = t, e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
    }

    pose() {
        this.skeleton.pose()
    }

    normalizeSkinWeights() {
        const t = new Fe, e = this.geometry.attributes.skinWeight;
        for (let n = 0, s = e.count; n < s; n++) {
            t.fromBufferAttribute(e, n);
            const r = 1 / t.manhattanLength();
            r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
        }
    }

    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }

    boneTransform(t, e) {
        const n = this.skeleton, s = this.geometry;
        Zy.fromBufferAttribute(s.attributes.skinIndex, t), jy.fromBufferAttribute(s.attributes.skinWeight, t), Xy.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
        for (let r = 0; r < 4; r++) {
            const o = jy.getComponent(r);
            if (o !== 0) {
                const a = Zy.getComponent(r);
                Ky.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), e.addScaledVector(CR.copy(Xy).applyMatrix4(Ky), o)
            }
        }
        return e.applyMatrix4(this.bindMatrixInverse)
    }
}

class ef extends re {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}

class ka extends Sn {
    constructor(t = null, e = 1, n = 1, s, r, o, a, l, c = sn, h = sn, u, d) {
        super(null, o, a, l, c, h, s, r, u, d), this.isDataTexture = !0, this.image = {
            data: t,
            width: e,
            height: n
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}

const Jy = new Yt, PR = new Yt;

class ph {
    constructor(t = [], e = []) {
        this.uuid = zs(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
    }

    init() {
        const t = this.bones, e = this.boneInverses;
        if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0) this.calculateInverses(); else if (t.length !== e.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let n = 0, s = this.bones.length; n < s; n++) this.boneInverses.push(new Yt)
        }
    }

    calculateInverses() {
        this.boneInverses.length = 0;
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const n = new Yt;
            this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n)
        }
    }

    pose() {
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const n = this.bones[t];
            n && n.matrixWorld.copy(this.boneInverses[t]).invert()
        }
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const n = this.bones[t];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }

    update() {
        const t = this.bones, e = this.boneInverses, n = this.boneMatrices, s = this.boneTexture;
        for (let r = 0, o = t.length; r < o; r++) {
            const a = t[r] ? t[r].matrixWorld : PR;
            Jy.multiplyMatrices(a, e[r]), Jy.toArray(n, r * 16)
        }
        s !== null && (s.needsUpdate = !0)
    }

    clone() {
        return new ph(this.bones, this.boneInverses)
    }

    computeBoneTexture() {
        let t = Math.sqrt(this.bones.length * 4);
        t = Db(t), t = Math.max(t, 4);
        const e = new Float32Array(t * t * 4);
        e.set(this.boneMatrices);
        const n = new ka(e, t, t, Os, ir);
        return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
    }

    getBoneByName(t) {
        for (let e = 0, n = this.bones.length; e < n; e++) {
            const s = this.bones[e];
            if (s.name === t) return s
        }
    }

    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }

    fromJSON(t, e) {
        this.uuid = t.uuid;
        for (let n = 0, s = t.bones.length; n < s; n++) {
            const r = t.bones[n];
            let o = e[r];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new ef), this.bones.push(o), this.boneInverses.push(new Yt().fromArray(t.boneInverses[n]))
        }
        return this.init(), this
    }

    toJSON() {
        const t = {
            metadata: {version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON"},
            bones: [],
            boneInverses: []
        };
        t.uuid = this.uuid;
        const e = this.bones, n = this.boneInverses;
        for (let s = 0, r = e.length; s < r; s++) {
            const o = e[s];
            t.bones.push(o.uuid);
            const a = n[s];
            t.boneInverses.push(a.toArray())
        }
        return t
    }
}

class ol extends ae {
    constructor(t, e, n, s = 1) {
        super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s
    }

    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }

    toJSON() {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
    }
}

const Qy = new Yt, tx = new Yt, lu = [], RR = new Yt, Ql = new ge;

class u0 extends ge {
    constructor(t, e, n) {
        super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new ol(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
        for (let s = 0; s < n; s++) this.setMatrixAt(s, RR)
    }

    copy(t, e) {
        return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
    }

    getColorAt(t, e) {
        e.fromArray(this.instanceColor.array, t * 3)
    }

    getMatrixAt(t, e) {
        e.fromArray(this.instanceMatrix.array, t * 16)
    }

    raycast(t, e) {
        const n = this.matrixWorld, s = this.count;
        if (Ql.geometry = this.geometry, Ql.material = this.material, Ql.material !== void 0) for (let r = 0; r < s; r++) {
            this.getMatrixAt(r, Qy), tx.multiplyMatrices(n, Qy), Ql.matrixWorld = tx, Ql.raycast(t, lu);
            for (let o = 0, a = lu.length; o < a; o++) {
                const l = lu[o];
                l.instanceId = r, l.object = this, e.push(l)
            }
            lu.length = 0
        }
    }

    setColorAt(t, e) {
        this.instanceColor === null && (this.instanceColor = new ol(new Float32Array(this.instanceMatrix.count * 3), 3)), e.toArray(this.instanceColor.array, t * 3)
    }

    setMatrixAt(t, e) {
        e.toArray(this.instanceMatrix.array, t * 16)
    }

    updateMorphTargets() {
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }
}

class Jn extends En {
    constructor(t) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new pt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
    }
}

const ex = new C, nx = new C, sx = new Yt, kp = new uh, cu = new Zr;

class lr extends re {
    constructor(t = new Xt, e = new Jn) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
    }

    copy(t, e) {
        return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
    }

    computeLineDistances() {
        const t = this.geometry;
        if (t.index === null) {
            const e = t.attributes.position, n = [0];
            for (let s = 1, r = e.count; s < r; s++) ex.fromBufferAttribute(e, s - 1), nx.fromBufferAttribute(e, s), n[s] = n[s - 1], n[s] += ex.distanceTo(nx);
            t.setAttribute("lineDistance", new Ct(n, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }

    raycast(t, e) {
        const n = this.geometry, s = this.matrixWorld, r = t.params.Line.threshold, o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(), cu.copy(n.boundingSphere), cu.applyMatrix4(s), cu.radius += r, t.ray.intersectsSphere(cu) === !1) return;
        sx.copy(s).invert(), kp.copy(t.ray).applyMatrix4(sx);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new C, h = new C, u = new C,
            d = new C, f = this.isLineSegments ? 2 : 1, g = n.index, p = n.attributes.position;
        if (g !== null) {
            const _ = Math.max(0, o.start), x = Math.min(g.count, o.start + o.count);
            for (let y = _, v = x - 1; y < v; y += f) {
                const w = g.getX(y), E = g.getX(y + 1);
                if (c.fromBufferAttribute(p, w), h.fromBufferAttribute(p, E), kp.distanceSqToSegment(c, h, d, u) > l) continue;
                d.applyMatrix4(this.matrixWorld);
                const b = t.ray.origin.distanceTo(d);
                b < t.near || b > t.far || e.push({
                    distance: b,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: y,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const _ = Math.max(0, o.start), x = Math.min(p.count, o.start + o.count);
            for (let y = _, v = x - 1; y < v; y += f) {
                if (c.fromBufferAttribute(p, y), h.fromBufferAttribute(p, y + 1), kp.distanceSqToSegment(c, h, d, u) > l) continue;
                d.applyMatrix4(this.matrixWorld);
                const E = t.ray.origin.distanceTo(d);
                E < t.near || E > t.far || e.push({
                    distance: E,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: y,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }

    updateMorphTargets() {
        const e = this.geometry.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
            const s = e[n[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let r = 0, o = s.length; r < o; r++) {
                    const a = s[r].name || String(r);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}

const ix = new C, rx = new C;

class pi extends lr {
    constructor(t, e) {
        super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
    }

    computeLineDistances() {
        const t = this.geometry;
        if (t.index === null) {
            const e = t.attributes.position, n = [];
            for (let s = 0, r = e.count; s < r; s += 2) ix.fromBufferAttribute(e, s), rx.fromBufferAttribute(e, s + 1), n[s] = s === 0 ? 0 : n[s - 1], n[s + 1] = n[s] + ix.distanceTo(rx);
            t.setAttribute("lineDistance", new Ct(n, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}

class d0 extends lr {
    constructor(t, e) {
        super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
    }
}

class nf extends En {
    constructor(t) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new pt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
    }
}

const ox = new Yt, xm = new uh, hu = new Zr, uu = new C;

class f0 extends re {
    constructor(t = new Xt, e = new nf) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
    }

    copy(t, e) {
        return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
    }

    raycast(t, e) {
        const n = this.geometry, s = this.matrixWorld, r = t.params.Points.threshold, o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(), hu.copy(n.boundingSphere), hu.applyMatrix4(s), hu.radius += r, t.ray.intersectsSphere(hu) === !1) return;
        ox.copy(s).invert(), xm.copy(t.ray).applyMatrix4(ox);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = n.index,
            u = n.attributes.position;
        if (c !== null) {
            const d = Math.max(0, o.start), f = Math.min(c.count, o.start + o.count);
            for (let g = d, m = f; g < m; g++) {
                const p = c.getX(g);
                uu.fromBufferAttribute(u, p), ax(uu, p, l, s, t, e, this)
            }
        } else {
            const d = Math.max(0, o.start), f = Math.min(u.count, o.start + o.count);
            for (let g = d, m = f; g < m; g++) uu.fromBufferAttribute(u, g), ax(uu, g, l, s, t, e, this)
        }
    }

    updateMorphTargets() {
        const e = this.geometry.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
            const s = e[n[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let r = 0, o = s.length; r < o; r++) {
                    const a = s[r].name || String(r);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}

function ax(i, t, e, n, s, r, o) {
    const a = xm.distanceSqToPoint(i);
    if (a < e) {
        const l = new C;
        xm.closestPointToPoint(i, l), l.applyMatrix4(n);
        const c = s.ray.origin.distanceTo(l);
        if (c < s.near || c > s.far) return;
        r.push({distance: c, distanceToRay: Math.sqrt(a), point: l, index: t, face: null, object: o})
    }
}

class LR extends Sn {
    constructor(t, e, n, s, r, o, a, l, c) {
        super(t, e, n, s, r, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Qe, this.magFilter = r !== void 0 ? r : Qe, this.generateMipmaps = !1;
        const h = this;

        function u() {
            h.needsUpdate = !0, t.requestVideoFrameCallback(u)
        }

        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(u)
    }

    clone() {
        return new this.constructor(this.image).copy(this)
    }

    update() {
        const t = this.image;
        "requestVideoFrameCallback" in t === !1 && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}

class NR extends Sn {
    constructor(t, e, n) {
        super({
            width: t,
            height: e
        }), this.isFramebufferTexture = !0, this.format = n, this.magFilter = sn, this.minFilter = sn, this.generateMipmaps = !1, this.needsUpdate = !0
    }
}

class p0 extends Sn {
    constructor(t, e, n, s, r, o, a, l, c, h, u, d) {
        super(null, o, a, l, c, h, s, r, u, d), this.isCompressedTexture = !0, this.image = {
            width: e,
            height: n
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }
}

class OR extends p0 {
    constructor(t, e, n, s, r, o) {
        super(t, e, n, r, o), this.isCompressedArrayTexture = !0, this.image.depth = s, this.wrapR = kn
    }
}

class DR extends Sn {
    constructor(t, e, n, s, r, o, a, l, c) {
        super(t, e, n, s, r, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}

class gi {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }

    getPointAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getPoint(n, e)
    }

    getPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return e
    }

    getSpacedPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
        return e
    }

    getLength() {
        const t = this.getLengths();
        return t[t.length - 1]
    }

    getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const e = [];
        let n, s = this.getPoint(0), r = 0;
        e.push(0);
        for (let o = 1; o <= t; o++) n = this.getPoint(o / t), r += n.distanceTo(s), e.push(r), s = n;
        return this.cacheArcLengths = e, e
    }

    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }

    getUtoTmapping(t, e) {
        const n = this.getLengths();
        let s = 0;
        const r = n.length;
        let o;
        e ? o = e : o = t * n[r - 1];
        let a = 0, l = r - 1, c;
        for (; a <= l;) if (s = Math.floor(a + (l - a) / 2), c = n[s] - o, c < 0) a = s + 1; else if (c > 0) l = s - 1; else {
            l = s;
            break
        }
        if (s = l, n[s] === o) return s / (r - 1);
        const h = n[s], d = n[s + 1] - h, f = (o - h) / d;
        return (s + f) / (r - 1)
    }

    getTangent(t, e) {
        let s = t - 1e-4, r = t + 1e-4;
        s < 0 && (s = 0), r > 1 && (r = 1);
        const o = this.getPoint(s), a = this.getPoint(r), l = e || (o.isVector2 ? new j : new C);
        return l.copy(a).sub(o).normalize(), l
    }

    getTangentAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getTangent(n, e)
    }

    computeFrenetFrames(t, e) {
        const n = new C, s = [], r = [], o = [], a = new C, l = new Yt;
        for (let f = 0; f <= t; f++) {
            const g = f / t;
            s[f] = this.getTangentAt(g, new C)
        }
        r[0] = new C, o[0] = new C;
        let c = Number.MAX_VALUE;
        const h = Math.abs(s[0].x), u = Math.abs(s[0].y), d = Math.abs(s[0].z);
        h <= c && (c = h, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), d <= c && n.set(0, 0, 1), a.crossVectors(s[0], n).normalize(), r[0].crossVectors(s[0], a), o[0].crossVectors(s[0], r[0]);
        for (let f = 1; f <= t; f++) {
            if (r[f] = r[f - 1].clone(), o[f] = o[f - 1].clone(), a.crossVectors(s[f - 1], s[f]), a.length() > Number.EPSILON) {
                a.normalize();
                const g = Math.acos(un(s[f - 1].dot(s[f]), -1, 1));
                r[f].applyMatrix4(l.makeRotationAxis(a, g))
            }
            o[f].crossVectors(s[f], r[f])
        }
        if (e === !0) {
            let f = Math.acos(un(r[0].dot(r[t]), -1, 1));
            f /= t, s[0].dot(a.crossVectors(r[0], r[t])) > 0 && (f = -f);
            for (let g = 1; g <= t; g++) r[g].applyMatrix4(l.makeRotationAxis(s[g], f * g)), o[g].crossVectors(s[g], r[g])
        }
        return {tangents: s, normals: r, binormals: o}
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }

    toJSON() {
        const t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
    }

    fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
}

class sf extends gi {
    constructor(t = 0, e = 0, n = 1, s = 1, r = 0, o = Math.PI * 2, a = !1, l = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = s, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
    }

    getPoint(t, e) {
        const n = e || new j, s = Math.PI * 2;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0;) r += s;
        for (; r > s;) r -= s;
        r < Number.EPSILON && (o ? r = 0 : r = s), this.aClockwise === !0 && !o && (r === s ? r = -s : r = r - s);
        const a = this.aStartAngle + t * r;
        let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation), u = Math.sin(this.aRotation), d = l - this.aX, f = c - this.aY;
            l = d * h - f * u + this.aX, c = d * u + f * h + this.aY
        }
        return n.set(l, c)
    }

    copy(t) {
        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }

    toJSON() {
        const t = super.toJSON();
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }
}

class nE extends sf {
    constructor(t, e, n, s, r, o) {
        super(t, e, n, n, s, r, o), this.isArcCurve = !0, this.type = "ArcCurve"
    }
}

function g0() {
    let i = 0, t = 0, e = 0, n = 0;

    function s(r, o, a, l) {
        i = r, t = a, e = -3 * r + 3 * o - 2 * a - l, n = 2 * r - 2 * o + a + l
    }

    return {
        initCatmullRom: function (r, o, a, l, c) {
            s(o, a, c * (a - r), c * (l - o))
        }, initNonuniformCatmullRom: function (r, o, a, l, c, h, u) {
            let d = (o - r) / c - (a - r) / (c + h) + (a - o) / h, f = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
            d *= h, f *= h, s(o, a, d, f)
        }, calc: function (r) {
            const o = r * r, a = o * r;
            return i + t * r + e * o + n * a
        }
    }
}

const du = new C, Up = new g0, Gp = new g0, Vp = new g0;

class sE extends gi {
    constructor(t = [], e = !1, n = "centripetal", s = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = s
    }

    getPoint(t, e = new C) {
        const n = e, s = this.points, r = s.length, o = (r - (this.closed ? 0 : 1)) * t;
        let a = Math.floor(o), l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
        let c, h;
        this.closed || a > 0 ? c = s[(a - 1) % r] : (du.subVectors(s[0], s[1]).add(s[0]), c = du);
        const u = s[a % r], d = s[(a + 1) % r];
        if (this.closed || a + 2 < r ? h = s[(a + 2) % r] : (du.subVectors(s[r - 1], s[r - 2]).add(s[r - 1]), h = du), this.curveType === "centripetal" || this.curveType === "chordal") {
            const f = this.curveType === "chordal" ? .5 : .25;
            let g = Math.pow(c.distanceToSquared(u), f), m = Math.pow(u.distanceToSquared(d), f),
                p = Math.pow(d.distanceToSquared(h), f);
            m < 1e-4 && (m = 1), g < 1e-4 && (g = m), p < 1e-4 && (p = m), Up.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, g, m, p), Gp.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, g, m, p), Vp.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, g, m, p)
        } else this.curveType === "catmullrom" && (Up.initCatmullRom(c.x, u.x, d.x, h.x, this.tension), Gp.initCatmullRom(c.y, u.y, d.y, h.y, this.tension), Vp.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
        return n.set(Up.calc(l), Gp.calc(l), Vp.calc(l)), n
    }

    copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const s = t.points[e];
            this.points.push(s.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }

    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const s = this.points[e];
            t.points.push(s.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }

    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const s = t.points[e];
            this.points.push(new C().fromArray(s))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }
}

function lx(i, t, e, n, s) {
    const r = (n - t) * .5, o = (s - e) * .5, a = i * i, l = i * a;
    return (2 * e - 2 * n + r + o) * l + (-3 * e + 3 * n - 2 * r - o) * a + r * i + e
}

function FR(i, t) {
    const e = 1 - i;
    return e * e * t
}

function zR(i, t) {
    return 2 * (1 - i) * i * t
}

function BR(i, t) {
    return i * i * t
}

function Mc(i, t, e, n) {
    return FR(i, t) + zR(i, e) + BR(i, n)
}

function kR(i, t) {
    const e = 1 - i;
    return e * e * e * t
}

function UR(i, t) {
    const e = 1 - i;
    return 3 * e * e * i * t
}

function GR(i, t) {
    return 3 * (1 - i) * i * i * t
}

function VR(i, t) {
    return i * i * i * t
}

function Tc(i, t, e, n, s) {
    return kR(i, t) + UR(i, e) + GR(i, n) + VR(i, s)
}

class m0 extends gi {
    constructor(t = new j, e = new j, n = new j, s = new j) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = s
    }

    getPoint(t, e = new j) {
        const n = e, s = this.v0, r = this.v1, o = this.v2, a = this.v3;
        return n.set(Tc(t, s.x, r.x, o.x, a.x), Tc(t, s.y, r.y, o.y, a.y)), n
    }

    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }

    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
}

class iE extends gi {
    constructor(t = new C, e = new C, n = new C, s = new C) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = s
    }

    getPoint(t, e = new C) {
        const n = e, s = this.v0, r = this.v1, o = this.v2, a = this.v3;
        return n.set(Tc(t, s.x, r.x, o.x, a.x), Tc(t, s.y, r.y, o.y, a.y), Tc(t, s.z, r.z, o.z, a.z)), n
    }

    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }

    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
}

class rf extends gi {
    constructor(t = new j, e = new j) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e
    }

    getPoint(t, e = new j) {
        const n = e;
        return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }

    getPointAt(t, e) {
        return this.getPoint(t, e)
    }

    getTangent(t, e) {
        const n = e || new j;
        return n.copy(this.v2).sub(this.v1).normalize(), n
    }

    copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }

    toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}

class rE extends gi {
    constructor(t = new C, e = new C) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e
    }

    getPoint(t, e = new C) {
        const n = e;
        return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }

    getPointAt(t, e) {
        return this.getPoint(t, e)
    }

    copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }

    toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}

class _0 extends gi {
    constructor(t = new j, e = new j, n = new j) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
    }

    getPoint(t, e = new j) {
        const n = e, s = this.v0, r = this.v1, o = this.v2;
        return n.set(Mc(t, s.x, r.x, o.x), Mc(t, s.y, r.y, o.y)), n
    }

    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }

    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}

class y0 extends gi {
    constructor(t = new C, e = new C, n = new C) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
    }

    getPoint(t, e = new C) {
        const n = e, s = this.v0, r = this.v1, o = this.v2;
        return n.set(Mc(t, s.x, r.x, o.x), Mc(t, s.y, r.y, o.y), Mc(t, s.z, r.z, o.z)), n
    }

    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }

    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}

class x0 extends gi {
    constructor(t = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t
    }

    getPoint(t, e = new j) {
        const n = e, s = this.points, r = (s.length - 1) * t, o = Math.floor(r), a = r - o, l = s[o === 0 ? o : o - 1],
            c = s[o], h = s[o > s.length - 2 ? s.length - 1 : o + 1], u = s[o > s.length - 3 ? s.length - 1 : o + 2];
        return n.set(lx(a, l.x, c.x, h.x, u.x), lx(a, l.y, c.y, h.y, u.y)), n
    }

    copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const s = t.points[e];
            this.points.push(s.clone())
        }
        return this
    }

    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const s = this.points[e];
            t.points.push(s.toArray())
        }
        return t
    }

    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const s = t.points[e];
            this.points.push(new j().fromArray(s))
        }
        return this
    }
}

var v0 = Object.freeze({
    __proto__: null,
    ArcCurve: nE,
    CatmullRomCurve3: sE,
    CubicBezierCurve: m0,
    CubicBezierCurve3: iE,
    EllipseCurve: sf,
    LineCurve: rf,
    LineCurve3: rE,
    QuadraticBezierCurve: _0,
    QuadraticBezierCurve3: y0,
    SplineCurve: x0
});

class oE extends gi {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    add(t) {
        this.curves.push(t)
    }

    closePath() {
        const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new rf(e, t))
    }

    getPoint(t, e) {
        const n = t * this.getLength(), s = this.getCurveLengths();
        let r = 0;
        for (; r < s.length;) {
            if (s[r] >= n) {
                const o = s[r] - n, a = this.curves[r], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, e)
            }
            r++
        }
        return null
    }

    getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1]
    }

    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }

    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let n = 0, s = this.curves.length; n < s; n++) e += this.curves[n].getLength(), t.push(e);
        return this.cacheLengths = t, t
    }

    getSpacedPoints(t = 40) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return this.autoClose && e.push(e[0]), e
    }

    getPoints(t = 12) {
        const e = [];
        let n;
        for (let s = 0, r = this.curves; s < r.length; s++) {
            const o = r[s],
                a = o.isEllipseCurve ? t * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? t * o.points.length : t,
                l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const h = l[c];
                n && n.equals(h) || (e.push(h), n = h)
            }
        }
        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
    }

    copy(t) {
        super.copy(t), this.curves = [];
        for (let e = 0, n = t.curves.length; e < n; e++) {
            const s = t.curves[e];
            this.curves.push(s.clone())
        }
        return this.autoClose = t.autoClose, this
    }

    toJSON() {
        const t = super.toJSON();
        t.autoClose = this.autoClose, t.curves = [];
        for (let e = 0, n = this.curves.length; e < n; e++) {
            const s = this.curves[e];
            t.curves.push(s.toJSON())
        }
        return t
    }

    fromJSON(t) {
        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
        for (let e = 0, n = t.curves.length; e < n; e++) {
            const s = t.curves[e];
            this.curves.push(new v0[s.type]().fromJSON(s))
        }
        return this
    }
}

class Uc extends oE {
    constructor(t) {
        super(), this.type = "Path", this.currentPoint = new j, t && this.setFromPoints(t)
    }

    setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
        return this
    }

    moveTo(t, e) {
        return this.currentPoint.set(t, e), this
    }

    lineTo(t, e) {
        const n = new rf(this.currentPoint.clone(), new j(t, e));
        return this.curves.push(n), this.currentPoint.set(t, e), this
    }

    quadraticCurveTo(t, e, n, s) {
        const r = new _0(this.currentPoint.clone(), new j(t, e), new j(n, s));
        return this.curves.push(r), this.currentPoint.set(n, s), this
    }

    bezierCurveTo(t, e, n, s, r, o) {
        const a = new m0(this.currentPoint.clone(), new j(t, e), new j(n, s), new j(r, o));
        return this.curves.push(a), this.currentPoint.set(r, o), this
    }

    splineThru(t) {
        const e = [this.currentPoint.clone()].concat(t), n = new x0(e);
        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
    }

    arc(t, e, n, s, r, o) {
        const a = this.currentPoint.x, l = this.currentPoint.y;
        return this.absarc(t + a, e + l, n, s, r, o), this
    }

    absarc(t, e, n, s, r, o) {
        return this.absellipse(t, e, n, n, s, r, o), this
    }

    ellipse(t, e, n, s, r, o, a, l) {
        const c = this.currentPoint.x, h = this.currentPoint.y;
        return this.absellipse(t + c, e + h, n, s, r, o, a, l), this
    }

    absellipse(t, e, n, s, r, o, a, l) {
        const c = new sf(t, e, n, s, r, o, a, l);
        if (this.curves.length > 0) {
            const u = c.getPoint(0);
            u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
        }
        this.curves.push(c);
        const h = c.getPoint(1);
        return this.currentPoint.copy(h), this
    }

    copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this
    }

    toJSON() {
        const t = super.toJSON();
        return t.currentPoint = this.currentPoint.toArray(), t
    }

    fromJSON(t) {
        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
    }
}

class Il extends Xt {
    constructor(t = [new j(0, -.5), new j(.5, 0), new j(0, .5)], e = 12, n = 0, s = Math.PI * 2) {
        super(), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: s
        }, e = Math.floor(e), s = un(s, 0, Math.PI * 2);
        const r = [], o = [], a = [], l = [], c = [], h = 1 / e, u = new C, d = new j, f = new C, g = new C, m = new C;
        let p = 0, _ = 0;
        for (let x = 0; x <= t.length - 1; x++) switch (x) {
            case 0:
                p = t[x + 1].x - t[x].x, _ = t[x + 1].y - t[x].y, f.x = _ * 1, f.y = -p, f.z = _ * 0, m.copy(f), f.normalize(), l.push(f.x, f.y, f.z);
                break;
            case t.length - 1:
                l.push(m.x, m.y, m.z);
                break;
            default:
                p = t[x + 1].x - t[x].x, _ = t[x + 1].y - t[x].y, f.x = _ * 1, f.y = -p, f.z = _ * 0, g.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), l.push(f.x, f.y, f.z), m.copy(g)
        }
        for (let x = 0; x <= e; x++) {
            const y = n + x * h * s, v = Math.sin(y), w = Math.cos(y);
            for (let E = 0; E <= t.length - 1; E++) {
                u.x = t[E].x * v, u.y = t[E].y, u.z = t[E].x * w, o.push(u.x, u.y, u.z), d.x = x / e, d.y = E / (t.length - 1), a.push(d.x, d.y);
                const S = l[3 * E + 0] * v, b = l[3 * E + 1], M = l[3 * E + 0] * w;
                c.push(S, b, M)
            }
        }
        for (let x = 0; x < e; x++) for (let y = 0; y < t.length - 1; y++) {
            const v = y + x * t.length, w = v, E = v + t.length, S = v + t.length + 1, b = v + 1;
            r.push(w, E, b), r.push(S, b, E)
        }
        this.setIndex(r), this.setAttribute("position", new Ct(o, 3)), this.setAttribute("uv", new Ct(a, 2)), this.setAttribute("normal", new Ct(c, 3))
    }

    static fromJSON(t) {
        return new Il(t.points, t.segments, t.phiStart, t.phiLength)
    }
}

class gh extends Il {
    constructor(t = 1, e = 1, n = 4, s = 8) {
        const r = new Uc;
        r.absarc(0, -e / 2, t, Math.PI * 1.5, 0), r.absarc(0, e / 2, t, 0, Math.PI * .5), super(r.getPoints(n), s), this.type = "CapsuleGeometry", this.parameters = {
            radius: t,
            height: e,
            capSegments: n,
            radialSegments: s
        }
    }

    static fromJSON(t) {
        return new gh(t.radius, t.length, t.capSegments, t.radialSegments)
    }
}

class mh extends Xt {
    constructor(t = 1, e = 32, n = 0, s = Math.PI * 2) {
        super(), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: s
        }, e = Math.max(3, e);
        const r = [], o = [], a = [], l = [], c = new C, h = new j;
        o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5);
        for (let u = 0, d = 3; u <= e; u++, d += 3) {
            const f = n + u / e * s;
            c.x = t * Math.cos(f), c.y = t * Math.sin(f), o.push(c.x, c.y, c.z), a.push(0, 0, 1), h.x = (o[d] / t + 1) / 2, h.y = (o[d + 1] / t + 1) / 2, l.push(h.x, h.y)
        }
        for (let u = 1; u <= e; u++) r.push(u, u + 1, 0);
        this.setIndex(r), this.setAttribute("position", new Ct(o, 3)), this.setAttribute("normal", new Ct(a, 3)), this.setAttribute("uv", new Ct(l, 2))
    }

    static fromJSON(t) {
        return new mh(t.radius, t.segments, t.thetaStart, t.thetaLength)
    }
}

class qo extends Xt {
    constructor(t = 1, e = 1, n = 1, s = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
        super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: s,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        s = Math.floor(s), r = Math.floor(r);
        const h = [], u = [], d = [], f = [];
        let g = 0;
        const m = [], p = n / 2;
        let _ = 0;
        x(), o === !1 && (t > 0 && y(!0), e > 0 && y(!1)), this.setIndex(h), this.setAttribute("position", new Ct(u, 3)), this.setAttribute("normal", new Ct(d, 3)), this.setAttribute("uv", new Ct(f, 2));

        function x() {
            const v = new C, w = new C;
            let E = 0;
            const S = (e - t) / n;
            for (let b = 0; b <= r; b++) {
                const M = [], I = b / r, N = I * (e - t) + t;
                for (let B = 0; B <= s; B++) {
                    const D = B / s, L = D * l + a, k = Math.sin(L), G = Math.cos(L);
                    w.x = N * k, w.y = -I * n + p, w.z = N * G, u.push(w.x, w.y, w.z), v.set(k, S, G).normalize(), d.push(v.x, v.y, v.z), f.push(D, 1 - I), M.push(g++)
                }
                m.push(M)
            }
            for (let b = 0; b < s; b++) for (let M = 0; M < r; M++) {
                const I = m[M][b], N = m[M + 1][b], B = m[M + 1][b + 1], D = m[M][b + 1];
                h.push(I, N, D), h.push(N, B, D), E += 6
            }
            c.addGroup(_, E, 0), _ += E
        }

        function y(v) {
            const w = g, E = new j, S = new C;
            let b = 0;
            const M = v === !0 ? t : e, I = v === !0 ? 1 : -1;
            for (let B = 1; B <= s; B++) u.push(0, p * I, 0), d.push(0, I, 0), f.push(.5, .5), g++;
            const N = g;
            for (let B = 0; B <= s; B++) {
                const L = B / s * l + a, k = Math.cos(L), G = Math.sin(L);
                S.x = M * G, S.y = p * I, S.z = M * k, u.push(S.x, S.y, S.z), d.push(0, I, 0), E.x = k * .5 + .5, E.y = G * .5 * I + .5, f.push(E.x, E.y), g++
            }
            for (let B = 0; B < s; B++) {
                const D = w + B, L = N + B;
                v === !0 ? h.push(L, L + 1, D) : h.push(L + 1, L, D), b += 3
            }
            c.addGroup(_, b, v === !0 ? 1 : 2), _ += b
        }
    }

    static fromJSON(t) {
        return new qo(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
    }
}

class _h extends qo {
    constructor(t = 1, e = 1, n = 32, s = 1, r = !1, o = 0, a = Math.PI * 2) {
        super(0, t, e, n, s, r, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: s,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    static fromJSON(t) {
        return new _h(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
    }
}

class ur extends Xt {
    constructor(t = [], e = [], n = 1, s = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {vertices: t, indices: e, radius: n, detail: s};
        const r = [], o = [];
        a(s), c(n), h(), this.setAttribute("position", new Ct(r, 3)), this.setAttribute("normal", new Ct(r.slice(), 3)), this.setAttribute("uv", new Ct(o, 2)), s === 0 ? this.computeVertexNormals() : this.normalizeNormals();

        function a(x) {
            const y = new C, v = new C, w = new C;
            for (let E = 0; E < e.length; E += 3) f(e[E + 0], y), f(e[E + 1], v), f(e[E + 2], w), l(y, v, w, x)
        }

        function l(x, y, v, w) {
            const E = w + 1, S = [];
            for (let b = 0; b <= E; b++) {
                S[b] = [];
                const M = x.clone().lerp(v, b / E), I = y.clone().lerp(v, b / E), N = E - b;
                for (let B = 0; B <= N; B++) B === 0 && b === E ? S[b][B] = M : S[b][B] = M.clone().lerp(I, B / N)
            }
            for (let b = 0; b < E; b++) for (let M = 0; M < 2 * (E - b) - 1; M++) {
                const I = Math.floor(M / 2);
                M % 2 === 0 ? (d(S[b][I + 1]), d(S[b + 1][I]), d(S[b][I])) : (d(S[b][I + 1]), d(S[b + 1][I + 1]), d(S[b + 1][I]))
            }
        }

        function c(x) {
            const y = new C;
            for (let v = 0; v < r.length; v += 3) y.x = r[v + 0], y.y = r[v + 1], y.z = r[v + 2], y.normalize().multiplyScalar(x), r[v + 0] = y.x, r[v + 1] = y.y, r[v + 2] = y.z
        }

        function h() {
            const x = new C;
            for (let y = 0; y < r.length; y += 3) {
                x.x = r[y + 0], x.y = r[y + 1], x.z = r[y + 2];
                const v = p(x) / 2 / Math.PI + .5, w = _(x) / Math.PI + .5;
                o.push(v, 1 - w)
            }
            g(), u()
        }

        function u() {
            for (let x = 0; x < o.length; x += 6) {
                const y = o[x + 0], v = o[x + 2], w = o[x + 4], E = Math.max(y, v, w), S = Math.min(y, v, w);
                E > .9 && S < .1 && (y < .2 && (o[x + 0] += 1), v < .2 && (o[x + 2] += 1), w < .2 && (o[x + 4] += 1))
            }
        }

        function d(x) {
            r.push(x.x, x.y, x.z)
        }

        function f(x, y) {
            const v = x * 3;
            y.x = t[v + 0], y.y = t[v + 1], y.z = t[v + 2]
        }

        function g() {
            const x = new C, y = new C, v = new C, w = new C, E = new j, S = new j, b = new j;
            for (let M = 0, I = 0; M < r.length; M += 9, I += 6) {
                x.set(r[M + 0], r[M + 1], r[M + 2]), y.set(r[M + 3], r[M + 4], r[M + 5]), v.set(r[M + 6], r[M + 7], r[M + 8]), E.set(o[I + 0], o[I + 1]), S.set(o[I + 2], o[I + 3]), b.set(o[I + 4], o[I + 5]), w.copy(x).add(y).add(v).divideScalar(3);
                const N = p(w);
                m(E, I + 0, x, N), m(S, I + 2, y, N), m(b, I + 4, v, N)
            }
        }

        function m(x, y, v, w) {
            w < 0 && x.x === 1 && (o[y] = x.x - 1), v.x === 0 && v.z === 0 && (o[y] = w / 2 / Math.PI + .5)
        }

        function p(x) {
            return Math.atan2(x.z, -x.x)
        }

        function _(x) {
            return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z))
        }
    }

    static fromJSON(t) {
        return new ur(t.vertices, t.indices, t.radius, t.details)
    }
}

class yh extends ur {
    constructor(t = 1, e = 0) {
        const n = (1 + Math.sqrt(5)) / 2, s = 1 / n,
            r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -s, -n, 0, -s, n, 0, s, -n, 0, s, n, -s, -n, 0, -s, n, 0, s, -n, 0, s, n, 0, -n, 0, -s, n, 0, -s, -n, 0, s, n, 0, s],
            o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(r, o, t, e), this.type = "DodecahedronGeometry", this.parameters = {radius: t, detail: e}
    }

    static fromJSON(t) {
        return new yh(t.radius, t.detail)
    }
}

const fu = new C, pu = new C, Hp = new C, gu = new Oo;

class aE extends Xt {
    constructor(t = null, e = 1) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {geometry: t, thresholdAngle: e}, t !== null) {
            const s = Math.pow(10, 4), r = Math.cos(Lo * e), o = t.getIndex(), a = t.getAttribute("position"),
                l = o ? o.count : a.count, c = [0, 0, 0], h = ["a", "b", "c"], u = new Array(3), d = {}, f = [];
            for (let g = 0; g < l; g += 3) {
                o ? (c[0] = o.getX(g), c[1] = o.getX(g + 1), c[2] = o.getX(g + 2)) : (c[0] = g, c[1] = g + 1, c[2] = g + 2);
                const {a: m, b: p, c: _} = gu;
                if (m.fromBufferAttribute(a, c[0]), p.fromBufferAttribute(a, c[1]), _.fromBufferAttribute(a, c[2]), gu.getNormal(Hp), u[0] = `${Math.round(m.x * s)},${Math.round(m.y * s)},${Math.round(m.z * s)}`, u[1] = `${Math.round(p.x * s)},${Math.round(p.y * s)},${Math.round(p.z * s)}`, u[2] = `${Math.round(_.x * s)},${Math.round(_.y * s)},${Math.round(_.z * s)}`, !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0])) for (let x = 0; x < 3; x++) {
                    const y = (x + 1) % 3, v = u[x], w = u[y], E = gu[h[x]], S = gu[h[y]], b = `${v}_${w}`,
                        M = `${w}_${v}`;
                    M in d && d[M] ? (Hp.dot(d[M].normal) <= r && (f.push(E.x, E.y, E.z), f.push(S.x, S.y, S.z)), d[M] = null) : b in d || (d[b] = {
                        index0: c[x],
                        index1: c[y],
                        normal: Hp.clone()
                    })
                }
            }
            for (const g in d) if (d[g]) {
                const {index0: m, index1: p} = d[g];
                fu.fromBufferAttribute(a, m), pu.fromBufferAttribute(a, p), f.push(fu.x, fu.y, fu.z), f.push(pu.x, pu.y, pu.z)
            }
            this.setAttribute("position", new Ct(f, 3))
        }
    }
}

class Do extends Uc {
    constructor(t) {
        super(t), this.uuid = zs(), this.type = "Shape", this.holes = []
    }

    getPointsHoles(t) {
        const e = [];
        for (let n = 0, s = this.holes.length; n < s; n++) e[n] = this.holes[n].getPoints(t);
        return e
    }

    extractPoints(t) {
        return {shape: this.getPoints(t), holes: this.getPointsHoles(t)}
    }

    copy(t) {
        super.copy(t), this.holes = [];
        for (let e = 0, n = t.holes.length; e < n; e++) {
            const s = t.holes[e];
            this.holes.push(s.clone())
        }
        return this
    }

    toJSON() {
        const t = super.toJSON();
        t.uuid = this.uuid, t.holes = [];
        for (let e = 0, n = this.holes.length; e < n; e++) {
            const s = this.holes[e];
            t.holes.push(s.toJSON())
        }
        return t
    }

    fromJSON(t) {
        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
        for (let e = 0, n = t.holes.length; e < n; e++) {
            const s = t.holes[e];
            this.holes.push(new Uc().fromJSON(s))
        }
        return this
    }
}

const HR = {
    triangulate: function (i, t, e = 2) {
        const n = t && t.length, s = n ? t[0] * e : i.length;
        let r = lE(i, 0, s, e, !0);
        const o = [];
        if (!r || r.next === r.prev) return o;
        let a, l, c, h, u, d, f;
        if (n && (r = XR(i, t, r, e)), i.length > 80 * e) {
            a = c = i[0], l = h = i[1];
            for (let g = e; g < s; g += e) u = i[g], d = i[g + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
            f = Math.max(c - a, h - l), f = f !== 0 ? 32767 / f : 0
        }
        return Gc(r, o, e, a, l, f, 0), o
    }
};

function lE(i, t, e, n, s) {
    let r, o;
    if (s === rL(i, t, e, n) > 0) for (r = t; r < e; r += n) o = cx(r, i[r], i[r + 1], o); else for (r = e - n; r >= t; r -= n) o = cx(r, i[r], i[r + 1], o);
    return o && of(o, o.next) && (Hc(o), o = o.next), o
}

function Uo(i, t) {
    if (!i) return i;
    t || (t = i);
    let e = i, n;
    do if (n = !1, !e.steiner && (of(e, e.next) || tn(e.prev, e, e.next) === 0)) {
        if (Hc(e), e = t = e.prev, e === e.next) break;
        n = !0
    } else e = e.next; while (n || e !== t);
    return t
}

function Gc(i, t, e, n, s, r, o) {
    if (!i) return;
    !o && r && QR(i, n, s, r);
    let a = i, l, c;
    for (; i.prev !== i.next;) {
        if (l = i.prev, c = i.next, r ? WR(i, n, s, r) : $R(i)) {
            t.push(l.i / e | 0), t.push(i.i / e | 0), t.push(c.i / e | 0), Hc(i), i = c.next, a = c.next;
            continue
        }
        if (i = c, i === a) {
            o ? o === 1 ? (i = qR(Uo(i), t, e), Gc(i, t, e, n, s, r, 2)) : o === 2 && YR(i, t, e, n, s, r) : Gc(Uo(i), t, e, n, s, r, 1);
            break
        }
    }
}

function $R(i) {
    const t = i.prev, e = i, n = i.next;
    if (tn(t, e, n) >= 0) return !1;
    const s = t.x, r = e.x, o = n.x, a = t.y, l = e.y, c = n.y, h = s < r ? s < o ? s : o : r < o ? r : o,
        u = a < l ? a < c ? a : c : l < c ? l : c, d = s > r ? s > o ? s : o : r > o ? r : o,
        f = a > l ? a > c ? a : c : l > c ? l : c;
    let g = n.next;
    for (; g !== t;) {
        if (g.x >= h && g.x <= d && g.y >= u && g.y <= f && Oa(s, a, r, l, o, c, g.x, g.y) && tn(g.prev, g, g.next) >= 0) return !1;
        g = g.next
    }
    return !0
}

function WR(i, t, e, n) {
    const s = i.prev, r = i, o = i.next;
    if (tn(s, r, o) >= 0) return !1;
    const a = s.x, l = r.x, c = o.x, h = s.y, u = r.y, d = o.y, f = a < l ? a < c ? a : c : l < c ? l : c,
        g = h < u ? h < d ? h : d : u < d ? u : d, m = a > l ? a > c ? a : c : l > c ? l : c,
        p = h > u ? h > d ? h : d : u > d ? u : d, _ = vm(f, g, t, e, n), x = vm(m, p, t, e, n);
    let y = i.prevZ, v = i.nextZ;
    for (; y && y.z >= _ && v && v.z <= x;) {
        if (y.x >= f && y.x <= m && y.y >= g && y.y <= p && y !== s && y !== o && Oa(a, h, l, u, c, d, y.x, y.y) && tn(y.prev, y, y.next) >= 0 || (y = y.prevZ, v.x >= f && v.x <= m && v.y >= g && v.y <= p && v !== s && v !== o && Oa(a, h, l, u, c, d, v.x, v.y) && tn(v.prev, v, v.next) >= 0)) return !1;
        v = v.nextZ
    }
    for (; y && y.z >= _;) {
        if (y.x >= f && y.x <= m && y.y >= g && y.y <= p && y !== s && y !== o && Oa(a, h, l, u, c, d, y.x, y.y) && tn(y.prev, y, y.next) >= 0) return !1;
        y = y.prevZ
    }
    for (; v && v.z <= x;) {
        if (v.x >= f && v.x <= m && v.y >= g && v.y <= p && v !== s && v !== o && Oa(a, h, l, u, c, d, v.x, v.y) && tn(v.prev, v, v.next) >= 0) return !1;
        v = v.nextZ
    }
    return !0
}

function qR(i, t, e) {
    let n = i;
    do {
        const s = n.prev, r = n.next.next;
        !of(s, r) && cE(s, n, n.next, r) && Vc(s, r) && Vc(r, s) && (t.push(s.i / e | 0), t.push(n.i / e | 0), t.push(r.i / e | 0), Hc(n), Hc(n.next), n = i = r), n = n.next
    } while (n !== i);
    return Uo(n)
}

function YR(i, t, e, n, s, r) {
    let o = i;
    do {
        let a = o.next.next;
        for (; a !== o.prev;) {
            if (o.i !== a.i && nL(o, a)) {
                let l = hE(o, a);
                o = Uo(o, o.next), l = Uo(l, l.next), Gc(o, t, e, n, s, r, 0), Gc(l, t, e, n, s, r, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== i)
}

function XR(i, t, e, n) {
    const s = [];
    let r, o, a, l, c;
    for (r = 0, o = t.length; r < o; r++) a = t[r] * n, l = r < o - 1 ? t[r + 1] * n : i.length, c = lE(i, a, l, n, !1), c === c.next && (c.steiner = !0), s.push(eL(c));
    for (s.sort(ZR), r = 0; r < s.length; r++) e = jR(s[r], e);
    return e
}

function ZR(i, t) {
    return i.x - t.x
}

function jR(i, t) {
    const e = KR(i, t);
    if (!e) return t;
    const n = hE(e, i);
    return Uo(n, n.next), Uo(e, e.next)
}

function KR(i, t) {
    let e = t, n = -1 / 0, s;
    const r = i.x, o = i.y;
    do {
        if (o <= e.y && o >= e.next.y && e.next.y !== e.y) {
            const d = e.x + (o - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
            if (d <= r && d > n && (n = d, s = e.x < e.next.x ? e : e.next, d === r)) return s
        }
        e = e.next
    } while (e !== t);
    if (!s) return null;
    const a = s, l = s.x, c = s.y;
    let h = 1 / 0, u;
    e = s;
    do r >= e.x && e.x >= l && r !== e.x && Oa(o < c ? r : n, o, l, c, o < c ? n : r, o, e.x, e.y) && (u = Math.abs(o - e.y) / (r - e.x), Vc(e, i) && (u < h || u === h && (e.x > s.x || e.x === s.x && JR(s, e))) && (s = e, h = u)), e = e.next; while (e !== a);
    return s
}

function JR(i, t) {
    return tn(i.prev, i, t.prev) < 0 && tn(t.next, i, i.next) < 0
}

function QR(i, t, e, n) {
    let s = i;
    do s.z === 0 && (s.z = vm(s.x, s.y, t, e, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; while (s !== i);
    s.prevZ.nextZ = null, s.prevZ = null, tL(s)
}

function tL(i) {
    let t, e, n, s, r, o, a, l, c = 1;
    do {
        for (e = i, i = null, r = null, o = 0; e;) {
            for (o++, n = e, a = 0, t = 0; t < c && (a++, n = n.nextZ, !!n); t++) ;
            for (l = c; a > 0 || l > 0 && n;) a !== 0 && (l === 0 || !n || e.z <= n.z) ? (s = e, e = e.nextZ, a--) : (s = n, n = n.nextZ, l--), r ? r.nextZ = s : i = s, s.prevZ = r, r = s;
            e = n
        }
        r.nextZ = null, c *= 2
    } while (o > 1);
    return i
}

function vm(i, t, e, n, s) {
    return i = (i - e) * s | 0, t = (t - n) * s | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1
}

function eL(i) {
    let t = i, e = i;
    do (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next; while (t !== i);
    return e
}

function Oa(i, t, e, n, s, r, o, a) {
    return (s - o) * (t - a) >= (i - o) * (r - a) && (i - o) * (n - a) >= (e - o) * (t - a) && (e - o) * (r - a) >= (s - o) * (n - a)
}

function nL(i, t) {
    return i.next.i !== t.i && i.prev.i !== t.i && !sL(i, t) && (Vc(i, t) && Vc(t, i) && iL(i, t) && (tn(i.prev, i, t.prev) || tn(i, t.prev, t)) || of(i, t) && tn(i.prev, i, i.next) > 0 && tn(t.prev, t, t.next) > 0)
}

function tn(i, t, e) {
    return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y)
}

function of(i, t) {
    return i.x === t.x && i.y === t.y
}

function cE(i, t, e, n) {
    const s = _u(tn(i, t, e)), r = _u(tn(i, t, n)), o = _u(tn(e, n, i)), a = _u(tn(e, n, t));
    return !!(s !== r && o !== a || s === 0 && mu(i, e, t) || r === 0 && mu(i, n, t) || o === 0 && mu(e, i, n) || a === 0 && mu(e, t, n))
}

function mu(i, t, e) {
    return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y)
}

function _u(i) {
    return i > 0 ? 1 : i < 0 ? -1 : 0
}

function sL(i, t) {
    let e = i;
    do {
        if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && cE(e, e.next, i, t)) return !0;
        e = e.next
    } while (e !== i);
    return !1
}

function Vc(i, t) {
    return tn(i.prev, i, i.next) < 0 ? tn(i, t, i.next) >= 0 && tn(i, i.prev, t) >= 0 : tn(i, t, i.prev) < 0 || tn(i, i.next, t) < 0
}

function iL(i, t) {
    let e = i, n = !1;
    const s = (i.x + t.x) / 2, r = (i.y + t.y) / 2;
    do e.y > r != e.next.y > r && e.next.y !== e.y && s < (e.next.x - e.x) * (r - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next; while (e !== i);
    return n
}

function hE(i, t) {
    const e = new wm(i.i, i.x, i.y), n = new wm(t.i, t.x, t.y), s = i.next, r = t.prev;
    return i.next = t, t.prev = i, e.next = s, s.prev = e, n.next = e, e.prev = n, r.next = n, n.prev = r, n
}

function cx(i, t, e, n) {
    const s = new wm(i, t, e);
    return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s
}

function Hc(i) {
    i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
}

function wm(i, t, e) {
    this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function rL(i, t, e, n) {
    let s = 0;
    for (let r = t, o = e - n; r < e; r += n) s += (i[o] - i[r]) * (i[r + 1] + i[o + 1]), o = r;
    return s
}

class Ri {
    static area(t) {
        const e = t.length;
        let n = 0;
        for (let s = e - 1, r = 0; r < e; s = r++) n += t[s].x * t[r].y - t[r].x * t[s].y;
        return n * .5
    }

    static isClockWise(t) {
        return Ri.area(t) < 0
    }

    static triangulateShape(t, e) {
        const n = [], s = [], r = [];
        hx(t), ux(n, t);
        let o = t.length;
        e.forEach(hx);
        for (let l = 0; l < e.length; l++) s.push(o), o += e[l].length, ux(n, e[l]);
        const a = HR.triangulate(n, s);
        for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
        return r
    }
}

function hx(i) {
    const t = i.length;
    t > 2 && i[t - 1].equals(i[0]) && i.pop()
}

function ux(i, t) {
    for (let e = 0; e < t.length; e++) i.push(t[e].x), i.push(t[e].y)
}

class xh extends Xt {
    constructor(t = new Do([new j(.5, .5), new j(-.5, .5), new j(-.5, -.5), new j(.5, -.5)]), e = {}) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, t = Array.isArray(t) ? t : [t];
        const n = this, s = [], r = [];
        for (let a = 0, l = t.length; a < l; a++) {
            const c = t[a];
            o(c)
        }
        this.setAttribute("position", new Ct(s, 3)), this.setAttribute("uv", new Ct(r, 2)), this.computeVertexNormals();

        function o(a) {
            const l = [], c = e.curveSegments !== void 0 ? e.curveSegments : 12, h = e.steps !== void 0 ? e.steps : 1,
                u = e.depth !== void 0 ? e.depth : 1;
            let d = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0,
                f = e.bevelThickness !== void 0 ? e.bevelThickness : .2,
                g = e.bevelSize !== void 0 ? e.bevelSize : f - .1, m = e.bevelOffset !== void 0 ? e.bevelOffset : 0,
                p = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
            const _ = e.extrudePath, x = e.UVGenerator !== void 0 ? e.UVGenerator : oL;
            let y, v = !1, w, E, S, b;
            _ && (y = _.getSpacedPoints(h), v = !0, d = !1, w = _.computeFrenetFrames(h, !1), E = new C, S = new C, b = new C), d || (p = 0, f = 0, g = 0, m = 0);
            const M = a.extractPoints(c);
            let I = M.shape;
            const N = M.holes;
            if (!Ri.isClockWise(I)) {
                I = I.reverse();
                for (let nt = 0, et = N.length; nt < et; nt++) {
                    const ft = N[nt];
                    Ri.isClockWise(ft) && (N[nt] = ft.reverse())
                }
            }
            const D = Ri.triangulateShape(I, N), L = I;
            for (let nt = 0, et = N.length; nt < et; nt++) {
                const ft = N[nt];
                I = I.concat(ft)
            }

            function k(nt, et, ft) {
                return et || console.error("THREE.ExtrudeGeometry: vec does not exist"), et.clone().multiplyScalar(ft).add(nt)
            }

            const G = I.length, Q = D.length;

            function q(nt, et, ft) {
                let Pt, _t, qt;
                const Vt = nt.x - et.x, Gt = nt.y - et.y, ke = ft.x - nt.x, ve = ft.y - nt.y, R = Vt * Vt + Gt * Gt,
                    A = Vt * ve - Gt * ke;
                if (Math.abs(A) > Number.EPSILON) {
                    const X = Math.sqrt(R), ht = Math.sqrt(ke * ke + ve * ve), dt = et.x - Gt / X, bt = et.y + Vt / X,
                        Wt = ft.x - ve / ht, O = ft.y + ke / ht,
                        V = ((Wt - dt) * ve - (O - bt) * ke) / (Vt * ve - Gt * ke);
                    Pt = dt + Vt * V - nt.x, _t = bt + Gt * V - nt.y;
                    const Et = Pt * Pt + _t * _t;
                    if (Et <= 2) return new j(Pt, _t);
                    qt = Math.sqrt(Et / 2)
                } else {
                    let X = !1;
                    Vt > Number.EPSILON ? ke > Number.EPSILON && (X = !0) : Vt < -Number.EPSILON ? ke < -Number.EPSILON && (X = !0) : Math.sign(Gt) === Math.sign(ve) && (X = !0), X ? (Pt = -Gt, _t = Vt, qt = Math.sqrt(R)) : (Pt = Vt, _t = Gt, qt = Math.sqrt(R / 2))
                }
                return new j(Pt / qt, _t / qt)
            }

            const at = [];
            for (let nt = 0, et = L.length, ft = et - 1, Pt = nt + 1; nt < et; nt++, ft++, Pt++) ft === et && (ft = 0), Pt === et && (Pt = 0), at[nt] = q(L[nt], L[ft], L[Pt]);
            const lt = [];
            let wt, W = at.concat();
            for (let nt = 0, et = N.length; nt < et; nt++) {
                const ft = N[nt];
                wt = [];
                for (let Pt = 0, _t = ft.length, qt = _t - 1, Vt = Pt + 1; Pt < _t; Pt++, qt++, Vt++) qt === _t && (qt = 0), Vt === _t && (Vt = 0), wt[Pt] = q(ft[Pt], ft[qt], ft[Vt]);
                lt.push(wt), W = W.concat(wt)
            }
            for (let nt = 0; nt < p; nt++) {
                const et = nt / p, ft = f * Math.cos(et * Math.PI / 2), Pt = g * Math.sin(et * Math.PI / 2) + m;
                for (let _t = 0, qt = L.length; _t < qt; _t++) {
                    const Vt = k(L[_t], at[_t], Pt);
                    Ut(Vt.x, Vt.y, -ft)
                }
                for (let _t = 0, qt = N.length; _t < qt; _t++) {
                    const Vt = N[_t];
                    wt = lt[_t];
                    for (let Gt = 0, ke = Vt.length; Gt < ke; Gt++) {
                        const ve = k(Vt[Gt], wt[Gt], Pt);
                        Ut(ve.x, ve.y, -ft)
                    }
                }
            }
            const st = g + m;
            for (let nt = 0; nt < G; nt++) {
                const et = d ? k(I[nt], W[nt], st) : I[nt];
                v ? (S.copy(w.normals[0]).multiplyScalar(et.x), E.copy(w.binormals[0]).multiplyScalar(et.y), b.copy(y[0]).add(S).add(E), Ut(b.x, b.y, b.z)) : Ut(et.x, et.y, 0)
            }
            for (let nt = 1; nt <= h; nt++) for (let et = 0; et < G; et++) {
                const ft = d ? k(I[et], W[et], st) : I[et];
                v ? (S.copy(w.normals[nt]).multiplyScalar(ft.x), E.copy(w.binormals[nt]).multiplyScalar(ft.y), b.copy(y[nt]).add(S).add(E), Ut(b.x, b.y, b.z)) : Ut(ft.x, ft.y, u / h * nt)
            }
            for (let nt = p - 1; nt >= 0; nt--) {
                const et = nt / p, ft = f * Math.cos(et * Math.PI / 2), Pt = g * Math.sin(et * Math.PI / 2) + m;
                for (let _t = 0, qt = L.length; _t < qt; _t++) {
                    const Vt = k(L[_t], at[_t], Pt);
                    Ut(Vt.x, Vt.y, u + ft)
                }
                for (let _t = 0, qt = N.length; _t < qt; _t++) {
                    const Vt = N[_t];
                    wt = lt[_t];
                    for (let Gt = 0, ke = Vt.length; Gt < ke; Gt++) {
                        const ve = k(Vt[Gt], wt[Gt], Pt);
                        v ? Ut(ve.x, ve.y + y[h - 1].y, y[h - 1].x + ft) : Ut(ve.x, ve.y, u + ft)
                    }
                }
            }
            gt(), mt();

            function gt() {
                const nt = s.length / 3;
                if (d) {
                    let et = 0, ft = G * et;
                    for (let Pt = 0; Pt < Q; Pt++) {
                        const _t = D[Pt];
                        Rt(_t[2] + ft, _t[1] + ft, _t[0] + ft)
                    }
                    et = h + p * 2, ft = G * et;
                    for (let Pt = 0; Pt < Q; Pt++) {
                        const _t = D[Pt];
                        Rt(_t[0] + ft, _t[1] + ft, _t[2] + ft)
                    }
                } else {
                    for (let et = 0; et < Q; et++) {
                        const ft = D[et];
                        Rt(ft[2], ft[1], ft[0])
                    }
                    for (let et = 0; et < Q; et++) {
                        const ft = D[et];
                        Rt(ft[0] + G * h, ft[1] + G * h, ft[2] + G * h)
                    }
                }
                n.addGroup(nt, s.length / 3 - nt, 0)
            }

            function mt() {
                const nt = s.length / 3;
                let et = 0;
                Y(L, et), et += L.length;
                for (let ft = 0, Pt = N.length; ft < Pt; ft++) {
                    const _t = N[ft];
                    Y(_t, et), et += _t.length
                }
                n.addGroup(nt, s.length / 3 - nt, 1)
            }

            function Y(nt, et) {
                let ft = nt.length;
                for (; --ft >= 0;) {
                    const Pt = ft;
                    let _t = ft - 1;
                    _t < 0 && (_t = nt.length - 1);
                    for (let qt = 0, Vt = h + p * 2; qt < Vt; qt++) {
                        const Gt = G * qt, ke = G * (qt + 1), ve = et + Pt + Gt, R = et + _t + Gt, A = et + _t + ke,
                            X = et + Pt + ke;
                        Nt(ve, R, A, X)
                    }
                }
            }

            function Ut(nt, et, ft) {
                l.push(nt), l.push(et), l.push(ft)
            }

            function Rt(nt, et, ft) {
                vt(nt), vt(et), vt(ft);
                const Pt = s.length / 3, _t = x.generateTopUV(n, s, Pt - 3, Pt - 2, Pt - 1);
                ee(_t[0]), ee(_t[1]), ee(_t[2])
            }

            function Nt(nt, et, ft, Pt) {
                vt(nt), vt(et), vt(Pt), vt(et), vt(ft), vt(Pt);
                const _t = s.length / 3, qt = x.generateSideWallUV(n, s, _t - 6, _t - 3, _t - 2, _t - 1);
                ee(qt[0]), ee(qt[1]), ee(qt[3]), ee(qt[1]), ee(qt[2]), ee(qt[3])
            }

            function vt(nt) {
                s.push(l[nt * 3 + 0]), s.push(l[nt * 3 + 1]), s.push(l[nt * 3 + 2])
            }

            function ee(nt) {
                r.push(nt.x), r.push(nt.y)
            }
        }
    }

    toJSON() {
        const t = super.toJSON(), e = this.parameters.shapes, n = this.parameters.options;
        return aL(e, n, t)
    }

    static fromJSON(t, e) {
        const n = [];
        for (let r = 0, o = t.shapes.length; r < o; r++) {
            const a = e[t.shapes[r]];
            n.push(a)
        }
        const s = t.options.extrudePath;
        return s !== void 0 && (t.options.extrudePath = new v0[s.type]().fromJSON(s)), new xh(n, t.options)
    }
}

const oL = {
    generateTopUV: function (i, t, e, n, s) {
        const r = t[e * 3], o = t[e * 3 + 1], a = t[n * 3], l = t[n * 3 + 1], c = t[s * 3], h = t[s * 3 + 1];
        return [new j(r, o), new j(a, l), new j(c, h)]
    }, generateSideWallUV: function (i, t, e, n, s, r) {
        const o = t[e * 3], a = t[e * 3 + 1], l = t[e * 3 + 2], c = t[n * 3], h = t[n * 3 + 1], u = t[n * 3 + 2],
            d = t[s * 3], f = t[s * 3 + 1], g = t[s * 3 + 2], m = t[r * 3], p = t[r * 3 + 1], _ = t[r * 3 + 2];
        return Math.abs(a - h) < Math.abs(o - c) ? [new j(o, 1 - l), new j(c, 1 - u), new j(d, 1 - g), new j(m, 1 - _)] : [new j(a, 1 - l), new j(h, 1 - u), new j(f, 1 - g), new j(p, 1 - _)]
    }
};

function aL(i, t, e) {
    if (e.shapes = [], Array.isArray(i)) for (let n = 0, s = i.length; n < s; n++) {
        const r = i[n];
        e.shapes.push(r.uuid)
    } else e.shapes.push(i.uuid);
    return e.options = Object.assign({}, t), t.extrudePath !== void 0 && (e.options.extrudePath = t.extrudePath.toJSON()), e
}

class vh extends ur {
    constructor(t = 1, e = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
            s = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
            r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(s, r, t, e), this.type = "IcosahedronGeometry", this.parameters = {radius: t, detail: e}
    }

    static fromJSON(t) {
        return new vh(t.radius, t.detail)
    }
}

class Al extends ur {
    constructor(t = 1, e = 0) {
        const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            s = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(n, s, t, e), this.type = "OctahedronGeometry", this.parameters = {radius: t, detail: e}
    }

    static fromJSON(t) {
        return new Al(t.radius, t.detail)
    }
}

class wh extends Xt {
    constructor(t = .5, e = 1, n = 32, s = 1, r = 0, o = Math.PI * 2) {
        super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: s,
            thetaStart: r,
            thetaLength: o
        }, n = Math.max(3, n), s = Math.max(1, s);
        const a = [], l = [], c = [], h = [];
        let u = t;
        const d = (e - t) / s, f = new C, g = new j;
        for (let m = 0; m <= s; m++) {
            for (let p = 0; p <= n; p++) {
                const _ = r + p / n * o;
                f.x = u * Math.cos(_), f.y = u * Math.sin(_), l.push(f.x, f.y, f.z), c.push(0, 0, 1), g.x = (f.x / e + 1) / 2, g.y = (f.y / e + 1) / 2, h.push(g.x, g.y)
            }
            u += d
        }
        for (let m = 0; m < s; m++) {
            const p = m * (n + 1);
            for (let _ = 0; _ < n; _++) {
                const x = _ + p, y = x, v = x + n + 1, w = x + n + 2, E = x + 1;
                a.push(y, v, E), a.push(v, w, E)
            }
        }
        this.setIndex(a), this.setAttribute("position", new Ct(l, 3)), this.setAttribute("normal", new Ct(c, 3)), this.setAttribute("uv", new Ct(h, 2))
    }

    static fromJSON(t) {
        return new wh(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
    }
}

class bh extends Xt {
    constructor(t = new Do([new j(0, .5), new j(-.5, -.5), new j(.5, -.5)]), e = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {shapes: t, curveSegments: e};
        const n = [], s = [], r = [], o = [];
        let a = 0, l = 0;
        if (Array.isArray(t) === !1) c(t); else for (let h = 0; h < t.length; h++) c(t[h]), this.addGroup(a, l, h), a += l, l = 0;
        this.setIndex(n), this.setAttribute("position", new Ct(s, 3)), this.setAttribute("normal", new Ct(r, 3)), this.setAttribute("uv", new Ct(o, 2));

        function c(h) {
            const u = s.length / 3, d = h.extractPoints(e);
            let f = d.shape;
            const g = d.holes;
            Ri.isClockWise(f) === !1 && (f = f.reverse());
            for (let p = 0, _ = g.length; p < _; p++) {
                const x = g[p];
                Ri.isClockWise(x) === !0 && (g[p] = x.reverse())
            }
            const m = Ri.triangulateShape(f, g);
            for (let p = 0, _ = g.length; p < _; p++) {
                const x = g[p];
                f = f.concat(x)
            }
            for (let p = 0, _ = f.length; p < _; p++) {
                const x = f[p];
                s.push(x.x, x.y, 0), r.push(0, 0, 1), o.push(x.x, x.y)
            }
            for (let p = 0, _ = m.length; p < _; p++) {
                const x = m[p], y = x[0] + u, v = x[1] + u, w = x[2] + u;
                n.push(y, v, w), l += 3
            }
        }
    }

    toJSON() {
        const t = super.toJSON(), e = this.parameters.shapes;
        return lL(e, t)
    }

    static fromJSON(t, e) {
        const n = [];
        for (let s = 0, r = t.shapes.length; s < r; s++) {
            const o = e[t.shapes[s]];
            n.push(o)
        }
        return new bh(n, t.curveSegments)
    }
}

function lL(i, t) {
    if (t.shapes = [], Array.isArray(i)) for (let e = 0, n = i.length; e < n; e++) {
        const s = i[e];
        t.shapes.push(s.uuid)
    } else t.shapes.push(i.uuid);
    return t
}

class Cl extends Xt {
    constructor(t = 1, e = 32, n = 16, s = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: s,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const h = [], u = new C, d = new C, f = [], g = [], m = [], p = [];
        for (let _ = 0; _ <= n; _++) {
            const x = [], y = _ / n;
            let v = 0;
            _ == 0 && o == 0 ? v = .5 / e : _ == n && l == Math.PI && (v = -.5 / e);
            for (let w = 0; w <= e; w++) {
                const E = w / e;
                u.x = -t * Math.cos(s + E * r) * Math.sin(o + y * a), u.y = t * Math.cos(o + y * a), u.z = t * Math.sin(s + E * r) * Math.sin(o + y * a), g.push(u.x, u.y, u.z), d.copy(u).normalize(), m.push(d.x, d.y, d.z), p.push(E + v, 1 - y), x.push(c++)
            }
            h.push(x)
        }
        for (let _ = 0; _ < n; _++) for (let x = 0; x < e; x++) {
            const y = h[_][x + 1], v = h[_][x], w = h[_ + 1][x], E = h[_ + 1][x + 1];
            (_ !== 0 || o > 0) && f.push(y, v, E), (_ !== n - 1 || l < Math.PI) && f.push(v, w, E)
        }
        this.setIndex(f), this.setAttribute("position", new Ct(g, 3)), this.setAttribute("normal", new Ct(m, 3)), this.setAttribute("uv", new Ct(p, 2))
    }

    static fromJSON(t) {
        return new Cl(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
    }
}

class Eh extends ur {
    constructor(t = 1, e = 0) {
        const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], s = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(n, s, t, e), this.type = "TetrahedronGeometry", this.parameters = {radius: t, detail: e}
    }

    static fromJSON(t) {
        return new Eh(t.radius, t.detail)
    }
}

class Sh extends Xt {
    constructor(t = 1, e = .4, n = 12, s = 48, r = Math.PI * 2) {
        super(), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: s,
            arc: r
        }, n = Math.floor(n), s = Math.floor(s);
        const o = [], a = [], l = [], c = [], h = new C, u = new C, d = new C;
        for (let f = 0; f <= n; f++) for (let g = 0; g <= s; g++) {
            const m = g / s * r, p = f / n * Math.PI * 2;
            u.x = (t + e * Math.cos(p)) * Math.cos(m), u.y = (t + e * Math.cos(p)) * Math.sin(m), u.z = e * Math.sin(p), a.push(u.x, u.y, u.z), h.x = t * Math.cos(m), h.y = t * Math.sin(m), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(g / s), c.push(f / n)
        }
        for (let f = 1; f <= n; f++) for (let g = 1; g <= s; g++) {
            const m = (s + 1) * f + g - 1, p = (s + 1) * (f - 1) + g - 1, _ = (s + 1) * (f - 1) + g,
                x = (s + 1) * f + g;
            o.push(m, p, x), o.push(p, _, x)
        }
        this.setIndex(o), this.setAttribute("position", new Ct(a, 3)), this.setAttribute("normal", new Ct(l, 3)), this.setAttribute("uv", new Ct(c, 2))
    }

    static fromJSON(t) {
        return new Sh(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
    }
}

class Mh extends Xt {
    constructor(t = 1, e = .4, n = 64, s = 8, r = 2, o = 3) {
        super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: s,
            p: r,
            q: o
        }, n = Math.floor(n), s = Math.floor(s);
        const a = [], l = [], c = [], h = [], u = new C, d = new C, f = new C, g = new C, m = new C, p = new C,
            _ = new C;
        for (let y = 0; y <= n; ++y) {
            const v = y / n * r * Math.PI * 2;
            x(v, r, o, t, f), x(v + .01, r, o, t, g), p.subVectors(g, f), _.addVectors(g, f), m.crossVectors(p, _), _.crossVectors(m, p), m.normalize(), _.normalize();
            for (let w = 0; w <= s; ++w) {
                const E = w / s * Math.PI * 2, S = -e * Math.cos(E), b = e * Math.sin(E);
                u.x = f.x + (S * _.x + b * m.x), u.y = f.y + (S * _.y + b * m.y), u.z = f.z + (S * _.z + b * m.z), l.push(u.x, u.y, u.z), d.subVectors(u, f).normalize(), c.push(d.x, d.y, d.z), h.push(y / n), h.push(w / s)
            }
        }
        for (let y = 1; y <= n; y++) for (let v = 1; v <= s; v++) {
            const w = (s + 1) * (y - 1) + (v - 1), E = (s + 1) * y + (v - 1), S = (s + 1) * y + v,
                b = (s + 1) * (y - 1) + v;
            a.push(w, E, b), a.push(E, S, b)
        }
        this.setIndex(a), this.setAttribute("position", new Ct(l, 3)), this.setAttribute("normal", new Ct(c, 3)), this.setAttribute("uv", new Ct(h, 2));

        function x(y, v, w, E, S) {
            const b = Math.cos(y), M = Math.sin(y), I = w / v * y, N = Math.cos(I);
            S.x = E * (2 + N) * .5 * b, S.y = E * (2 + N) * M * .5, S.z = E * Math.sin(I) * .5
        }
    }

    static fromJSON(t) {
        return new Mh(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
    }
}

class Th extends Xt {
    constructor(t = new y0(new C(-1, -1, 0), new C(-1, 1, 0), new C(1, 1, 0)), e = 64, n = 1, s = 8, r = !1) {
        super(), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: s,
            closed: r
        };
        const o = t.computeFrenetFrames(e, r);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        const a = new C, l = new C, c = new j;
        let h = new C;
        const u = [], d = [], f = [], g = [];
        m(), this.setIndex(g), this.setAttribute("position", new Ct(u, 3)), this.setAttribute("normal", new Ct(d, 3)), this.setAttribute("uv", new Ct(f, 2));

        function m() {
            for (let y = 0; y < e; y++) p(y);
            p(r === !1 ? e : 0), x(), _()
        }

        function p(y) {
            h = t.getPointAt(y / e, h);
            const v = o.normals[y], w = o.binormals[y];
            for (let E = 0; E <= s; E++) {
                const S = E / s * Math.PI * 2, b = Math.sin(S), M = -Math.cos(S);
                l.x = M * v.x + b * w.x, l.y = M * v.y + b * w.y, l.z = M * v.z + b * w.z, l.normalize(), d.push(l.x, l.y, l.z), a.x = h.x + n * l.x, a.y = h.y + n * l.y, a.z = h.z + n * l.z, u.push(a.x, a.y, a.z)
            }
        }

        function _() {
            for (let y = 1; y <= e; y++) for (let v = 1; v <= s; v++) {
                const w = (s + 1) * (y - 1) + (v - 1), E = (s + 1) * y + (v - 1), S = (s + 1) * y + v,
                    b = (s + 1) * (y - 1) + v;
                g.push(w, E, b), g.push(E, S, b)
            }
        }

        function x() {
            for (let y = 0; y <= e; y++) for (let v = 0; v <= s; v++) c.x = y / e, c.y = v / s, f.push(c.x, c.y)
        }
    }

    toJSON() {
        const t = super.toJSON();
        return t.path = this.parameters.path.toJSON(), t
    }

    static fromJSON(t) {
        return new Th(new v0[t.path.type]().fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
    }
}

class uE extends Xt {
    constructor(t = null) {
        if (super(), this.type = "WireframeGeometry", this.parameters = {geometry: t}, t !== null) {
            const e = [], n = new Set, s = new C, r = new C;
            if (t.index !== null) {
                const o = t.attributes.position, a = t.index;
                let l = t.groups;
                l.length === 0 && (l = [{start: 0, count: a.count, materialIndex: 0}]);
                for (let c = 0, h = l.length; c < h; ++c) {
                    const u = l[c], d = u.start, f = u.count;
                    for (let g = d, m = d + f; g < m; g += 3) for (let p = 0; p < 3; p++) {
                        const _ = a.getX(g + p), x = a.getX(g + (p + 1) % 3);
                        s.fromBufferAttribute(o, _), r.fromBufferAttribute(o, x), dx(s, r, n) === !0 && (e.push(s.x, s.y, s.z), e.push(r.x, r.y, r.z))
                    }
                }
            } else {
                const o = t.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++) for (let c = 0; c < 3; c++) {
                    const h = 3 * a + c, u = 3 * a + (c + 1) % 3;
                    s.fromBufferAttribute(o, h), r.fromBufferAttribute(o, u), dx(s, r, n) === !0 && (e.push(s.x, s.y, s.z), e.push(r.x, r.y, r.z))
                }
            }
            this.setAttribute("position", new Ct(e, 3))
        }
    }
}

function dx(i, t, e) {
    const n = `${i.x},${i.y},${i.z}-${t.x},${t.y},${t.z}`, s = `${t.x},${t.y},${t.z}-${i.x},${i.y},${i.z}`;
    return e.has(n) === !0 || e.has(s) === !0 ? !1 : (e.add(n), e.add(s), !0)
}

var fx = Object.freeze({
    __proto__: null,
    BoxGeometry: Vi,
    CapsuleGeometry: gh,
    CircleGeometry: mh,
    ConeGeometry: _h,
    CylinderGeometry: qo,
    DodecahedronGeometry: yh,
    EdgesGeometry: aE,
    ExtrudeGeometry: xh,
    IcosahedronGeometry: vh,
    LatheGeometry: Il,
    OctahedronGeometry: Al,
    PlaneGeometry: Sl,
    PolyhedronGeometry: ur,
    RingGeometry: wh,
    ShapeGeometry: bh,
    SphereGeometry: Cl,
    TetrahedronGeometry: Eh,
    TorusGeometry: Sh,
    TorusKnotGeometry: Mh,
    TubeGeometry: Th,
    WireframeGeometry: uE
});

class dE extends En {
    constructor(t) {
        super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new pt(0), this.transparent = !0, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.fog = t.fog, this
    }
}

class fE extends jn {
    constructor(t) {
        super(t), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
    }
}

class Zn extends En {
    constructor(t) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new pt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new pt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xr, this.normalScale = new j(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}

class dr extends Zn {
    constructor(t) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new j(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function () {
                return un(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            }, set: function (e) {
                this.ior = (1 + .4 * e) / (1 - .4 * e)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new pt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new pt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new pt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(t)
    }

    get sheen() {
        return this._sheen
    }

    set sheen(t) {
        this._sheen > 0 != t > 0 && this.version++, this._sheen = t
    }

    get clearcoat() {
        return this._clearcoat
    }

    set clearcoat(t) {
        this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
    }

    get iridescence() {
        return this._iridescence
    }

    set iridescence(t) {
        this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
    }

    get transmission() {
        return this._transmission
    }

    set transmission(t) {
        this._transmission > 0 != t > 0 && this.version++, this._transmission = t
    }

    copy(t) {
        return super.copy(t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
    }
}

class pE extends En {
    constructor(t) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new pt(16777215), this.specular = new pt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new pt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xr, this.normalScale = new j(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = hh, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}

class gE extends En {
    constructor(t) {
        super(), this.isMeshToonMaterial = !0, this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.color = new pt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new pt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xr, this.normalScale = new j(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
    }
}

class mE extends En {
    constructor(t) {
        super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xr, this.normalScale = new j(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
    }
}

class _E extends En {
    constructor(t) {
        super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new pt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new pt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xr, this.normalScale = new j(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = hh, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}

class yE extends En {
    constructor(t) {
        super(), this.isMeshMatcapMaterial = !0, this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new pt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xr, this.normalScale = new j(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}

class xE extends Jn {
    constructor(t) {
        super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    }
}

function qs(i, t, e) {
    return w0(i) ? new i.constructor(i.subarray(t, e !== void 0 ? e : i.length)) : i.slice(t, e)
}

function Ao(i, t, e) {
    return !i || !e && i.constructor === t ? i : typeof t.BYTES_PER_ELEMENT == "number" ? new t(i) : Array.prototype.slice.call(i)
}

function w0(i) {
    return ArrayBuffer.isView(i) && !(i instanceof DataView)
}

function vE(i) {
    function t(s, r) {
        return i[s] - i[r]
    }

    const e = i.length, n = new Array(e);
    for (let s = 0; s !== e; ++s) n[s] = s;
    return n.sort(t), n
}

function bm(i, t, e) {
    const n = i.length, s = new i.constructor(n);
    for (let r = 0, o = 0; o !== n; ++r) {
        const a = e[r] * t;
        for (let l = 0; l !== t; ++l) s[o++] = i[a + l]
    }
    return s
}

function b0(i, t, e, n) {
    let s = 1, r = i[0];
    for (; r !== void 0 && r[n] === void 0;) r = i[s++];
    if (r === void 0) return;
    let o = r[n];
    if (o !== void 0) if (Array.isArray(o)) do o = r[n], o !== void 0 && (t.push(r.time), e.push.apply(e, o)), r = i[s++]; while (r !== void 0); else if (o.toArray !== void 0) do o = r[n], o !== void 0 && (t.push(r.time), o.toArray(e, e.length)), r = i[s++]; while (r !== void 0); else do o = r[n], o !== void 0 && (t.push(r.time), e.push(o)), r = i[s++]; while (r !== void 0)
}

function cL(i, t, e, n, s = 30) {
    const r = i.clone();
    r.name = t;
    const o = [];
    for (let l = 0; l < r.tracks.length; ++l) {
        const c = r.tracks[l], h = c.getValueSize(), u = [], d = [];
        for (let f = 0; f < c.times.length; ++f) {
            const g = c.times[f] * s;
            if (!(g < e || g >= n)) {
                u.push(c.times[f]);
                for (let m = 0; m < h; ++m) d.push(c.values[f * h + m])
            }
        }
        u.length !== 0 && (c.times = Ao(u, c.times.constructor), c.values = Ao(d, c.values.constructor), o.push(c))
    }
    r.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < r.tracks.length; ++l) a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
    for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
    return r.resetDuration(), r
}

function hL(i, t = 0, e = i, n = 30) {
    n <= 0 && (n = 30);
    const s = e.tracks.length, r = t / n;
    for (let o = 0; o < s; ++o) {
        const a = e.tracks[o], l = a.ValueTypeName;
        if (l === "bool" || l === "string") continue;
        const c = i.tracks.find(function (_) {
            return _.name === a.name && _.ValueTypeName === l
        });
        if (c === void 0) continue;
        let h = 0;
        const u = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = u / 3);
        let d = 0;
        const f = c.getValueSize();
        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = f / 3);
        const g = a.times.length - 1;
        let m;
        if (r <= a.times[0]) {
            const _ = h, x = u - h;
            m = qs(a.values, _, x)
        } else if (r >= a.times[g]) {
            const _ = g * u + h, x = _ + u - h;
            m = qs(a.values, _, x)
        } else {
            const _ = a.createInterpolant(), x = h, y = u - h;
            _.evaluate(r), m = qs(_.resultBuffer, x, y)
        }
        l === "quaternion" && new On().fromArray(m).normalize().conjugate().toArray(m);
        const p = c.times.length;
        for (let _ = 0; _ < p; ++_) {
            const x = _ * f + d;
            if (l === "quaternion") On.multiplyQuaternionsFlat(c.values, x, m, 0, c.values, x); else {
                const y = f - d * 2;
                for (let v = 0; v < y; ++v) c.values[x + v] -= m[v]
            }
        }
    }
    return i.blendMode = Jm, i
}

var uL = Object.freeze({
    __proto__: null,
    arraySlice: qs,
    convertArray: Ao,
    flattenJSON: b0,
    getKeyframeOrder: vE,
    isTypedArray: w0,
    makeClipAdditive: hL,
    sortedArray: bm,
    subclip: cL
});

class Pl {
    constructor(t, e, n, s) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
    }

    evaluate(t) {
        const e = this.parameterPositions;
        let n = this._cachedIndex, s = e[n], r = e[n - 1];
        t:{
            e:{
                let o;
                n:{
                    s:if (!(t < s)) {
                        for (let a = n + 2; ;) {
                            if (s === void 0) {
                                if (t < r) break s;
                                return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                            }
                            if (n === a) break;
                            if (r = s, s = e[++n], t < s) break e
                        }
                        o = e.length;
                        break n
                    }
                    if (!(t >= r)) {
                        const a = e[1];
                        t < a && (n = 2, r = a);
                        for (let l = n - 2; ;) {
                            if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (n === l) break;
                            if (s = r, r = e[--n - 1], t >= r) break e
                        }
                        o = n, n = 0;
                        break n
                    }
                    break t
                }
                for (; n < o;) {
                    const a = n + o >>> 1;
                    t < e[a] ? o = a : n = a + 1
                }
                if (s = e[n], r = e[n - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (s === void 0) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n, this.intervalChanged_(n, r, s)
        }
        return this.interpolate_(n, r, t, s)
    }

    getSettings_() {
        return this.settings || this.DefaultSettings_
    }

    copySampleValue_(t) {
        const e = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = t * s;
        for (let o = 0; o !== s; ++o) e[o] = n[r + o];
        return e
    }

    interpolate_() {
        throw new Error("call to abstract method")
    }

    intervalChanged_() {
    }
}

class wE extends Pl {
    constructor(t, e, n, s) {
        super(t, e, n, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Mo,
            endingEnd: Mo
        }
    }

    intervalChanged_(t, e, n) {
        const s = this.parameterPositions;
        let r = t - 2, o = t + 1, a = s[r], l = s[o];
        if (a === void 0) switch (this.getSettings_().endingStart) {
            case To:
                r = t, a = 2 * e - n;
                break;
            case Dc:
                r = s.length - 2, a = e + s[r] - s[r + 1];
                break;
            default:
                r = t, a = n
        }
        if (l === void 0) switch (this.getSettings_().endingEnd) {
            case To:
                o = t, l = 2 * n - e;
                break;
            case Dc:
                o = 1, l = n + s[1] - s[0];
                break;
            default:
                o = t - 1, l = e
        }
        const c = (n - e) * .5, h = this.valueSize;
        this._weightPrev = c / (e - a), this._weightNext = c / (l - n), this._offsetPrev = r * h, this._offsetNext = o * h
    }

    interpolate_(t, e, n, s) {
        const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, c = l - a,
            h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, f = this._weightNext,
            g = (n - e) / (s - e), m = g * g, p = m * g, _ = -d * p + 2 * d * m - d * g,
            x = (1 + d) * p + (-1.5 - 2 * d) * m + (-.5 + d) * g + 1, y = (-1 - f) * p + (1.5 + f) * m + .5 * g,
            v = f * p - f * m;
        for (let w = 0; w !== a; ++w) r[w] = _ * o[h + w] + x * o[c + w] + y * o[l + w] + v * o[u + w];
        return r
    }
}

class E0 extends Pl {
    constructor(t, e, n, s) {
        super(t, e, n, s)
    }

    interpolate_(t, e, n, s) {
        const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, c = l - a,
            h = (n - e) / (s - e), u = 1 - h;
        for (let d = 0; d !== a; ++d) r[d] = o[c + d] * u + o[l + d] * h;
        return r
    }
}

class bE extends Pl {
    constructor(t, e, n, s) {
        super(t, e, n, s)
    }

    interpolate_(t) {
        return this.copySampleValue_(t - 1)
    }
}

class mi {
    constructor(t, e, n, s) {
        if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = Ao(e, this.TimeBufferType), this.values = Ao(n, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation)
    }

    static toJSON(t) {
        const e = t.constructor;
        let n;
        if (e.toJSON !== this.toJSON) n = e.toJSON(t); else {
            n = {name: t.name, times: Ao(t.times, Array), values: Ao(t.values, Array)};
            const s = t.getInterpolation();
            s !== t.DefaultInterpolation && (n.interpolation = s)
        }
        return n.type = t.ValueTypeName, n
    }

    InterpolantFactoryMethodDiscrete(t) {
        return new bE(this.times, this.values, this.getValueSize(), t)
    }

    InterpolantFactoryMethodLinear(t) {
        return new E0(this.times, this.values, this.getValueSize(), t)
    }

    InterpolantFactoryMethodSmooth(t) {
        return new wE(this.times, this.values, this.getValueSize(), t)
    }

    setInterpolation(t) {
        let e;
        switch (t) {
            case sl:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case ko:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case Ku:
                e = this.InterpolantFactoryMethodSmooth;
                break
        }
        if (e === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this
        }
        return this.createInterpolant = e, this
    }

    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return sl;
            case this.InterpolantFactoryMethodLinear:
                return ko;
            case this.InterpolantFactoryMethodSmooth:
                return Ku
        }
    }

    getValueSize() {
        return this.values.length / this.times.length
    }

    shift(t) {
        if (t !== 0) {
            const e = this.times;
            for (let n = 0, s = e.length; n !== s; ++n) e[n] += t
        }
        return this
    }

    scale(t) {
        if (t !== 1) {
            const e = this.times;
            for (let n = 0, s = e.length; n !== s; ++n) e[n] *= t
        }
        return this
    }

    trim(t, e) {
        const n = this.times, s = n.length;
        let r = 0, o = s - 1;
        for (; r !== s && n[r] < t;) ++r;
        for (; o !== -1 && n[o] > e;) --o;
        if (++o, r !== 0 || o !== s) {
            r >= o && (o = Math.max(o, 1), r = o - 1);
            const a = this.getValueSize();
            this.times = qs(n, r, o), this.values = qs(this.values, r * a, o * a)
        }
        return this
    }

    validate() {
        let t = !0;
        const e = this.getValueSize();
        e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
        const n = this.times, s = this.values, r = n.length;
        r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
        let o = null;
        for (let a = 0; a !== r; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), t = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), t = !1;
                break
            }
            o = l
        }
        if (s !== void 0 && w0(s)) for (let a = 0, l = s.length; a !== l; ++a) {
            const c = s[a];
            if (isNaN(c)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), t = !1;
                break
            }
        }
        return t
    }

    optimize() {
        const t = qs(this.times), e = qs(this.values), n = this.getValueSize(), s = this.getInterpolation() === Ku,
            r = t.length - 1;
        let o = 1;
        for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = t[a], h = t[a + 1];
            if (c !== h && (a !== 1 || c !== t[0])) if (s) l = !0; else {
                const u = a * n, d = u - n, f = u + n;
                for (let g = 0; g !== n; ++g) {
                    const m = e[u + g];
                    if (m !== e[d + g] || m !== e[f + g]) {
                        l = !0;
                        break
                    }
                }
            }
            if (l) {
                if (a !== o) {
                    t[o] = t[a];
                    const u = a * n, d = o * n;
                    for (let f = 0; f !== n; ++f) e[d + f] = e[u + f]
                }
                ++o
            }
        }
        if (r > 0) {
            t[o] = t[r];
            for (let a = r * n, l = o * n, c = 0; c !== n; ++c) e[l + c] = e[a + c];
            ++o
        }
        return o !== t.length ? (this.times = qs(t, 0, o), this.values = qs(e, 0, o * n)) : (this.times = t, this.values = e), this
    }

    clone() {
        const t = qs(this.times, 0), e = qs(this.values, 0), n = this.constructor, s = new n(this.name, t, e);
        return s.createInterpolant = this.createInterpolant, s
    }
}

mi.prototype.TimeBufferType = Float32Array;
mi.prototype.ValueBufferType = Float32Array;
mi.prototype.DefaultInterpolation = ko;

class Yo extends mi {
}

Yo.prototype.ValueTypeName = "bool";
Yo.prototype.ValueBufferType = Array;
Yo.prototype.DefaultInterpolation = sl;
Yo.prototype.InterpolantFactoryMethodLinear = void 0;
Yo.prototype.InterpolantFactoryMethodSmooth = void 0;

class S0 extends mi {
}

S0.prototype.ValueTypeName = "color";

class al extends mi {
}

al.prototype.ValueTypeName = "number";

class EE extends Pl {
    constructor(t, e, n, s) {
        super(t, e, n, s)
    }

    interpolate_(t, e, n, s) {
        const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - e) / (s - e);
        let c = t * a;
        for (let h = c + a; c !== h; c += 4) On.slerpFlat(r, 0, o, c - a, o, c, l);
        return r
    }
}

class $r extends mi {
    InterpolantFactoryMethodLinear(t) {
        return new EE(this.times, this.values, this.getValueSize(), t)
    }
}

$r.prototype.ValueTypeName = "quaternion";
$r.prototype.DefaultInterpolation = ko;
$r.prototype.InterpolantFactoryMethodSmooth = void 0;

class Xo extends mi {
}

Xo.prototype.ValueTypeName = "string";
Xo.prototype.ValueBufferType = Array;
Xo.prototype.DefaultInterpolation = sl;
Xo.prototype.InterpolantFactoryMethodLinear = void 0;
Xo.prototype.InterpolantFactoryMethodSmooth = void 0;

class ll extends mi {
}

ll.prototype.ValueTypeName = "vector";

class Wr {
    constructor(t, e = -1, n, s = qd) {
        this.name = t, this.tracks = n, this.duration = e, this.blendMode = s, this.uuid = zs(), this.duration < 0 && this.resetDuration()
    }

    static parse(t) {
        const e = [], n = t.tracks, s = 1 / (t.fps || 1);
        for (let o = 0, a = n.length; o !== a; ++o) e.push(fL(n[o]).scale(s));
        const r = new this(t.name, t.duration, e, t.blendMode);
        return r.uuid = t.uuid, r
    }

    static toJSON(t) {
        const e = [], n = t.tracks,
            s = {name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode};
        for (let r = 0, o = n.length; r !== o; ++r) e.push(mi.toJSON(n[r]));
        return s
    }

    static CreateFromMorphTargetSequence(t, e, n, s) {
        const r = e.length, o = [];
        for (let a = 0; a < r; a++) {
            let l = [], c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
            const h = vE(l);
            l = bm(l, 1, h), c = bm(c, 1, h), !s && l[0] === 0 && (l.push(r), c.push(c[0])), o.push(new al(".morphTargetInfluences[" + e[a].name + "]", l, c).scale(1 / n))
        }
        return new this(t, -1, o)
    }

    static findByName(t, e) {
        let n = t;
        if (!Array.isArray(t)) {
            const s = t;
            n = s.geometry && s.geometry.animations || s.animations
        }
        for (let s = 0; s < n.length; s++) if (n[s].name === e) return n[s];
        return null
    }

    static CreateClipsFromMorphTargetSequences(t, e, n) {
        const s = {}, r = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = t.length; a < l; a++) {
            const c = t[a], h = c.name.match(r);
            if (h && h.length > 1) {
                const u = h[1];
                let d = s[u];
                d || (s[u] = d = []), d.push(c)
            }
        }
        const o = [];
        for (const a in s) o.push(this.CreateFromMorphTargetSequence(a, s[a], e, n));
        return o
    }

    static parseAnimation(t, e) {
        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const n = function (u, d, f, g, m) {
            if (f.length !== 0) {
                const p = [], _ = [];
                b0(f, p, _, g), p.length !== 0 && m.push(new u(d, p, _))
            }
        }, s = [], r = t.name || "default", o = t.fps || 30, a = t.blendMode;
        let l = t.length || -1;
        const c = t.hierarchy || [];
        for (let u = 0; u < c.length; u++) {
            const d = c[u].keys;
            if (!(!d || d.length === 0)) if (d[0].morphTargets) {
                const f = {};
                let g;
                for (g = 0; g < d.length; g++) if (d[g].morphTargets) for (let m = 0; m < d[g].morphTargets.length; m++) f[d[g].morphTargets[m]] = -1;
                for (const m in f) {
                    const p = [], _ = [];
                    for (let x = 0; x !== d[g].morphTargets.length; ++x) {
                        const y = d[g];
                        p.push(y.time), _.push(y.morphTarget === m ? 1 : 0)
                    }
                    s.push(new al(".morphTargetInfluence[" + m + "]", p, _))
                }
                l = f.length * o
            } else {
                const f = ".bones[" + e[u].name + "]";
                n(ll, f + ".position", d, "pos", s), n($r, f + ".quaternion", d, "rot", s), n(ll, f + ".scale", d, "scl", s)
            }
        }
        return s.length === 0 ? null : new this(r, l, s, a)
    }

    resetDuration() {
        const t = this.tracks;
        let e = 0;
        for (let n = 0, s = t.length; n !== s; ++n) {
            const r = this.tracks[n];
            e = Math.max(e, r.times[r.times.length - 1])
        }
        return this.duration = e, this
    }

    trim() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this
    }

    validate() {
        let t = !0;
        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
        return t
    }

    optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this
    }

    clone() {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode)
    }

    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function dL(i) {
    switch (i.toLowerCase()) {
        case"scalar":
        case"double":
        case"float":
        case"number":
        case"integer":
            return al;
        case"vector":
        case"vector2":
        case"vector3":
        case"vector4":
            return ll;
        case"color":
            return S0;
        case"quaternion":
            return $r;
        case"bool":
        case"boolean":
            return Yo;
        case"string":
            return Xo
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i)
}

function fL(i) {
    if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t = dL(i.type);
    if (i.times === void 0) {
        const e = [], n = [];
        b0(i.keys, e, n, "value"), i.times = e, i.values = n
    }
    return t.parse !== void 0 ? t.parse(i) : new t(i.name, i.times, i.values, i.interpolation)
}

const Go = {
    enabled: !1, files: {}, add: function (i, t) {
        this.enabled !== !1 && (this.files[i] = t)
    }, get: function (i) {
        if (this.enabled !== !1) return this.files[i]
    }, remove: function (i) {
        delete this.files[i]
    }, clear: function () {
        this.files = {}
    }
};

class M0 {
    constructor(t, e, n) {
        const s = this;
        let r = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (h) {
            a++, r === !1 && s.onStart !== void 0 && s.onStart(h, o, a), r = !0
        }, this.itemEnd = function (h) {
            o++, s.onProgress !== void 0 && s.onProgress(h, o, a), o === a && (r = !1, s.onLoad !== void 0 && s.onLoad())
        }, this.itemError = function (h) {
            s.onError !== void 0 && s.onError(h)
        }, this.resolveURL = function (h) {
            return l ? l(h) : h
        }, this.setURLModifier = function (h) {
            return l = h, this
        }, this.addHandler = function (h, u) {
            return c.push(h, u), this
        }, this.removeHandler = function (h) {
            const u = c.indexOf(h);
            return u !== -1 && c.splice(u, 2), this
        }, this.getHandler = function (h) {
            for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u], g = c[u + 1];
                if (f.global && (f.lastIndex = 0), f.test(h)) return g
            }
            return null
        }
    }
}

const SE = new M0;

class ps {
    constructor(t) {
        this.manager = t !== void 0 ? t : SE, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }

    load() {
    }

    loadAsync(t, e) {
        const n = this;
        return new Promise(function (s, r) {
            n.load(t, s, e, r)
        })
    }

    parse() {
    }

    setCrossOrigin(t) {
        return this.crossOrigin = t, this
    }

    setWithCredentials(t) {
        return this.withCredentials = t, this
    }

    setPath(t) {
        return this.path = t, this
    }

    setResourcePath(t) {
        return this.resourcePath = t, this
    }

    setRequestHeader(t) {
        return this.requestHeader = t, this
    }
}

const Ki = {};

class pL extends Error {
    constructor(t, e) {
        super(t), this.response = e
    }
}

class ks extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = Go.get(t);
        if (r !== void 0) return this.manager.itemStart(t), setTimeout(() => {
            e && e(r), this.manager.itemEnd(t)
        }, 0), r;
        if (Ki[t] !== void 0) {
            Ki[t].push({onLoad: e, onProgress: n, onError: s});
            return
        }
        Ki[t] = [], Ki[t].push({onLoad: e, onProgress: n, onError: s});
        const o = new Request(t, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        }), a = this.mimeType, l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
                const h = Ki[t], u = c.body.getReader(),
                    d = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), f = d ? parseInt(d) : 0,
                    g = f !== 0;
                let m = 0;
                const p = new ReadableStream({
                    start(_) {
                        x();

                        function x() {
                            u.read().then(({done: y, value: v}) => {
                                if (y) _.close(); else {
                                    m += v.byteLength;
                                    const w = new ProgressEvent("progress", {lengthComputable: g, loaded: m, total: f});
                                    for (let E = 0, S = h.length; E < S; E++) {
                                        const b = h[E];
                                        b.onProgress && b.onProgress(w)
                                    }
                                    _.enqueue(v), x()
                                }
                            })
                        }
                    }
                });
                return new Response(p)
            } else throw new pL(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
        }).then(c => {
            switch (l) {
                case"arraybuffer":
                    return c.arrayBuffer();
                case"blob":
                    return c.blob();
                case"document":
                    return c.text().then(h => new DOMParser().parseFromString(h, a));
                case"json":
                    return c.json();
                default:
                    if (a === void 0) return c.text();
                {
                    const u = /charset="?([^;"\s]*)"?/i.exec(a), d = u && u[1] ? u[1].toLowerCase() : void 0,
                        f = new TextDecoder(d);
                    return c.arrayBuffer().then(g => f.decode(g))
                }
            }
        }).then(c => {
            Go.add(t, c);
            const h = Ki[t];
            delete Ki[t];
            for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onLoad && f.onLoad(c)
            }
        }).catch(c => {
            const h = Ki[t];
            if (h === void 0) throw this.manager.itemError(t), c;
            delete Ki[t];
            for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onError && f.onError(c)
            }
            this.manager.itemError(t)
        }).finally(() => {
            this.manager.itemEnd(t)
        }), this.manager.itemStart(t)
    }

    setResponseType(t) {
        return this.responseType = t, this
    }

    setMimeType(t) {
        return this.mimeType = t, this
    }
}

class gL extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = this, o = new ks(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function (a) {
            try {
                e(r.parse(JSON.parse(a)))
            } catch (l) {
                s ? s(l) : console.error(l), r.manager.itemError(t)
            }
        }, n, s)
    }

    parse(t) {
        const e = [];
        for (let n = 0; n < t.length; n++) {
            const s = Wr.parse(t[n]);
            e.push(s)
        }
        return e
    }
}

class mL extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = this, o = [], a = new p0, l = new ks(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
        let c = 0;

        function h(u) {
            l.load(t[u], function (d) {
                const f = r.parse(d, !0);
                o[u] = {
                    width: f.width,
                    height: f.height,
                    format: f.format,
                    mipmaps: f.mipmaps
                }, c += 1, c === 6 && (f.mipmapCount === 1 && (a.minFilter = Qe), a.image = o, a.format = f.format, a.needsUpdate = !0, e && e(a))
            }, n, s)
        }

        if (Array.isArray(t)) for (let u = 0, d = t.length; u < d; ++u) h(u); else l.load(t, function (u) {
            const d = r.parse(u, !0);
            if (d.isCubemap) {
                const f = d.mipmaps.length / d.mipmapCount;
                for (let g = 0; g < f; g++) {
                    o[g] = {mipmaps: []};
                    for (let m = 0; m < d.mipmapCount; m++) o[g].mipmaps.push(d.mipmaps[g * d.mipmapCount + m]), o[g].format = d.format, o[g].width = d.width, o[g].height = d.height
                }
                a.image = o
            } else a.image.width = d.width, a.image.height = d.height, a.mipmaps = d.mipmaps;
            d.mipmapCount === 1 && (a.minFilter = Qe), a.format = d.format, a.needsUpdate = !0, e && e(a)
        }, n, s);
        return a
    }
}

class $c extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = Go.get(t);
        if (o !== void 0) return r.manager.itemStart(t), setTimeout(function () {
            e && e(o), r.manager.itemEnd(t)
        }, 0), o;
        const a = Bc("img");

        function l() {
            h(), Go.add(t, this), e && e(this), r.manager.itemEnd(t)
        }

        function c(u) {
            h(), s && s(u), r.manager.itemError(t), r.manager.itemEnd(t)
        }

        function h() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1)
        }

        return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
    }
}

class _L extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = new dh, o = new $c(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;

        function l(c) {
            o.load(t[c], function (h) {
                r.images[c] = h, a++, a === 6 && (r.needsUpdate = !0, e && e(r))
            }, void 0, s)
        }

        for (let c = 0; c < t.length; ++c) l(c);
        return r
    }
}

class yL extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = this, o = new ka, a = new ks(this.manager);
        return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(t, function (l) {
            const c = r.parse(l);
            c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : kn, o.wrapT = c.wrapT !== void 0 ? c.wrapT : kn, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Qe, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Qe, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.encoding !== void 0 && (o.encoding = c.encoding), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = zi), c.mipmapCount === 1 && (o.minFilter = Qe), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, e && e(o, c))
        }, n, s), o
    }
}

class T0 extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = new Sn, o = new $c(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (a) {
            r.image = a, r.needsUpdate = !0, e !== void 0 && e(r)
        }, n, s), r
    }
}

class jr extends re {
    constructor(t, e = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new pt(t), this.intensity = e
    }

    dispose() {
    }

    copy(t, e) {
        return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
    }

    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e
    }
}

class ME extends jr {
    constructor(t, e, n) {
        super(t, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(re.DEFAULT_UP), this.updateMatrix(), this.groundColor = new pt(e)
    }

    copy(t, e) {
        return super.copy(t, e), this.groundColor.copy(t.groundColor), this
    }
}

const $p = new Yt, px = new C, gx = new C;

class I0 {
    constructor(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new j(512, 512), this.map = null, this.mapPass = null, this.matrix = new Yt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new jd, this._frameExtents = new j(1, 1), this._viewportCount = 1, this._viewports = [new Fe(0, 0, 1, 1)]
    }

    getViewportCount() {
        return this._viewportCount
    }

    getFrustum() {
        return this._frustum
    }

    updateMatrices(t) {
        const e = this.camera, n = this.matrix;
        px.setFromMatrixPosition(t.matrixWorld), e.position.copy(px), gx.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(gx), e.updateMatrixWorld(), $p.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix($p), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply($p)
    }

    getViewport(t) {
        return this._viewports[t]
    }

    getFrameExtents() {
        return this._frameExtents
    }

    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }

    copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
    }

    clone() {
        return new this.constructor().copy(this)
    }

    toJSON() {
        const t = {};
        return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
    }
}

class xL extends I0 {
    constructor() {
        super(new bn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }

    updateMatrices(t) {
        const e = this.camera, n = zc * 2 * t.angle * this.focus, s = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
        (n !== e.fov || s !== e.aspect || r !== e.far) && (e.fov = n, e.aspect = s, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
    }

    copy(t) {
        return super.copy(t), this.focus = t.focus, this
    }
}

class A0 extends jr {
    constructor(t, e, n = 0, s = Math.PI / 3, r = 0, o = 2) {
        super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(re.DEFAULT_UP), this.updateMatrix(), this.target = new re, this.distance = n, this.angle = s, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new xL
    }

    get power() {
        return this.intensity * Math.PI
    }

    set power(t) {
        this.intensity = t / Math.PI
    }

    dispose() {
        this.shadow.dispose()
    }

    copy(t, e) {
        return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}

const mx = new Yt, tc = new C, Wp = new C;

class vL extends I0 {
    constructor() {
        super(new bn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new j(4, 2), this._viewportCount = 6, this._viewports = [new Fe(2, 1, 1, 1), new Fe(0, 1, 1, 1), new Fe(3, 1, 1, 1), new Fe(1, 1, 1, 1), new Fe(3, 0, 1, 1), new Fe(1, 0, 1, 1)], this._cubeDirections = [new C(1, 0, 0), new C(-1, 0, 0), new C(0, 0, 1), new C(0, 0, -1), new C(0, 1, 0), new C(0, -1, 0)], this._cubeUps = [new C(0, 1, 0), new C(0, 1, 0), new C(0, 1, 0), new C(0, 1, 0), new C(0, 0, 1), new C(0, 0, -1)]
    }

    updateMatrices(t, e = 0) {
        const n = this.camera, s = this.matrix, r = t.distance || n.far;
        r !== n.far && (n.far = r, n.updateProjectionMatrix()), tc.setFromMatrixPosition(t.matrixWorld), n.position.copy(tc), Wp.copy(n.position), Wp.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Wp), n.updateMatrixWorld(), s.makeTranslation(-tc.x, -tc.y, -tc.z), mx.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(mx)
    }
}

class C0 extends jr {
    constructor(t, e, n = 0, s = 2) {
        super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new vL
    }

    get power() {
        return this.intensity * 4 * Math.PI
    }

    set power(t) {
        this.intensity = t / (4 * Math.PI)
    }

    dispose() {
        this.shadow.dispose()
    }

    copy(t, e) {
        return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }
}

class wL extends I0 {
    constructor() {
        super(new Ml(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}

class af extends jr {
    constructor(t, e) {
        super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(re.DEFAULT_UP), this.updateMatrix(), this.target = new re, this.shadow = new wL
    }

    dispose() {
        this.shadow.dispose()
    }

    copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}

class P0 extends jr {
    constructor(t, e) {
        super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}

class TE extends jr {
    constructor(t, e, n = 10, s = 10) {
        super(t, e), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = s
    }

    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }

    set power(t) {
        this.intensity = t / (this.width * this.height * Math.PI)
    }

    copy(t) {
        return super.copy(t), this.width = t.width, this.height = t.height, this
    }

    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.width = this.width, e.object.height = this.height, e
    }
}

class IE {
    constructor() {
        this.isSphericalHarmonics3 = !0, this.coefficients = [];
        for (let t = 0; t < 9; t++) this.coefficients.push(new C)
    }

    set(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
        return this
    }

    zero() {
        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
        return this
    }

    getAt(t, e) {
        const n = t.x, s = t.y, r = t.z, o = this.coefficients;
        return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * s), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], 1.092548 * (n * s)), e.addScaledVector(o[5], 1.092548 * (s * r)), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], 1.092548 * (n * r)), e.addScaledVector(o[8], .546274 * (n * n - s * s)), e
    }

    getIrradianceAt(t, e) {
        const n = t.x, s = t.y, r = t.z, o = this.coefficients;
        return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 2 * .511664 * s), e.addScaledVector(o[2], 2 * .511664 * r), e.addScaledVector(o[3], 2 * .511664 * n), e.addScaledVector(o[4], 2 * .429043 * n * s), e.addScaledVector(o[5], 2 * .429043 * s * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], 2 * .429043 * n * r), e.addScaledVector(o[8], .429043 * (n * n - s * s)), e
    }

    add(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
        return this
    }

    addScaledSH(t, e) {
        for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
        return this
    }

    scale(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
        return this
    }

    lerp(t, e) {
        for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
        return this
    }

    equals(t) {
        for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
        return !0
    }

    copy(t) {
        return this.set(t.coefficients)
    }

    clone() {
        return new this.constructor().copy(this)
    }

    fromArray(t, e = 0) {
        const n = this.coefficients;
        for (let s = 0; s < 9; s++) n[s].fromArray(t, e + s * 3);
        return this
    }

    toArray(t = [], e = 0) {
        const n = this.coefficients;
        for (let s = 0; s < 9; s++) n[s].toArray(t, e + s * 3);
        return t
    }

    static getBasisAt(t, e) {
        const n = t.x, s = t.y, r = t.z;
        e[0] = .282095, e[1] = .488603 * s, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * s, e[5] = 1.092548 * s * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - s * s)
    }
}

class lf extends jr {
    constructor(t = new IE, e = 1) {
        super(void 0, e), this.isLightProbe = !0, this.sh = t
    }

    copy(t) {
        return super.copy(t), this.sh.copy(t.sh), this
    }

    fromJSON(t) {
        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
    }

    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.sh = this.sh.toArray(), e
    }
}

class cf extends ps {
    constructor(t) {
        super(t), this.textures = {}
    }

    load(t, e, n, s) {
        const r = this, o = new ks(r.manager);
        o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function (a) {
            try {
                e(r.parse(JSON.parse(a)))
            } catch (l) {
                s ? s(l) : console.error(l), r.manager.itemError(t)
            }
        }, n, s)
    }

    parse(t) {
        const e = this.textures;

        function n(r) {
            return e[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), e[r]
        }

        const s = cf.createMaterialFromType(t.type);
        if (t.uuid !== void 0 && (s.uuid = t.uuid), t.name !== void 0 && (s.name = t.name), t.color !== void 0 && s.color !== void 0 && s.color.setHex(t.color), t.roughness !== void 0 && (s.roughness = t.roughness), t.metalness !== void 0 && (s.metalness = t.metalness), t.sheen !== void 0 && (s.sheen = t.sheen), t.sheenColor !== void 0 && (s.sheenColor = new pt().setHex(t.sheenColor)), t.sheenRoughness !== void 0 && (s.sheenRoughness = t.sheenRoughness), t.emissive !== void 0 && s.emissive !== void 0 && s.emissive.setHex(t.emissive), t.specular !== void 0 && s.specular !== void 0 && s.specular.setHex(t.specular), t.specularIntensity !== void 0 && (s.specularIntensity = t.specularIntensity), t.specularColor !== void 0 && s.specularColor !== void 0 && s.specularColor.setHex(t.specularColor), t.shininess !== void 0 && (s.shininess = t.shininess), t.clearcoat !== void 0 && (s.clearcoat = t.clearcoat), t.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = t.clearcoatRoughness), t.iridescence !== void 0 && (s.iridescence = t.iridescence), t.iridescenceIOR !== void 0 && (s.iridescenceIOR = t.iridescenceIOR), t.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = t.iridescenceThicknessRange), t.transmission !== void 0 && (s.transmission = t.transmission), t.thickness !== void 0 && (s.thickness = t.thickness), t.attenuationDistance !== void 0 && (s.attenuationDistance = t.attenuationDistance), t.attenuationColor !== void 0 && s.attenuationColor !== void 0 && s.attenuationColor.setHex(t.attenuationColor), t.fog !== void 0 && (s.fog = t.fog), t.flatShading !== void 0 && (s.flatShading = t.flatShading), t.blending !== void 0 && (s.blending = t.blending), t.combine !== void 0 && (s.combine = t.combine), t.side !== void 0 && (s.side = t.side), t.shadowSide !== void 0 && (s.shadowSide = t.shadowSide), t.opacity !== void 0 && (s.opacity = t.opacity), t.transparent !== void 0 && (s.transparent = t.transparent), t.alphaTest !== void 0 && (s.alphaTest = t.alphaTest), t.depthTest !== void 0 && (s.depthTest = t.depthTest), t.depthWrite !== void 0 && (s.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (s.colorWrite = t.colorWrite), t.stencilWrite !== void 0 && (s.stencilWrite = t.stencilWrite), t.stencilWriteMask !== void 0 && (s.stencilWriteMask = t.stencilWriteMask), t.stencilFunc !== void 0 && (s.stencilFunc = t.stencilFunc), t.stencilRef !== void 0 && (s.stencilRef = t.stencilRef), t.stencilFuncMask !== void 0 && (s.stencilFuncMask = t.stencilFuncMask), t.stencilFail !== void 0 && (s.stencilFail = t.stencilFail), t.stencilZFail !== void 0 && (s.stencilZFail = t.stencilZFail), t.stencilZPass !== void 0 && (s.stencilZPass = t.stencilZPass), t.wireframe !== void 0 && (s.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (s.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (s.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (s.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (s.rotation = t.rotation), t.linewidth !== 1 && (s.linewidth = t.linewidth), t.dashSize !== void 0 && (s.dashSize = t.dashSize), t.gapSize !== void 0 && (s.gapSize = t.gapSize), t.scale !== void 0 && (s.scale = t.scale), t.polygonOffset !== void 0 && (s.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (s.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (s.polygonOffsetUnits = t.polygonOffsetUnits), t.dithering !== void 0 && (s.dithering = t.dithering), t.alphaToCoverage !== void 0 && (s.alphaToCoverage = t.alphaToCoverage), t.premultipliedAlpha !== void 0 && (s.premultipliedAlpha = t.premultipliedAlpha), t.forceSinglePass !== void 0 && (s.forceSinglePass = t.forceSinglePass), t.visible !== void 0 && (s.visible = t.visible), t.toneMapped !== void 0 && (s.toneMapped = t.toneMapped), t.userData !== void 0 && (s.userData = t.userData), t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? s.vertexColors = t.vertexColors > 0 : s.vertexColors = t.vertexColors), t.uniforms !== void 0) for (const r in t.uniforms) {
            const o = t.uniforms[r];
            switch (s.uniforms[r] = {}, o.type) {
                case"t":
                    s.uniforms[r].value = n(o.value);
                    break;
                case"c":
                    s.uniforms[r].value = new pt().setHex(o.value);
                    break;
                case"v2":
                    s.uniforms[r].value = new j().fromArray(o.value);
                    break;
                case"v3":
                    s.uniforms[r].value = new C().fromArray(o.value);
                    break;
                case"v4":
                    s.uniforms[r].value = new Fe().fromArray(o.value);
                    break;
                case"m3":
                    s.uniforms[r].value = new ds().fromArray(o.value);
                    break;
                case"m4":
                    s.uniforms[r].value = new Yt().fromArray(o.value);
                    break;
                default:
                    s.uniforms[r].value = o.value
            }
        }
        if (t.defines !== void 0 && (s.defines = t.defines), t.vertexShader !== void 0 && (s.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (s.fragmentShader = t.fragmentShader), t.glslVersion !== void 0 && (s.glslVersion = t.glslVersion), t.extensions !== void 0) for (const r in t.extensions) s.extensions[r] = t.extensions[r];
        if (t.size !== void 0 && (s.size = t.size), t.sizeAttenuation !== void 0 && (s.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (s.map = n(t.map)), t.matcap !== void 0 && (s.matcap = n(t.matcap)), t.alphaMap !== void 0 && (s.alphaMap = n(t.alphaMap)), t.bumpMap !== void 0 && (s.bumpMap = n(t.bumpMap)), t.bumpScale !== void 0 && (s.bumpScale = t.bumpScale), t.normalMap !== void 0 && (s.normalMap = n(t.normalMap)), t.normalMapType !== void 0 && (s.normalMapType = t.normalMapType), t.normalScale !== void 0) {
            let r = t.normalScale;
            Array.isArray(r) === !1 && (r = [r, r]), s.normalScale = new j().fromArray(r)
        }
        return t.displacementMap !== void 0 && (s.displacementMap = n(t.displacementMap)), t.displacementScale !== void 0 && (s.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (s.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (s.roughnessMap = n(t.roughnessMap)), t.metalnessMap !== void 0 && (s.metalnessMap = n(t.metalnessMap)), t.emissiveMap !== void 0 && (s.emissiveMap = n(t.emissiveMap)), t.emissiveIntensity !== void 0 && (s.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (s.specularMap = n(t.specularMap)), t.specularIntensityMap !== void 0 && (s.specularIntensityMap = n(t.specularIntensityMap)), t.specularColorMap !== void 0 && (s.specularColorMap = n(t.specularColorMap)), t.envMap !== void 0 && (s.envMap = n(t.envMap)), t.envMapIntensity !== void 0 && (s.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (s.reflectivity = t.reflectivity), t.refractionRatio !== void 0 && (s.refractionRatio = t.refractionRatio), t.lightMap !== void 0 && (s.lightMap = n(t.lightMap)), t.lightMapIntensity !== void 0 && (s.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (s.aoMap = n(t.aoMap)), t.aoMapIntensity !== void 0 && (s.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (s.gradientMap = n(t.gradientMap)), t.clearcoatMap !== void 0 && (s.clearcoatMap = n(t.clearcoatMap)), t.clearcoatRoughnessMap !== void 0 && (s.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), t.clearcoatNormalMap !== void 0 && (s.clearcoatNormalMap = n(t.clearcoatNormalMap)), t.clearcoatNormalScale !== void 0 && (s.clearcoatNormalScale = new j().fromArray(t.clearcoatNormalScale)), t.iridescenceMap !== void 0 && (s.iridescenceMap = n(t.iridescenceMap)), t.iridescenceThicknessMap !== void 0 && (s.iridescenceThicknessMap = n(t.iridescenceThicknessMap)), t.transmissionMap !== void 0 && (s.transmissionMap = n(t.transmissionMap)), t.thicknessMap !== void 0 && (s.thicknessMap = n(t.thicknessMap)), t.sheenColorMap !== void 0 && (s.sheenColorMap = n(t.sheenColorMap)), t.sheenRoughnessMap !== void 0 && (s.sheenRoughnessMap = n(t.sheenRoughnessMap)), s
    }

    setTextures(t) {
        return this.textures = t, this
    }

    static createMaterialFromType(t) {
        const e = {
            ShadowMaterial: dE,
            SpriteMaterial: tf,
            RawShaderMaterial: fE,
            ShaderMaterial: jn,
            PointsMaterial: nf,
            MeshPhysicalMaterial: dr,
            MeshStandardMaterial: Zn,
            MeshPhongMaterial: pE,
            MeshToonMaterial: gE,
            MeshNormalMaterial: mE,
            MeshLambertMaterial: _E,
            MeshDepthMaterial: a0,
            MeshDistanceMaterial: l0,
            MeshBasicMaterial: rn,
            MeshMatcapMaterial: yE,
            LineDashedMaterial: xE,
            LineBasicMaterial: Jn,
            Material: En
        };
        return new e[t]
    }
}

class cl {
    static decodeText(t) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(t);
        let e = "";
        for (let n = 0, s = t.length; n < s; n++) e += String.fromCharCode(t[n]);
        try {
            return decodeURIComponent(escape(e))
        } catch {
            return e
        }
    }

    static extractUrlBase(t) {
        const e = t.lastIndexOf("/");
        return e === -1 ? "./" : t.slice(0, e + 1)
    }

    static resolveURL(t, e) {
        return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
    }
}

class AE extends Xt {
    constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }

    copy(t) {
        return super.copy(t), this.instanceCount = t.instanceCount, this
    }

    toJSON() {
        const t = super.toJSON();
        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
    }
}

class CE extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = this, o = new ks(r.manager);
        o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function (a) {
            try {
                e(r.parse(JSON.parse(a)))
            } catch (l) {
                s ? s(l) : console.error(l), r.manager.itemError(t)
            }
        }, n, s)
    }

    parse(t) {
        const e = {}, n = {};

        function s(f, g) {
            if (e[g] !== void 0) return e[g];
            const p = f.interleavedBuffers[g], _ = r(f, p.buffer), x = La(p.type, _), y = new fh(x, p.stride);
            return y.uuid = p.uuid, e[g] = y, y
        }

        function r(f, g) {
            if (n[g] !== void 0) return n[g];
            const p = f.arrayBuffers[g], _ = new Uint32Array(p).buffer;
            return n[g] = _, _
        }

        const o = t.isInstancedBufferGeometry ? new AE : new Xt, a = t.data.index;
        if (a !== void 0) {
            const f = La(a.type, a.array);
            o.setIndex(new ae(f, 1))
        }
        const l = t.data.attributes;
        for (const f in l) {
            const g = l[f];
            let m;
            if (g.isInterleavedBufferAttribute) {
                const p = s(t.data, g.data);
                m = new Hr(p, g.itemSize, g.offset, g.normalized)
            } else {
                const p = La(g.type, g.array), _ = g.isInstancedBufferAttribute ? ol : ae;
                m = new _(p, g.itemSize, g.normalized)
            }
            g.name !== void 0 && (m.name = g.name), g.usage !== void 0 && m.setUsage(g.usage), g.updateRange !== void 0 && (m.updateRange.offset = g.updateRange.offset, m.updateRange.count = g.updateRange.count), o.setAttribute(f, m)
        }
        const c = t.data.morphAttributes;
        if (c) for (const f in c) {
            const g = c[f], m = [];
            for (let p = 0, _ = g.length; p < _; p++) {
                const x = g[p];
                let y;
                if (x.isInterleavedBufferAttribute) {
                    const v = s(t.data, x.data);
                    y = new Hr(v, x.itemSize, x.offset, x.normalized)
                } else {
                    const v = La(x.type, x.array);
                    y = new ae(v, x.itemSize, x.normalized)
                }
                x.name !== void 0 && (y.name = x.name), m.push(y)
            }
            o.morphAttributes[f] = m
        }
        t.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const u = t.data.groups || t.data.drawcalls || t.data.offsets;
        if (u !== void 0) for (let f = 0, g = u.length; f !== g; ++f) {
            const m = u[f];
            o.addGroup(m.start, m.count, m.materialIndex)
        }
        const d = t.data.boundingSphere;
        if (d !== void 0) {
            const f = new C;
            d.center !== void 0 && f.fromArray(d.center), o.boundingSphere = new Zr(f, d.radius)
        }
        return t.name && (o.name = t.name), t.userData && (o.userData = t.userData), o
    }
}

class bL extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = this, o = this.path === "" ? cl.extractUrlBase(t) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new ks(this.manager);
        a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function (l) {
            let c = null;
            try {
                c = JSON.parse(l)
            } catch (u) {
                s !== void 0 && s(u), console.error("THREE:ObjectLoader: Can't parse " + t + ".", u.message);
                return
            }
            const h = c.metadata;
            if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
                s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + t)), console.error("THREE.ObjectLoader: Can't load " + t);
                return
            }
            r.parse(c, e)
        }, n, s)
    }

    async loadAsync(t, e) {
        const n = this, s = this.path === "" ? cl.extractUrlBase(t) : this.path;
        this.resourcePath = this.resourcePath || s;
        const r = new ks(this.manager);
        r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
        const o = await r.loadAsync(t, e), a = JSON.parse(o), l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + t);
        return await n.parseAsync(a)
    }

    parse(t, e) {
        const n = this.parseAnimations(t.animations), s = this.parseShapes(t.shapes),
            r = this.parseGeometries(t.geometries, s), o = this.parseImages(t.images, function () {
                e !== void 0 && e(c)
            }), a = this.parseTextures(t.textures, o), l = this.parseMaterials(t.materials, a),
            c = this.parseObject(t.object, r, l, a, n), h = this.parseSkeletons(t.skeletons, c);
        if (this.bindSkeletons(c, h), e !== void 0) {
            let u = !1;
            for (const d in o) if (o[d].data instanceof HTMLImageElement) {
                u = !0;
                break
            }
            u === !1 && e(c)
        }
        return c
    }

    async parseAsync(t) {
        const e = this.parseAnimations(t.animations), n = this.parseShapes(t.shapes),
            s = this.parseGeometries(t.geometries, n), r = await this.parseImagesAsync(t.images),
            o = this.parseTextures(t.textures, r), a = this.parseMaterials(t.materials, o),
            l = this.parseObject(t.object, s, a, o, e), c = this.parseSkeletons(t.skeletons, l);
        return this.bindSkeletons(l, c), l
    }

    parseShapes(t) {
        const e = {};
        if (t !== void 0) for (let n = 0, s = t.length; n < s; n++) {
            const r = new Do().fromJSON(t[n]);
            e[r.uuid] = r
        }
        return e
    }

    parseSkeletons(t, e) {
        const n = {}, s = {};
        if (e.traverse(function (r) {
            r.isBone && (s[r.uuid] = r)
        }), t !== void 0) for (let r = 0, o = t.length; r < o; r++) {
            const a = new ph().fromJSON(t[r], s);
            n[a.uuid] = a
        }
        return n
    }

    parseGeometries(t, e) {
        const n = {};
        if (t !== void 0) {
            const s = new CE;
            for (let r = 0, o = t.length; r < o; r++) {
                let a;
                const l = t[r];
                switch (l.type) {
                    case"BufferGeometry":
                    case"InstancedBufferGeometry":
                        a = s.parse(l);
                        break;
                    default:
                        l.type in fx ? a = fx[l.type].fromJSON(l, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a
            }
        }
        return n
    }

    parseMaterials(t, e) {
        const n = {}, s = {};
        if (t !== void 0) {
            const r = new cf;
            r.setTextures(e);
            for (let o = 0, a = t.length; o < a; o++) {
                const l = t[o];
                n[l.uuid] === void 0 && (n[l.uuid] = r.parse(l)), s[l.uuid] = n[l.uuid]
            }
        }
        return s
    }

    parseAnimations(t) {
        const e = {};
        if (t !== void 0) for (let n = 0; n < t.length; n++) {
            const s = t[n], r = Wr.parse(s);
            e[r.uuid] = r
        }
        return e
    }

    parseImages(t, e) {
        const n = this, s = {};
        let r;

        function o(l) {
            return n.manager.itemStart(l), r.load(l, function () {
                n.manager.itemEnd(l)
            }, void 0, function () {
                n.manager.itemError(l), n.manager.itemEnd(l)
            })
        }

        function a(l) {
            if (typeof l == "string") {
                const c = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
                return o(h)
            } else return l.data ? {data: La(l.type, l.data), width: l.width, height: l.height} : null
        }

        if (t !== void 0 && t.length > 0) {
            const l = new M0(e);
            r = new $c(l), r.setCrossOrigin(this.crossOrigin);
            for (let c = 0, h = t.length; c < h; c++) {
                const u = t[c], d = u.url;
                if (Array.isArray(d)) {
                    const f = [];
                    for (let g = 0, m = d.length; g < m; g++) {
                        const p = d[g], _ = a(p);
                        _ !== null && (_ instanceof HTMLImageElement ? f.push(_) : f.push(new ka(_.data, _.width, _.height)))
                    }
                    s[u.uuid] = new Io(f)
                } else {
                    const f = a(u.url);
                    s[u.uuid] = new Io(f)
                }
            }
        }
        return s
    }

    async parseImagesAsync(t) {
        const e = this, n = {};
        let s;

        async function r(o) {
            if (typeof o == "string") {
                const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : e.resourcePath + a;
                return await s.loadAsync(l)
            } else return o.data ? {data: La(o.type, o.data), width: o.width, height: o.height} : null
        }

        if (t !== void 0 && t.length > 0) {
            s = new $c(this.manager), s.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = t.length; o < a; o++) {
                const l = t[o], c = l.url;
                if (Array.isArray(c)) {
                    const h = [];
                    for (let u = 0, d = c.length; u < d; u++) {
                        const f = c[u], g = await r(f);
                        g !== null && (g instanceof HTMLImageElement ? h.push(g) : h.push(new ka(g.data, g.width, g.height)))
                    }
                    n[l.uuid] = new Io(h)
                } else {
                    const h = await r(l.url);
                    n[l.uuid] = new Io(h)
                }
            }
        }
        return n
    }

    parseTextures(t, e) {
        function n(r, o) {
            return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), o[r])
        }

        const s = {};
        if (t !== void 0) for (let r = 0, o = t.length; r < o; r++) {
            const a = t[r];
            a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), e[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
            const l = e[a.image], c = l.data;
            let h;
            Array.isArray(c) ? (h = new dh, c.length === 6 && (h.needsUpdate = !0)) : (c && c.data ? h = new ka : h = new Sn, c && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = n(a.mapping, EL)), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = n(a.wrap[0], _x), h.wrapT = n(a.wrap[1], _x)), a.format !== void 0 && (h.format = a.format), a.type !== void 0 && (h.type = a.type), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = n(a.minFilter, yx)), a.magFilter !== void 0 && (h.magFilter = n(a.magFilter, yx)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (h.userData = a.userData), s[a.uuid] = h
        }
        return s
    }

    parseObject(t, e, n, s, r) {
        let o;

        function a(d) {
            return e[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), e[d]
        }

        function l(d) {
            if (d !== void 0) {
                if (Array.isArray(d)) {
                    const f = [];
                    for (let g = 0, m = d.length; g < m; g++) {
                        const p = d[g];
                        n[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), f.push(n[p])
                    }
                    return f
                }
                return n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), n[d]
            }
        }

        function c(d) {
            return s[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), s[d]
        }

        let h, u;
        switch (t.type) {
            case"Scene":
                o = new Sc, t.background !== void 0 && (Number.isInteger(t.background) ? o.background = new pt(t.background) : o.background = c(t.background)), t.environment !== void 0 && (o.environment = c(t.environment)), t.fog !== void 0 && (t.fog.type === "Fog" ? o.fog = new Qd(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (o.fog = new Jd(t.fog.color, t.fog.density))), t.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = t.backgroundBlurriness), t.backgroundIntensity !== void 0 && (o.backgroundIntensity = t.backgroundIntensity);
                break;
            case"PerspectiveCamera":
                o = new bn(t.fov, t.aspect, t.near, t.far), t.focus !== void 0 && (o.focus = t.focus), t.zoom !== void 0 && (o.zoom = t.zoom), t.filmGauge !== void 0 && (o.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (o.filmOffset = t.filmOffset), t.view !== void 0 && (o.view = Object.assign({}, t.view));
                break;
            case"OrthographicCamera":
                o = new Ml(t.left, t.right, t.top, t.bottom, t.near, t.far), t.zoom !== void 0 && (o.zoom = t.zoom), t.view !== void 0 && (o.view = Object.assign({}, t.view));
                break;
            case"AmbientLight":
                o = new P0(t.color, t.intensity);
                break;
            case"DirectionalLight":
                o = new af(t.color, t.intensity);
                break;
            case"PointLight":
                o = new C0(t.color, t.intensity, t.distance, t.decay);
                break;
            case"RectAreaLight":
                o = new TE(t.color, t.intensity, t.width, t.height);
                break;
            case"SpotLight":
                o = new A0(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                break;
            case"HemisphereLight":
                o = new ME(t.color, t.groundColor, t.intensity);
                break;
            case"LightProbe":
                o = new lf().fromJSON(t);
                break;
            case"SkinnedMesh":
                h = a(t.geometry), u = l(t.material), o = new h0(h, u), t.bindMode !== void 0 && (o.bindMode = t.bindMode), t.bindMatrix !== void 0 && o.bindMatrix.fromArray(t.bindMatrix), t.skeleton !== void 0 && (o.skeleton = t.skeleton);
                break;
            case"Mesh":
                h = a(t.geometry), u = l(t.material), o = new ge(h, u);
                break;
            case"InstancedMesh":
                h = a(t.geometry), u = l(t.material);
                const d = t.count, f = t.instanceMatrix, g = t.instanceColor;
                o = new u0(h, u, d), o.instanceMatrix = new ol(new Float32Array(f.array), 16), g !== void 0 && (o.instanceColor = new ol(new Float32Array(g.array), g.itemSize));
                break;
            case"LOD":
                o = new eE;
                break;
            case"Line":
                o = new lr(a(t.geometry), l(t.material));
                break;
            case"LineLoop":
                o = new d0(a(t.geometry), l(t.material));
                break;
            case"LineSegments":
                o = new pi(a(t.geometry), l(t.material));
                break;
            case"PointCloud":
            case"Points":
                o = new f0(a(t.geometry), l(t.material));
                break;
            case"Sprite":
                o = new tE(l(t.material));
                break;
            case"Group":
                o = new or;
                break;
            case"Bone":
                o = new ef;
                break;
            default:
                o = new re
        }
        if (o.uuid = t.uuid, t.name !== void 0 && (o.name = t.name), t.matrix !== void 0 ? (o.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = t.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (t.position !== void 0 && o.position.fromArray(t.position), t.rotation !== void 0 && o.rotation.fromArray(t.rotation), t.quaternion !== void 0 && o.quaternion.fromArray(t.quaternion), t.scale !== void 0 && o.scale.fromArray(t.scale)), t.castShadow !== void 0 && (o.castShadow = t.castShadow), t.receiveShadow !== void 0 && (o.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (o.shadow.bias = t.shadow.bias), t.shadow.normalBias !== void 0 && (o.shadow.normalBias = t.shadow.normalBias), t.shadow.radius !== void 0 && (o.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(t.shadow.camera))), t.visible !== void 0 && (o.visible = t.visible), t.frustumCulled !== void 0 && (o.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (o.renderOrder = t.renderOrder), t.userData !== void 0 && (o.userData = t.userData), t.layers !== void 0 && (o.layers.mask = t.layers), t.children !== void 0) {
            const d = t.children;
            for (let f = 0; f < d.length; f++) o.add(this.parseObject(d[f], e, n, s, r))
        }
        if (t.animations !== void 0) {
            const d = t.animations;
            for (let f = 0; f < d.length; f++) {
                const g = d[f];
                o.animations.push(r[g])
            }
        }
        if (t.type === "LOD") {
            t.autoUpdate !== void 0 && (o.autoUpdate = t.autoUpdate);
            const d = t.levels;
            for (let f = 0; f < d.length; f++) {
                const g = d[f], m = o.getObjectByProperty("uuid", g.object);
                m !== void 0 && o.addLevel(m, g.distance, g.hysteresis)
            }
        }
        return o
    }

    bindSkeletons(t, e) {
        Object.keys(e).length !== 0 && t.traverse(function (n) {
            if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                const s = e[n.skeleton];
                s === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(s, n.bindMatrix)
            }
        })
    }
}

const EL = {
    UVMapping: $d,
    CubeReflectionMapping: Br,
    CubeRefractionMapping: kr,
    EquirectangularReflectionMapping: Lc,
    EquirectangularRefractionMapping: Nc,
    CubeUVReflectionMapping: El
}, _x = {RepeatWrapping: Ur, ClampToEdgeWrapping: kn, MirroredRepeatWrapping: el}, yx = {
    NearestFilter: sn,
    NearestMipmapNearestFilter: Oc,
    NearestMipmapLinearFilter: Ba,
    LinearFilter: Qe,
    LinearMipmapNearestFilter: Wd,
    LinearMipmapLinearFilter: zi
};

class PE extends ps {
    constructor(t) {
        super(t), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {premultiplyAlpha: "none"}
    }

    setOptions(t) {
        return this.options = t, this
    }

    load(t, e, n, s) {
        t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = Go.get(t);
        if (o !== void 0) return r.manager.itemStart(t), setTimeout(function () {
            e && e(o), r.manager.itemEnd(t)
        }, 0), o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then(function (l) {
            return l.blob()
        }).then(function (l) {
            return createImageBitmap(l, Object.assign(r.options, {colorSpaceConversion: "none"}))
        }).then(function (l) {
            Go.add(t, l), e && e(l), r.manager.itemEnd(t)
        }).catch(function (l) {
            s && s(l), r.manager.itemError(t), r.manager.itemEnd(t)
        }), r.manager.itemStart(t)
    }
}

let yu;

class R0 {
    static getContext() {
        return yu === void 0 && (yu = new (window.AudioContext || window.webkitAudioContext)), yu
    }

    static setContext(t) {
        yu = t
    }
}

class SL extends ps {
    constructor(t) {
        super(t)
    }

    load(t, e, n, s) {
        const r = this, o = new ks(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function (a) {
            try {
                const l = a.slice(0);
                R0.getContext().decodeAudioData(l, function (h) {
                    e(h)
                })
            } catch (l) {
                s ? s(l) : console.error(l), r.manager.itemError(t)
            }
        }, n, s)
    }
}

class ML extends lf {
    constructor(t, e, n = 1) {
        super(void 0, n), this.isHemisphereLightProbe = !0;
        const s = new pt().set(t), r = new pt().set(e), o = new C(s.r, s.g, s.b), a = new C(r.r, r.g, r.b),
            l = Math.sqrt(Math.PI), c = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
    }
}

class TL extends lf {
    constructor(t, e = 1) {
        super(void 0, e), this.isAmbientLightProbe = !0;
        const n = new pt().set(t);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}

const xx = new Yt, vx = new Yt, oo = new Yt;

class IL {
    constructor() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new bn, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new bn, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }

    update(t) {
        const e = this._cache;
        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, oo.copy(t.projectionMatrix);
            const s = e.eyeSep / 2, r = s * e.near / e.focus, o = e.near * Math.tan(Lo * e.fov * .5) / e.zoom;
            let a, l;
            vx.elements[12] = -s, xx.elements[12] = s, a = -o * e.aspect + r, l = o * e.aspect + r, oo.elements[0] = 2 * e.near / (l - a), oo.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(oo), a = -o * e.aspect - r, l = o * e.aspect - r, oo.elements[0] = 2 * e.near / (l - a), oo.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(oo)
        }
        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(vx), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(xx)
    }
}

class hf {
    constructor(t = !0) {
        this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }

    start() {
        this.startTime = wx(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }

    stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }

    getElapsedTime() {
        return this.getDelta(), this.elapsedTime
    }

    getDelta() {
        let t = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const e = wx();
            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
        }
        return t
    }
}

function wx() {
    return (typeof performance > "u" ? Date : performance).now()
}

const ao = new C, bx = new On, AL = new C, lo = new C;

class CL extends re {
    constructor() {
        super(), this.type = "AudioListener", this.context = R0.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new hf
    }

    getInput() {
        return this.gain
    }

    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
    }

    getFilter() {
        return this.filter
    }

    setFilter(t) {
        return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
    }

    getMasterVolume() {
        return this.gain.gain.value
    }

    setMasterVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
    }

    updateMatrixWorld(t) {
        super.updateMatrixWorld(t);
        const e = this.context.listener, n = this.up;
        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ao, bx, AL), lo.set(0, 0, -1).applyQuaternion(bx), e.positionX) {
            const s = this.context.currentTime + this.timeDelta;
            e.positionX.linearRampToValueAtTime(ao.x, s), e.positionY.linearRampToValueAtTime(ao.y, s), e.positionZ.linearRampToValueAtTime(ao.z, s), e.forwardX.linearRampToValueAtTime(lo.x, s), e.forwardY.linearRampToValueAtTime(lo.y, s), e.forwardZ.linearRampToValueAtTime(lo.z, s), e.upX.linearRampToValueAtTime(n.x, s), e.upY.linearRampToValueAtTime(n.y, s), e.upZ.linearRampToValueAtTime(n.z, s)
        } else e.setPosition(ao.x, ao.y, ao.z), e.setOrientation(lo.x, lo.y, lo.z, n.x, n.y, n.z)
    }
}

class RE extends re {
    constructor(t) {
        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
    }

    getOutput() {
        return this.gain
    }

    setNodeSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
    }

    setMediaElementSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
    }

    setMediaStreamSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
    }

    setBuffer(t) {
        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
    }

    play(t = 0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + t;
        const e = this.context.createBufferSource();
        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
    }

    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
    }

    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
    }

    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this
    }

    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this
    }

    getFilters() {
        return this.filters
    }

    setFilters(t) {
        return t || (t = []), this._connected === !0 ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
    }

    setDetune(t) {
        if (this.detune = t, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }

    getDetune() {
        return this.detune
    }

    getFilter() {
        return this.getFilters()[0]
    }

    setFilter(t) {
        return this.setFilters(t ? [t] : [])
    }

    setPlaybackRate(t) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
    }

    getPlaybackRate() {
        return this.playbackRate
    }

    onEnded() {
        this.isPlaying = !1
    }

    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }

    setLoop(t) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this
    }

    setLoopStart(t) {
        return this.loopStart = t, this
    }

    setLoopEnd(t) {
        return this.loopEnd = t, this
    }

    getVolume() {
        return this.gain.gain.value
    }

    setVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
    }
}

const co = new C, Ex = new On, PL = new C, ho = new C;

class RL extends RE {
    constructor(t) {
        super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    disconnect() {
        super.disconnect(), this.panner.disconnect(this.gain)
    }

    getOutput() {
        return this.panner
    }

    getRefDistance() {
        return this.panner.refDistance
    }

    setRefDistance(t) {
        return this.panner.refDistance = t, this
    }

    getRolloffFactor() {
        return this.panner.rolloffFactor
    }

    setRolloffFactor(t) {
        return this.panner.rolloffFactor = t, this
    }

    getDistanceModel() {
        return this.panner.distanceModel
    }

    setDistanceModel(t) {
        return this.panner.distanceModel = t, this
    }

    getMaxDistance() {
        return this.panner.maxDistance
    }

    setMaxDistance(t) {
        return this.panner.maxDistance = t, this
    }

    setDirectionalCone(t, e, n) {
        return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
    }

    updateMatrixWorld(t) {
        if (super.updateMatrixWorld(t), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
        this.matrixWorld.decompose(co, Ex, PL), ho.set(0, 0, 1).applyQuaternion(Ex);
        const e = this.panner;
        if (e.positionX) {
            const n = this.context.currentTime + this.listener.timeDelta;
            e.positionX.linearRampToValueAtTime(co.x, n), e.positionY.linearRampToValueAtTime(co.y, n), e.positionZ.linearRampToValueAtTime(co.z, n), e.orientationX.linearRampToValueAtTime(ho.x, n), e.orientationY.linearRampToValueAtTime(ho.y, n), e.orientationZ.linearRampToValueAtTime(ho.z, n)
        } else e.setPosition(co.x, co.y, co.z), e.setOrientation(ho.x, ho.y, ho.z)
    }
}

class LL {
    constructor(t, e = 2048) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
    }

    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data
    }

    getAverageFrequency() {
        let t = 0;
        const e = this.getFrequencyData();
        for (let n = 0; n < e.length; n++) t += e[n];
        return t / e.length
    }
}

class LE {
    constructor(t, e, n) {
        this.binding = t, this.valueSize = n;
        let s, r, o;
        switch (e) {
            case"quaternion":
                s = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                break;
            case"string":
            case"bool":
                s = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                break;
            default:
                s = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5)
        }
        this._mixBufferRegion = s, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }

    accumulate(t, e) {
        const n = this.buffer, s = this.valueSize, r = t * s + s;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== s; ++a) n[r + a] = n[a];
            o = e
        } else {
            o += e;
            const a = e / o;
            this._mixBufferRegion(n, r, 0, a, s)
        }
        this.cumulativeWeight = o
    }

    accumulateAdditive(t) {
        const e = this.buffer, n = this.valueSize, s = n * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, s, 0, t, n), this.cumulativeWeightAdditive += t
    }

    apply(t) {
        const e = this.valueSize, n = this.buffer, s = t * e + e, r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive, a = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
            const l = e * this._origIndex;
            this._mixBufferRegion(n, s, l, 1 - r, e)
        }
        o > 0 && this._mixBufferRegionAdditive(n, s, this._addIndex * e, 1, e);
        for (let l = e, c = e + e; l !== c; ++l) if (n[l] !== n[l + e]) {
            a.setValue(n, s);
            break
        }
    }

    saveOriginalState() {
        const t = this.binding, e = this.buffer, n = this.valueSize, s = n * this._origIndex;
        t.getValue(e, s);
        for (let r = n, o = s; r !== o; ++r) e[r] = e[s + r % n];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
    }

    restoreOriginalState() {
        const t = this.valueSize * 3;
        this.binding.setValue(this.buffer, t)
    }

    _setAdditiveIdentityNumeric() {
        const t = this._addIndex * this.valueSize, e = t + this.valueSize;
        for (let n = t; n < e; n++) this.buffer[n] = 0
    }

    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
    }

    _setAdditiveIdentityOther() {
        const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
    }

    _select(t, e, n, s, r) {
        if (s >= .5) for (let o = 0; o !== r; ++o) t[e + o] = t[n + o]
    }

    _slerp(t, e, n, s) {
        On.slerpFlat(t, e, t, e, t, n, s)
    }

    _slerpAdditive(t, e, n, s, r) {
        const o = this._workIndex * r;
        On.multiplyQuaternionsFlat(t, o, t, e, t, n), On.slerpFlat(t, e, t, e, t, o, s)
    }

    _lerp(t, e, n, s, r) {
        const o = 1 - s;
        for (let a = 0; a !== r; ++a) {
            const l = e + a;
            t[l] = t[l] * o + t[n + a] * s
        }
    }

    _lerpAdditive(t, e, n, s, r) {
        for (let o = 0; o !== r; ++o) {
            const a = e + o;
            t[a] = t[a] + t[n + o] * s
        }
    }
}

const L0 = "\\[\\]\\.:\\/", NL = new RegExp("[" + L0 + "]", "g"), N0 = "[^" + L0 + "]",
    OL = "[^" + L0.replace("\\.", "") + "]", DL = /((?:WC+[\/:])*)/.source.replace("WC", N0),
    FL = /(WCOD+)?/.source.replace("WCOD", OL), zL = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", N0),
    BL = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", N0), kL = new RegExp("^" + DL + FL + zL + BL + "$"),
    UL = ["material", "materials", "bones", "map"];

class GL {
    constructor(t, e, n) {
        const s = n || fe.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, s)
    }

    getValue(t, e) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_, s = this._bindings[n];
        s !== void 0 && s.getValue(t, e)
    }

    setValue(t, e) {
        const n = this._bindings;
        for (let s = this._targetGroup.nCachedObjects_, r = n.length; s !== r; ++s) n[s].setValue(t, e)
    }

    bind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
    }

    unbind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
    }
}

class fe {
    constructor(t, e, n) {
        this.path = e, this.parsedPath = n || fe.parseTrackName(e), this.node = fe.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }

    static create(t, e, n) {
        return t && t.isAnimationObjectGroup ? new fe.Composite(t, e, n) : new fe(t, e, n)
    }

    static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(NL, "")
    }

    static parseTrackName(t) {
        const e = kL.exec(t);
        if (e === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const n = {nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6]},
            s = n.nodeName && n.nodeName.lastIndexOf(".");
        if (s !== void 0 && s !== -1) {
            const r = n.nodeName.substring(s + 1);
            UL.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, s), n.objectName = r)
        }
        if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return n
    }

    static findNode(t, e) {
        if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e);
            if (n !== void 0) return n
        }
        if (t.children) {
            const n = function (r) {
                for (let o = 0; o < r.length; o++) {
                    const a = r[o];
                    if (a.name === e || a.uuid === e) return a;
                    const l = n(a.children);
                    if (l) return l
                }
                return null
            }, s = n(t.children);
            if (s) return s
        }
        return null
    }

    _getValue_unavailable() {
    }

    _setValue_unavailable() {
    }

    _getValue_direct(t, e) {
        t[e] = this.targetObject[this.propertyName]
    }

    _getValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let s = 0, r = n.length; s !== r; ++s) t[e++] = n[s]
    }

    _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex]
    }

    _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e)
    }

    _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e]
    }

    _setValue_direct_setNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
    }

    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let s = 0, r = n.length; s !== r; ++s) n[s] = t[e++]
    }

    _setValue_array_setNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let s = 0, r = n.length; s !== r; ++s) n[s] = t[e++];
        this.targetObject.needsUpdate = !0
    }

    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let s = 0, r = n.length; s !== r; ++s) n[s] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e]
    }

    _setValue_arrayElement_setNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
    }

    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e)
    }

    _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
    }

    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e)
    }

    _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e)
    }

    bind() {
        let t = this.node;
        const e = this.parsedPath, n = e.objectName, s = e.propertyName;
        let r = e.propertyIndex;
        if (t || (t = fe.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (n) {
            let c = e.objectIndex;
            switch (n) {
                case"materials":
                    if (!t.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!t.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    t = t.material.materials;
                    break;
                case"bones":
                    if (!t.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    t = t.skeleton.bones;
                    for (let h = 0; h < t.length; h++) if (t[h].name === c) {
                        c = h;
                        break
                    }
                    break;
                case"map":
                    if ("map" in t) {
                        t = t.map;
                        break
                    }
                    if (!t.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!t.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    t = t.material.map;
                    break;
                default:
                    if (t[n] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    t = t[n]
            }
            if (c !== void 0) {
                if (t[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    return
                }
                t = t[c]
            }
        }
        const o = t[s];
        if (o === void 0) {
            const c = e.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + s + " but it wasn't found.", t);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = t, t.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (r !== void 0) {
            if (s === "morphTargetInfluences") {
                if (!t.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!t.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                t.morphTargetDictionary[r] !== void 0 && (r = t.morphTargetDictionary[r])
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
        } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = s;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }

    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}

fe.Composite = GL;
fe.prototype.BindingType = {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3};
fe.prototype.Versioning = {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2};
fe.prototype.GetterByBindingType = [fe.prototype._getValue_direct, fe.prototype._getValue_array, fe.prototype._getValue_arrayElement, fe.prototype._getValue_toArray];
fe.prototype.SetterByBindingTypeAndVersioning = [[fe.prototype._setValue_direct, fe.prototype._setValue_direct_setNeedsUpdate, fe.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [fe.prototype._setValue_array, fe.prototype._setValue_array_setNeedsUpdate, fe.prototype._setValue_array_setMatrixWorldNeedsUpdate], [fe.prototype._setValue_arrayElement, fe.prototype._setValue_arrayElement_setNeedsUpdate, fe.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [fe.prototype._setValue_fromArray, fe.prototype._setValue_fromArray_setNeedsUpdate, fe.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

class VL {
    constructor() {
        this.isAnimationObjectGroup = !0, this.uuid = zs(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const t = {};
        this._indicesByUUID = t;
        for (let n = 0, s = arguments.length; n !== s; ++n) t[arguments[n].uuid] = n;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const e = this;
        this.stats = {
            objects: {
                get total() {
                    return e._objects.length
                }, get inUse() {
                    return this.total - e.nCachedObjects_
                }
            }, get bindingsPerObject() {
                return e._bindings.length
            }
        }
    }

    add() {
        const t = this._objects, e = this._indicesByUUID, n = this._paths, s = this._parsedPaths, r = this._bindings,
            o = r.length;
        let a, l = t.length, c = this.nCachedObjects_;
        for (let h = 0, u = arguments.length; h !== u; ++h) {
            const d = arguments[h], f = d.uuid;
            let g = e[f];
            if (g === void 0) {
                g = l++, e[f] = g, t.push(d);
                for (let m = 0, p = o; m !== p; ++m) r[m].push(new fe(d, n[m], s[m]))
            } else if (g < c) {
                a = t[g];
                const m = --c, p = t[m];
                e[p.uuid] = g, t[g] = p, e[f] = m, t[m] = d;
                for (let _ = 0, x = o; _ !== x; ++_) {
                    const y = r[_], v = y[m];
                    let w = y[g];
                    y[g] = v, w === void 0 && (w = new fe(d, n[_], s[_])), y[m] = w
                }
            } else t[g] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = c
    }

    remove() {
        const t = this._objects, e = this._indicesByUUID, n = this._bindings, s = n.length;
        let r = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o], c = l.uuid, h = e[c];
            if (h !== void 0 && h >= r) {
                const u = r++, d = t[u];
                e[d.uuid] = h, t[h] = d, e[c] = u, t[u] = l;
                for (let f = 0, g = s; f !== g; ++f) {
                    const m = n[f], p = m[u], _ = m[h];
                    m[h] = p, m[u] = _
                }
            }
        }
        this.nCachedObjects_ = r
    }

    uncache() {
        const t = this._objects, e = this._indicesByUUID, n = this._bindings, s = n.length;
        let r = this.nCachedObjects_, o = t.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a], h = c.uuid, u = e[h];
            if (u !== void 0) if (delete e[h], u < r) {
                const d = --r, f = t[d], g = --o, m = t[g];
                e[f.uuid] = u, t[u] = f, e[m.uuid] = d, t[d] = m, t.pop();
                for (let p = 0, _ = s; p !== _; ++p) {
                    const x = n[p], y = x[d], v = x[g];
                    x[u] = y, x[d] = v, x.pop()
                }
            } else {
                const d = --o, f = t[d];
                d > 0 && (e[f.uuid] = u), t[u] = f, t.pop();
                for (let g = 0, m = s; g !== m; ++g) {
                    const p = n[g];
                    p[u] = p[d], p.pop()
                }
            }
        }
        this.nCachedObjects_ = r
    }

    subscribe_(t, e) {
        const n = this._bindingsIndicesByPath;
        let s = n[t];
        const r = this._bindings;
        if (s !== void 0) return r[s];
        const o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, h = this.nCachedObjects_,
            u = new Array(c);
        s = r.length, n[t] = s, o.push(t), a.push(e), r.push(u);
        for (let d = h, f = l.length; d !== f; ++d) {
            const g = l[d];
            u[d] = new fe(g, t, e)
        }
        return u
    }

    unsubscribe_(t) {
        const e = this._bindingsIndicesByPath, n = e[t];
        if (n !== void 0) {
            const s = this._paths, r = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = t[a];
            e[c] = n, o[n] = l, o.pop(), r[n] = r[a], r.pop(), s[n] = s[a], s.pop()
        }
    }
}

class HL {
    constructor(t, e, n = null, s = e.blendMode) {
        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = s;
        const r = e.tracks, o = r.length, a = new Array(o), l = {endingStart: Mo, endingEnd: Mo};
        for (let c = 0; c !== o; ++c) {
            const h = r[c].createInterpolant(null);
            a[c] = h, h.settings = l
        }
        this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Ab, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    play() {
        return this._mixer._activateAction(this), this
    }

    stop() {
        return this._mixer._deactivateAction(this), this.reset()
    }

    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }

    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }

    isScheduled() {
        return this._mixer._isActiveAction(this)
    }

    startAt(t) {
        return this._startTime = t, this
    }

    setLoop(t, e) {
        return this.loop = t, this.repetitions = e, this
    }

    setEffectiveWeight(t) {
        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
    }

    getEffectiveWeight() {
        return this._effectiveWeight
    }

    fadeIn(t) {
        return this._scheduleFading(t, 0, 1)
    }

    fadeOut(t) {
        return this._scheduleFading(t, 1, 0)
    }

    crossFadeFrom(t, e, n) {
        if (t.fadeOut(e), this.fadeIn(e), n) {
            const s = this._clip.duration, r = t._clip.duration, o = r / s, a = s / r;
            t.warp(1, o, e), this.warp(a, 1, e)
        }
        return this
    }

    crossFadeTo(t, e, n) {
        return t.crossFadeFrom(this, e, n)
    }

    stopFading() {
        const t = this._weightInterpolant;
        return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }

    setEffectiveTimeScale(t) {
        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
    }

    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }

    setDuration(t) {
        return this.timeScale = this._clip.duration / t, this.stopWarping()
    }

    syncWith(t) {
        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
    }

    halt(t) {
        return this.warp(this._effectiveTimeScale, 0, t)
    }

    warp(t, e, n) {
        const s = this._mixer, r = s.time, o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = s._lendControlInterpolant(), this._timeScaleInterpolant = a);
        const l = a.parameterPositions, c = a.sampleValues;
        return l[0] = r, l[1] = r + n, c[0] = t / o, c[1] = e / o, this
    }

    stopWarping() {
        const t = this._timeScaleInterpolant;
        return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }

    getMixer() {
        return this._mixer
    }

    getClip() {
        return this._clip
    }

    getRoot() {
        return this._localRoot || this._mixer._root
    }

    _update(t, e, n, s) {
        if (!this.enabled) {
            this._updateWeight(t);
            return
        }
        const r = this._startTime;
        if (r !== null) {
            const l = (t - r) * n;
            l < 0 || n === 0 ? e = 0 : (this._startTime = null, e = n * l)
        }
        e *= this._updateTimeScale(t);
        const o = this._updateTime(e), a = this._updateWeight(t);
        if (a > 0) {
            const l = this._interpolants, c = this._propertyBindings;
            switch (this.blendMode) {
                case Jm:
                    for (let h = 0, u = l.length; h !== u; ++h) l[h].evaluate(o), c[h].accumulateAdditive(a);
                    break;
                case qd:
                default:
                    for (let h = 0, u = l.length; h !== u; ++h) l[h].evaluate(o), c[h].accumulate(s, a)
            }
        }
    }

    _updateWeight(t) {
        let e = 0;
        if (this.enabled) {
            e = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
                const s = n.evaluate(t)[0];
                e *= s, t > n.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = e, e
    }

    _updateTimeScale(t) {
        let e = 0;
        if (!this.paused) {
            e = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (n !== null) {
                const s = n.evaluate(t)[0];
                e *= s, t > n.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e)
            }
        }
        return this._effectiveTimeScale = e, e
    }

    _updateTime(t) {
        const e = this._clip.duration, n = this.loop;
        let s = this.time + t, r = this._loopCount;
        const o = n === Cb;
        if (t === 0) return r === -1 ? s : o && (r & 1) === 1 ? e - s : s;
        if (n === Ib) {
            r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            t:{
                if (s >= e) s = e; else if (s < 0) s = 0; else {
                    this.time = s;
                    break t
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1
                })
            }
        } else {
            if (r === -1 && (t >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), s >= e || s < 0) {
                const a = Math.floor(s / e);
                s -= e * a, r += Math.abs(a);
                const l = this.repetitions - r;
                if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = t > 0 ? e : 0, this.time = s, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1
                }); else {
                    if (l === 1) {
                        const c = t < 0;
                        this._setEndings(c, !c, o)
                    } else this._setEndings(!1, !1, o);
                    this._loopCount = r, this.time = s, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else this.time = s;
            if (o && (r & 1) === 1) return e - s
        }
        return s
    }

    _setEndings(t, e, n) {
        const s = this._interpolantSettings;
        n ? (s.endingStart = To, s.endingEnd = To) : (t ? s.endingStart = this.zeroSlopeAtStart ? To : Mo : s.endingStart = Dc, e ? s.endingEnd = this.zeroSlopeAtEnd ? To : Mo : s.endingEnd = Dc)
    }

    _scheduleFading(t, e, n) {
        const s = this._mixer, r = s.time;
        let o = this._weightInterpolant;
        o === null && (o = s._lendControlInterpolant(), this._weightInterpolant = o);
        const a = o.parameterPositions, l = o.sampleValues;
        return a[0] = r, l[0] = e, a[1] = r + t, l[1] = n, this
    }
}

const $L = new Float32Array(1);

class NE extends Gi {
    constructor(t) {
        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    _bindAction(t, e) {
        const n = t._localRoot || this._root, s = t._clip.tracks, r = s.length, o = t._propertyBindings,
            a = t._interpolants, l = n.uuid, c = this._bindingsByRootAndName;
        let h = c[l];
        h === void 0 && (h = {}, c[l] = h);
        for (let u = 0; u !== r; ++u) {
            const d = s[u], f = d.name;
            let g = h[f];
            if (g !== void 0) ++g.referenceCount, o[u] = g; else {
                if (g = o[u], g !== void 0) {
                    g._cacheIndex === null && (++g.referenceCount, this._addInactiveBinding(g, l, f));
                    continue
                }
                const m = e && e._propertyBindings[u].binding.parsedPath;
                g = new LE(fe.create(n, f, m), d.ValueTypeName, d.getValueSize()), ++g.referenceCount, this._addInactiveBinding(g, l, f), o[u] = g
            }
            a[u].resultBuffer = g.buffer
        }
    }

    _activateAction(t) {
        if (!this._isActiveAction(t)) {
            if (t._cacheIndex === null) {
                const n = (t._localRoot || this._root).uuid, s = t._clip.uuid, r = this._actionsByClip[s];
                this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, s, n)
            }
            const e = t._propertyBindings;
            for (let n = 0, s = e.length; n !== s; ++n) {
                const r = e[n];
                r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState())
            }
            this._lendAction(t)
        }
    }

    _deactivateAction(t) {
        if (this._isActiveAction(t)) {
            const e = t._propertyBindings;
            for (let n = 0, s = e.length; n !== s; ++n) {
                const r = e[n];
                --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r))
            }
            this._takeBackAction(t)
        }
    }

    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const t = this;
        this.stats = {
            actions: {
                get total() {
                    return t._actions.length
                }, get inUse() {
                    return t._nActiveActions
                }
            }, bindings: {
                get total() {
                    return t._bindings.length
                }, get inUse() {
                    return t._nActiveBindings
                }
            }, controlInterpolants: {
                get total() {
                    return t._controlInterpolants.length
                }, get inUse() {
                    return t._nActiveControlInterpolants
                }
            }
        }
    }

    _isActiveAction(t) {
        const e = t._cacheIndex;
        return e !== null && e < this._nActiveActions
    }

    _addInactiveAction(t, e, n) {
        const s = this._actions, r = this._actionsByClip;
        let o = r[e];
        if (o === void 0) o = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, r[e] = o; else {
            const a = o.knownActions;
            t._byClipCacheIndex = a.length, a.push(t)
        }
        t._cacheIndex = s.length, s.push(t), o.actionByRoot[n] = t
    }

    _removeInactiveAction(t) {
        const e = this._actions, n = e[e.length - 1], s = t._cacheIndex;
        n._cacheIndex = s, e[s] = n, e.pop(), t._cacheIndex = null;
        const r = t._clip.uuid, o = this._actionsByClip, a = o[r], l = a.knownActions, c = l[l.length - 1],
            h = t._byClipCacheIndex;
        c._byClipCacheIndex = h, l[h] = c, l.pop(), t._byClipCacheIndex = null;
        const u = a.actionByRoot, d = (t._localRoot || this._root).uuid;
        delete u[d], l.length === 0 && delete o[r], this._removeInactiveBindingsForAction(t)
    }

    _removeInactiveBindingsForAction(t) {
        const e = t._propertyBindings;
        for (let n = 0, s = e.length; n !== s; ++n) {
            const r = e[n];
            --r.referenceCount === 0 && this._removeInactiveBinding(r)
        }
    }

    _lendAction(t) {
        const e = this._actions, n = t._cacheIndex, s = this._nActiveActions++, r = e[s];
        t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r
    }

    _takeBackAction(t) {
        const e = this._actions, n = t._cacheIndex, s = --this._nActiveActions, r = e[s];
        t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r
    }

    _addInactiveBinding(t, e, n) {
        const s = this._bindingsByRootAndName, r = this._bindings;
        let o = s[e];
        o === void 0 && (o = {}, s[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t)
    }

    _removeInactiveBinding(t) {
        const e = this._bindings, n = t.binding, s = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName,
            a = o[s], l = e[e.length - 1], c = t._cacheIndex;
        l._cacheIndex = c, e[c] = l, e.pop(), delete a[r], Object.keys(a).length === 0 && delete o[s]
    }

    _lendBinding(t) {
        const e = this._bindings, n = t._cacheIndex, s = this._nActiveBindings++, r = e[s];
        t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r
    }

    _takeBackBinding(t) {
        const e = this._bindings, n = t._cacheIndex, s = --this._nActiveBindings, r = e[s];
        t._cacheIndex = s, e[s] = t, r._cacheIndex = n, e[n] = r
    }

    _lendControlInterpolant() {
        const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
        let n = t[e];
        return n === void 0 && (n = new E0(new Float32Array(2), new Float32Array(2), 1, $L), n.__cacheIndex = e, t[e] = n), n
    }

    _takeBackControlInterpolant(t) {
        const e = this._controlInterpolants, n = t.__cacheIndex, s = --this._nActiveControlInterpolants, r = e[s];
        t.__cacheIndex = s, e[s] = t, r.__cacheIndex = n, e[n] = r
    }

    clipAction(t, e, n) {
        const s = e || this._root, r = s.uuid;
        let o = typeof t == "string" ? Wr.findByName(s, t) : t;
        const a = o !== null ? o.uuid : t, l = this._actionsByClip[a];
        let c = null;
        if (n === void 0 && (o !== null ? n = o.blendMode : n = qd), l !== void 0) {
            const u = l.actionByRoot[r];
            if (u !== void 0 && u.blendMode === n) return u;
            c = l.knownActions[0], o === null && (o = c._clip)
        }
        if (o === null) return null;
        const h = new HL(this, o, e, n);
        return this._bindAction(h, c), this._addInactiveAction(h, a, r), h
    }

    existingAction(t, e) {
        const n = e || this._root, s = n.uuid, r = typeof t == "string" ? Wr.findByName(n, t) : t, o = r ? r.uuid : t,
            a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[s] || null
    }

    stopAllAction() {
        const t = this._actions, e = this._nActiveActions;
        for (let n = e - 1; n >= 0; --n) t[n].stop();
        return this
    }

    update(t) {
        t *= this.timeScale;
        const e = this._actions, n = this._nActiveActions, s = this.time += t, r = Math.sign(t),
            o = this._accuIndex ^= 1;
        for (let c = 0; c !== n; ++c) e[c]._update(s, t, r, o);
        const a = this._bindings, l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c) a[c].apply(o);
        return this
    }

    setTime(t) {
        this.time = 0;
        for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
        return this.update(t)
    }

    getRoot() {
        return this._root
    }

    uncacheClip(t) {
        const e = this._actions, n = t.uuid, s = this._actionsByClip, r = s[n];
        if (r !== void 0) {
            const o = r.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const h = c._cacheIndex, u = e[e.length - 1];
                c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = h, e[h] = u, e.pop(), this._removeInactiveBindingsForAction(c)
            }
            delete s[n]
        }
    }

    uncacheRoot(t) {
        const e = t.uuid, n = this._actionsByClip;
        for (const o in n) {
            const a = n[o].actionByRoot, l = a[e];
            l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
        }
        const s = this._bindingsByRootAndName, r = s[e];
        if (r !== void 0) for (const o in r) {
            const a = r[o];
            a.restoreOriginalState(), this._removeInactiveBinding(a)
        }
    }

    uncacheAction(t, e) {
        const n = this.existingAction(t, e);
        n !== null && (this._deactivateAction(n), this._removeInactiveAction(n))
    }
}

class O0 {
    constructor(t) {
        this.value = t
    }

    clone() {
        return new O0(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}

let WL = 0;

class qL extends Gi {
    constructor() {
        super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {value: WL++}), this.name = "", this.usage = Fc, this.uniforms = []
    }

    add(t) {
        return this.uniforms.push(t), this
    }

    remove(t) {
        const e = this.uniforms.indexOf(t);
        return e !== -1 && this.uniforms.splice(e, 1), this
    }

    setName(t) {
        return this.name = t, this
    }

    setUsage(t) {
        return this.usage = t, this
    }

    dispose() {
        return this.dispatchEvent({type: "dispose"}), this
    }

    copy(t) {
        this.name = t.name, this.usage = t.usage;
        const e = t.uniforms;
        this.uniforms.length = 0;
        for (let n = 0, s = e.length; n < s; n++) this.uniforms.push(e[n].clone());
        return this
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

class YL extends fh {
    constructor(t, e, n = 1) {
        super(t, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
    }

    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }

    clone(t) {
        const e = super.clone(t);
        return e.meshPerAttribute = this.meshPerAttribute, e
    }

    toJSON(t) {
        const e = super.toJSON(t);
        return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
    }
}

class XL {
    constructor(t, e, n, s, r) {
        this.isGLBufferAttribute = !0, this.name = "", this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = s, this.count = r, this.version = 0
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }

    setBuffer(t) {
        return this.buffer = t, this
    }

    setType(t, e) {
        return this.type = t, this.elementSize = e, this
    }

    setItemSize(t) {
        return this.itemSize = t, this
    }

    setCount(t) {
        return this.count = t, this
    }
}

class OE {
    constructor(t, e, n = 0, s = 1 / 0) {
        this.ray = new uh(t, e), this.near = n, this.far = s, this.camera = null, this.layers = new Xd, this.params = {
            Mesh: {},
            Line: {threshold: 1},
            LOD: {},
            Points: {threshold: 1},
            Sprite: {}
        }
    }

    set(t, e) {
        this.ray.set(t, e)
    }

    setFromCamera(t, e) {
        e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
    }

    intersectObject(t, e = !0, n = []) {
        return Em(t, this, n, e), n.sort(Sx), n
    }

    intersectObjects(t, e = !0, n = []) {
        for (let s = 0, r = t.length; s < r; s++) Em(t[s], this, n, e);
        return n.sort(Sx), n
    }
}

function Sx(i, t) {
    return i.distance - t.distance
}

function Em(i, t, e, n) {
    if (i.layers.test(t.layers) && i.raycast(t, e), n === !0) {
        const s = i.children;
        for (let r = 0, o = s.length; r < o; r++) Em(s[r], t, e, !0)
    }
}

class Sm {
    constructor(t = 1, e = 0, n = 0) {
        return this.radius = t, this.phi = e, this.theta = n, this
    }

    set(t, e, n) {
        return this.radius = t, this.phi = e, this.theta = n, this
    }

    copy(t) {
        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
    }

    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }

    setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
    }

    setFromCartesianCoords(t, e, n) {
        return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(un(e / this.radius, -1, 1))), this
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

class ZL {
    constructor(t = 1, e = 0, n = 0) {
        return this.radius = t, this.theta = e, this.y = n, this
    }

    set(t, e, n) {
        return this.radius = t, this.theta = e, this.y = n, this
    }

    copy(t) {
        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
    }

    setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
    }

    setFromCartesianCoords(t, e, n) {
        return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

const Mx = new j;

class jL {
    constructor(t = new j(1 / 0, 1 / 0), e = new j(-1 / 0, -1 / 0)) {
        this.isBox2 = !0, this.min = t, this.max = e
    }

    set(t, e) {
        return this.min.copy(t), this.max.copy(e), this
    }

    setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this
    }

    setFromCenterAndSize(t, e) {
        const n = Mx.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
    }

    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
    }

    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }

    getCenter(t) {
        return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }

    getSize(t) {
        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
    }

    expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
    }

    expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
    }

    expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
    }

    containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
    }

    containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
    }

    getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
    }

    intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
    }

    clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max)
    }

    distanceToPoint(t) {
        return Mx.copy(t).clamp(this.min, this.max).sub(t).length()
    }

    intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this
    }

    union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
    }

    translate(t) {
        return this.min.add(t), this.max.add(t), this
    }

    equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
    }
}

const Tx = new C, xu = new C;

class KL {
    constructor(t = new C, e = new C) {
        this.start = t, this.end = e
    }

    set(t, e) {
        return this.start.copy(t), this.end.copy(e), this
    }

    copy(t) {
        return this.start.copy(t.start), this.end.copy(t.end), this
    }

    getCenter(t) {
        return t.addVectors(this.start, this.end).multiplyScalar(.5)
    }

    delta(t) {
        return t.subVectors(this.end, this.start)
    }

    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }

    distance() {
        return this.start.distanceTo(this.end)
    }

    at(t, e) {
        return this.delta(e).multiplyScalar(t).add(this.start)
    }

    closestPointToPointParameter(t, e) {
        Tx.subVectors(t, this.start), xu.subVectors(this.end, this.start);
        const n = xu.dot(xu);
        let r = xu.dot(Tx) / n;
        return e && (r = un(r, 0, 1)), r
    }

    closestPointToPoint(t, e, n) {
        const s = this.closestPointToPointParameter(t, e);
        return this.delta(n).multiplyScalar(s).add(this.start)
    }

    applyMatrix4(t) {
        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
    }

    equals(t) {
        return t.start.equals(this.start) && t.end.equals(this.end)
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

const Ix = new C;

class JL extends re {
    constructor(t, e) {
        super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper";
        const n = new Xt,
            s = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
            const c = o / l * Math.PI * 2, h = a / l * Math.PI * 2;
            s.push(Math.cos(c), Math.sin(c), 1, Math.cos(h), Math.sin(h), 1)
        }
        n.setAttribute("position", new Ct(s, 3));
        const r = new Jn({fog: !1, toneMapped: !1});
        this.cone = new pi(n, r), this.add(this.cone), this.update()
    }

    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }

    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
        const t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t), Ix.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ix), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}

const xr = new C, vu = new Yt, qp = new Yt;

class QL extends pi {
    constructor(t) {
        const e = DE(t), n = new Xt, s = [], r = [], o = new pt(0, 0, 1), a = new pt(0, 1, 0);
        for (let c = 0; c < e.length; c++) {
            const h = e[c];
            h.parent && h.parent.isBone && (s.push(0, 0, 0), s.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
        }
        n.setAttribute("position", new Ct(s, 3)), n.setAttribute("color", new Ct(r, 3));
        const l = new Jn({vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0});
        super(n, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }

    updateMatrixWorld(t) {
        const e = this.bones, n = this.geometry, s = n.getAttribute("position");
        qp.copy(this.root.matrixWorld).invert();
        for (let r = 0, o = 0; r < e.length; r++) {
            const a = e[r];
            a.parent && a.parent.isBone && (vu.multiplyMatrices(qp, a.matrixWorld), xr.setFromMatrixPosition(vu), s.setXYZ(o, xr.x, xr.y, xr.z), vu.multiplyMatrices(qp, a.parent.matrixWorld), xr.setFromMatrixPosition(vu), s.setXYZ(o + 1, xr.x, xr.y, xr.z), o += 2)
        }
        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function DE(i) {
    const t = [];
    i.isBone === !0 && t.push(i);
    for (let e = 0; e < i.children.length; e++) t.push.apply(t, DE(i.children[e]));
    return t
}

class tN extends ge {
    constructor(t, e, n) {
        const s = new Cl(e, 4, 2), r = new rn({wireframe: !0, fog: !1, toneMapped: !1});
        super(s, r), this.light = t, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }

    update() {
        this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}

const eN = new C, Ax = new pt, Cx = new pt;

class nN extends re {
    constructor(t, e, n) {
        super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
        const s = new Al(e);
        s.rotateY(Math.PI * .5), this.material = new rn({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }), this.color === void 0 && (this.material.vertexColors = !0);
        const r = s.getAttribute("position"), o = new Float32Array(r.count * 3);
        s.setAttribute("color", new ae(o, 3)), this.add(new ge(s, this.material)), this.update()
    }

    dispose() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }

    update() {
        const t = this.children[0];
        if (this.color !== void 0) this.material.color.set(this.color); else {
            const e = t.geometry.getAttribute("color");
            Ax.copy(this.light.color), Cx.copy(this.light.groundColor);
            for (let n = 0, s = e.count; n < s; n++) {
                const r = n < s / 2 ? Ax : Cx;
                e.setXYZ(n, r.r, r.g, r.b)
            }
            e.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1), t.lookAt(eN.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}

class sN extends pi {
    constructor(t = 10, e = 10, n = 4473924, s = 8947848) {
        n = new pt(n), s = new pt(s);
        const r = e / 2, o = t / e, a = t / 2, l = [], c = [];
        for (let d = 0, f = 0, g = -a; d <= e; d++, g += o) {
            l.push(-a, 0, g, a, 0, g), l.push(g, 0, -a, g, 0, a);
            const m = d === r ? n : s;
            m.toArray(c, f), f += 3, m.toArray(c, f), f += 3, m.toArray(c, f), f += 3, m.toArray(c, f), f += 3
        }
        const h = new Xt;
        h.setAttribute("position", new Ct(l, 3)), h.setAttribute("color", new Ct(c, 3));
        const u = new Jn({vertexColors: !0, toneMapped: !1});
        super(h, u), this.type = "GridHelper"
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

class iN extends pi {
    constructor(t = 10, e = 16, n = 8, s = 64, r = 4473924, o = 8947848) {
        r = new pt(r), o = new pt(o);
        const a = [], l = [];
        if (e > 1) for (let u = 0; u < e; u++) {
            const d = u / e * (Math.PI * 2), f = Math.sin(d) * t, g = Math.cos(d) * t;
            a.push(0, 0, 0), a.push(f, 0, g);
            const m = u & 1 ? r : o;
            l.push(m.r, m.g, m.b), l.push(m.r, m.g, m.b)
        }
        for (let u = 0; u < n; u++) {
            const d = u & 1 ? r : o, f = t - t / n * u;
            for (let g = 0; g < s; g++) {
                let m = g / s * (Math.PI * 2), p = Math.sin(m) * f, _ = Math.cos(m) * f;
                a.push(p, 0, _), l.push(d.r, d.g, d.b), m = (g + 1) / s * (Math.PI * 2), p = Math.sin(m) * f, _ = Math.cos(m) * f, a.push(p, 0, _), l.push(d.r, d.g, d.b)
            }
        }
        const c = new Xt;
        c.setAttribute("position", new Ct(a, 3)), c.setAttribute("color", new Ct(l, 3));
        const h = new Jn({vertexColors: !0, toneMapped: !1});
        super(c, h), this.type = "PolarGridHelper"
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

const Px = new C, wu = new C, Rx = new C;

class rN extends re {
    constructor(t, e, n) {
        super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", e === void 0 && (e = 1);
        let s = new Xt;
        s.setAttribute("position", new Ct([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        const r = new Jn({fog: !1, toneMapped: !1});
        this.lightPlane = new lr(s, r), this.add(this.lightPlane), s = new Xt, s.setAttribute("position", new Ct([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new lr(s, r), this.add(this.targetLine), this.update()
    }

    dispose() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }

    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Px.setFromMatrixPosition(this.light.matrixWorld), wu.setFromMatrixPosition(this.light.target.matrixWorld), Rx.subVectors(wu, Px), this.lightPlane.lookAt(wu), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(wu), this.targetLine.scale.z = Rx.length()
    }
}

const bu = new C, en = new Zd;

class oN extends pi {
    constructor(t) {
        const e = new Xt, n = new Jn({color: 16777215, vertexColors: !0, toneMapped: !1}), s = [], r = [], o = {};
        a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");

        function a(g, m) {
            l(g), l(m)
        }

        function l(g) {
            s.push(0, 0, 0), r.push(0, 0, 0), o[g] === void 0 && (o[g] = []), o[g].push(s.length / 3 - 1)
        }

        e.setAttribute("position", new Ct(s, 3)), e.setAttribute("color", new Ct(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
        const c = new pt(16755200), h = new pt(16711680), u = new pt(43775), d = new pt(16777215), f = new pt(3355443);
        this.setColors(c, h, u, d, f)
    }

    setColors(t, e, n, s, r) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, t.r, t.g, t.b), a.setXYZ(1, t.r, t.g, t.b), a.setXYZ(2, t.r, t.g, t.b), a.setXYZ(3, t.r, t.g, t.b), a.setXYZ(4, t.r, t.g, t.b), a.setXYZ(5, t.r, t.g, t.b), a.setXYZ(6, t.r, t.g, t.b), a.setXYZ(7, t.r, t.g, t.b), a.setXYZ(8, t.r, t.g, t.b), a.setXYZ(9, t.r, t.g, t.b), a.setXYZ(10, t.r, t.g, t.b), a.setXYZ(11, t.r, t.g, t.b), a.setXYZ(12, t.r, t.g, t.b), a.setXYZ(13, t.r, t.g, t.b), a.setXYZ(14, t.r, t.g, t.b), a.setXYZ(15, t.r, t.g, t.b), a.setXYZ(16, t.r, t.g, t.b), a.setXYZ(17, t.r, t.g, t.b), a.setXYZ(18, t.r, t.g, t.b), a.setXYZ(19, t.r, t.g, t.b), a.setXYZ(20, t.r, t.g, t.b), a.setXYZ(21, t.r, t.g, t.b), a.setXYZ(22, t.r, t.g, t.b), a.setXYZ(23, t.r, t.g, t.b), a.setXYZ(24, e.r, e.g, e.b), a.setXYZ(25, e.r, e.g, e.b), a.setXYZ(26, e.r, e.g, e.b), a.setXYZ(27, e.r, e.g, e.b), a.setXYZ(28, e.r, e.g, e.b), a.setXYZ(29, e.r, e.g, e.b), a.setXYZ(30, e.r, e.g, e.b), a.setXYZ(31, e.r, e.g, e.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, s.r, s.g, s.b), a.setXYZ(39, s.r, s.g, s.b), a.setXYZ(40, r.r, r.g, r.b), a.setXYZ(41, r.r, r.g, r.b), a.setXYZ(42, r.r, r.g, r.b), a.setXYZ(43, r.r, r.g, r.b), a.setXYZ(44, r.r, r.g, r.b), a.setXYZ(45, r.r, r.g, r.b), a.setXYZ(46, r.r, r.g, r.b), a.setXYZ(47, r.r, r.g, r.b), a.setXYZ(48, r.r, r.g, r.b), a.setXYZ(49, r.r, r.g, r.b), a.needsUpdate = !0
    }

    update() {
        const t = this.geometry, e = this.pointMap, n = 1, s = 1;
        en.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), an("c", e, t, en, 0, 0, -1), an("t", e, t, en, 0, 0, 1), an("n1", e, t, en, -n, -s, -1), an("n2", e, t, en, n, -s, -1), an("n3", e, t, en, -n, s, -1), an("n4", e, t, en, n, s, -1), an("f1", e, t, en, -n, -s, 1), an("f2", e, t, en, n, -s, 1), an("f3", e, t, en, -n, s, 1), an("f4", e, t, en, n, s, 1), an("u1", e, t, en, n * .7, s * 1.1, -1), an("u2", e, t, en, -n * .7, s * 1.1, -1), an("u3", e, t, en, 0, s * 2, -1), an("cf1", e, t, en, -n, 0, 1), an("cf2", e, t, en, n, 0, 1), an("cf3", e, t, en, 0, -s, 1), an("cf4", e, t, en, 0, s, 1), an("cn1", e, t, en, -n, 0, -1), an("cn2", e, t, en, n, 0, -1), an("cn3", e, t, en, 0, -s, -1), an("cn4", e, t, en, 0, s, -1), t.getAttribute("position").needsUpdate = !0
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function an(i, t, e, n, s, r, o) {
    bu.set(s, r, o).unproject(n);
    const a = t[i];
    if (a !== void 0) {
        const l = e.getAttribute("position");
        for (let c = 0, h = a.length; c < h; c++) l.setXYZ(a[c], bu.x, bu.y, bu.z)
    }
}

const Eu = new fi;

class aN extends pi {
    constructor(t, e = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            s = new Float32Array(8 * 3), r = new Xt;
        r.setIndex(new ae(n, 1)), r.setAttribute("position", new ae(s, 3)), super(r, new Jn({
            color: e,
            toneMapped: !1
        })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
    }

    update(t) {
        if (t !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Eu.setFromObject(this.object), Eu.isEmpty()) return;
        const e = Eu.min, n = Eu.max, s = this.geometry.attributes.position, r = s.array;
        r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, s.needsUpdate = !0, this.geometry.computeBoundingSphere()
    }

    setFromObject(t) {
        return this.object = t, this.update(), this
    }

    copy(t, e) {
        return super.copy(t, e), this.object = t.object, this
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

class lN extends pi {
    constructor(t, e = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new Xt;
        r.setIndex(new ae(n, 1)), r.setAttribute("position", new Ct(s, 3)), super(r, new Jn({
            color: e,
            toneMapped: !1
        })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
    }

    updateMatrixWorld(t) {
        const e = this.box;
        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

class cN extends lr {
    constructor(t, e = 1, n = 16776960) {
        const s = n, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Xt;
        o.setAttribute("position", new Ct(r, 3)), o.computeBoundingSphere(), super(o, new Jn({
            color: s,
            toneMapped: !1
        })), this.type = "PlaneHelper", this.plane = t, this.size = e;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Xt;
        l.setAttribute("position", new Ct(a, 3)), l.computeBoundingSphere(), this.add(new ge(l, new rn({
            color: s,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }

    updateMatrixWorld(t) {
        this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(t)
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }
}

const Lx = new C;
let Su, Yp;

class hN extends re {
    constructor(t = new C(0, 0, 1), e = new C(0, 0, 0), n = 1, s = 16776960, r = n * .2, o = r * .2) {
        super(), this.type = "ArrowHelper", Su === void 0 && (Su = new Xt, Su.setAttribute("position", new Ct([0, 0, 0, 0, 1, 0], 3)), Yp = new qo(0, .5, 1, 5, 1), Yp.translate(0, -.5, 0)), this.position.copy(e), this.line = new lr(Su, new Jn({
            color: s,
            toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ge(Yp, new rn({
            color: s,
            toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o)
    }

    setDirection(t) {
        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0); else {
            Lx.set(t.z, 0, -t.x).normalize();
            const e = Math.acos(t.y);
            this.quaternion.setFromAxisAngle(Lx, e)
        }
    }

    setLength(t, e = t * .2, n = e * .2) {
        this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
    }

    setColor(t) {
        this.line.material.color.set(t), this.cone.material.color.set(t)
    }

    copy(t) {
        return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
    }

    dispose() {
        this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
    }
}

class uN extends pi {
    constructor(t = 1) {
        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], s = new Xt;
        s.setAttribute("position", new Ct(e, 3)), s.setAttribute("color", new Ct(n, 3));
        const r = new Jn({vertexColors: !0, toneMapped: !1});
        super(s, r), this.type = "AxesHelper"
    }

    setColors(t, e, n) {
        const s = new pt, r = this.geometry.attributes.color.array;
        return s.set(t), s.toArray(r, 0), s.toArray(r, 3), s.set(e), s.toArray(r, 6), s.toArray(r, 9), s.set(n), s.toArray(r, 12), s.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
    }

    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

class dN {
    constructor() {
        this.type = "ShapePath", this.color = new pt, this.subPaths = [], this.currentPath = null
    }

    moveTo(t, e) {
        return this.currentPath = new Uc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
    }

    lineTo(t, e) {
        return this.currentPath.lineTo(t, e), this
    }

    quadraticCurveTo(t, e, n, s) {
        return this.currentPath.quadraticCurveTo(t, e, n, s), this
    }

    bezierCurveTo(t, e, n, s, r, o) {
        return this.currentPath.bezierCurveTo(t, e, n, s, r, o), this
    }

    splineThru(t) {
        return this.currentPath.splineThru(t), this
    }

    toShapes(t) {
        function e(_) {
            const x = [];
            for (let y = 0, v = _.length; y < v; y++) {
                const w = _[y], E = new Do;
                E.curves = w.curves, x.push(E)
            }
            return x
        }

        function n(_, x) {
            const y = x.length;
            let v = !1;
            for (let w = y - 1, E = 0; E < y; w = E++) {
                let S = x[w], b = x[E], M = b.x - S.x, I = b.y - S.y;
                if (Math.abs(I) > Number.EPSILON) {
                    if (I < 0 && (S = x[E], M = -M, b = x[w], I = -I), _.y < S.y || _.y > b.y) continue;
                    if (_.y === S.y) {
                        if (_.x === S.x) return !0
                    } else {
                        const N = I * (_.x - S.x) - M * (_.y - S.y);
                        if (N === 0) return !0;
                        if (N < 0) continue;
                        v = !v
                    }
                } else {
                    if (_.y !== S.y) continue;
                    if (b.x <= _.x && _.x <= S.x || S.x <= _.x && _.x <= b.x) return !0
                }
            }
            return v
        }

        const s = Ri.isClockWise, r = this.subPaths;
        if (r.length === 0) return [];
        let o, a, l;
        const c = [];
        if (r.length === 1) return a = r[0], l = new Do, l.curves = a.curves, c.push(l), c;
        let h = !s(r[0].getPoints());
        h = t ? !h : h;
        const u = [], d = [];
        let f = [], g = 0, m;
        d[g] = void 0, f[g] = [];
        for (let _ = 0, x = r.length; _ < x; _++) a = r[_], m = a.getPoints(), o = s(m), o = t ? !o : o, o ? (!h && d[g] && g++, d[g] = {
            s: new Do,
            p: m
        }, d[g].s.curves = a.curves, h && g++, f[g] = []) : f[g].push({h: a, p: m[0]});
        if (!d[0]) return e(r);
        if (d.length > 1) {
            let _ = !1, x = 0;
            for (let y = 0, v = d.length; y < v; y++) u[y] = [];
            for (let y = 0, v = d.length; y < v; y++) {
                const w = f[y];
                for (let E = 0; E < w.length; E++) {
                    const S = w[E];
                    let b = !0;
                    for (let M = 0; M < d.length; M++) n(S.p, d[M].p) && (y !== M && x++, b ? (b = !1, u[M].push(S)) : _ = !0);
                    b && u[y].push(S)
                }
            }
            x > 0 && _ === !1 && (f = u)
        }
        let p;
        for (let _ = 0, x = d.length; _ < x; _++) {
            l = d[_].s, c.push(l), p = f[_];
            for (let y = 0, v = p.length; y < v; y++) l.holes.push(p[y].h)
        }
        return c
    }
}

const nr = fN();

function fN() {
    const i = new ArrayBuffer(4), t = new Float32Array(i), e = new Uint32Array(i), n = new Uint32Array(512),
        s = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (n[l] = 0, n[l | 256] = 32768, s[l] = 24, s[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, s[l] = -c - 1, s[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, s[l] = 13, s[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, s[l] = 24, s[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, s[l] = 13, s[l | 256] = 13)
    }
    const r = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13, h = 0;
        for (; !(c & 8388608);) c <<= 1, h -= 8388608;
        c &= -8388609, h += 947912704, r[l] = c | h
    }
    for (let l = 1024; l < 2048; ++l) r[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l) o[l] = l << 23;
    o[31] = 1199570944, o[32] = 2147483648;
    for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
    return {
        floatView: t,
        uint32View: e,
        baseTable: n,
        shiftTable: s,
        mantissaTable: r,
        exponentTable: o,
        offsetTable: a
    }
}

function pN(i) {
    Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = un(i, -65504, 65504), nr.floatView[0] = i;
    const t = nr.uint32View[0], e = t >> 23 & 511;
    return nr.baseTable[e] + ((t & 8388607) >> nr.shiftTable[e])
}

function gN(i) {
    const t = i >> 10;
    return nr.uint32View[0] = nr.mantissaTable[nr.offsetTable[t] + (i & 1023)] + nr.exponentTable[t], nr.floatView[0]
}

var mN = Object.freeze({__proto__: null, fromHalfFloat: gN, toHalfFloat: pN});

class _N extends Vi {
    constructor(t, e, n, s, r, o) {
        console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(t, e, n, s, r, o)
    }
}

class yN extends gh {
    constructor(t, e, n, s) {
        console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(t, e, n, s)
    }
}

class xN extends mh {
    constructor(t, e, n, s) {
        console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(t, e, n, s)
    }
}

class vN extends _h {
    constructor(t, e, n, s, r, o, a) {
        console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(t, e, n, s, r, o, a)
    }
}

class wN extends qo {
    constructor(t, e, n, s, r, o, a, l) {
        console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(t, e, n, s, r, o, a, l)
    }
}

class bN extends yh {
    constructor(t, e) {
        console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(t, e)
    }
}

class EN extends xh {
    constructor(t, e) {
        console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(t, e)
    }
}

class SN extends vh {
    constructor(t, e) {
        console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(t, e)
    }
}

class MN extends Il {
    constructor(t, e, n, s) {
        console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(t, e, n, s)
    }
}

class TN extends Al {
    constructor(t, e) {
        console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(t, e)
    }
}

class IN extends Sl {
    constructor(t, e, n, s) {
        console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(t, e, n, s)
    }
}

class AN extends ur {
    constructor(t, e, n, s) {
        console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(t, e, n, s)
    }
}

class CN extends wh {
    constructor(t, e, n, s, r, o) {
        console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(t, e, n, s, r, o)
    }
}

class PN extends bh {
    constructor(t, e) {
        console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(t, e)
    }
}

class RN extends Cl {
    constructor(t, e, n, s, r, o, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(t, e, n, s, r, o, a)
    }
}

class LN extends Eh {
    constructor(t, e) {
        console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(t, e)
    }
}

class NN extends Sh {
    constructor(t, e, n, s, r) {
        console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(t, e, n, s, r)
    }
}

class ON extends Mh {
    constructor(t, e, n, s, r, o) {
        console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(t, e, n, s, r, o)
    }
}

class DN extends Th {
    constructor(t, e, n, s, r) {
        console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(t, e, n, s, r)
    }
}

typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: Hd}}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Hd);
const FN = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: hb,
    AddEquation: vo,
    AddOperation: ob,
    AdditiveAnimationBlendMode: Jm,
    AdditiveBlending: Rc,
    AlphaFormat: _b,
    AlwaysDepth: Qw,
    AlwaysStencilFunc: Ob,
    AmbientLight: P0,
    AmbientLightProbe: TL,
    AnimationClip: Wr,
    AnimationLoader: gL,
    AnimationMixer: NE,
    AnimationObjectGroup: VL,
    AnimationUtils: uL,
    ArcCurve: nE,
    ArrayCamera: jb,
    ArrowHelper: hN,
    Audio: RE,
    AudioAnalyser: LL,
    AudioContext: R0,
    AudioListener: CL,
    AudioLoader: SL,
    AxesHelper: uN,
    BackSide: xs,
    BasicDepthPacking: Rb,
    BasicShadowMap: UT,
    Bone: ef,
    BooleanKeyframeTrack: Yo,
    Box2: jL,
    Box3: fi,
    Box3Helper: lN,
    BoxBufferGeometry: _N,
    BoxGeometry: Vi,
    BoxHelper: aN,
    BufferAttribute: ae,
    BufferGeometry: Xt,
    BufferGeometryLoader: CE,
    ByteType: db,
    Cache: Go,
    Camera: Zd,
    CameraHelper: oN,
    CanvasTexture: DR,
    CapsuleBufferGeometry: yN,
    CapsuleGeometry: gh,
    CatmullRomCurve3: sE,
    CineonToneMapping: cb,
    CircleBufferGeometry: xN,
    CircleGeometry: mh,
    ClampToEdgeWrapping: kn,
    Clock: hf,
    Color: pt,
    ColorKeyframeTrack: S0,
    ColorManagement: Wn,
    CompressedArrayTexture: OR,
    CompressedTexture: p0,
    CompressedTextureLoader: mL,
    ConeBufferGeometry: vN,
    ConeGeometry: _h,
    CubeCamera: Vb,
    CubeReflectionMapping: Br,
    CubeRefractionMapping: kr,
    CubeTexture: dh,
    CubeTextureLoader: _L,
    CubeUVReflectionMapping: El,
    CubicBezierCurve: m0,
    CubicBezierCurve3: iE,
    CubicInterpolant: wE,
    CullFaceBack: Ug,
    CullFaceFront: kw,
    CullFaceFrontBack: kT,
    CullFaceNone: Bw,
    Curve: gi,
    CurvePath: oE,
    CustomBlending: Uw,
    CustomToneMapping: ub,
    CylinderBufferGeometry: wN,
    CylinderGeometry: qo,
    Cylindrical: ZL,
    Data3DTexture: n0,
    DataArrayTexture: Yd,
    DataTexture: ka,
    DataTextureLoader: yL,
    DataUtils: mN,
    DecrementStencilOp: jT,
    DecrementWrapStencilOp: JT,
    DefaultLoadingManager: SE,
    DepthFormat: Dr,
    DepthStencilFormat: Bo,
    DepthTexture: Kb,
    DirectionalLight: af,
    DirectionalLightHelper: rN,
    DiscreteInterpolant: bE,
    DodecahedronBufferGeometry: bN,
    DodecahedronGeometry: yh,
    DoubleSide: Ci,
    DstAlphaFactor: Yw,
    DstColorFactor: Zw,
    DynamicCopyUsage: fI,
    DynamicDrawUsage: aI,
    DynamicReadUsage: hI,
    EdgesGeometry: aE,
    EllipseCurve: sf,
    EqualDepth: eb,
    EqualStencilFunc: nI,
    EquirectangularReflectionMapping: Lc,
    EquirectangularRefractionMapping: Nc,
    Euler: s0,
    EventDispatcher: Gi,
    ExtrudeBufferGeometry: EN,
    ExtrudeGeometry: xh,
    FileLoader: ks,
    Float16BufferAttribute: YI,
    Float32BufferAttribute: Ct,
    Float64BufferAttribute: XI,
    FloatType: ir,
    Fog: Qd,
    FogExp2: Jd,
    FramebufferTexture: NR,
    FrontSide: Fi,
    Frustum: jd,
    GLBufferAttribute: XL,
    GLSL1: gI,
    GLSL3: pm,
    GreaterDepth: sb,
    GreaterEqualDepth: nb,
    GreaterEqualStencilFunc: oI,
    GreaterStencilFunc: iI,
    GridHelper: sN,
    Group: or,
    HalfFloatType: nl,
    HemisphereLight: ME,
    HemisphereLightHelper: nN,
    HemisphereLightProbe: ML,
    IcosahedronBufferGeometry: SN,
    IcosahedronGeometry: vh,
    ImageBitmapLoader: PE,
    ImageLoader: $c,
    ImageUtils: e0,
    IncrementStencilOp: ZT,
    IncrementWrapStencilOp: KT,
    InstancedBufferAttribute: ol,
    InstancedBufferGeometry: AE,
    InstancedInterleavedBuffer: YL,
    InstancedMesh: u0,
    Int16BufferAttribute: WI,
    Int32BufferAttribute: qI,
    Int8BufferAttribute: VI,
    IntType: pb,
    InterleavedBuffer: fh,
    InterleavedBufferAttribute: Hr,
    Interpolant: Pl,
    InterpolateDiscrete: sl,
    InterpolateLinear: ko,
    InterpolateSmooth: Ku,
    InvertStencilOp: QT,
    KeepStencilOp: Ju,
    KeyframeTrack: mi,
    LOD: eE,
    LatheBufferGeometry: MN,
    LatheGeometry: Il,
    Layers: Xd,
    LessDepth: tb,
    LessEqualDepth: rd,
    LessEqualStencilFunc: sI,
    LessStencilFunc: eI,
    Light: jr,
    LightProbe: lf,
    Line: lr,
    Line3: KL,
    LineBasicMaterial: Jn,
    LineCurve: rf,
    LineCurve3: rE,
    LineDashedMaterial: xE,
    LineLoop: d0,
    LineSegments: pi,
    LinearEncoding: Vr,
    LinearFilter: Qe,
    LinearInterpolant: E0,
    LinearMipMapLinearFilter: WT,
    LinearMipMapNearestFilter: $T,
    LinearMipmapLinearFilter: zi,
    LinearMipmapNearestFilter: Wd,
    LinearSRGBColorSpace: il,
    LinearToneMapping: ab,
    Loader: ps,
    LoaderUtils: cl,
    LoadingManager: M0,
    LoopOnce: Ib,
    LoopPingPong: Cb,
    LoopRepeat: Ab,
    LuminanceAlphaFormat: xb,
    LuminanceFormat: yb,
    MOUSE: _o,
    Material: En,
    MaterialLoader: cf,
    MathUtils: Fb,
    Matrix3: ds,
    Matrix4: Yt,
    MaxEquation: $g,
    Mesh: ge,
    MeshBasicMaterial: rn,
    MeshDepthMaterial: a0,
    MeshDistanceMaterial: l0,
    MeshLambertMaterial: _E,
    MeshMatcapMaterial: yE,
    MeshNormalMaterial: mE,
    MeshPhongMaterial: pE,
    MeshPhysicalMaterial: dr,
    MeshStandardMaterial: Zn,
    MeshToonMaterial: gE,
    MinEquation: Hg,
    MirroredRepeatWrapping: el,
    MixOperation: rb,
    MultiplyBlending: Vg,
    MultiplyOperation: hh,
    NearestFilter: sn,
    NearestMipMapLinearFilter: HT,
    NearestMipMapNearestFilter: VT,
    NearestMipmapLinearFilter: Ba,
    NearestMipmapNearestFilter: Oc,
    NeverDepth: Jw,
    NeverStencilFunc: tI,
    NoBlending: ar,
    NoColorSpace: qT,
    NoToneMapping: Pi,
    NormalAnimationBlendMode: qd,
    NormalBlending: Or,
    NotEqualDepth: ib,
    NotEqualStencilFunc: rI,
    NumberKeyframeTrack: al,
    Object3D: re,
    ObjectLoader: bL,
    ObjectSpaceNormalMap: Nb,
    OctahedronBufferGeometry: TN,
    OctahedronGeometry: Al,
    OneFactor: $w,
    OneMinusDstAlphaFactor: Xw,
    OneMinusDstColorFactor: jw,
    OneMinusSrcAlphaFactor: jm,
    OneMinusSrcColorFactor: qw,
    OrthographicCamera: Ml,
    PCFShadowMap: Ym,
    PCFSoftShadowMap: Xm,
    PMREMGenerator: _m,
    Path: Uc,
    PerspectiveCamera: bn,
    Plane: er,
    PlaneBufferGeometry: IN,
    PlaneGeometry: Sl,
    PlaneHelper: cN,
    PointLight: C0,
    PointLightHelper: tN,
    Points: f0,
    PointsMaterial: nf,
    PolarGridHelper: iN,
    PolyhedronBufferGeometry: AN,
    PolyhedronGeometry: ur,
    PositionalAudio: RL,
    PropertyBinding: fe,
    PropertyMixer: LE,
    QuadraticBezierCurve: _0,
    QuadraticBezierCurve3: y0,
    Quaternion: On,
    QuaternionKeyframeTrack: $r,
    QuaternionLinearInterpolant: EE,
    RED_GREEN_RGTC2_Format: dm,
    RED_RGTC1_Format: Tb,
    REVISION: Hd,
    RGBADepthPacking: Lb,
    RGBAFormat: Os,
    RGBAIntegerFormat: Sb,
    RGBA_ASTC_10x10_Format: lm,
    RGBA_ASTC_10x5_Format: rm,
    RGBA_ASTC_10x6_Format: om,
    RGBA_ASTC_10x8_Format: am,
    RGBA_ASTC_12x10_Format: cm,
    RGBA_ASTC_12x12_Format: hm,
    RGBA_ASTC_4x4_Format: Kg,
    RGBA_ASTC_5x4_Format: Jg,
    RGBA_ASTC_5x5_Format: Qg,
    RGBA_ASTC_6x5_Format: tm,
    RGBA_ASTC_6x6_Format: em,
    RGBA_ASTC_8x5_Format: nm,
    RGBA_ASTC_8x6_Format: sm,
    RGBA_ASTC_8x8_Format: im,
    RGBA_BPTC_Format: ju,
    RGBA_ETC2_EAC_Format: jg,
    RGBA_PVRTC_2BPPV1_Format: Xg,
    RGBA_PVRTC_4BPPV1_Format: Yg,
    RGBA_S3TC_DXT1_Format: Yu,
    RGBA_S3TC_DXT3_Format: Xu,
    RGBA_S3TC_DXT5_Format: Zu,
    RGB_ETC1_Format: Mb,
    RGB_ETC2_Format: Zg,
    RGB_PVRTC_2BPPV1_Format: qg,
    RGB_PVRTC_4BPPV1_Format: Wg,
    RGB_S3TC_DXT1_Format: qu,
    RGFormat: bb,
    RGIntegerFormat: Eb,
    RawShaderMaterial: fE,
    Ray: uh,
    Raycaster: OE,
    RectAreaLight: TE,
    RedFormat: vb,
    RedIntegerFormat: wb,
    ReinhardToneMapping: lb,
    RepeatWrapping: Ur,
    ReplaceStencilOp: XT,
    ReverseSubtractEquation: Vw,
    RingBufferGeometry: CN,
    RingGeometry: wh,
    SIGNED_RED_GREEN_RGTC2_Format: fm,
    SIGNED_RED_RGTC1_Format: um,
    SRGBColorSpace: ii,
    Scene: Sc,
    ShaderChunk: Qt,
    ShaderLib: ai,
    ShaderMaterial: jn,
    ShadowMaterial: dE,
    Shape: Do,
    ShapeBufferGeometry: PN,
    ShapeGeometry: bh,
    ShapePath: dN,
    ShapeUtils: Ri,
    ShortType: fb,
    Skeleton: ph,
    SkeletonHelper: QL,
    SkinnedMesh: h0,
    Source: Io,
    Sphere: Zr,
    SphereBufferGeometry: RN,
    SphereGeometry: Cl,
    Spherical: Sm,
    SphericalHarmonics3: IE,
    SplineCurve: x0,
    SpotLight: A0,
    SpotLightHelper: JL,
    Sprite: tE,
    SpriteMaterial: tf,
    SrcAlphaFactor: Zm,
    SrcAlphaSaturateFactor: Kw,
    SrcColorFactor: Ww,
    StaticCopyUsage: dI,
    StaticDrawUsage: Fc,
    StaticReadUsage: cI,
    StereoCamera: IL,
    StreamCopyUsage: pI,
    StreamDrawUsage: lI,
    StreamReadUsage: uI,
    StringKeyframeTrack: Xo,
    SubtractEquation: Gw,
    SubtractiveBlending: Gg,
    TOUCH: yo,
    TangentSpaceNormalMap: Xr,
    TetrahedronBufferGeometry: LN,
    TetrahedronGeometry: Eh,
    Texture: Sn,
    TextureLoader: T0,
    TorusBufferGeometry: NN,
    TorusGeometry: Sh,
    TorusKnotBufferGeometry: ON,
    TorusKnotGeometry: Mh,
    Triangle: Oo,
    TriangleFanDrawMode: od,
    TriangleStripDrawMode: Qm,
    TrianglesDrawMode: Pb,
    TubeBufferGeometry: DN,
    TubeGeometry: Th,
    TwoPassDoubleSide: GT,
    UVMapping: $d,
    Uint16BufferAttribute: i0,
    Uint32BufferAttribute: r0,
    Uint8BufferAttribute: HI,
    Uint8ClampedBufferAttribute: $I,
    Uniform: O0,
    UniformsGroup: qL,
    UniformsLib: xt,
    UniformsUtils: kc,
    UnsignedByteType: Gr,
    UnsignedInt248Type: Ro,
    UnsignedIntType: Lr,
    UnsignedShort4444Type: gb,
    UnsignedShort5551Type: mb,
    UnsignedShortType: Km,
    VSMShadowMap: Ra,
    Vector2: j,
    Vector3: C,
    Vector4: Fe,
    VectorKeyframeTrack: ll,
    VideoTexture: LR,
    WebGL1Renderer: Jb,
    WebGL3DRenderTarget: LI,
    WebGLArrayRenderTarget: RI,
    WebGLCubeRenderTarget: Hb,
    WebGLMultipleRenderTargets: NI,
    WebGLRenderTarget: fs,
    WebGLRenderer: c0,
    WebGLUtils: Zb,
    WireframeGeometry: uE,
    WrapAroundEnding: Dc,
    ZeroCurvatureEnding: Mo,
    ZeroFactor: Hw,
    ZeroSlopeEnding: To,
    ZeroStencilOp: YT,
    _SRGBAFormat: ad,
    sRGBEncoding: Ee
}, Symbol.toStringTag, {value: "Module"})), Nx = {type: "change"}, Xp = {type: "start"}, Ox = {type: "end"};

class zN extends Gi {
    constructor(t, e) {
        super(), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new C, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }, this.mouseButtons = {LEFT: _o.ROTATE, MIDDLE: _o.DOLLY, RIGHT: _o.PAN}, this.touches = {
            ONE: yo.ROTATE,
            TWO: yo.DOLLY_PAN
        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
            return a.phi
        }, this.getAzimuthalAngle = function () {
            return a.theta
        }, this.getDistance = function () {
            return this.object.position.distanceTo(this.target)
        }, this.listenToKeyEvents = function (O) {
            O.addEventListener("keydown", ve), this._domElementKeyEvents = O
        }, this.saveState = function () {
            n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
        }, this.reset = function () {
            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(Nx), n.update(), r = s.NONE
        }, this.update = function () {
            const O = new C, V = new On().setFromUnitVectors(t.up, new C(0, 1, 0)), Et = V.clone().invert(), It = new C,
                Mt = new On, Ft = 2 * Math.PI;
            return function () {
                const oe = n.object.position;
                O.copy(oe).sub(n.target), O.applyQuaternion(V), a.setFromVector3(O), n.autoRotate && r === s.NONE && M(S()), n.enableDamping ? (a.theta += l.theta * n.dampingFactor, a.phi += l.phi * n.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
                let ce = n.minAzimuthAngle, Ue = n.maxAzimuthAngle;
                return isFinite(ce) && isFinite(Ue) && (ce < -Math.PI ? ce += Ft : ce > Math.PI && (ce -= Ft), Ue < -Math.PI ? Ue += Ft : Ue > Math.PI && (Ue -= Ft), ce <= Ue ? a.theta = Math.max(ce, Math.min(Ue, a.theta)) : a.theta = a.theta > (ce + Ue) / 2 ? Math.max(ce, a.theta) : Math.min(Ue, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= c, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), n.enableDamping === !0 ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), O.setFromSpherical(a), O.applyQuaternion(Et), oe.copy(n.target).add(O), n.object.lookAt(n.target), n.enableDamping === !0 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (l.set(0, 0, 0), h.set(0, 0, 0)), c = 1, u || It.distanceToSquared(n.object.position) > o || 8 * (1 - Mt.dot(n.object.quaternion)) > o ? (n.dispatchEvent(Nx), It.copy(n.object.position), Mt.copy(n.object.quaternion), u = !1, !0) : !1
            }
        }(), this.dispose = function () {
            n.domElement.removeEventListener("contextmenu", X), n.domElement.removeEventListener("pointerdown", ft), n.domElement.removeEventListener("pointercancel", qt), n.domElement.removeEventListener("wheel", ke), n.domElement.removeEventListener("pointermove", Pt), n.domElement.removeEventListener("pointerup", _t), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", ve)
        };
        const n = this, s = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let r = s.NONE;
        const o = 1e-6, a = new Sm, l = new Sm;
        let c = 1;
        const h = new C;
        let u = !1;
        const d = new j, f = new j, g = new j, m = new j, p = new j, _ = new j, x = new j, y = new j, v = new j, w = [],
            E = {};

        function S() {
            return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
        }

        function b() {
            return Math.pow(.95, n.zoomSpeed)
        }

        function M(O) {
            l.theta -= O
        }

        function I(O) {
            l.phi -= O
        }

        const N = function () {
            const O = new C;
            return function (Et, It) {
                O.setFromMatrixColumn(It, 0), O.multiplyScalar(-Et), h.add(O)
            }
        }(), B = function () {
            const O = new C;
            return function (Et, It) {
                n.screenSpacePanning === !0 ? O.setFromMatrixColumn(It, 1) : (O.setFromMatrixColumn(It, 0), O.crossVectors(n.object.up, O)), O.multiplyScalar(Et), h.add(O)
            }
        }(), D = function () {
            const O = new C;
            return function (Et, It) {
                const Mt = n.domElement;
                if (n.object.isPerspectiveCamera) {
                    const Ft = n.object.position;
                    O.copy(Ft).sub(n.target);
                    let Ot = O.length();
                    Ot *= Math.tan(n.object.fov / 2 * Math.PI / 180), N(2 * Et * Ot / Mt.clientHeight, n.object.matrix), B(2 * It * Ot / Mt.clientHeight, n.object.matrix)
                } else n.object.isOrthographicCamera ? (N(Et * (n.object.right - n.object.left) / n.object.zoom / Mt.clientWidth, n.object.matrix), B(It * (n.object.top - n.object.bottom) / n.object.zoom / Mt.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
            }
        }();

        function L(O) {
            n.object.isPerspectiveCamera ? c /= O : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * O)), n.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
        }

        function k(O) {
            n.object.isPerspectiveCamera ? c *= O : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / O)), n.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
        }

        function G(O) {
            d.set(O.clientX, O.clientY)
        }

        function Q(O) {
            x.set(O.clientX, O.clientY)
        }

        function q(O) {
            m.set(O.clientX, O.clientY)
        }

        function at(O) {
            f.set(O.clientX, O.clientY), g.subVectors(f, d).multiplyScalar(n.rotateSpeed);
            const V = n.domElement;
            M(2 * Math.PI * g.x / V.clientHeight), I(2 * Math.PI * g.y / V.clientHeight), d.copy(f), n.update()
        }

        function lt(O) {
            y.set(O.clientX, O.clientY), v.subVectors(y, x), v.y > 0 ? L(b()) : v.y < 0 && k(b()), x.copy(y), n.update()
        }

        function wt(O) {
            p.set(O.clientX, O.clientY), _.subVectors(p, m).multiplyScalar(n.panSpeed), D(_.x, _.y), m.copy(p), n.update()
        }

        function W(O) {
            O.deltaY < 0 ? k(b()) : O.deltaY > 0 && L(b()), n.update()
        }

        function st(O) {
            let V = !1;
            switch (O.code) {
                case n.keys.UP:
                    O.ctrlKey || O.metaKey || O.shiftKey ? I(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(0, n.keyPanSpeed), V = !0;
                    break;
                case n.keys.BOTTOM:
                    O.ctrlKey || O.metaKey || O.shiftKey ? I(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(0, -n.keyPanSpeed), V = !0;
                    break;
                case n.keys.LEFT:
                    O.ctrlKey || O.metaKey || O.shiftKey ? M(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(n.keyPanSpeed, 0), V = !0;
                    break;
                case n.keys.RIGHT:
                    O.ctrlKey || O.metaKey || O.shiftKey ? M(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(-n.keyPanSpeed, 0), V = !0;
                    break
            }
            V && (O.preventDefault(), n.update())
        }

        function gt() {
            if (w.length === 1) d.set(w[0].pageX, w[0].pageY); else {
                const O = .5 * (w[0].pageX + w[1].pageX), V = .5 * (w[0].pageY + w[1].pageY);
                d.set(O, V)
            }
        }

        function mt() {
            if (w.length === 1) m.set(w[0].pageX, w[0].pageY); else {
                const O = .5 * (w[0].pageX + w[1].pageX), V = .5 * (w[0].pageY + w[1].pageY);
                m.set(O, V)
            }
        }

        function Y() {
            const O = w[0].pageX - w[1].pageX, V = w[0].pageY - w[1].pageY, Et = Math.sqrt(O * O + V * V);
            x.set(0, Et)
        }

        function Ut() {
            n.enableZoom && Y(), n.enablePan && mt()
        }

        function Rt() {
            n.enableZoom && Y(), n.enableRotate && gt()
        }

        function Nt(O) {
            if (w.length == 1) f.set(O.pageX, O.pageY); else {
                const Et = Wt(O), It = .5 * (O.pageX + Et.x), Mt = .5 * (O.pageY + Et.y);
                f.set(It, Mt)
            }
            g.subVectors(f, d).multiplyScalar(n.rotateSpeed);
            const V = n.domElement;
            M(2 * Math.PI * g.x / V.clientHeight), I(2 * Math.PI * g.y / V.clientHeight), d.copy(f)
        }

        function vt(O) {
            if (w.length === 1) p.set(O.pageX, O.pageY); else {
                const V = Wt(O), Et = .5 * (O.pageX + V.x), It = .5 * (O.pageY + V.y);
                p.set(Et, It)
            }
            _.subVectors(p, m).multiplyScalar(n.panSpeed), D(_.x, _.y), m.copy(p)
        }

        function ee(O) {
            const V = Wt(O), Et = O.pageX - V.x, It = O.pageY - V.y, Mt = Math.sqrt(Et * Et + It * It);
            y.set(0, Mt), v.set(0, Math.pow(y.y / x.y, n.zoomSpeed)), L(v.y), x.copy(y)
        }

        function nt(O) {
            n.enableZoom && ee(O), n.enablePan && vt(O)
        }

        function et(O) {
            n.enableZoom && ee(O), n.enableRotate && Nt(O)
        }

        function ft(O) {
            n.enabled !== !1 && (w.length === 0 && (n.domElement.setPointerCapture(O.pointerId), n.domElement.addEventListener("pointermove", Pt), n.domElement.addEventListener("pointerup", _t)), ht(O), O.pointerType === "touch" ? R(O) : Vt(O))
        }

        function Pt(O) {
            n.enabled !== !1 && (O.pointerType === "touch" ? A(O) : Gt(O))
        }

        function _t(O) {
            dt(O), w.length === 0 && (n.domElement.releasePointerCapture(O.pointerId), n.domElement.removeEventListener("pointermove", Pt), n.domElement.removeEventListener("pointerup", _t)), n.dispatchEvent(Ox), r = s.NONE
        }

        function qt(O) {
            dt(O)
        }

        function Vt(O) {
            let V;
            switch (O.button) {
                case 0:
                    V = n.mouseButtons.LEFT;
                    break;
                case 1:
                    V = n.mouseButtons.MIDDLE;
                    break;
                case 2:
                    V = n.mouseButtons.RIGHT;
                    break;
                default:
                    V = -1
            }
            switch (V) {
                case _o.DOLLY:
                    if (n.enableZoom === !1) return;
                    Q(O), r = s.DOLLY;
                    break;
                case _o.ROTATE:
                    if (O.ctrlKey || O.metaKey || O.shiftKey) {
                        if (n.enablePan === !1) return;
                        q(O), r = s.PAN
                    } else {
                        if (n.enableRotate === !1) return;
                        G(O), r = s.ROTATE
                    }
                    break;
                case _o.PAN:
                    if (O.ctrlKey || O.metaKey || O.shiftKey) {
                        if (n.enableRotate === !1) return;
                        G(O), r = s.ROTATE
                    } else {
                        if (n.enablePan === !1) return;
                        q(O), r = s.PAN
                    }
                    break;
                default:
                    r = s.NONE
            }
            r !== s.NONE && n.dispatchEvent(Xp)
        }

        function Gt(O) {
            switch (r) {
                case s.ROTATE:
                    if (n.enableRotate === !1) return;
                    at(O);
                    break;
                case s.DOLLY:
                    if (n.enableZoom === !1) return;
                    lt(O);
                    break;
                case s.PAN:
                    if (n.enablePan === !1) return;
                    wt(O);
                    break
            }
        }

        function ke(O) {
            n.enabled === !1 || n.enableZoom === !1 || r !== s.NONE || (O.preventDefault(), n.dispatchEvent(Xp), W(O), n.dispatchEvent(Ox))
        }

        function ve(O) {
            n.enabled === !1 || n.enablePan === !1 || st(O)
        }

        function R(O) {
            switch (bt(O), w.length) {
                case 1:
                    switch (n.touches.ONE) {
                        case yo.ROTATE:
                            if (n.enableRotate === !1) return;
                            gt(), r = s.TOUCH_ROTATE;
                            break;
                        case yo.PAN:
                            if (n.enablePan === !1) return;
                            mt(), r = s.TOUCH_PAN;
                            break;
                        default:
                            r = s.NONE
                    }
                    break;
                case 2:
                    switch (n.touches.TWO) {
                        case yo.DOLLY_PAN:
                            if (n.enableZoom === !1 && n.enablePan === !1) return;
                            Ut(), r = s.TOUCH_DOLLY_PAN;
                            break;
                        case yo.DOLLY_ROTATE:
                            if (n.enableZoom === !1 && n.enableRotate === !1) return;
                            Rt(), r = s.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            r = s.NONE
                    }
                    break;
                default:
                    r = s.NONE
            }
            r !== s.NONE && n.dispatchEvent(Xp)
        }

        function A(O) {
            switch (bt(O), r) {
                case s.TOUCH_ROTATE:
                    if (n.enableRotate === !1) return;
                    Nt(O), n.update();
                    break;
                case s.TOUCH_PAN:
                    if (n.enablePan === !1) return;
                    vt(O), n.update();
                    break;
                case s.TOUCH_DOLLY_PAN:
                    if (n.enableZoom === !1 && n.enablePan === !1) return;
                    nt(O), n.update();
                    break;
                case s.TOUCH_DOLLY_ROTATE:
                    if (n.enableZoom === !1 && n.enableRotate === !1) return;
                    et(O), n.update();
                    break;
                default:
                    r = s.NONE
            }
        }

        function X(O) {
            n.enabled !== !1 && O.preventDefault()
        }

        function ht(O) {
            w.push(O)
        }

        function dt(O) {
            delete E[O.pointerId];
            for (let V = 0; V < w.length; V++) if (w[V].pointerId == O.pointerId) {
                w.splice(V, 1);
                return
            }
        }

        function bt(O) {
            let V = E[O.pointerId];
            V === void 0 && (V = new j, E[O.pointerId] = V), V.set(O.pageX, O.pageY)
        }

        function Wt(O) {
            const V = O.pointerId === w[0].pointerId ? w[1] : w[0];
            return E[V.pointerId]
        }

        n.domElement.addEventListener("contextmenu", X), n.domElement.addEventListener("pointerdown", ft), n.domElement.addEventListener("pointercancel", qt), n.domElement.addEventListener("wheel", ke, {passive: !1}), this.update()
    }
}

class FE extends re {
    constructor() {
        super();
        z(this, "renderData");
        this.renderData === void 0 && (this.renderData = {x: 0, y: 0, visible: !0, distSq: 0, zIndex: 0})
    }
}

class BN {
    constructor() {
        z(this, "_width", 0);
        z(this, "_height", 0);
        z(this, "_widthHalf", 0);
        z(this, "_heightHalf", 0);
        z(this, "_a", new C);
        z(this, "_b", new C);
        z(this, "_cb", null);
        z(this, "vector", new C);
        z(this, "viewMatrix", new Yt);
        z(this, "viewProjectionMatrix", new Yt);
        z(this, "flattenObjects", [])
    }

    getSize() {
        return {width: this._width, height: this._height}
    }

    setSize(t, e) {
        this._width = t, this._height = e, this._widthHalf = this._width * .5, this._heightHalf = this._height * .5
    }

    renderObject(t, e, n) {
        const s = t.visible;
        if (t instanceof FE) {
            this.vector.setFromMatrixPosition(t.matrixWorld), this.vector.applyMatrix4(this.viewProjectionMatrix);
            const r = n && s && this.vector.z >= -1 && this.vector.z <= 1,
                o = this.vector.x * this._widthHalf + this._widthHalf,
                a = -this.vector.y * this._heightHalf + this._heightHalf;
            t.renderData.x = o, t.renderData.y = a, t.renderData.visible = r, t.renderData.distSq = this.getDistanceToSquared(e, t), this.flattenObjects.push(t)
        }
        for (let r = 0, o = t.children.length; r < o; r++) this.renderObject(t.children[r], e, n && s)
    }

    getDistanceToSquared(t, e) {
        return this._a.setFromMatrixPosition(t.matrixWorld), this._b.setFromMatrixPosition(e.matrixWorld), this._a.distanceToSquared(this._b)
    }

    zOrder() {
        this.flattenObjects.sort((e, n) => e.renderData.distSq - n.renderData.distSq);
        let t = this.flattenObjects.length;
        for (let e = 0, n = this.flattenObjects.length; e < n; e++) this.flattenObjects[e].renderData.zIndex = t - e
    }

    render(t, e) {
        t.matrixAutoUpdate === !0 && t.updateMatrixWorld(), e.parent === null && e.updateMatrixWorld(), this.viewMatrix.copy(e.matrixWorldInverse), this.viewProjectionMatrix.multiplyMatrices(e.projectionMatrix, this.viewMatrix), this.flattenObjects.length = 0, this.renderObject(t, e, t.visible), this.zOrder(), this._cb != null && this._cb(this.flattenObjects, this, t, e)
    }

    setRenderCallback(t) {
        this._cb = t
    }
}

var Ua = (i => (i[i.Architecture = 0] = "Architecture", i[i.Information3D = 1] = "Information3D", i[i.Information2D = 2] = "Information2D", i))(Ua || {}),
    mc = (i => (i[i.Global = 0] = "Global", i[i.Floor = 1] = "Floor", i))(mc || {});

class kN extends Event {
    constructor(e, n) {
        super(e);
        z(this, "layer");
        this.layer = n.layer
    }
}

class UN extends kN {
    constructor(e, n) {
        super(e, {layer: n.layer});
        z(this, "entityId");
        z(this, "intersection");
        z(this, "mouseEvent");
        this.entityId = n.entityId, this.intersection = n.intersection, this.mouseEvent = n.mouseEvent
    }
}

class zE extends EventTarget {
    constructor({viewer: e, name: n, parentScene: s, coverage: r, visualizationType: o, useBoundingBox: a}) {
        super();
        z(this, "name");
        z(this, "_viewer");
        z(this, "coverage");
        z(this, "visualizationType");
        z(this, "_layerScene");
        z(this, "_parentScene");
        z(this, "layerEntities");
        z(this, "useBoundingBox");
        z(this, "layerBoundingBox");
        z(this, "savedMaterials");
        z(this, "savedTransparencies");
        this.name = n, this._viewer = new WeakRef(e), this.coverage = r, this.visualizationType = o, this._parentScene = new WeakRef(s);
        let l = new re;
        l.userData.layerName = n, this.parentScene.add(l), this._layerScene = new WeakRef(l), this.layerEntities = new Map, this.layerBoundingBox = new fi, this.useBoundingBox = a === !0, this.savedMaterials = new WeakMap, this.savedTransparencies = new WeakMap
    }

    get viewer() {
        const e = this._viewer.deref();
        if (e == null) throw "Layer.viewer: GC 후 참조";
        return e
    }

    get parentScene() {
        const e = this._parentScene.deref();
        if (e == null) throw "Layer.parentScene: GC 후 참조";
        return e
    }

    get layerScene() {
        let e = this._layerScene.deref();
        if (e == null) throw "GlobalLayer.layerScene: GC 후 참조";
        return e
    }

    setVisible(e) {
        this.layerScene.visible = e
    }

    isVisible() {
        return this.layerScene.visible
    }

    * getEntities(e = () => !0, n = !1) {
        for (let [s, r] of this.layerEntities) {
            const o = r.deref();
            if (o != null && e(s, o) === !0 && (yield[s, o], n === !0)) break
        }
    }

    saveMaterials() {
        let e = new WeakMap;
        this.layerScene.traverse(n => {
            if (n instanceof ge && !this.savedMaterials.has(n) && n.material != null && (n.material instanceof rn || n.material instanceof Zn)) {
                const s = n.material;
                let r = e.get(s);
                r == null && (r = s.clone(), e.set(s, r)), this.savedMaterials.set(n, r)
            }
        })
    }

    removeSavedMaterials(e) {
        e.traverse(n => {
            if (n instanceof ge) {
                let s = this.savedMaterials.get(n);
                s != null && (Ds.ReleaseMaterial(s), this.savedMaterials.delete(n))
            }
        })
    }

    removeAllSavedMaterials() {
        this.layerScene.traverse(e => {
            if (e instanceof ge) {
                let n = this.savedMaterials.get(e);
                n != null && (Ds.ReleaseMaterial(n), this.savedMaterials.delete(e))
            }
        })
    }

    restoreMaterials() {
        this.layerScene.traverse(e => {
            if (e instanceof ge) {
                const n = this.savedMaterials.get(e);
                n != null && (e.material != null && (e.material instanceof rn || e.material instanceof Zn) && (Ds.ReleaseMaterial(e.material), e.material = null), e.material = n.clone())
            }
        })
    }

    saveTransparencies() {
        this.layerScene.traverse(e => {
            e instanceof ge && e.material != null && (e.material instanceof rn || e.material instanceof Zn) && this.savedTransparencies.set(e, {
                transparent: e.material.transparent,
                opacity: e.material.opacity
            })
        })
    }

    setTransparencies(e, n) {
        this.layerScene.traverse(s => {
            s instanceof ge && s.material != null && (s.material instanceof rn || s.material instanceof Zn) && (s.material.transparent = e, s.material.opacity = n)
        })
    }

    restoreTransparencies() {
        this.layerScene.traverse(e => {
            if (e instanceof ge && e.material != null && (e.material instanceof rn || e.material instanceof Zn)) {
                const n = this.savedTransparencies.get(e);
                n != null && (e.material.transparent = n.transparent, e.material.opacity = n.opacity)
            }
        })
    }

    dispose() {
        this.removeAllSavedMaterials();
        const e = this._layerScene.deref();
        e != null && Ds.ReleaseObject3D(e)
    }
}

class GN extends zE {
    constructor({viewer: t, name: e, parentScene: n, useBoundingBox: s, visualizationType: r}) {
        super({viewer: t, name: e, parentScene: n, coverage: 0, visualizationType: r, useBoundingBox: s})
    }

    addEntity(t, e) {
        e.userData.entityId = t, e.userData.layerName = this.name, this.layerScene.add(e), this.useBoundingBox === !0 && this.layerBoundingBox.expandByObject(e), this.layerEntities.set(t, new WeakRef(e))
    }

    * getEntities() {
        for (let [t, e] of this.layerEntities) {
            const n = e.deref();
            n != null && (yield[t, n])
        }
    }

    getEntity(t) {
        var e;
        return ((e = this.layerEntities.get(t)) == null ? void 0 : e.deref()) ?? null
    }

    removeEntity(t) {
        var n;
        const e = (n = this.layerEntities.get(t)) == null ? void 0 : n.deref();
        e != null && (this.removeSavedMaterials(e), Ds.ReleaseObject3D(e)), this.layerEntities.delete(t), this.useBoundingBox === !0 && this.updateLayerBoundingBox()
    }

    removeAllEntities() {
        this.removeAllSavedMaterials(), this.layerEntities.forEach(t => {
            const e = t.deref();
            e != null && Ds.ReleaseObject3D(e)
        }), this.layerEntities.clear(), this.layerBoundingBox.makeEmpty()
    }

    updateLayerBoundingBox() {
        this.layerBoundingBox.makeEmpty(), this.layerEntities.forEach(t => {
            const e = t.deref();
            e != null && this.layerBoundingBox.expandByObject(e)
        })
    }

    dispose() {
        this.layerEntities.clear(), this.layerBoundingBox.makeEmpty(), super.dispose()
    }
}

class Zp extends zE {
    constructor({viewer: e, name: n, parentScene: s, floorIdElevations: r, useBoundingBox: o, visualizationType: a}) {
        super({viewer: e, name: n, parentScene: s, coverage: 1, visualizationType: a, useBoundingBox: o});
        z(this, "floorEntities");
        z(this, "entityIdFloorIds");
        z(this, "entitySelectionEnabled");
        z(this, "useHoverEffect");
        z(this, "prevHoverEntity");
        z(this, "selectionReadyEmissiveColor");
        z(this, "selectedEmissiveColor");
        z(this, "normalEmissiveColor");
        z(this, "boundOnMouseMove");
        z(this, "boundOnClick");
        this.entitySelectionEnabled = !1, this.useHoverEffect = !1, this.prevHoverEntity = null, this.selectionReadyEmissiveColor = new pt(127), this.selectedEmissiveColor = new pt(16776960), this.normalEmissiveColor = new pt(0), this.boundOnMouseMove = this.onMouseMove.bind(this), this.boundOnClick = this.onClick.bind(this), this.floorEntities = new Map, this.entityIdFloorIds = new Map;
        for (let {floorId: l, elevation: c} of r) {
            let h = new re;
            h.position.y = c, this.layerScene.add(h), h.updateMatrix(), h.userData.floorId = l, h.userData.layerName = n, this.floorEntities.set(l, {
                floorScene: new WeakRef(h),
                boundingBox: new fi,
                entities: new Map
            })
        }
    }

    updateLayerBoundingBox() {
        var e;
        this.layerBoundingBox.makeEmpty();
        for (let [n, s] of this.floorEntities) ((e = s.floorScene.deref()) == null ? void 0 : e.visible) === !0 && this.layerBoundingBox.union(s.boundingBox)
    }

    setFloorVisible(e, n = !0) {
        const s = this.floorEntities.get(e);
        if (s == null) return;
        const r = s.floorScene.deref();
        r != null && (r.visible = n, this.updateLayerBoundingBox())
    }

    isFloorVisible(e) {
        const n = this.floorEntities.get(e);
        if (n == null) return !1;
        const s = n.floorScene.deref();
        return s == null ? !1 : s.visible
    }

    addEntity(e, n, s) {
        let r = this.floorEntities.get(e);
        if (r == null) throw "FloorLayer.addObject: 존재하지 않는 floorId: " + e;
        let o = r.floorScene.deref();
        if (o == null) throw "FloorLayer.addObject: floorScene GC 후 참조: " + e;
        s.userData.entityId = n, s.userData.floorId = e, s.userData.layerName = this.name, o.add(s);
        let a = new WeakRef(s);
        this.layerEntities.set(n, a), r.entities.set(n, a), this.entityIdFloorIds.set(n, e), this.useBoundingBox === !0 && r.boundingBox.expandByObject(s, !0)
    }

    * getEntitiesByFloorId(e, n = () => !0, s = !1) {
        let r = this.floorEntities.get(e);
        if (r != null) for (let [o, a] of r.entities) {
            const l = a.deref();
            if (l != null && n(e, o, l) === !0 && (yield[e, o, l], s === !0)) break
        }
    }

    getEntity(e) {
        var n;
        return ((n = this.layerEntities.get(e)) == null ? void 0 : n.deref()) ?? null
    }

    removeEntity(e) {
        var o;
        const n = this.entityIdFloorIds.get(e);
        if (n == null) return;
        const s = this.floorEntities.get(n);
        if (s == null) return;
        let r = (o = s.entities.get(e)) == null ? void 0 : o.deref();
        r != null && (this.removeSavedMaterials(r), Ds.ReleaseObject3D(r)), this.layerEntities.delete(e), s.entities.delete(e), this.useBoundingBox === !0 && (s.boundingBox.makeEmpty(), s.entities.forEach(a => {
            const l = a.deref();
            l != null && s.boundingBox.expandByObject(l)
        }))
    }

    removeAllEntities(e) {
        if (e != null) {
            const n = this.floorEntities.get(e);
            n != null && (n.entities.forEach((s, r) => {
                const o = s.deref();
                o != null && (this.removeSavedMaterials(o), Ds.ReleaseObject3D(o)), this.layerEntities.delete(r)
            }), n.entities.clear(), n.boundingBox.makeEmpty())
        } else this.removeAllSavedMaterials(), [...this.floorEntities.keys()].forEach(n => this.removeAllEntities(n))
    }

    onMouseMove(e) {
        e.preventDefault(), e.stopPropagation();
        const n = this.viewer.updateRaycaster(e);
        let s = !1;
        for (let [, r] of this.floorEntities) {
            const o = r.floorScene.deref();
            if (o == null || !o.visible) continue;
            const a = n.intersectObjects(o.children, !1);
            if (a.length > 0) {
                const c = a[0].object;
                c instanceof ge && c.material != null && c != this.prevHoverEntity && (this.changeEmissive(c.material, this.selectedEmissiveColor, 1), s = !0, this.prevHoverEntity != null && this.prevHoverEntity.material != null && this.changeEmissive(this.prevHoverEntity.material, this.normalEmissiveColor, 0), this.prevHoverEntity = c)
            }
        }
        s || (this.prevHoverEntity != null && this.prevHoverEntity.material != null && this.changeEmissive(this.prevHoverEntity.material, this.normalEmissiveColor, 0), this.prevHoverEntity = null)
    }

    onClick(e) {
        e.preventDefault(), e.stopPropagation();
        const n = this.viewer.updateRaycaster(e);
        let s = [];
        for (let [r, o] of this.floorEntities) {
            const a = o.floorScene.deref();
            a == null || !a.visible || s.push(...n.intersectObjects(a.children, !1))
        }
        if (s.length > 0) {
            s.sort((a, l) => a.distance - l.distance);
            const r = s[0], o = r.object;
            this.dispatchEvent(new UN("entityselect", {
                layer: this,
                entityId: o.userData.entityId,
                intersection: r,
                mouseEvent: e
            }))
        }
    }

    enableEntitySelection(e) {
        if (this.entitySelectionEnabled != !0) {
            this.viewer.renderer.domElement.addEventListener("click", this.boundOnClick, !1), this.entitySelectionEnabled = !0, this.useHoverEffect = e === !0, this.useHoverEffect === !0 && this.viewer.renderer.domElement.addEventListener("mousemove", this.boundOnMouseMove, !1);
            for (let [n, s] of this.layerEntities) {
                const r = s.deref();
                r == null || !(r instanceof ge) || r.material == null || this.changeEmissive(r.material, this.selectionReadyEmissiveColor, 1)
            }
        }
    }

    changeEmissive(e, n, s) {
        Array.isArray(e) ? e.forEach(r => this.changeEmissive(r, n, s)) : (e.emissive = n, e.emissiveIntensity = s)
    }

    disableEntitySelection() {
        this.entitySelectionEnabled = !1, this.viewer.renderer.domElement.removeEventListener("click", this.boundOnClick), this.viewer.renderer.domElement.removeEventListener("mousemove", this.boundOnMouseMove);
        for (let [e, n] of this.layerEntities) {
            const s = n.deref();
            s == null || !(s instanceof ge) || s.material == null || this.changeEmissive(s.material, this.normalEmissiveColor, 0)
        }
    }

    dispose() {
        this.entitySelectionEnabled = !1, this.viewer.renderer.domElement.removeEventListener("click", this.boundOnClick), this.viewer.renderer.domElement.removeEventListener("mousemove", this.boundOnMouseMove), this.floorEntities.clear(), this.layerEntities.clear(), this.entityIdFloorIds.clear(), super.dispose()
    }
}

const BE = {
    uniforms: {tDiffuse: {value: null}, opacity: {value: 1}}, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
};

class Ih {
    constructor() {
        this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
    }

    setSize() {
    }

    render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.")
    }

    dispose() {
    }
}

const VN = new Ml(-1, 1, 1, -1, 0, 1), D0 = new Xt;
D0.setAttribute("position", new Ct([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
D0.setAttribute("uv", new Ct([0, 2, 0, 0, 2, 0], 2));

class kE {
    constructor(t) {
        this._mesh = new ge(D0, t)
    }

    dispose() {
        this._mesh.geometry.dispose()
    }

    render(t) {
        t.render(this._mesh, VN)
    }

    get material() {
        return this._mesh.material
    }

    set material(t) {
        this._mesh.material = t
    }
}

class HN extends Ih {
    constructor(t, e) {
        super(), this.textureID = e !== void 0 ? e : "tDiffuse", t instanceof jn ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = kc.clone(t.uniforms), this.material = new jn({
            defines: Object.assign({}, t.defines),
            uniforms: this.uniforms,
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader
        })), this.fsQuad = new kE(this.material)
    }

    render(t, e, n) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
    }

    dispose() {
        this.material.dispose(), this.fsQuad.dispose()
    }
}

class Dx extends Ih {
    constructor(t, e) {
        super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
    }

    render(t, e, n) {
        const s = t.getContext(), r = t.state;
        r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0);
        let o, a;
        this.inverse ? (o = 0, a = 1) : (o = 1, a = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), r.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), r.buffers.stencil.setClear(a), r.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), r.buffers.stencil.setLocked(!0)
    }
}

class $N extends Ih {
    constructor() {
        super(), this.needsSwap = !1
    }

    render(t) {
        t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
    }
}

class WN {
    constructor(t, e) {
        if (this.renderer = t, e === void 0) {
            const n = t.getSize(new j);
            this._pixelRatio = t.getPixelRatio(), this._width = n.width, this._height = n.height, e = new fs(this._width * this._pixelRatio, this._height * this._pixelRatio), e.texture.name = "EffectComposer.rt1"
        } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
        this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new HN(BE), this.clock = new hf
    }

    swapBuffers() {
        const t = this.readBuffer;
        this.readBuffer = this.writeBuffer, this.writeBuffer = t
    }

    addPass(t) {
        this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }

    insertPass(t, e) {
        this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }

    removePass(t) {
        const e = this.passes.indexOf(t);
        e !== -1 && this.passes.splice(e, 1)
    }

    isLastEnabledPass(t) {
        for (let e = t + 1; e < this.passes.length; e++) if (this.passes[e].enabled) return !1;
        return !0
    }

    render(t) {
        t === void 0 && (t = this.clock.getDelta());
        const e = this.renderer.getRenderTarget();
        let n = !1;
        for (let s = 0, r = this.passes.length; s < r; s++) {
            const o = this.passes[s];
            if (o.enabled !== !1) {
                if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), o.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), o.needsSwap) {
                    if (n) {
                        const a = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
                        l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(a.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                Dx !== void 0 && (o instanceof Dx ? n = !0 : o instanceof $N && (n = !1))
            }
        }
        this.renderer.setRenderTarget(e)
    }

    reset(t) {
        if (t === void 0) {
            const e = this.renderer.getSize(new j);
            this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
    }

    setSize(t, e) {
        this._width = t, this._height = e;
        const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
        this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
        for (let r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, s)
    }

    setPixelRatio(t) {
        this._pixelRatio = t, this.setSize(this._width, this._height)
    }

    dispose() {
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose()
    }
}

class qN extends Ih {
    constructor(t, e, n, s, r) {
        super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = r !== void 0 ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new pt
    }

    render(t, e, n) {
        const s = t.autoClear;
        t.autoClear = !1;
        let r, o;
        this.overrideMaterial !== void 0 && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), r = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, r), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = o), t.autoClear = s
    }
}

const YN = {
    shaderID: "luminosityHighPass",
    uniforms: {
        tDiffuse: {value: null},
        luminosityThreshold: {value: 1},
        smoothWidth: {value: 1},
        defaultColor: {value: new pt(0)},
        defaultOpacity: {value: 0}
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
};

class hl extends Ih {
    constructor(t, e, n, s) {
        super(), this.strength = e !== void 0 ? e : 1, this.radius = n, this.threshold = s, this.resolution = t !== void 0 ? new j(t.x, t.y) : new j(256, 256), this.clearColor = new pt(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
        let r = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new fs(r, o), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
        for (let u = 0; u < this.nMips; u++) {
            const d = new fs(r, o);
            d.texture.name = "UnrealBloomPass.h" + u, d.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(d);
            const f = new fs(r, o);
            f.texture.name = "UnrealBloomPass.v" + u, f.texture.generateMipmaps = !1, this.renderTargetsVertical.push(f), r = Math.round(r / 2), o = Math.round(o / 2)
        }
        const a = YN;
        this.highPassUniforms = kc.clone(a.uniforms), this.highPassUniforms.luminosityThreshold.value = s, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new jn({
            uniforms: this.highPassUniforms,
            vertexShader: a.vertexShader,
            fragmentShader: a.fragmentShader,
            defines: {}
        }), this.separableBlurMaterials = [];
        const l = [3, 5, 7, 9, 11];
        r = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2);
        for (let u = 0; u < this.nMips; u++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[u])), this.separableBlurMaterials[u].uniforms.texSize.value = new j(r, o), r = Math.round(r / 2), o = Math.round(o / 2);
        this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0;
        const c = [1, .8, .6, .4, .2];
        this.compositeMaterial.uniforms.bloomFactors.value = c, this.bloomTintColors = [new C(1, 1, 1), new C(1, 1, 1), new C(1, 1, 1), new C(1, 1, 1), new C(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
        const h = BE;
        this.copyUniforms = kc.clone(h.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new jn({
            uniforms: this.copyUniforms,
            vertexShader: h.vertexShader,
            fragmentShader: h.fragmentShader,
            blending: Rc,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new pt, this.oldClearAlpha = 1, this.basic = new rn, this.fsQuad = new kE(null)
    }

    dispose() {
        for (let t = 0; t < this.renderTargetsHorizontal.length; t++) this.renderTargetsHorizontal[t].dispose();
        for (let t = 0; t < this.renderTargetsVertical.length; t++) this.renderTargetsVertical[t].dispose();
        this.renderTargetBright.dispose();
        for (let t = 0; t < this.separableBlurMaterials.length; t++) this.separableBlurMaterials[t].dispose();
        this.compositeMaterial.dispose(), this.materialCopy.dispose(), this.basic.dispose(), this.fsQuad.dispose()
    }

    setSize(t, e) {
        let n = Math.round(t / 2), s = Math.round(e / 2);
        this.renderTargetBright.setSize(n, s);
        for (let r = 0; r < this.nMips; r++) this.renderTargetsHorizontal[r].setSize(n, s), this.renderTargetsVertical[r].setSize(n, s), this.separableBlurMaterials[r].uniforms.texSize.value = new j(n, s), n = Math.round(n / 2), s = Math.round(s / 2)
    }

    render(t, e, n, s, r) {
        t.getClearColor(this._oldClearColor), this.oldClearAlpha = t.getClearAlpha();
        const o = t.autoClear;
        t.autoClear = !1, t.setClearColor(this.clearColor, 0), r && t.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t.setRenderTarget(this.renderTargetBright), t.clear(), this.fsQuad.render(t);
        let a = this.renderTargetBright;
        for (let l = 0; l < this.nMips; l++) this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[l].uniforms.direction.value = hl.BlurDirectionX, t.setRenderTarget(this.renderTargetsHorizontal[l]), t.clear(), this.fsQuad.render(t), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = hl.BlurDirectionY, t.setRenderTarget(this.renderTargetsVertical[l]), t.clear(), this.fsQuad.render(t), a = this.renderTargetsVertical[l];
        this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t.setRenderTarget(this.renderTargetsHorizontal[0]), t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && t.state.buffers.stencil.setTest(!0), this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(n), this.fsQuad.render(t)), t.setClearColor(this._oldClearColor, this.oldClearAlpha), t.autoClear = o
    }

    getSeperableBlurMaterial(t) {
        return new jn({
            defines: {KERNEL_RADIUS: t, SIGMA: t},
            uniforms: {colorTexture: {value: null}, texSize: {value: new j(.5, .5)}, direction: {value: new j(.5, .5)}},
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
        })
    }

    getCompositeMaterial(t) {
        return new jn({
            defines: {NUM_MIPS: t},
            uniforms: {
                blurTexture1: {value: null},
                blurTexture2: {value: null},
                blurTexture3: {value: null},
                blurTexture4: {value: null},
                blurTexture5: {value: null},
                bloomStrength: {value: 1},
                bloomFactors: {value: null},
                bloomTintColors: {value: null},
                bloomRadius: {value: 0}
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
        })
    }
}

hl.BlurDirectionX = new j(1, 0);
hl.BlurDirectionY = new j(0, 1);
const XN = "Behaviour", UE = "Alpha", GE = "Attraction", ZN = "Collision", VE = "Color", HE = "CrossZone", $E = "Force",
    WE = "Gravity", qE = "RandomDrift", YE = "Repulsion", XE = "Rotate", ZE = "Scale", jE = "Spring",
    jN = "Initializer", KE = "Body", F0 = "BodySprite", z0 = "Texture", JE = "Life", QE = "Mass", tS = "Position",
    eS = "Radius", nS = "VectorVelocity", sS = "PolarVelocity", iS = "RadialVelocity", KN = "Rate", rS = [F0, z0],
    JN = "Zone", oS = "BoxZone", aS = "LineZone", lS = "MeshZone", cS = "PointZone", QN = "ScreenZone",
    hS = "SphereZone", t3 = "BaseRenderer", e3 = "SpriteRenderer", n3 = "MeshRenderer", us = 3.142, B0 = 500,
    Ga = us / 180, Mm = 100, uS = "euler", s3 = () => (!process || !process.env, !1), Ic = {
        easeLinear: function (i) {
            return i
        }, easeInQuad: function (i) {
            return Math.pow(i, 2)
        }, easeOutQuad: function (i) {
            return -(Math.pow(i - 1, 2) - 1)
        }, easeInOutQuad: function (i) {
            return (i /= .5) < 1 ? .5 * Math.pow(i, 2) : -.5 * ((i -= 2) * i - 2)
        }, easeInCubic: function (i) {
            return Math.pow(i, 3)
        }, easeOutCubic: function (i) {
            return Math.pow(i - 1, 3) + 1
        }, easeInOutCubic: function (i) {
            return (i /= .5) < 1 ? .5 * Math.pow(i, 3) : .5 * (Math.pow(i - 2, 3) + 2)
        }, easeInQuart: function (i) {
            return Math.pow(i, 4)
        }, easeOutQuart: function (i) {
            return -(Math.pow(i - 1, 4) - 1)
        }, easeInOutQuart: function (i) {
            return (i /= .5) < 1 ? .5 * Math.pow(i, 4) : -.5 * ((i -= 2) * Math.pow(i, 3) - 2)
        }, easeInSine: function (i) {
            return -Math.cos(i * (us / 2)) + 1
        }, easeOutSine: function (i) {
            return Math.sin(i * (us / 2))
        }, easeInOutSine: function (i) {
            return -.5 * (Math.cos(us * i) - 1)
        }, easeInExpo: function (i) {
            return i === 0 ? 0 : Math.pow(2, 10 * (i - 1))
        }, easeOutExpo: function (i) {
            return i === 1 ? 1 : -Math.pow(2, -10 * i) + 1
        }, easeInOutExpo: function (i) {
            return i === 0 ? 0 : i === 1 ? 1 : (i /= .5) < 1 ? .5 * Math.pow(2, 10 * (i - 1)) : .5 * (-Math.pow(2, -10 * --i) + 2)
        }, easeInCirc: function (i) {
            return -(Math.sqrt(1 - i * i) - 1)
        }, easeOutCirc: function (i) {
            return Math.sqrt(1 - Math.pow(i - 1, 2))
        }, easeInOutCirc: function (i) {
            return (i /= .5) < 1 ? -.5 * (Math.sqrt(1 - i * i) - 1) : .5 * (Math.sqrt(1 - (i -= 2) * i) + 1)
        }, easeInBack: function (i) {
            var t = 1.70158;
            return i * i * ((t + 1) * i - t)
        }, easeOutBack: function (i) {
            var t = 1.70158;
            return (i = i - 1) * i * ((t + 1) * i + t) + 1
        }, easeInOutBack: function (i) {
            var t = 1.70158;
            return (i /= .5) < 1 ? .5 * (i * i * (((t *= 1.525) + 1) * i - t)) : .5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2)
        }
    }, {
        easeLinear: dS,
        easeInQuad: Kj,
        easeOutQuad: Jj,
        easeInOutQuad: Qj,
        easeInCubic: tK,
        easeOutCubic: eK,
        easeInOutCubic: nK,
        easeInQuart: sK,
        easeOutQuart: iK,
        easeInOutQuart: rK,
        easeInSine: oK,
        easeOutSine: aK,
        easeInOutSine: lK,
        easeInExpo: cK,
        easeOutExpo: hK,
        easeInOutExpo: uK,
        easeInCirc: dK,
        easeOutCirc: fK,
        easeInOutCirc: pK,
        easeInBack: gK,
        easeOutBack: mK,
        easeInOutBack: _K
    } = Ic, _i = i => Ic[i] ? Ic[i] : Ic.easeLinear, Fx = 1 / 0, zx = 0, Bx = 1, kx = !1, Ux = !1, Gx = null, Vx = null,
    Hx = 1, $x = 10, Wx = 1, qx = 1, Yx = !1, Xx = !1, Zx = dS, Tm = .0167,
    Im = [tS, JE, eS, QE, KE, F0, z0, sS, iS, nS], fS = [UE, GE, VE, HE, $E, WE, qE, YE, XE, ZE, jE],
    i3 = [oS, aS, lS, cS, hS];

function Wc(i) {
    "@babel/helpers - typeof";
    return Wc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t
    } : function (t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Wc(i)
}

function r3(i, t) {
    if (Wc(i) !== "object" || i === null) return i;
    var e = i[Symbol.toPrimitive];
    if (e !== void 0) {
        var n = e.call(i, t || "default");
        if (Wc(n) !== "object") return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(i)
}

function o3(i) {
    var t = r3(i, "string");
    return Wc(t) === "symbol" ? t : String(t)
}

function Ah(i, t, e) {
    return t = o3(t), t in i ? Object.defineProperty(i, t, {
        value: e,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : i[t] = e, i
}

const jx = {
    getRGB: function (i) {
        var t = {};
        if (typeof i == "number") n = Math.floor(i), t.r = (i >> 16 & 255) / 255, t.g = (i >> 8 & 255) / 255, t.b = (i & 255) / 255; else if (typeof i == "string") {
            var e;
            if (e = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) t.r = Math.min(255, parseInt(e[1], 10)) / 255, t.g = Math.min(255, parseInt(e[2], 10)) / 255, t.b = Math.min(255, parseInt(e[3], 10)) / 255; else if (e = /^\#([A-Fa-f0-9]+)$/.exec(i)) {
                var n = e[1];
                t.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255, t.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255, t.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255
            }
        } else t.r = i.r, t.g = i.g, t.b = i.b;
        return t
    }
}, pS = {
    _id: 0, _uids: new Map, getNewId: function () {
        return `PUID_${++this._id}`
    }, id: function (i) {
        if (this._uids.has(i)) return this._uids.get(i);
        const t = this.getNewId();
        return this._uids.set(i, t), t
    }
};
var qc = {
    DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
        for (var i = [], t = 0; t < 256; t++) i[t] = (t < 16 ? "0" : "") + t.toString(16);
        return function () {
            var n = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0,
                r = Math.random() * 4294967295 | 0, o = Math.random() * 4294967295 | 0,
                a = i[n & 255] + i[n >> 8 & 255] + i[n >> 16 & 255] + i[n >> 24 & 255] + "-" + i[s & 255] + i[s >> 8 & 255] + "-" + i[s >> 16 & 15 | 64] + i[s >> 24 & 255] + "-" + i[r & 63 | 128] + i[r >> 8 & 255] + "-" + i[r >> 16 & 255] + i[r >> 24 & 255] + i[o & 255] + i[o >> 8 & 255] + i[o >> 16 & 255] + i[o >> 24 & 255];
            return a.toUpperCase()
        }
    }(), clamp: function (i, t, e) {
        return Math.max(t, Math.min(e, i))
    }, euclideanModulo: function (i, t) {
        return (i % t + t) % t
    }, mapLinear: function (i, t, e, n, s) {
        return n + (i - t) * (s - n) / (e - t)
    }, lerp: function (i, t, e) {
        return (1 - e) * i + e * t
    }, smoothstep: function (i, t, e) {
        return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * (3 - 2 * i))
    }, smootherstep: function (i, t, e) {
        return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * i * (i * (i * 6 - 15) + 10))
    }, randInt: function (i, t) {
        return i + Math.floor(Math.random() * (t - i + 1))
    }, randFloat: function (i, t) {
        return i + Math.random() * (t - i)
    }, randFloatSpread: function (i) {
        return i * (.5 - Math.random())
    }, degToRad: function (i) {
        return i * qc.DEG2RAD
    }, radToDeg: function (i) {
        return i * qc.RAD2DEG
    }, isPowerOfTwo: function (i) {
        return (i & i - 1) === 0 && i !== 0
    }, ceilPowerOfTwo: function (i) {
        return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
    }, floorPowerOfTwo: function (i) {
        return Math.pow(2, Math.floor(Math.log(i) / Math.LN2))
    }
};

function ul(i, t, e, n) {
    this._x = i || 0, this._y = t || 0, this._z = e || 0, this._w = n !== void 0 ? n : 1
}

Object.assign(ul, {
    slerp: function (i, t, e, n) {
        return e.copy(i).slerp(t, n)
    }, slerpFlat: function (i, t, e, n, s, r, o) {
        var a = e[n + 0], l = e[n + 1], c = e[n + 2], h = e[n + 3], u = s[r + 0], d = s[r + 1], f = s[r + 2],
            g = s[r + 3];
        if (h !== g || a !== u || l !== d || c !== f) {
            var m = 1 - o, p = a * u + l * d + c * f + h * g, _ = p >= 0 ? 1 : -1, x = 1 - p * p;
            if (x > Number.EPSILON) {
                var y = Math.sqrt(x), v = Math.atan2(y, p * _);
                m = Math.sin(m * v) / y, o = Math.sin(o * v) / y
            }
            var w = o * _;
            if (a = a * m + u * w, l = l * m + d * w, c = c * m + f * w, h = h * m + g * w, m === 1 - o) {
                var E = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                a *= E, l *= E, c *= E, h *= E
            }
        }
        i[t] = a, i[t + 1] = l, i[t + 2] = c, i[t + 3] = h
    }
});
Object.defineProperties(ul.prototype, {
    x: {
        get: function () {
            return this._x
        }, set: function (i) {
            this._x = i, this._onChangeCallback()
        }
    }, y: {
        get: function () {
            return this._y
        }, set: function (i) {
            this._y = i, this._onChangeCallback()
        }
    }, z: {
        get: function () {
            return this._z
        }, set: function (i) {
            this._z = i, this._onChangeCallback()
        }
    }, w: {
        get: function () {
            return this._w
        }, set: function (i) {
            this._w = i, this._onChangeCallback()
        }
    }
});
Object.assign(ul.prototype, {
    isQuaternion: !0, set: function (i, t, e, n) {
        return this._x = i, this._y = t, this._z = e, this._w = n, this._onChangeCallback(), this
    }, clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }, copy: function (i) {
        return this._x = i.x, this._y = i.y, this._z = i.z, this._w = i.w, this._onChangeCallback(), this
    }, setFromEuler: function (i, t) {
        if (!(i && i.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        var e = i._x, n = i._y, s = i._z, r = i.order, o = Math.cos, a = Math.sin, l = o(e / 2), c = o(n / 2),
            h = o(s / 2), u = a(e / 2), d = a(n / 2), f = a(s / 2);
        return r === "XYZ" ? (this._x = u * c * h + l * d * f, this._y = l * d * h - u * c * f, this._z = l * c * f + u * d * h, this._w = l * c * h - u * d * f) : r === "YXZ" ? (this._x = u * c * h + l * d * f, this._y = l * d * h - u * c * f, this._z = l * c * f - u * d * h, this._w = l * c * h + u * d * f) : r === "ZXY" ? (this._x = u * c * h - l * d * f, this._y = l * d * h + u * c * f, this._z = l * c * f + u * d * h, this._w = l * c * h - u * d * f) : r === "ZYX" ? (this._x = u * c * h - l * d * f, this._y = l * d * h + u * c * f, this._z = l * c * f - u * d * h, this._w = l * c * h + u * d * f) : r === "YZX" ? (this._x = u * c * h + l * d * f, this._y = l * d * h + u * c * f, this._z = l * c * f - u * d * h, this._w = l * c * h - u * d * f) : r === "XZY" && (this._x = u * c * h - l * d * f, this._y = l * d * h - u * c * f, this._z = l * c * f + u * d * h, this._w = l * c * h + u * d * f), t !== !1 && this._onChangeCallback(), this
    }, setFromAxisAngle: function (i, t) {
        var e = t / 2, n = Math.sin(e);
        return this._x = i.x * n, this._y = i.y * n, this._z = i.z * n, this._w = Math.cos(e), this._onChangeCallback(), this
    }, setFromRotationMatrix: function (i) {
        var t = i.elements, e = t[0], n = t[4], s = t[8], r = t[1], o = t[5], a = t[9], l = t[2], c = t[6], h = t[10],
            u = e + o + h, d;
        return u > 0 ? (d = .5 / Math.sqrt(u + 1), this._w = .25 / d, this._x = (c - a) * d, this._y = (s - l) * d, this._z = (r - n) * d) : e > o && e > h ? (d = 2 * Math.sqrt(1 + e - o - h), this._w = (c - a) / d, this._x = .25 * d, this._y = (n + r) / d, this._z = (s + l) / d) : o > h ? (d = 2 * Math.sqrt(1 + o - e - h), this._w = (s - l) / d, this._x = (n + r) / d, this._y = .25 * d, this._z = (a + c) / d) : (d = 2 * Math.sqrt(1 + h - e - o), this._w = (r - n) / d, this._x = (s + l) / d, this._y = (a + c) / d, this._z = .25 * d), this._onChangeCallback(), this
    }, setFromUnitVectors: function (i, t) {
        var e = 1e-6, n = i.dot(t) + 1;
        return n < e ? (n = 0, Math.abs(i.x) > Math.abs(i.z) ? (this._x = -i.y, this._y = i.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -i.z, this._z = i.y, this._w = n)) : (this._x = i.y * t.z - i.z * t.y, this._y = i.z * t.x - i.x * t.z, this._z = i.x * t.y - i.y * t.x, this._w = n), this.normalize()
    }, angleTo: function (i) {
        return 2 * Math.acos(Math.abs(qc.clamp(this.dot(i), -1, 1)))
    }, rotateTowards: function (i, t) {
        var e = this.angleTo(i);
        if (e === 0) return this;
        var n = Math.min(1, t / e);
        return this.slerp(i, n), this
    }, inverse: function () {
        return this.conjugate()
    }, conjugate: function () {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }, dot: function (i) {
        return this._x * i._x + this._y * i._y + this._z * i._z + this._w * i._w
    }, lengthSq: function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }, length: function () {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }, normalize: function () {
        var i = this.length();
        return i === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (i = 1 / i, this._x = this._x * i, this._y = this._y * i, this._z = this._z * i, this._w = this._w * i), this._onChangeCallback(), this
    }, multiply: function (i, t) {
        return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(i, t)) : this.multiplyQuaternions(this, i)
    }, premultiply: function (i) {
        return this.multiplyQuaternions(i, this)
    }, multiplyQuaternions: function (i, t) {
        var e = i._x, n = i._y, s = i._z, r = i._w, o = t._x, a = t._y, l = t._z, c = t._w;
        return this._x = e * c + r * o + n * l - s * a, this._y = n * c + r * a + s * o - e * l, this._z = s * c + r * l + e * a - n * o, this._w = r * c - e * o - n * a - s * l, this._onChangeCallback(), this
    }, slerp: function (i, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(i);
        var e = this._x, n = this._y, s = this._z, r = this._w, o = r * i._w + e * i._x + n * i._y + s * i._z;
        if (o < 0 ? (this._w = -i._w, this._x = -i._x, this._y = -i._y, this._z = -i._z, o = -o) : this.copy(i), o >= 1) return this._w = r, this._x = e, this._y = n, this._z = s, this;
        var a = 1 - o * o;
        if (a <= Number.EPSILON) {
            var l = 1 - t;
            return this._w = l * r + t * this._w, this._x = l * e + t * this._x, this._y = l * n + t * this._y, this._z = l * s + t * this._z, this.normalize(), this._onChangeCallback(), this
        }
        var c = Math.sqrt(a), h = Math.atan2(c, o), u = Math.sin((1 - t) * h) / c, d = Math.sin(t * h) / c;
        return this._w = r * u + this._w * d, this._x = e * u + this._x * d, this._y = n * u + this._y * d, this._z = s * u + this._z * d, this._onChangeCallback(), this
    }, equals: function (i) {
        return i._x === this._x && i._y === this._y && i._z === this._z && i._w === this._w
    }, fromArray: function (i, t) {
        return t === void 0 && (t = 0), this._x = i[t], this._y = i[t + 1], this._z = i[t + 2], this._w = i[t + 3], this._onChangeCallback(), this
    }, toArray: function (i, t) {
        return i === void 0 && (i = []), t === void 0 && (t = 0), i[t] = this._x, i[t + 1] = this._y, i[t + 2] = this._z, i[t + 3] = this._w, i
    }, _onChange: function (i) {
        return this._onChangeCallback = i, this
    }, _onChangeCallback: function () {
    }
});

function Yn(i, t, e) {
    this.x = i || 0, this.y = t || 0, this.z = e || 0
}

Object.assign(Yn.prototype, {
    isVector3: !0, set: function (i, t, e) {
        return this.x = i, this.y = t, this.z = e, this
    }, setScalar: function (i) {
        return this.x = i, this.y = i, this.z = i, this
    }, setX: function (i) {
        return this.x = i, this
    }, setY: function (i) {
        return this.y = i, this
    }, setZ: function (i) {
        return this.z = i, this
    }, setComponent: function (i, t) {
        switch (i) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + i)
        }
        return this
    }, getComponent: function (i) {
        switch (i) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + i)
        }
    }, clone: function () {
        return new this.constructor(this.x, this.y, this.z)
    }, copy: function (i) {
        return this.x = i.x, this.y = i.y, this.z = i.z, this
    }, add: function (i, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(i, t)) : (this.x += i.x, this.y += i.y, this.z += i.z, this)
    }, addScalar: function (i) {
        return this.x += i, this.y += i, this.z += i, this
    }, addVectors: function (i, t) {
        return this.x = i.x + t.x, this.y = i.y + t.y, this.z = i.z + t.z, this
    }, addScaledVector: function (i, t) {
        return this.x += i.x * t, this.y += i.y * t, this.z += i.z * t, this
    }, sub: function (i, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(i, t)) : (this.x -= i.x, this.y -= i.y, this.z -= i.z, this)
    }, subScalar: function (i) {
        return this.x -= i, this.y -= i, this.z -= i, this
    }, subVectors: function (i, t) {
        return this.x = i.x - t.x, this.y = i.y - t.y, this.z = i.z - t.z, this
    }, multiply: function (i, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(i, t)) : (this.x *= i.x, this.y *= i.y, this.z *= i.z, this)
    }, multiplyScalar: function (i) {
        return this.x *= i, this.y *= i, this.z *= i, this
    }, multiplyVectors: function (i, t) {
        return this.x = i.x * t.x, this.y = i.y * t.y, this.z = i.z * t.z, this
    }, applyEuler: function () {
        var i = new ul;
        return function (e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(i.setFromEuler(e))
        }
    }(), applyAxisAngle: function () {
        var i = new ul;
        return function (e, n) {
            return this.applyQuaternion(i.setFromAxisAngle(e, n))
        }
    }(), applyMatrix3: function (i) {
        var t = this.x, e = this.y, n = this.z, s = i.elements;
        return this.x = s[0] * t + s[3] * e + s[6] * n, this.y = s[1] * t + s[4] * e + s[7] * n, this.z = s[2] * t + s[5] * e + s[8] * n, this
    }, applyMatrix4: function (i) {
        var t = this.x, e = this.y, n = this.z, s = i.elements, r = 1 / (s[3] * t + s[7] * e + s[11] * n + s[15]);
        return this.x = (s[0] * t + s[4] * e + s[8] * n + s[12]) * r, this.y = (s[1] * t + s[5] * e + s[9] * n + s[13]) * r, this.z = (s[2] * t + s[6] * e + s[10] * n + s[14]) * r, this
    }, applyQuaternion: function (i) {
        var t = this.x, e = this.y, n = this.z, s = i.x, r = i.y, o = i.z, a = i.w, l = a * t + r * n - o * e,
            c = a * e + o * t - s * n, h = a * n + s * e - r * t, u = -s * t - r * e - o * n;
        return this.x = l * a + u * -s + c * -o - h * -r, this.y = c * a + u * -r + h * -s - l * -o, this.z = h * a + u * -o + l * -r - c * -s, this
    }, project: function (i) {
        return this.applyMatrix4(i.matrixWorldInverse).applyMatrix4(i.projectionMatrix)
    }, unproject: function (i) {
        return this.applyMatrix4(i.projectionMatrixInverse).applyMatrix4(i.matrixWorld)
    }, transformDirection: function (i) {
        var t = this.x, e = this.y, n = this.z, s = i.elements;
        return this.x = s[0] * t + s[4] * e + s[8] * n, this.y = s[1] * t + s[5] * e + s[9] * n, this.z = s[2] * t + s[6] * e + s[10] * n, this.normalize()
    }, divide: function (i) {
        return this.x /= i.x, this.y /= i.y, this.z /= i.z, this
    }, divideScalar: function (i) {
        return this.multiplyScalar(1 / i)
    }, min: function (i) {
        return this.x = Math.min(this.x, i.x), this.y = Math.min(this.y, i.y), this.z = Math.min(this.z, i.z), this
    }, max: function (i) {
        return this.x = Math.max(this.x, i.x), this.y = Math.max(this.y, i.y), this.z = Math.max(this.z, i.z), this
    }, clamp: function (i, t) {
        return this.x = Math.max(i.x, Math.min(t.x, this.x)), this.y = Math.max(i.y, Math.min(t.y, this.y)), this.z = Math.max(i.z, Math.min(t.z, this.z)), this
    }, clampScalar: function (i, t) {
        return this.x = Math.max(i, Math.min(t, this.x)), this.y = Math.max(i, Math.min(t, this.y)), this.z = Math.max(i, Math.min(t, this.z)), this
    }, clampLength: function (i, t) {
        var e = this.length();
        return this.divideScalar(e || 1).multiplyScalar(Math.max(i, Math.min(t, e)))
    }, floor: function () {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }, ceil: function () {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }, round: function () {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }, roundToZero: function () {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }, negate: function () {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }, dot: function (i) {
        return this.x * i.x + this.y * i.y + this.z * i.z
    }, lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }, length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }, manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }, normalize: function () {
        return this.divideScalar(this.length() || 1)
    }, setLength: function (i) {
        return this.normalize().multiplyScalar(i)
    }, lerp: function (i, t) {
        return this.x += (i.x - this.x) * t, this.y += (i.y - this.y) * t, this.z += (i.z - this.z) * t, this
    }, lerpVectors: function (i, t, e) {
        return this.subVectors(t, i).multiplyScalar(e).add(i)
    }, cross: function (i, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(i, t)) : this.crossVectors(this, i)
    }, crossVectors: function (i, t) {
        var e = i.x, n = i.y, s = i.z, r = t.x, o = t.y, a = t.z;
        return this.x = n * a - s * o, this.y = s * r - e * a, this.z = e * o - n * r, this
    }, projectOnVector: function (i) {
        var t = i.dot(this) / i.lengthSq();
        return this.copy(i).multiplyScalar(t)
    }, projectOnPlane: function () {
        var i = new Yn;
        return function (e) {
            return i.copy(this).projectOnVector(e), this.sub(i)
        }
    }(), reflect: function () {
        var i = new Yn;
        return function (e) {
            return this.sub(i.copy(e).multiplyScalar(2 * this.dot(e)))
        }
    }(), angleTo: function (i) {
        var t = this.dot(i) / Math.sqrt(this.lengthSq() * i.lengthSq());
        return Math.acos(qc.clamp(t, -1, 1))
    }, distanceTo: function (i) {
        return Math.sqrt(this.distanceToSquared(i))
    }, distanceToSquared: function (i) {
        var t = this.x - i.x, e = this.y - i.y, n = this.z - i.z;
        return t * t + e * e + n * n
    }, manhattanDistanceTo: function (i) {
        return Math.abs(this.x - i.x) + Math.abs(this.y - i.y) + Math.abs(this.z - i.z)
    }, setFromSpherical: function (i) {
        return this.setFromSphericalCoords(i.radius, i.phi, i.theta)
    }, setFromSphericalCoords: function (i, t, e) {
        var n = Math.sin(t) * i;
        return this.x = n * Math.sin(e), this.y = Math.cos(t) * i, this.z = n * Math.cos(e), this
    }, setFromCylindrical: function (i) {
        return this.setFromCylindricalCoords(i.radius, i.theta, i.y)
    }, setFromCylindricalCoords: function (i, t, e) {
        return this.x = i * Math.sin(t), this.y = e, this.z = i * Math.cos(t), this
    }, setFromMatrixPosition: function (i) {
        var t = i.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this
    }, setFromMatrixScale: function (i) {
        var t = this.setFromMatrixColumn(i, 0).length(), e = this.setFromMatrixColumn(i, 1).length(),
            n = this.setFromMatrixColumn(i, 2).length();
        return this.x = t, this.y = e, this.z = n, this
    }, setFromMatrixColumn: function (i, t) {
        return this.fromArray(i.elements, t * 4)
    }, equals: function (i) {
        return i.x === this.x && i.y === this.y && i.z === this.z
    }, fromArray: function (i, t) {
        return t === void 0 && (t = 0), this.x = i[t], this.y = i[t + 1], this.z = i[t + 2], this
    }, toArray: function (i, t) {
        return i === void 0 && (i = []), t === void 0 && (t = 0), i[t] = this.x, i[t + 1] = this.y, i[t + 2] = this.z, i
    }, fromBufferAttribute: function (i, t, e) {
        return e !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = i.getX(t), this.y = i.getY(t), this.z = i.getZ(t), this
    }
});

function nd() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
}

Object.assign(nd.prototype, {
    isMatrix4: !0, set: function (i, t, e, n, s, r, o, a, l, c, h, u, d, f, g, m) {
        var p = this.elements;
        return p[0] = i, p[4] = t, p[8] = e, p[12] = n, p[1] = s, p[5] = r, p[9] = o, p[13] = a, p[2] = l, p[6] = c, p[10] = h, p[14] = u, p[3] = d, p[7] = f, p[11] = g, p[15] = m, this
    }, identity: function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }, clone: function () {
        return new nd().fromArray(this.elements)
    }, copy: function (i) {
        var t = this.elements, e = i.elements;
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this
    }, copyPosition: function (i) {
        var t = this.elements, e = i.elements;
        return t[12] = e[12], t[13] = e[13], t[14] = e[14], this
    }, extractBasis: function (i, t, e) {
        return i.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), e.setFromMatrixColumn(this, 2), this
    }, makeBasis: function (i, t, e) {
        return this.set(i.x, t.x, e.x, 0, i.y, t.y, e.y, 0, i.z, t.z, e.z, 0, 0, 0, 0, 1), this
    }, extractRotation: function () {
        var i = new Yn;
        return function (e) {
            var n = this.elements, s = e.elements, r = 1 / i.setFromMatrixColumn(e, 0).length(),
                o = 1 / i.setFromMatrixColumn(e, 1).length(), a = 1 / i.setFromMatrixColumn(e, 2).length();
            return n[0] = s[0] * r, n[1] = s[1] * r, n[2] = s[2] * r, n[3] = 0, n[4] = s[4] * o, n[5] = s[5] * o, n[6] = s[6] * o, n[7] = 0, n[8] = s[8] * a, n[9] = s[9] * a, n[10] = s[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
        }
    }(), makeRotationFromEuler: function (i) {
        i && i.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var t = this.elements, e = i.x, n = i.y, s = i.z, r = Math.cos(e), o = Math.sin(e), a = Math.cos(n),
            l = Math.sin(n), c = Math.cos(s), h = Math.sin(s);
        if (i.order === "XYZ") {
            var u = r * c, d = r * h, f = o * c, g = o * h;
            t[0] = a * c, t[4] = -a * h, t[8] = l, t[1] = d + f * l, t[5] = u - g * l, t[9] = -o * a, t[2] = g - u * l, t[6] = f + d * l, t[10] = r * a
        } else if (i.order === "YXZ") {
            var m = a * c, p = a * h, _ = l * c, x = l * h;
            t[0] = m + x * o, t[4] = _ * o - p, t[8] = r * l, t[1] = r * h, t[5] = r * c, t[9] = -o, t[2] = p * o - _, t[6] = x + m * o, t[10] = r * a
        } else if (i.order === "ZXY") {
            var m = a * c, p = a * h, _ = l * c, x = l * h;
            t[0] = m - x * o, t[4] = -r * h, t[8] = _ + p * o, t[1] = p + _ * o, t[5] = r * c, t[9] = x - m * o, t[2] = -r * l, t[6] = o, t[10] = r * a
        } else if (i.order === "ZYX") {
            var u = r * c, d = r * h, f = o * c, g = o * h;
            t[0] = a * c, t[4] = f * l - d, t[8] = u * l + g, t[1] = a * h, t[5] = g * l + u, t[9] = d * l - f, t[2] = -l, t[6] = o * a, t[10] = r * a
        } else if (i.order === "YZX") {
            var y = r * a, v = r * l, w = o * a, E = o * l;
            t[0] = a * c, t[4] = E - y * h, t[8] = w * h + v, t[1] = h, t[5] = r * c, t[9] = -o * c, t[2] = -l * c, t[6] = v * h + w, t[10] = y - E * h
        } else if (i.order === "XZY") {
            var y = r * a, v = r * l, w = o * a, E = o * l;
            t[0] = a * c, t[4] = -h, t[8] = l * c, t[1] = y * h + E, t[5] = r * c, t[9] = v * h - w, t[2] = w * h - v, t[6] = o * c, t[10] = E * h + y
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }, makeRotationFromQuaternion: function () {
        var i = new Yn(0, 0, 0), t = new Yn(1, 1, 1);
        return function (n) {
            return this.compose(i, n, t)
        }
    }(), lookAt: function () {
        var i = new Yn, t = new Yn, e = new Yn;
        return function (s, r, o) {
            var a = this.elements;
            return e.subVectors(s, r), e.lengthSq() === 0 && (e.z = 1), e.normalize(), i.crossVectors(o, e), i.lengthSq() === 0 && (Math.abs(o.z) === 1 ? e.x += 1e-4 : e.z += 1e-4, e.normalize(), i.crossVectors(o, e)), i.normalize(), t.crossVectors(e, i), a[0] = i.x, a[4] = t.x, a[8] = e.x, a[1] = i.y, a[5] = t.y, a[9] = e.y, a[2] = i.z, a[6] = t.z, a[10] = e.z, this
        }
    }(), multiply: function (i, t) {
        return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(i, t)) : this.multiplyMatrices(this, i)
    }, premultiply: function (i) {
        return this.multiplyMatrices(i, this)
    }, multiplyMatrices: function (i, t) {
        var e = i.elements, n = t.elements, s = this.elements, r = e[0], o = e[4], a = e[8], l = e[12], c = e[1],
            h = e[5], u = e[9], d = e[13], f = e[2], g = e[6], m = e[10], p = e[14], _ = e[3], x = e[7], y = e[11],
            v = e[15], w = n[0], E = n[4], S = n[8], b = n[12], M = n[1], I = n[5], N = n[9], B = n[13], D = n[2],
            L = n[6], k = n[10], G = n[14], Q = n[3], q = n[7], at = n[11], lt = n[15];
        return s[0] = r * w + o * M + a * D + l * Q, s[4] = r * E + o * I + a * L + l * q, s[8] = r * S + o * N + a * k + l * at, s[12] = r * b + o * B + a * G + l * lt, s[1] = c * w + h * M + u * D + d * Q, s[5] = c * E + h * I + u * L + d * q, s[9] = c * S + h * N + u * k + d * at, s[13] = c * b + h * B + u * G + d * lt, s[2] = f * w + g * M + m * D + p * Q, s[6] = f * E + g * I + m * L + p * q, s[10] = f * S + g * N + m * k + p * at, s[14] = f * b + g * B + m * G + p * lt, s[3] = _ * w + x * M + y * D + v * Q, s[7] = _ * E + x * I + y * L + v * q, s[11] = _ * S + x * N + y * k + v * at, s[15] = _ * b + x * B + y * G + v * lt, this
    }, multiplyScalar: function (i) {
        var t = this.elements;
        return t[0] *= i, t[4] *= i, t[8] *= i, t[12] *= i, t[1] *= i, t[5] *= i, t[9] *= i, t[13] *= i, t[2] *= i, t[6] *= i, t[10] *= i, t[14] *= i, t[3] *= i, t[7] *= i, t[11] *= i, t[15] *= i, this
    }, applyToBufferAttribute: function () {
        var i = new Yn;
        return function (e) {
            for (var n = 0, s = e.count; n < s; n++) i.x = e.getX(n), i.y = e.getY(n), i.z = e.getZ(n), i.applyMatrix4(this), e.setXYZ(n, i.x, i.y, i.z);
            return e
        }
    }(), determinant: function () {
        var i = this.elements, t = i[0], e = i[4], n = i[8], s = i[12], r = i[1], o = i[5], a = i[9], l = i[13],
            c = i[2], h = i[6], u = i[10], d = i[14], f = i[3], g = i[7], m = i[11], p = i[15];
        return f * (+s * a * h - n * l * h - s * o * u + e * l * u + n * o * d - e * a * d) + g * (+t * a * d - t * l * u + s * r * u - n * r * d + n * l * c - s * a * c) + m * (+t * l * h - t * o * d - s * r * h + e * r * d + s * o * c - e * l * c) + p * (-n * o * c - t * a * h + t * o * u + n * r * h - e * r * u + e * a * c)
    }, transpose: function () {
        var i = this.elements, t;
        return t = i[1], i[1] = i[4], i[4] = t, t = i[2], i[2] = i[8], i[8] = t, t = i[6], i[6] = i[9], i[9] = t, t = i[3], i[3] = i[12], i[12] = t, t = i[7], i[7] = i[13], i[13] = t, t = i[11], i[11] = i[14], i[14] = t, this
    }, setPosition: function (i, t, e) {
        var n = this.elements;
        return i.isVector3 ? (n[12] = i.x, n[13] = i.y, n[14] = i.z) : (n[12] = i, n[13] = t, n[14] = e), this
    }, getInverse: function (i, t) {
        var e = this.elements, n = i.elements, s = n[0], r = n[1], o = n[2], a = n[3], l = n[4], c = n[5], h = n[6],
            u = n[7], d = n[8], f = n[9], g = n[10], m = n[11], p = n[12], _ = n[13], x = n[14], y = n[15],
            v = f * x * u - _ * g * u + _ * h * m - c * x * m - f * h * y + c * g * y,
            w = p * g * u - d * x * u - p * h * m + l * x * m + d * h * y - l * g * y,
            E = d * _ * u - p * f * u + p * c * m - l * _ * m - d * c * y + l * f * y,
            S = p * f * h - d * _ * h - p * c * g + l * _ * g + d * c * x - l * f * x,
            b = s * v + r * w + o * E + a * S;
        if (b === 0) {
            var M = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
            if (t === !0) throw new Error(M);
            return console.warn(M), this.identity()
        }
        var I = 1 / b;
        return e[0] = v * I, e[1] = (_ * g * a - f * x * a - _ * o * m + r * x * m + f * o * y - r * g * y) * I, e[2] = (c * x * a - _ * h * a + _ * o * u - r * x * u - c * o * y + r * h * y) * I, e[3] = (f * h * a - c * g * a - f * o * u + r * g * u + c * o * m - r * h * m) * I, e[4] = w * I, e[5] = (d * x * a - p * g * a + p * o * m - s * x * m - d * o * y + s * g * y) * I, e[6] = (p * h * a - l * x * a - p * o * u + s * x * u + l * o * y - s * h * y) * I, e[7] = (l * g * a - d * h * a + d * o * u - s * g * u - l * o * m + s * h * m) * I, e[8] = E * I, e[9] = (p * f * a - d * _ * a - p * r * m + s * _ * m + d * r * y - s * f * y) * I, e[10] = (l * _ * a - p * c * a + p * r * u - s * _ * u - l * r * y + s * c * y) * I, e[11] = (d * c * a - l * f * a - d * r * u + s * f * u + l * r * m - s * c * m) * I, e[12] = S * I, e[13] = (d * _ * o - p * f * o + p * r * g - s * _ * g - d * r * x + s * f * x) * I, e[14] = (p * c * o - l * _ * o - p * r * h + s * _ * h + l * r * x - s * c * x) * I, e[15] = (l * f * o - d * c * o + d * r * h - s * f * h - l * r * g + s * c * g) * I, this
    }, scale: function (i) {
        var t = this.elements, e = i.x, n = i.y, s = i.z;
        return t[0] *= e, t[4] *= n, t[8] *= s, t[1] *= e, t[5] *= n, t[9] *= s, t[2] *= e, t[6] *= n, t[10] *= s, t[3] *= e, t[7] *= n, t[11] *= s, this
    }, getMaxScaleOnAxis: function () {
        var i = this.elements, t = i[0] * i[0] + i[1] * i[1] + i[2] * i[2], e = i[4] * i[4] + i[5] * i[5] + i[6] * i[6],
            n = i[8] * i[8] + i[9] * i[9] + i[10] * i[10];
        return Math.sqrt(Math.max(t, e, n))
    }, makeTranslation: function (i, t, e) {
        return this.set(1, 0, 0, i, 0, 1, 0, t, 0, 0, 1, e, 0, 0, 0, 1), this
    }, makeRotationX: function (i) {
        var t = Math.cos(i), e = Math.sin(i);
        return this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
    }, makeRotationY: function (i) {
        var t = Math.cos(i), e = Math.sin(i);
        return this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
    }, makeRotationZ: function (i) {
        var t = Math.cos(i), e = Math.sin(i);
        return this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }, makeRotationAxis: function (i, t) {
        var e = Math.cos(t), n = Math.sin(t), s = 1 - e, r = i.x, o = i.y, a = i.z, l = s * r, c = s * o;
        return this.set(l * r + e, l * o - n * a, l * a + n * o, 0, l * o + n * a, c * o + e, c * a - n * r, 0, l * a - n * o, c * a + n * r, s * a * a + e, 0, 0, 0, 0, 1), this
    }, makeScale: function (i, t, e) {
        return this.set(i, 0, 0, 0, 0, t, 0, 0, 0, 0, e, 0, 0, 0, 0, 1), this
    }, makeShear: function (i, t, e) {
        return this.set(1, t, e, 0, i, 1, e, 0, i, t, 1, 0, 0, 0, 0, 1), this
    }, compose: function (i, t, e) {
        var n = this.elements, s = t._x, r = t._y, o = t._z, a = t._w, l = s + s, c = r + r, h = o + o, u = s * l,
            d = s * c, f = s * h, g = r * c, m = r * h, p = o * h, _ = a * l, x = a * c, y = a * h, v = e.x, w = e.y,
            E = e.z;
        return n[0] = (1 - (g + p)) * v, n[1] = (d + y) * v, n[2] = (f - x) * v, n[3] = 0, n[4] = (d - y) * w, n[5] = (1 - (u + p)) * w, n[6] = (m + _) * w, n[7] = 0, n[8] = (f + x) * E, n[9] = (m - _) * E, n[10] = (1 - (u + g)) * E, n[11] = 0, n[12] = i.x, n[13] = i.y, n[14] = i.z, n[15] = 1, this
    }, decompose: function () {
        var i = new Yn, t = new nd;
        return function (n, s, r) {
            var o = this.elements, a = i.set(o[0], o[1], o[2]).length(), l = i.set(o[4], o[5], o[6]).length(),
                c = i.set(o[8], o[9], o[10]).length(), h = this.determinant();
            h < 0 && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], t.copy(this);
            var u = 1 / a, d = 1 / l, f = 1 / c;
            return t.elements[0] *= u, t.elements[1] *= u, t.elements[2] *= u, t.elements[4] *= d, t.elements[5] *= d, t.elements[6] *= d, t.elements[8] *= f, t.elements[9] *= f, t.elements[10] *= f, s.setFromRotationMatrix(t), r.x = a, r.y = l, r.z = c, this
        }
    }(), makePerspective: function (i, t, e, n, s, r) {
        r === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        var o = this.elements, a = 2 * s / (t - i), l = 2 * s / (e - n), c = (t + i) / (t - i), h = (e + n) / (e - n),
            u = -(r + s) / (r - s), d = -2 * r * s / (r - s);
        return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
    }, makeOrthographic: function (i, t, e, n, s, r) {
        var o = this.elements, a = 1 / (t - i), l = 1 / (e - n), c = 1 / (r - s), h = (t + i) * a, u = (e + n) * l,
            d = (r + s) * c;
        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
    }, equals: function (i) {
        for (var t = this.elements, e = i.elements, n = 0; n < 16; n++) if (t[n] !== e[n]) return !1;
        return !0
    }, fromArray: function (i, t) {
        t === void 0 && (t = 0);
        for (var e = 0; e < 16; e++) this.elements[e] = i[e + t];
        return this
    }, toArray: function (i, t) {
        i === void 0 && (i = []), t === void 0 && (t = 0);
        var e = this.elements;
        return i[t] = e[0], i[t + 1] = e[1], i[t + 2] = e[2], i[t + 3] = e[3], i[t + 4] = e[4], i[t + 5] = e[5], i[t + 6] = e[6], i[t + 7] = e[7], i[t + 8] = e[8], i[t + 9] = e[9], i[t + 10] = e[10], i[t + 11] = e[11], i[t + 12] = e[12], i[t + 13] = e[13], i[t + 14] = e[14], i[t + 15] = e[15], i
    }
});

function Zo(i, t, e, n) {
    this._x = i || 0, this._y = t || 0, this._z = e || 0, this._order = n || Zo.DefaultOrder
}

Zo.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
Zo.DefaultOrder = "XYZ";
Object.defineProperties(Zo.prototype, {
    x: {
        get: function () {
            return this._x
        }, set: function (i) {
            this._x = i, this._onChangeCallback()
        }
    }, y: {
        get: function () {
            return this._y
        }, set: function (i) {
            this._y = i, this._onChangeCallback()
        }
    }, z: {
        get: function () {
            return this._z
        }, set: function (i) {
            this._z = i, this._onChangeCallback()
        }
    }, order: {
        get: function () {
            return this._order
        }, set: function (i) {
            this._order = i, this._onChangeCallback()
        }
    }
});
Object.assign(Zo.prototype, {
    isEuler: !0, set: function (i, t, e, n) {
        return this._x = i, this._y = t, this._z = e, this._order = n || this._order, this._onChangeCallback(), this
    }, clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }, copy: function (i) {
        return this._x = i._x, this._y = i._y, this._z = i._z, this._order = i._order, this._onChangeCallback(), this
    }, setFromRotationMatrix: function (i, t, e) {
        var n = qc.clamp, s = i.elements, r = s[0], o = s[4], a = s[8], l = s[1], c = s[5], h = s[9], u = s[2],
            d = s[6], f = s[10];
        return t = t || this._order, t === "XYZ" ? (this._y = Math.asin(n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(d, c), this._z = 0)) : t === "YXZ" ? (this._x = Math.asin(-n(h, -1, 1)), Math.abs(h) < .99999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r), this._z = 0)) : t === "ZXY" ? (this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r))) : t === "ZYX" ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c))) : t === "YZX" ? (this._z = Math.asin(n(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, f))) : t === "XZY" ? (this._z = Math.asin(-n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, f), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, e !== !1 && this._onChangeCallback(), this
    }, setFromQuaternion: function () {
        var i = new nd;
        return function (e, n, s) {
            return i.makeRotationFromQuaternion(e), this.setFromRotationMatrix(i, n, s)
        }
    }(), setFromVector3: function (i, t) {
        return this.set(i.x, i.y, i.z, t || this._order)
    }, reorder: function () {
        var i = new ul;
        return function (e) {
            return i.setFromEuler(this), this.setFromQuaternion(i, e)
        }
    }(), equals: function (i) {
        return i._x === this._x && i._y === this._y && i._z === this._z && i._order === this._order
    }, fromArray: function (i) {
        return this._x = i[0], this._y = i[1], this._z = i[2], i[3] !== void 0 && (this._order = i[3]), this._onChangeCallback(), this
    }, toArray: function (i, t) {
        return i === void 0 && (i = []), t === void 0 && (t = 0), i[t] = this._x, i[t + 1] = this._y, i[t + 2] = this._z, i[t + 3] = this._order, i
    }, toVector3: function (i) {
        return i ? i.set(this._x, this._y, this._z) : new Yn(this._x, this._y, this._z)
    }, _onChange: function (i) {
        return this._onChangeCallback = i, this
    }, _onChangeCallback: function () {
    }
});
var a3 = 0, l3 = 1, gS = 2, c3 = 3, h3 = 4, u3 = 5;
const Pr = {
    toScreenPos: function () {
        var i = new Yn;
        return function (t, e, n) {
            return i.copy(t), i.project(e), i.x = Math.round((i.x + 1) * n.width / 2), i.y = Math.round((-i.y + 1) * n.height / 2), i.z = 0, i
        }
    }(), toSpacePos: function () {
        var i = new Yn, t = new Yn, e;
        return function (n, s, r) {
            return i.set(n.x / r.width * 2 - 1, -(n.y / r.height) * 2 + 1, .5), i.unproject(s), t.copy(i.sub(s.position).normalize()), e = -s.position.z / t.z, i.copy(s.position), i.add(t.multiplyScalar(e)), i
        }
    }()
}, ys = {
    initValue: function (i, t) {
        var e = i != null && i != null ? i : t;
        return e
    }, isArray: function (i) {
        return Object.prototype.toString.call(i) === "[object Array]"
    }, destroyArray: function (i) {
        i.length = 0
    }, destroyObject: function (i) {
        for (var t in i) delete i[t]
    }, isUndefined: function () {
        for (var i in arguments) {
            var t = arguments[i];
            if (t !== void 0) return !1
        }
        return !0
    }, setVectorByObj: function (i, t) {
        t.x !== void 0 && (i.position.x = t.x), t.y !== void 0 && (i.position.y = t.y), t.z !== void 0 && (i.position.z = t.z), t.vx !== void 0 && (i.velocity.x = t.vx), t.vy !== void 0 && (i.velocity.y = t.vy), t.vz !== void 0 && (i.velocity.z = t.vz), t.ax !== void 0 && (i.acceleration.x = t.ax), t.ay !== void 0 && (i.acceleration.y = t.ay), t.az !== void 0 && (i.acceleration.z = t.az), t.p !== void 0 && i.position.copy(t.p), t.v !== void 0 && i.velocity.copy(t.v), t.a !== void 0 && i.acceleration.copy(t.a), t.position !== void 0 && i.position.copy(t.position), t.velocity !== void 0 && i.velocity.copy(t.velocity), t.accelerate !== void 0 && i.acceleration.copy(t.accelerate)
    }, setPrototypeByObj: function (i, t, e) {
        for (var n in t) i.hasOwnProperty(n) && (e ? e.indexOf(n) < 0 && (i[n] = this._getValue(t[n])) : i[n] = this._getValue(t[n]));
        return i
    }, _getValue: function (i) {
        return i.constructor.type === "Span" ? i.getValue() : i
    }
};
var Mu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function k0(i) {
    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
}

var Am = {exports: {}},
    Kx = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
if (Kx) {
    var Jx = new Uint8Array(16);
    Am.exports = function () {
        return Kx(Jx), Jx
    }
} else {
    var Qx = new Array(16);
    Am.exports = function () {
        for (var t = 0, e; t < 16; t++) t & 3 || (e = Math.random() * 4294967296), Qx[t] = e >>> ((t & 3) << 3) & 255;
        return Qx
    }
}
var d3 = Am.exports, mS = [];
for (var Tu = 0; Tu < 256; ++Tu) mS[Tu] = (Tu + 256).toString(16).substr(1);

function f3(i, t) {
    var e = t || 0, n = mS;
    return [n[i[e++]], n[i[e++]], n[i[e++]], n[i[e++]], "-", n[i[e++]], n[i[e++]], "-", n[i[e++]], n[i[e++]], "-", n[i[e++]], n[i[e++]], "-", n[i[e++]], n[i[e++]], n[i[e++]], n[i[e++]], n[i[e++]], n[i[e++]]].join("")
}

var p3 = f3, g3 = d3, m3 = p3, t1, jp, Kp = 0, Jp = 0;

function _3(i, t, e) {
    var n = t && e || 0, s = t || [];
    i = i || {};
    var r = i.node || t1, o = i.clockseq !== void 0 ? i.clockseq : jp;
    if (r == null || o == null) {
        var a = g3();
        r == null && (r = t1 = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]), o == null && (o = jp = (a[6] << 8 | a[7]) & 16383)
    }
    var l = i.msecs !== void 0 ? i.msecs : new Date().getTime(), c = i.nsecs !== void 0 ? i.nsecs : Jp + 1,
        h = l - Kp + (c - Jp) / 1e4;
    if (h < 0 && i.clockseq === void 0 && (o = o + 1 & 16383), (h < 0 || l > Kp) && i.nsecs === void 0 && (c = 0), c >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    Kp = l, Jp = c, jp = o, l += 122192928e5;
    var u = ((l & 268435455) * 1e4 + c) % 4294967296;
    s[n++] = u >>> 24 & 255, s[n++] = u >>> 16 & 255, s[n++] = u >>> 8 & 255, s[n++] = u & 255;
    var d = l / 4294967296 * 1e4 & 268435455;
    s[n++] = d >>> 8 & 255, s[n++] = d & 255, s[n++] = d >>> 24 & 15 | 16, s[n++] = d >>> 16 & 255, s[n++] = o >>> 8 | 128, s[n++] = o & 255;
    for (var f = 0; f < 6; ++f) s[n + f] = r[f];
    return t || m3(s)
}

var y3 = _3;
const U0 = k0(y3);

function e1(i, t) {
    var e = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        t && (n = n.filter(function (s) {
            return Object.getOwnPropertyDescriptor(i, s).enumerable
        })), e.push.apply(e, n)
    }
    return e
}

function n1(i) {
    for (var t = 1; t < arguments.length; t++) {
        var e = arguments[t] != null ? arguments[t] : {};
        t % 2 ? e1(Object(e), !0).forEach(function (n) {
            Ah(i, n, e[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : e1(Object(e)).forEach(function (n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        })
    }
    return i
}

const cd = (i, t) => n1(n1({}, i), t), dn = {
    randomAToB: function (i, t, e) {
        return e ? (Math.random() * (t - i) >> 0) + i : i + Math.random() * (t - i)
    }, randomFloating: function (i, t, e) {
        return this.randomAToB(i - t, i + t, e)
    }, randomZone: function (i) {
    }, degreeTransform: function (i) {
        return i * us / 180
    }, toColor16: function (t) {
        return "#" + t.toString(16)
    }, randomColor: function () {
        return "#" + ("00000" + (Math.random() * 16777216 << 0).toString(16)).slice(-6)
    }, lerp: function (i, t, e) {
        return t + (i - t) * e
    }, getNormal: function (i, t) {
        return i.x == 0 && i.y == 0 ? i.z == 0 ? t.set(1, 0, 1) : t.set(1, 1, -i.y / i.z) : i.x == 0 ? t.set(1, 0, 1) : t.set(-i.y / i.x, 1, 1), t.normalize()
    }, axisRotate: function (i, t, e, n) {
        var s = Math.cos(n), r = Math.sin(n), o = e.dot(t) * (1 - s);
        i.copy(e), i.cross(t).scalar(r), i.addValue(t.x * s, t.y * s, t.z * s), i.addValue(e.x * o, e.y * o, e.z * o)
    }
}, x3 = "ArraySpan", v3 = "ColorSpan", w3 = "Polar3D", b3 = "Span";

class Xs {
    constructor(t, e, n) {
        this._isArray = !1, this.type = b3, ys.isArray(t) ? (this._isArray = !0, this.a = t) : (this.a = ys.initValue(t, 1), this.b = ys.initValue(e, this.a), this._center = ys.initValue(n, !1))
    }

    getValue(t) {
        return this._isArray ? this.a[this.a.length * Math.random() >> 0] : this._center ? dn.randomFloating(this.a, this.b, t) : dn.randomAToB(this.a, this.b, t)
    }
}

const Kn = (i, t, e) => i instanceof Xs ? i : t === void 0 ? new Xs(i) : e === void 0 ? new Xs(i, t) : new Xs(i, t, e);
var E3 = Math.floor, S3 = Math.random;

function M3(i, t) {
    return i + E3(S3() * (t - i + 1))
}

var T3 = M3, I3 = T3;

function A3(i) {
    var t = i.length;
    return t ? i[I3(0, t - 1)] : void 0
}

var _S = A3;

function C3(i, t) {
    for (var e = -1, n = i == null ? 0 : i.length, s = Array(n); ++e < n;) s[e] = t(i[e], e, i);
    return s
}

var P3 = C3, R3 = P3;

function L3(i, t) {
    return R3(t, function (e) {
        return i[e]
    })
}

var N3 = L3;

function O3(i, t) {
    for (var e = -1, n = Array(i); ++e < i;) n[e] = t(e);
    return n
}

var D3 = O3, F3 = typeof Mu == "object" && Mu && Mu.Object === Object && Mu, yS = F3, z3 = yS,
    B3 = typeof self == "object" && self && self.Object === Object && self, k3 = z3 || B3 || Function("return this")(),
    xS = k3, U3 = xS, G3 = U3.Symbol, vS = G3, s1 = vS, wS = Object.prototype, V3 = wS.hasOwnProperty, H3 = wS.toString,
    ec = s1 ? s1.toStringTag : void 0;

function $3(i) {
    var t = V3.call(i, ec), e = i[ec];
    try {
        i[ec] = void 0;
        var n = !0
    } catch {
    }
    var s = H3.call(i);
    return n && (t ? i[ec] = e : delete i[ec]), s
}

var W3 = $3, q3 = Object.prototype, Y3 = q3.toString;

function X3(i) {
    return Y3.call(i)
}

var Z3 = X3, i1 = vS, j3 = W3, K3 = Z3, J3 = "[object Null]", Q3 = "[object Undefined]",
    r1 = i1 ? i1.toStringTag : void 0;

function tO(i) {
    return i == null ? i === void 0 ? Q3 : J3 : r1 && r1 in Object(i) ? j3(i) : K3(i)
}

var uf = tO;

function eO(i) {
    return i != null && typeof i == "object"
}

var df = eO, nO = uf, sO = df, iO = "[object Arguments]";

function rO(i) {
    return sO(i) && nO(i) == iO
}

var oO = rO, o1 = oO, aO = df, bS = Object.prototype, lO = bS.hasOwnProperty, cO = bS.propertyIsEnumerable,
    hO = o1(function () {
        return arguments
    }()) ? o1 : function (i) {
        return aO(i) && lO.call(i, "callee") && !cO.call(i, "callee")
    }, uO = hO, dO = Array.isArray, ES = dO, hd = {exports: {}};

function fO() {
    return !1
}

var pO = fO;
hd.exports;
(function (i, t) {
    var e = xS, n = pO, s = t && !t.nodeType && t, r = s && !0 && i && !i.nodeType && i, o = r && r.exports === s,
        a = o ? e.Buffer : void 0, l = a ? a.isBuffer : void 0, c = l || n;
    i.exports = c
})(hd, hd.exports);
var gO = hd.exports, mO = 9007199254740991, _O = /^(?:0|[1-9]\d*)$/;

function yO(i, t) {
    var e = typeof i;
    return t = t ?? mO, !!t && (e == "number" || e != "symbol" && _O.test(i)) && i > -1 && i % 1 == 0 && i < t
}

var xO = yO, vO = 9007199254740991;

function wO(i) {
    return typeof i == "number" && i > -1 && i % 1 == 0 && i <= vO
}

var SS = wO, bO = uf, EO = SS, SO = df, MO = "[object Arguments]", TO = "[object Array]", IO = "[object Boolean]",
    AO = "[object Date]", CO = "[object Error]", PO = "[object Function]", RO = "[object Map]", LO = "[object Number]",
    NO = "[object Object]", OO = "[object RegExp]", DO = "[object Set]", FO = "[object String]",
    zO = "[object WeakMap]", BO = "[object ArrayBuffer]", kO = "[object DataView]", UO = "[object Float32Array]",
    GO = "[object Float64Array]", VO = "[object Int8Array]", HO = "[object Int16Array]", $O = "[object Int32Array]",
    WO = "[object Uint8Array]", qO = "[object Uint8ClampedArray]", YO = "[object Uint16Array]",
    XO = "[object Uint32Array]", qe = {};
qe[UO] = qe[GO] = qe[VO] = qe[HO] = qe[$O] = qe[WO] = qe[qO] = qe[YO] = qe[XO] = !0;
qe[MO] = qe[TO] = qe[BO] = qe[IO] = qe[kO] = qe[AO] = qe[CO] = qe[PO] = qe[RO] = qe[LO] = qe[NO] = qe[OO] = qe[DO] = qe[FO] = qe[zO] = !1;

function ZO(i) {
    return SO(i) && EO(i.length) && !!qe[bO(i)]
}

var jO = ZO;

function KO(i) {
    return function (t) {
        return i(t)
    }
}

var JO = KO, ud = {exports: {}};
ud.exports;
(function (i, t) {
    var e = yS, n = t && !t.nodeType && t, s = n && !0 && i && !i.nodeType && i, r = s && s.exports === n,
        o = r && e.process, a = function () {
            try {
                var l = s && s.require && s.require("util").types;
                return l || o && o.binding && o.binding("util")
            } catch {
            }
        }();
    i.exports = a
})(ud, ud.exports);
var QO = ud.exports, tD = jO, eD = JO, a1 = QO, l1 = a1 && a1.isTypedArray, nD = l1 ? eD(l1) : tD, sD = nD, iD = D3,
    rD = uO, oD = ES, aD = gO, lD = xO, cD = sD, hD = Object.prototype, uD = hD.hasOwnProperty;

function dD(i, t) {
    var e = oD(i), n = !e && rD(i), s = !e && !n && aD(i), r = !e && !n && !s && cD(i), o = e || n || s || r,
        a = o ? iD(i.length, String) : [], l = a.length;
    for (var c in i) (t || uD.call(i, c)) && !(o && (c == "length" || s && (c == "offset" || c == "parent") || r && (c == "buffer" || c == "byteLength" || c == "byteOffset") || lD(c, l))) && a.push(c);
    return a
}

var fD = dD, pD = Object.prototype;

function gD(i) {
    var t = i && i.constructor, e = typeof t == "function" && t.prototype || pD;
    return i === e
}

var mD = gD;

function _D(i, t) {
    return function (e) {
        return i(t(e))
    }
}

var yD = _D, xD = yD, vD = xD(Object.keys, Object), wD = vD, bD = mD, ED = wD, SD = Object.prototype,
    MD = SD.hasOwnProperty;

function TD(i) {
    if (!bD(i)) return ED(i);
    var t = [];
    for (var e in Object(i)) MD.call(i, e) && e != "constructor" && t.push(e);
    return t
}

var ID = TD;

function AD(i) {
    var t = typeof i;
    return i != null && (t == "object" || t == "function")
}

var CD = AD, PD = uf, RD = CD, LD = "[object AsyncFunction]", ND = "[object Function]",
    OD = "[object GeneratorFunction]", DD = "[object Proxy]";

function FD(i) {
    if (!RD(i)) return !1;
    var t = PD(i);
    return t == ND || t == OD || t == LD || t == DD
}

var zD = FD, BD = zD, kD = SS;

function UD(i) {
    return i != null && kD(i.length) && !BD(i)
}

var GD = UD, VD = fD, HD = ID, $D = GD;

function WD(i) {
    return $D(i) ? VD(i) : HD(i)
}

var qD = WD, YD = N3, XD = qD;

function ZD(i) {
    return i == null ? [] : YD(i, XD(i))
}

var jD = ZD, KD = _S, JD = jD;

function QD(i) {
    return KD(JD(i))
}

var tF = QD, eF = _S, nF = tF, sF = ES;

function iF(i) {
    var t = sF(i) ? eF : nF;
    return t(i)
}

var rF = iF;
const MS = k0(rF);

class c1 extends Xs {
    constructor(t) {
        super(), this.type = x3, this.items = Array.isArray(t) ? t : [t]
    }

    getValue() {
        return MS(this.items)
    }
}

const oF = i => i ? i instanceof c1 ? i : new c1(i) : null;

class h1 extends Xs {
    constructor(t) {
        super(), this.type = v3, this.shouldRandomize = t === "random", this.colors = Array.isArray(t) ? t : [t]
    }

    getValue() {
        return this.shouldRandomize ? dn.randomColor() : MS(this.colors)
    }
}

const u1 = i => (i || (console.warn(`Invalid colors argument ${i} passed to createColorSpan. Defaulting to 'random'.`), i = "random"), i instanceof h1 ? i : new h1(i)),
    dd = "EULER", d1 = (i, t, e) => {
        i.sleep || (i.old.position.copy(i.position), i.old.velocity.copy(i.velocity), i.acceleration.scalar(1 / i.mass), i.velocity.add(i.acceleration.scalar(t)), i.position.add(i.old.velocity.scalar(t)), e && i.velocity.scalar(Math.pow(e, t / Tm)), i.acceleration.clear())
    }, f1 = (i, t, e, n = dd) => {
        switch (n) {
            case dd:
                d1(i, t, e);
                break;
            default:
                d1(i, t, e)
        }
    };
let ye = class extends Yn {
    clear() {
        return this.x = 0, this.y = 0, this.z = 0, this
    }

    scalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this
    }

    addValue(t, e, n) {
        return this.x += t, this.y += e, this.z += n, this
    }

    toString() {
        return "x:" + this.x + "y:" + this.y + "z:" + this.z
    }

    eulerFromDir(t) {
        return new Zo().setFromVector3(t)
    }
};

class G0 {
    constructor(t, e, n) {
        this.type = w3, this.radius = t || 1, this.phi = n || 0, this.theta = e || 0
    }

    set(t, e, n) {
        return this.radius = t || 1, this.phi = n || 0, this.theta = e || 0, this
    }

    setRadius(t) {
        return this.radius = t, this
    }

    setPhi(t) {
        return this.phi = t, this
    }

    setTheta(t) {
        return this.theta = t, this
    }

    copy(t) {
        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
    }

    toVector3D() {
        return new ye(this.getX(), this.getY(), this.getZ())
    }

    getX() {
        return this.radius * Math.sin(this.theta) * Math.cos(this.phi)
    }

    getY() {
        return -this.radius * Math.sin(this.theta) * Math.sin(this.phi)
    }

    getZ() {
        return this.radius * Math.cos(this.theta)
    }

    normalize() {
        return this.radius = 1, this
    }

    equals(t) {
        return t.radius === this.radius && t.phi === this.phi && t.theta === this.theta
    }

    clear() {
        return this.radius = 0, this.phi = 0, this.theta = 0, this
    }

    clone() {
        return new G0(this.radius, this.phi, this.theta)
    }
}

const aF = "Particle", lF = "Pool", cF = "System";

class p1 {
    constructor(t) {
        this.id = `particle-${U0()}`, this.type = aF, this.life = Fx, this.age = zx, this.energy = Bx, this.dead = kx, this.sleep = Ux, this.body = Gx, this.parent = Vx, this.mass = Hx, this.radius = $x, this.alpha = Wx, this.scale = qx, this.useColor = Yx, this.useAlpha = Xx, this.easing = Zx, this.position = new ye, this.velocity = new ye, this.acceleration = new ye, this.old = {}, this.old.position = this.position.clone(), this.old.velocity = this.velocity.clone(), this.old.acceleration = this.acceleration.clone(), this.behaviours = [], this.transform = {}, this.color = {
            r: 0,
            g: 0,
            b: 0
        }, this.rotation = new ye, this.distanceToCamera = 0, ys.setPrototypeByObj(this, t)
    }

    getDirection() {
        return Math.atan2(this.velocity.x, -this.velocity.y) * (180 / us)
    }

    reset() {
        return this.life = Fx, this.age = zx, this.energy = Bx, this.dead = kx, this.sleep = Ux, this.body = Gx, this.parent = Vx, this.mass = Hx, this.radius = $x, this.alpha = Wx, this.scale = qx, this.useColor = Yx, this.useAlpha = Xx, this.easing = Zx, this.position.set(0, 0, 0), this.velocity.set(0, 0, 0), this.acceleration.set(0, 0, 0), this.old.position.set(0, 0, 0), this.old.velocity.set(0, 0, 0), this.old.acceleration.set(0, 0, 0), this.color.r = 0, this.color.g = 0, this.color.b = 0, this.rotation.clear(), ys.destroyObject(this.transform), this.removeAllBehaviours(), this
    }

    update(t, e) {
        if (!this.sleep) {
            this.age += t;
            let n = this.behaviours.length;
            for (; n--;) this.behaviours[n].applyBehaviour(this, t, e)
        }
        if (this.age >= this.life) this.destroy(); else {
            const n = this.easing(this.age / this.life);
            this.energy = Math.max(1 - n, 0)
        }
    }

    addBehaviour(t) {
        this.behaviours.push(t), t.initialize(this)
    }

    addBehaviours(t) {
        let e = t.length;
        for (; e--;) this.addBehaviour(t[e])
    }

    removeBehaviour(t) {
        const e = this.behaviours.indexOf(t);
        e > -1 && this.behaviours.splice(e, 1)
    }

    removeAllBehaviours() {
        ys.destroyArray(this.behaviours)
    }

    destroy() {
        this.removeAllBehaviours(), this.energy = 0, this.dead = !0, this.parent = null
    }
}

class Cm {
    constructor() {
        this.type = lF, this.cID = 0, this.list = {}
    }

    create(t, ...e) {
        if (!this.canCreateNewObject(t)) throw new Error("The pool is unable to create or clone the object supplied");
        if (this.cID++, this.canInstantiateObject(t)) return new t(...e);
        if (this.canCloneObject(t)) return t.clone()
    }

    canInstantiateObject(t) {
        return typeof t == "function"
    }

    canCloneObject(t) {
        return t.clone && typeof t.clone == "function"
    }

    canCreateNewObject(t) {
        return !!(this.canInstantiateObject(t) || this.canCloneObject(t))
    }

    getCount() {
        var t = 0;
        for (var e in this.list) t += this.list[e].length;
        return t++
    }

    get(t, ...e) {
        var n, s = t.__puid || pS.id(t);
        return this.list[s] && this.list[s].length > 0 ? n = this.list[s].pop() : n = this.create(t, ...e), n.__puid = t.__puid || s, n
    }

    expire(t) {
        return this._getList(t.__puid).push(t)
    }

    destroy() {
        for (var t in this.list) this.list[t].length = 0, delete this.list[t]
    }

    _getList(t) {
        return t = t || "default", this.list[t] || (this.list[t] = []), this.list[t]
    }
}

class TS {
    constructor() {
        this.listeners = null
    }

    set listeners(t) {
        this._listeners = t
    }

    get listeners() {
        return this._listeners
    }

    addEventListener(t, e) {
        return this.listeners ? this.removeEventListener(t, e) : this.listeners = {}, this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e), e
    }

    removeEventListener(t, e) {
        if (this.listeners && this.listeners[t]) {
            for (var n = this.listeners[t], s = 0, r = n.length; s < r; s++) if (n[s] == e) {
                r == 1 ? delete this.listeners[t] : n.splice(s, 1);
                break
            }
        }
    }

    removeAllEventListeners(t) {
        t ? this.listeners && delete this.listeners[t] : this.listeners = null
    }

    dispatchEvent(t, e) {
        var n = !1, s = this.listeners;
        if (t && s) {
            var r = s[t];
            if (!r) return n;
            r = r.slice();
            for (var o, a = r.length; a--;) o = r[a], n = n || o(e)
        }
        return !!n
    }

    hasEventListener(t) {
        var e = this.listeners;
        return !!(e && e[t])
    }
}

const Pm = "SYSTEM_UPDATE", Rm = "PARTICLE_CREATED", Lm = "PARTICLE_UPDATE", Nm = "PARTICLE_DEAD", hF = "EMITTER_ADDED",
    uF = "EMITTER_REMOVED", g1 = "EMITTER_DEAD", dF = "SYSTEM_UPDATE_AFTER";
let fr = class {
    constructor(t = jN, e = !0) {
        this.type = t, this.isEnabled = e
    }

    init(t, e) {
        this.isEnabled && (e ? (this.initialize(e), e.hasBeenInitialized = !0) : (this.initialize(t), t.hasBeenInitialized = !0))
    }

    reset() {
    }

    initialize(t) {
    }

    static requiresWebGlApi() {
        return !1
    }

    static fromJSON(t) {
    }
};

class ff extends fr {
    constructor(t, e, n, s = !0) {
        super(KE, s), this.body = oF(t), this.w = e, this.h = n || e
    }

    initialize(t) {
        var e = this.body.getValue();
        this.w ? t.body = {width: this.w, height: this.h, body: e} : t.body = e
    }

    static fromJSON(t) {
        const {body: e, width: n, height: s, isEnabled: r = !0} = t;
        return new ff(e, n, s, r)
    }
}

function m1(i, t) {
    var e = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        t && (n = n.filter(function (s) {
            return Object.getOwnPropertyDescriptor(i, s).enumerable
        })), e.push.apply(e, n)
    }
    return e
}

function _1(i) {
    for (var t = 1; t < arguments.length; t++) {
        var e = arguments[t] != null ? arguments[t] : {};
        t % 2 ? m1(Object(e), !0).forEach(function (n) {
            Ah(i, n, e[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : m1(Object(e)).forEach(function (n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        })
    }
    return i
}

const fd = {
        AdditiveBlending: gS,
        CustomBlending: u3,
        MultiplyBlending: h3,
        NoBlending: a3,
        NormalBlending: l3,
        SubtractiveBlending: c3
    }, Yc = {color: 16711680, blending: gS, fog: !0}, Va = _1(_1({}, Yc), {}, {blending: "AdditiveBlending"}), fF = 1,
    pF = 1;

function y1(i, t) {
    var e = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        t && (n = n.filter(function (s) {
            return Object.getOwnPropertyDescriptor(i, s).enumerable
        })), e.push.apply(e, n)
    }
    return e
}

function Iu(i) {
    for (var t = 1; t < arguments.length; t++) {
        var e = arguments[t] != null ? arguments[t] : {};
        t % 2 ? y1(Object(e), !0).forEach(function (n) {
            Ah(i, n, e[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : y1(Object(e)).forEach(function (n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        })
    }
    return i
}

class V0 extends fr {
    constructor(t, e, n = Yc, s = !0) {
        super(F0, s);
        const {Sprite: r, SpriteMaterial: o, TextureLoader: a} = t;
        this.materialProperties = cd(Yc, n), new a().load(e, l => {
            this.texture = l, this.material = new o(Iu(Iu({}, {map: l}), this.materialProperties)), this.sprite = new r(this.material)
        }, void 0, l => {
            throw new Error(l)
        })
    }

    initialize(t) {
        t.body = this.sprite
    }

    static fromJSON(t, e) {
        const {texture: n, materialProperties: s = Va, isEnabled: r = !0} = t, o = a => {
            const {blending: l} = a;
            return Iu(Iu({}, a), {}, {blending: l ? fd[l] : fd[Va.blending]})
        };
        return new V0(e, n, cd(Va, o(s)), r)
    }
}

const gF = new Zo, IS = {
    particleEuler: null, initialize: function (i, t, e) {
        let n = e.length;
        for (; n--;) e[n].init(i, t);
        i.bindEmitter && this.bindEmitter(i, t)
    }, bindEmitter: function (i, t) {
        const {rotation: {x: e, y: n, z: s}} = i;
        t.position.add(i.position), t.velocity.add(i.velocity), t.acceleration.add(i.acceleration), t.velocity.applyEuler(gF.set(e, n, s))
    }
};

class pf extends fr {
    constructor(t, e, n, s = !0) {
        super(JE, s), this.lifePan = Kn(t, e, n)
    }

    initialize(t) {
        this.lifePan.a == 1 / 0 || this.lifePan.a == "infi" ? t.life = 1 / 0 : t.life = this.lifePan.getValue()
    }

    static fromJSON(t) {
        const {min: e, max: n, center: s = !1, isEnabled: r = !0} = t;
        return new pf(e, n, s, r)
    }
}

class gf extends fr {
    constructor(t, e, n = !1, s = !0) {
        super(QE, s), this.massPan = Kn(t, e, n)
    }

    initialize(t) {
        t.mass = this.massPan.getValue()
    }

    static fromJSON(t) {
        const {min: e, max: n, center: s = !1, isEnabled: r = !0} = t;
        return new gf(e, n, s, r)
    }
}

function mF(i, t) {
    if (i == null) return {};
    var e = {}, n = Object.keys(i), s, r;
    for (r = 0; r < n.length; r++) s = n[r], !(t.indexOf(s) >= 0) && (e[s] = i[s]);
    return e
}

function _F(i, t) {
    if (i == null) return {};
    var e = mF(i, t), n, s;
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(i);
        for (s = 0; s < r.length; s++) n = r[s], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(i, n) && (e[n] = i[n])
    }
    return e
}

let Rl = class {
    constructor(t = JN) {
        this.type = t, this.vector = new ye(0, 0, 0), this.random = 0, this.crossType = "dead", this.log = !0, this.supportsCrossing = !0
    }

    getPosition() {
        return null
    }

    crossing(t) {
        if (!this.supportsCrossing) return console.warn(`${this.constructor.name} does not support the crossing method`);
        switch (this.crossType) {
            case"bound":
                this._bound(t);
                break;
            case"cross":
                this._cross(t);
                break;
            case"dead":
                this._dead(t);
                break
        }
    }

    isBoxZone() {
        return !1
    }

    isLineZone() {
        return !1
    }

    isMeshZone() {
        return !1
    }

    isPointZone() {
        return !1
    }

    isScreenZone() {
        return !1
    }

    isSphereZone() {
        return !1
    }

    _dead(t) {
    }

    _bound(t) {
    }

    _cross(t) {
    }
};

class yF extends Rl {
    constructor(t, e, n, d, r, o) {
        super(oS);
        var a, l, c, h, u, d;
        ys.isUndefined(e, n, d, r, o) ? (a = l = c = 0, h = u = d = t || 100) : ys.isUndefined(d, r, o) ? (a = l = c = 0, h = t, u = e, d = n) : (a = t, l = e, c = n, h = d, u = r, d = o), this.x = a, this.y = l, this.z = c, this.width = h, this.height = u, this.depth = d, this.friction = .85, this.max = 6
    }

    isBoxZone() {
        return !0
    }

    getPosition() {
        return this.vector.x = this.x + dn.randomAToB(-.5, .5) * this.width, this.vector.y = this.y + dn.randomAToB(-.5, .5) * this.height, this.vector.z = this.z + dn.randomAToB(-.5, .5) * this.depth, this.vector
    }

    _dead(t) {
        (t.position.x + t.radius < this.x - this.width / 2 || t.position.x - t.radius > this.x + this.width / 2) && (t.dead = !0), (t.position.y + t.radius < this.y - this.height / 2 || t.position.y - t.radius > this.y + this.height / 2) && (t.dead = !0), (t.position.z + t.radius < this.z - this.depth / 2 || t.position.z - t.radius > this.z + this.depth / 2) && (t.dead = !0)
    }

    _bound(t) {
        t.position.x - t.radius < this.x - this.width / 2 ? (t.position.x = this.x - this.width / 2 + t.radius, t.velocity.x *= -this.friction, this._static(t, "x")) : t.position.x + t.radius > this.x + this.width / 2 && (t.position.x = this.x + this.width / 2 - t.radius, t.velocity.x *= -this.friction, this._static(t, "x")), t.position.y - t.radius < this.y - this.height / 2 ? (t.position.y = this.y - this.height / 2 + t.radius, t.velocity.y *= -this.friction, this._static(t, "y")) : t.position.y + t.radius > this.y + this.height / 2 && (t.position.y = this.y + this.height / 2 - t.radius, t.velocity.y *= -this.friction, this._static(t, "y")), t.position.z - t.radius < this.z - this.depth / 2 ? (t.position.z = this.z - this.depth / 2 + t.radius, t.velocity.z *= -this.friction, this._static(t, "z")) : t.position.z + t.radius > this.z + this.depth / 2 && (t.position.z = this.z + this.depth / 2 - t.radius, t.velocity.z *= -this.friction, this._static(t, "z"))
    }

    _static(t, e) {
        t.velocity[e] * t.acceleration[e] > 0 || Math.abs(t.velocity[e]) < Math.abs(t.acceleration[e]) * .0167 * this.max && (t.velocity[e] = 0, t.acceleration[e] = 0)
    }

    _cross(t) {
        t.position.x + t.radius < this.x - this.width / 2 && t.velocity.x <= 0 ? t.position.x = this.x + this.width / 2 + t.radius : t.position.x - t.radius > this.x + this.width / 2 && t.velocity.x >= 0 && (t.position.x = this.x - this.width / 2 - t.radius), t.position.y + t.radius < this.y - this.height / 2 && t.velocity.y <= 0 ? t.position.y = this.y + this.height / 2 + t.radius : t.position.y - t.radius > this.y + this.height / 2 && t.velocity.y >= 0 && (t.position.y = this.y - this.height / 2 - t.radius), t.position.z + t.radius < this.z - this.depth / 2 && t.velocity.z <= 0 ? t.position.z = this.z + this.depth / 2 + t.radius : t.position.z - t.radius > this.z + this.depth / 2 && t.velocity.z >= 0 && (t.position.z = this.z - this.depth / 2 - t.radius)
    }
}

class xF extends Rl {
    constructor(t, e, n, s, r, o) {
        super(aS), t instanceof ye ? (this.x1 = t.x, this.y1 = t.y, this.z1 = t.z, this.x2 = s.x, this.y2 = s.y, this.z2 = s.z) : (this.x1 = t, this.y1 = e, this.z1 = n, this.x2 = s, this.y2 = r, this.z2 = o), this.supportsCrossing = !1
    }

    isLineZone() {
        return !0
    }

    getPosition() {
        return this.random = Math.random(), this.vector.x = this.x1 + this.random * (this.x2 - this.x1), this.vector.y = this.y1 + this.random * (this.y2 - this.y1), this.vector.z = this.z1 + this.random * (this.z2 - this.z1), this.vector
    }
}

class vF extends Rl {
    constructor(t, e = 1, n) {
        if (super(lS), this.geometry = null, this.scale = e, this.supportsCrossing = !1, t.type && t.type === "Geometry" && (this.geometry = t), t.geometry && (this.geometry = t.geometry), !this.geometry) throw new Error("MeshZone unable to set geometry from the supplied bounds");
        this.geometry.isBufferGeometry && (this.geometry = new n().fromBufferGeometry(this.geometry))
    }

    isMeshZone() {
        return !0
    }

    getPosition() {
        const t = this.geometry.vertices, e = t[t.length * Math.random() >> 0];
        return this.vector.x = e.x * this.scale, this.vector.y = e.y * this.scale, this.vector.z = e.z * this.scale, this.vector
    }
}

class wF extends Rl {
    constructor(t, e, n) {
        super(cS);
        var s;
        ys.isUndefined(t, e, n) ? s = 0 : s = t, this.x = s, this.y = s, this.z = s, this.supportsCrossing = !1
    }

    isPointZone() {
        return !0
    }

    getPosition() {
        return this.vector.x = this.x, this.vector.y = this.y, this.vector.z = this.z, this.vector
    }
}

class H0 extends Rl {
    constructor(t, e, n, s) {
        super(QN), this.camera = t, this.renderer = e, this.dis = n || 20, s = s || "1234";
        for (var r = 1; r < 5; r++) this["d" + r] = s.indexOf(r + "") >= 0
    }

    isScreenZone() {
        return !0
    }

    _dead(t) {
        var e = Pr.toScreenPos(t.position, this.camera, this.renderer.domElement), n = this.renderer.domElement;
        (e.y + t.radius < -this.dis && this.d1 || e.y - t.radius > n.height + this.dis && this.d3) && (t.dead = !0), (e.x + t.radius < -this.dis && this.d4 || e.x - t.radius > n.width + this.dis && this.d2) && (t.dead = !0)
    }

    _bound(t) {
        var e = Pr.toScreenPos(t.position, this.camera, this.renderer.domElement), n = this.renderer.domElement;
        (e.y + t.radius < -this.dis || e.y - t.radius > n.height + this.dis) && (t.velocity.y *= -1), (e.x + t.radius < -this.dis || e.x - t.radius > n.width + this.dis) && (t.velocity.y *= -1)
    }
}

H0.prototype.getPosition = function () {
    var i = new ye, t;
    return function () {
        return t = this.renderer.domElement, i.x = Math.random() * t.width, i.y = Math.random() * t.height, this.vector.copy(Pr.toSpacePos(i, this.camera, t)), this.vector
    }
}();
H0.prototype._cross = function () {
    var i = new ye;
    return function (t) {
        var e = Pr.toScreenPos(t.position, this.camera, this.renderer.domElement), n = this.renderer.domElement;
        e.y + t.radius < -this.dis ? (i.x = e.x, i.y = n.height + this.dis + t.radius, t.position.y = Pr.toSpacePos(i, this.camera, n).y) : e.y - t.radius > n.height + this.dis && (i.x = e.x, i.y = -this.dis - t.radius, t.position.y = Pr.toSpacePos(i, this.camera, n).y), e.x + t.radius < -this.dis ? (i.y = e.y, i.x = n.width + this.dis + t.radius, t.position.x = Pr.toSpacePos(i, this.camera, n).x) : e.x - t.radius > n.width + this.dis && (i.y = e.y, i.x = -this.dis - t.radius, t.position.x = Pr.toSpacePos(i, this.camera, n).x)
    }
}();

class mf extends Rl {
    constructor(t, e, n, s) {
        super(hS);
        let r, o;
        ys.isUndefined(e, n, s) ? (r = 0, o = t || 100) : (r = t, o = s), this.x = r, this.y = r, this.z = r, this.radius = o, this.the = this.phi = 0
    }

    isSphereZone() {
        return !0
    }

    _dead(t) {
        var e = t.position.distanceTo(this);
        e - t.radius > this.radius && (t.dead = !0)
    }

    _cross() {
        console.warn(`${this.constructor.name} does not support the _cross method`)
    }
}

mf.prototype.getPosition = function () {
    var i, t, e;
    return function () {
        return this.random = Math.random(), e = this.random * this.radius, i = us * Math.random(), t = us * 2 * Math.random(), this.vector.x = this.x + e * Math.sin(i) * Math.cos(t), this.vector.y = this.y + e * Math.sin(t) * Math.sin(i), this.vector.z = this.z + e * Math.cos(i), this.vector
    }
}();
mf.prototype._bound = function () {
    var i = new ye, t = new ye, e;
    return function (n) {
        var s = n.position.distanceTo(this);
        s + n.radius >= this.radius && (i.copy(n.position).sub(this).normalize(), t.copy(n.velocity), e = 2 * t.dot(i), n.velocity.sub(i.scalar(e)))
    }
}();
const AS = Object.freeze(Object.defineProperty({
    __proto__: null,
    BoxZone: yF,
    LineZone: xF,
    MeshZone: vF,
    PointZone: wF,
    ScreenZone: H0,
    SphereZone: mf
}, Symbol.toStringTag, {value: "Module"})), bF = ["zoneType"];
let $0 = class CS extends fr {
    constructor() {
        super(tS), this.reset.apply(this, arguments)
    }

    reset() {
        this.zones ? this.zones.length = 0 : this.zones = [], this.zones = this.zones.concat(Array.prototype.slice.call(arguments))
    }

    addZone() {
        this.zones = this.zones.concat(Array.prototype.slice.call(arguments))
    }

    static fromJSON(t) {
        const {zoneType: e} = t, n = _F(t, bF);
        if (!i3.includes(e)) throw new Error(`The zone type ${e} is invalid or not yet supported`);
        return new CS(new AS[e](...Object.values(n)))
    }
};
$0.prototype.initialize = function () {
    let i;
    return function (t) {
        i = this.zones[Math.random() * this.zones.length >> 0], i.getPosition(), t.position.x = i.vector.x, t.position.y = i.vector.y, t.position.z = i.vector.z
    }
}();

class W0 extends fr {
    constructor(t, e, n = !1, s = !0) {
        super(eS, s), this.radius = Kn(t, e, n)
    }

    reset(t, e, n = !1) {
        this.radius = Kn(t, e, n)
    }

    initialize(t) {
        t.radius = this.radius.getValue(), t.transform.oldRadius = t.radius
    }

    static fromJSON(t) {
        const {width: e, height: n, center: s = !1, isEnabled: r = !0} = t;
        return new W0(e, n, s, r)
    }
}

class jo extends fr {
    constructor(t = fF, e = pF) {
        super(KN), this.numPan = Kn(t), this.timePan = Kn(e), this.startTime = 0, this.nextTime = 0, this.init()
    }

    init() {
        this.startTime = 0, this.nextTime = this.timePan.getValue()
    }

    getValue(t) {
        return this.startTime += t, this.startTime >= this.nextTime ? (this.init(), this.numPan.b == 1 ? this.numPan.getValue("Float") > .5 ? 1 : 0 : this.numPan.getValue("Int")) : 0
    }

    static fromJSON(t) {
        const {particlesMin: e, particlesMax: n, perSecondMin: s, perSecondMax: r} = t;
        return new jo(new Xs(e, n), new Xs(s, r))
    }
}

function x1(i, t) {
    var e = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        t && (n = n.filter(function (s) {
            return Object.getOwnPropertyDescriptor(i, s).enumerable
        })), e.push.apply(e, n)
    }
    return e
}

function Au(i) {
    for (var t = 1; t < arguments.length; t++) {
        var e = arguments[t] != null ? arguments[t] : {};
        t % 2 ? x1(Object(e), !0).forEach(function (n) {
            Ah(i, n, e[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : x1(Object(e)).forEach(function (n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        })
    }
    return i
}

class _f extends fr {
    constructor(t, e, n = Yc, s = !0) {
        super(z0, s);
        const {Sprite: r, SpriteMaterial: o} = t;
        this.materialProperties = cd(Yc, n), this.texture = e, this.material = new o(Au(Au({}, {map: e}), this.materialProperties)), this.sprite = new r(this.material)
    }

    initialize(t) {
        t.body = this.sprite
    }

    static fromJSON(t, e) {
        const {loadedTexture: n, materialProperties: s = Va, isEnabled: r = !0} = t, o = a => {
            const {blending: l} = a;
            return Au(Au({}, a), {}, {blending: l ? fd[l] : fd[Va.blending]})
        };
        return new _f(e, n, cd(Va, o(s)), r)
    }
}

class yf extends fr {
    constructor(t, e = !0) {
        super(t, e), this.dirVec = new ye(0, 0, 0)
    }

    normalize(t) {
        return t * Mm
    }
}

yf.prototype.initialize = function () {
    var i, t = new ye(0, 0, 1), e = new ye(0, 0, 0);
    return function (s) {
        return i = this.tha * Math.random(), this._useV && this.dirVec.copy(this.dir).scalar(this.radiusPan.getValue()), dn.getNormal(this.dirVec, t), e.copy(this.dirVec).applyAxisAngle(t, i), e.applyAxisAngle(this.dirVec.normalize(), Math.random() * us * 2), s.velocity.copy(e), this
    }
}();

class q0 extends yf {
    constructor(t, e, n = !0) {
        super(sS, n), this.tha = e * Ga, this.dirVec = t.toVector3D(), this._useV = !1
    }

    static fromJSON(t) {
        const {polarRadius: e, polarTheta: n, polarPhi: s, velocityTheta: r, isEnabled: o = !0} = t;
        return new q0(new G0(e, n, s), r, o)
    }
}

class xf extends yf {
    constructor(t, e, n, s = !0) {
        super(iS, s), this.radiusPan = Kn(t), this.dir = e.clone().normalize(), this.tha = n * Ga, this._useV = !0
    }

    static fromJSON(t) {
        const {radius: e, x: n, y: s, z: r, theta: o, isEnabled: a = !0} = t;
        return new xf(e, new ye(n, s, r), o, a)
    }
}

class Y0 extends yf {
    constructor(t, e, n = !0) {
        super(nS, n), this.radiusPan = Kn(1), this.dir = t.clone(), this.tha = e * Ga, this._useV = !0
    }

    static fromJSON(t) {
        const {x: e, y: n, z: s, theta: r, isEnabled: o = !0} = t;
        return new Y0(new ye(e, n, s), r, o)
    }
}

const pd = Object.freeze(Object.defineProperty({
    __proto__: null,
    Body: ff,
    BodySprite: V0,
    InitializerUtil: IS,
    Life: pf,
    Mass: gf,
    PolarVelocity: q0,
    Position: $0,
    RadialVelocity: xf,
    Radius: W0,
    Rate: jo,
    Texture: _f,
    VectorVelocity: Y0
}, Symbol.toStringTag, {value: "Module"})), EF = .006, SF = !0, MF = new jo(1, .1), TF = !1, IF = void 0;
var AF = uf, CF = df, PF = "[object Number]";

function RF(i) {
    return typeof i == "number" || CF(i) && AF(i) == PF
}

var LF = RF;
const _c = k0(LF), NF = "Emitter";

class Om extends p1 {
    constructor(t) {
        super(t), this.type = NF, this.particles = [], this.initializers = [], this.behaviours = [], this.emitterBehaviours = [], this.currentEmitTime = 0, this.totalEmitTimes = -1, this.damping = EF, this.bindEmitter = SF, this.bindEmitterEvent = TF, this.rate = MF, this.isEmitting = !1, this.id = `emitter-${U0()}`, this.cID = 0, this.name = "Emitter", this.index = IF, this.eventDispatcher = new TS
    }

    dispatch(t, e = this) {
        this.eventDispatcher.dispatchEvent(t, e)
    }

    setRate(t) {
        return this.rate = t, this
    }

    setPosition(t = {}) {
        const {position: e} = this, {x: n = e.x, y: s = e.y, z: r = e.z} = t;
        return this.position.set(n, s, r), this
    }

    setRotation(t = {}) {
        const {rotation: e} = this, {x: n = e.x, y: s = e.y, z: r = e.z} = t;
        return this.rotation.set(n, s, r), this
    }

    emit(t = 1 / 0, e = 1 / 0) {
        return this.currentEmitTime = 0, this.totalEmitTimes = _c(t) ? t : 1 / 0, t === 1 ? this.life = t : this.life = _c(e) ? e : 1 / 0, this.rate.init(), this.isEmitting = !0, this
    }

    experimental_emit() {
        const {isEmitting: t, totalEmitTimes: e, life: n} = this;
        return t || (this.currentEmitTime = 0, e || this.setTotalEmitTimes(1 / 0), n || this.setLife(1 / 0), this.rate.init(), this.isEmitting = !0), this
    }

    setTotalEmitTimes(t = 1 / 0) {
        return this.totalEmitTimes = _c(t) ? t : 1 / 0, this
    }

    setLife(t = 1 / 0) {
        return this.totalEmitTimes === 1 ? this.life = this.totalEmitTimes : this.life = _c(t) ? t : 1 / 0, this
    }

    stopEmit() {
        this.totalEmitTimes = -1, this.currentEmitTime = 0, this.isEmitting = !1
    }

    removeAllParticles() {
        let t = this.particles.length;
        for (; t--;) this.particles[t].dead = !0
    }

    addInitializer(t) {
        return this.initializers.push(t), this
    }

    addInitializers(t) {
        let e = t.length;
        for (; e--;) this.addInitializer(t[e]);
        return this
    }

    setInitializers(t) {
        return this.initializers = t, this
    }

    removeInitializer(t) {
        const e = this.initializers.indexOf(t);
        return e > -1 && this.initializers.splice(e, 1), this
    }

    removeAllInitializers() {
        return ys.destroyArray(this.initializers), this
    }

    addBehaviour(t) {
        return this.behaviours.push(t), this
    }

    addBehaviours(t) {
        let e = t.length;
        for (; e--;) this.addBehaviour(t[e]);
        return this
    }

    setBehaviours(t) {
        return this.behaviours = t, this
    }

    removeBehaviour(t) {
        const e = this.behaviours.indexOf(t);
        return e > -1 && this.behaviours.splice(e, 1), this
    }

    removeAllBehaviours() {
        return ys.destroyArray(this.behaviours), this
    }

    addEmitterBehaviour(t) {
        return this.emitterBehaviours.push(t), t.initialize(this), this
    }

    addEmitterBehaviours(t) {
        let e = t.length;
        for (; e--;) this.addEmitterBehaviour(t[e]);
        return this
    }

    setEmitterBehaviours(t) {
        const e = t.length;
        this.emitterBehaviours = t;
        for (let n = 0; n < e; n++) this.emitterBehaviours[n].initialize(this);
        return this
    }

    removeEmitterBehaviour(t) {
        const e = this.emitterBehaviours.indexOf(t);
        return e > -1 && this.emitterBehaviours.splice(e, 1), this
    }

    removeAllEmitterBehaviours() {
        return ys.destroyArray(this.emitterBehaviours), this
    }

    addOnEmitterDeadEventListener(t) {
        return this.eventDispatcher.addEventListener(`${this.id}_${g1}`, () => t()), this
    }

    createParticle() {
        const t = this.parent.pool.get(p1), e = this.particles.length;
        return this.setupParticle(t, e), this.parent && this.parent.dispatch(Rm, t), this.bindEmitterEvent && this.dispatch(Rm, t), t
    }

    setupParticle(t, e) {
        const {initializers: n, behaviours: s} = this;
        IS.initialize(this, t, n), t.addBehaviours(s), t.parent = this, t.index = e, this.particles.push(t)
    }

    update(t) {
        if (!this.isEmitting) return;
        this.age += t, (this.dead || this.age >= this.life) && this.destroy(), this.generate(t), this.integrate(t);
        let e = this.particles.length;
        for (; e--;) {
            const n = this.particles[e];
            n.dead && (this.parent && this.parent.dispatch(Nm, n), this.bindEmitterEvent && this.dispatch(Nm, n), this.parent.pool.expire(n.reset()), this.particles.splice(e, 1))
        }
        this.updateEmitterBehaviours(t)
    }

    updateEmitterBehaviours(t) {
        if (this.sleep) return;
        const e = this.emitterBehaviours.length;
        for (let n = 0; n < e; n++) this.emitterBehaviours[n].applyBehaviour(this, t, n)
    }

    integrate(t) {
        const e = this.parent ? this.parent.integrationType : dd, n = 1 - this.damping;
        f1(this, t, n, e);
        let s = this.particles.length;
        for (; s--;) {
            const r = this.particles[s];
            r.update(t, s), f1(r, t, n, e), this.parent && this.parent.dispatch(Lm, r), this.bindEmitterEvent && this.dispatch(Lm, r)
        }
    }

    generate(t) {
        if (this.totalEmitTimes === 1) {
            let e = this.rate.getValue(99999);
            for (e > 0 && (this.cID = e); e--;) this.createParticle();
            this.totalEmitTimes = 0;
            return
        }
        if (this.currentEmitTime += t, this.currentEmitTime < this.totalEmitTimes) {
            let e = this.rate.getValue(t);
            for (e > 0 && (this.cID = e); e--;) this.createParticle()
        }
    }

    destroy() {
        this.dead = !0, this.energy = 0, this.totalEmitTimes = -1, this.particles.length == 0 && (this.isEmitting = !1, this.removeAllInitializers(), this.removeAllBehaviours(), this.dispatch(`${this.id}_${g1}`), this.parent && this.parent.removeEmitter(this))
    }
}

const Dm = 1 / 0, v1 = 1e3, w1 = 100, sd = dS, b1 = .03, OF = .002, DF = 4e-6, FF = "dead";
let yi = class {
    constructor(t = 1 / 0, e = sd, n = XN, s = !0) {
        this.type = n, this.isEnabled = s, this.id = `behaviour-${U0()}`, this.life = t, this.easing = e, this.age = 0, this.energy = 1, this.dead = !1
    }

    reset(t = Dm, e = sd) {
        this.life = t, this.easing = e || sd
    }

    set life(t) {
        this._life = _c(t) ? t : Dm
    }

    get life() {
        return this._life
    }

    normalizeForce(t) {
        return t.scalar(Mm)
    }

    normalizeValue(t) {
        return t * Mm
    }

    initialize(t) {
    }

    applyBehaviour(t, e, n) {
        this.isEnabled && this.mutate(t, e, n)
    }

    mutate(t, e, n) {
    }

    energize(t, e) {
        if (this.dead) return;
        if (this.age += e, this.age >= this.life) {
            this.energy = 0, this.dead = !0;
            return
        }
        const n = this.easing(t.age / t.life);
        this.energy = Math.max(1 - n, 0)
    }

    destroy() {
    }

    fromJSON(t) {
    }
};

class X0 extends yi {
    constructor(t = 1, e = null, n, s, r = !0) {
        super(n, s, UE, r), this.alphaA = t, this.alphaB = e, this.reset(t, e)
    }

    get same() {
        return this._same
    }

    set same(t) {
        this._same = t
    }

    reset(t = 1, e = null, n, s) {
        this.same = e == null, this.alphaA = Kn(t), this.alphaB = Kn(e), n && super.reset(n, s)
    }

    initialize(t) {
        t.useAlpha = !0, t.transform.alphaA = this.alphaA.getValue(), t.transform.alphaB = this.same ? t.transform.alphaA : this.alphaB.getValue()
    }

    mutate(t, e, n) {
        this.energize(t, e, n), t.alpha = dn.lerp(t.transform.alphaA, t.transform.alphaB, this.energy), t.alpha < OF && (t.alpha = 0)
    }

    static fromJSON(t) {
        const {alphaA: e, alphaB: n, life: s, easing: r, isEnabled: o = !0} = t;
        return new X0(e, n, s, _i(r), o)
    }
}

class vf extends yi {
    constructor(t = new ye, e = w1, n = v1, s = Dm, r = sd, o = !0) {
        super(s, r, GE, o), this.targetPosition = t, this.radius = n, this.force = this.normalizeValue(e), this.radiusSq = this.radius * this.radius, this.attractionForce = new ye, this.lengthSq = 0
    }

    reset(t = new ye, e = w1, n = v1, s, r) {
        this.targetPosition = t, this.radius = n, this.force = this.normalizeValue(e), this.radiusSq = this.radius * this.radius, this.attractionForce = new ye, this.lengthSq = 0, s && super.reset(s, r)
    }

    mutate(t, e, n) {
        this.energize(t, e, n), this.attractionForce.copy(this.targetPosition), this.attractionForce.sub(t.position), this.lengthSq = this.attractionForce.lengthSq(), this.lengthSq > DF && this.lengthSq < this.radiusSq && (this.attractionForce.normalize(), this.attractionForce.scalar(1 - this.lengthSq / this.radiusSq), this.attractionForce.scalar(this.force), t.acceleration.add(this.attractionForce))
    }

    static fromJSON(t) {
        const {x: e, y: n, z: s, force: r, radius: o, life: a, easing: l, isEnabled: c = !0} = t;
        return new vf(new ye(e, n, s), r, o, a, _i(l), c)
    }
}

class zF extends yi {
    constructor(t, e, n, s, r, o = !0) {
        super(s, r, ZN, o), this.reset(t, e, n)
    }

    reset(t, e, n, s, r) {
        this.emitter = t, this.useMass = e, this.onCollide = n, this.particles = [], this.delta = new ye, s && super.reset(s, r)
    }

    mutate(t, e, n) {
        const s = this.emitter ? this.emitter.particles.slice(n) : this.particles.slice(n);
        let r, o, a, l, c, h, u = s.length;
        for (; u--;) r = s[u], r != t && (this.delta.copy(r.position).sub(t.position), o = this.delta.lengthSq(), l = t.radius + r.radius, o <= l * l && (a = l - Math.sqrt(o), a += .5, c = this._getAverageMass(t, r), h = this._getAverageMass(r, t), t.position.add(this.delta.clone().normalize().scalar(a * -c)), r.position.add(this.delta.normalize().scalar(a * h)), this.onCollide && this.onCollide(t, r)))
    }

    _getAverageMass(t, e) {
        return this.useMass ? e.mass / (t.mass + e.mass) : .5
    }

    fromJSON(t) {
    }
}

class wf extends yi {
    constructor(t, e, n, s, r = !0) {
        super(n, s, VE, r), this.reset(t, e)
    }

    get same() {
        return this._same
    }

    set same(t) {
        this._same = t
    }

    reset(t, e, n, s) {
        this.same = e == null, this.colorA = u1(t), this.colorB = u1(e), n && super.reset(n, s)
    }

    initialize(t) {
        t.transform.colorA = jx.getRGB(this.colorA.getValue()), t.useColor = !0, t.transform.colorB = this.same ? t.transform.colorA : jx.getRGB(this.colorB.getValue())
    }

    mutate(t, e, n) {
        this.energize(t, e, n), this._same ? (t.color.r = t.transform.colorA.r, t.color.g = t.transform.colorA.g, t.color.b = t.transform.colorA.b) : (t.color.r = dn.lerp(t.transform.colorA.r, t.transform.colorB.r, this.energy), t.color.g = dn.lerp(t.transform.colorA.g, t.transform.colorB.g, this.energy), t.color.b = dn.lerp(t.transform.colorA.b, t.transform.colorB.b, this.energy))
    }

    static fromJSON(t) {
        const {colorA: e, colorB: n, life: s, easing: r, isEnabled: o = !0} = t;
        return new wf(e, n, s, _i(r), o)
    }
}

class Z0 extends yi {
    constructor(t, e, n, s, r) {
        super(n, s, HE, r), this.reset(t, e)
    }

    reset(t, e = FF, n, s) {
        this.zone = t, this.zone.crossType = e, n && super.reset(n, s)
    }

    mutate(t, e, n) {
        this.energize(t, e, n), this.zone.crossing.call(this.zone, t)
    }

    static fromJSON(t) {
        const {zoneType: e, zoneParams: n, crossType: s, life: r, easing: o, isEnabled: a = !0} = t,
            l = new AS[e](...Object.values(n));
        return new Z0(l, s, r, _i(o), a)
    }
}

class bf extends yi {
    constructor(t, e, n, s, r, o = !0) {
        super(s, r, $E, o), this.reset(t, e, n)
    }

    reset(t, e, n) {
        this.force = this.normalizeForce(new ye(t, e, n)), this.force.id = Math.random()
    }

    mutate(t, e, n) {
        this.energize(t, e, n), t.acceleration.add(this.force)
    }

    static fromJSON(t) {
        const {fx: e, fy: n, fz: s, life: r, easing: o, isEnabled: a = !0} = t;
        return new bf(e, n, s, r, _i(o), a)
    }
}

class Ef extends bf {
    constructor(t, e, n, s = !0) {
        super(0, -t, 0, e, n, s), this.type = WE
    }

    static fromJSON(t) {
        const {gravity: e, life: n, easing: s, isEnabled: r = !0} = t;
        return new Ef(e, n, _i(s), r)
    }
}

class Sf extends yi {
    constructor(t, e, n, s = b1, r, o, a = !0) {
        super(r, o, qE, a), this.reset(t, e, n, s), this.time = 0
    }

    reset(t, e, n, s = b1, r, o) {
        this.randomForce = this.normalizeForce(new ye(t, e, n)), this.delayPan = Kn(s), this.time = 0, r && super.reset(r, o)
    }

    mutate(t, e, n) {
        if (this.energize(t, e, n), this.time += e, this.time >= this.delayPan.getValue()) {
            const s = dn.randomAToB(-this.randomForce.x, this.randomForce.x),
                r = dn.randomAToB(-this.randomForce.y, this.randomForce.y),
                o = dn.randomAToB(-this.randomForce.z, this.randomForce.z);
            t.acceleration.addValue(s, r, o), this.time = 0
        }
    }

    static fromJSON(t) {
        const {x: e, y: n, z: s, delay: r, life: o, easing: a, isEnabled: l = !0} = t;
        return new Sf(e, n, s, r, o, _i(a), l)
    }
}

class j0 extends vf {
    constructor(t, e, n, s, r, o = !0) {
        super(t, e, n, s, r, o), this.force *= -1, this.type = YE
    }

    reset(t, e, n, s, r) {
        super.reset(t, e, n, s, r), this.force *= -1
    }

    static fromJSON(t) {
        const {x: e, y: n, z: s, force: r, radius: o, life: a, easing: l, isEnabled: c = !0} = t;
        return new j0(new ye(e, n, s), r, o, a, _i(l), c)
    }
}

class K0 extends yi {
    constructor(t, e, n, s, r, o = !0) {
        super(s, r, XE, o), this.reset(t, e, n)
    }

    get rotationType() {
        return this._rotationType
    }

    set rotationType(t) {
        this._rotationType = t
    }

    reset(t, e, n, s, r) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0, t === void 0 || t == "same" ? this.rotationType = "same" : e == null ? this.rotationType = "set" : n === void 0 ? this.rotationType = "to" : (this.rotationType = "add", this.x = Kn(this.x * Ga), this.y = Kn(this.y * Ga), this.z = Kn(this.z * Ga)), s && super.reset(s, r)
    }

    initialize(t) {
        switch (this.rotationType) {
            case"same":
                break;
            case"set":
                this._setRotation(t.rotation, this.x);
                break;
            case"to":
                t.transform.fR = t.transform.fR || new ye, t.transform.tR = t.transform.tR || new ye, this._setRotation(t.transform.fR, this.x), this._setRotation(t.transform.tR, this.y);
                break;
            case"add":
                t.transform.addR = new ye(this.x.getValue(), this.y.getValue(), this.z.getValue());
                break
        }
    }

    _setRotation(t, e) {
        if (t = t || new ye, e == "random") {
            var n = dn.randomAToB(-us, us), s = dn.randomAToB(-us, us), r = dn.randomAToB(-us, us);
            t.set(n, s, r)
        } else e instanceof ye && t.copy(e)
    }

    mutate(t, e, n) {
        switch (this.energize(t, e, n), this.rotationType) {
            case"same":
                t.rotation || (t.rotation = new ye), t.rotation.eulerFromDir(t.velocity);
                break;
            case"set":
                break;
            case"to":
                t.rotation.x = dn.lerp(t.transform.fR.x, t.transform.tR.x, this.energy), t.rotation.y = dn.lerp(t.transform.fR.y, t.transform.tR.y, this.energy), t.rotation.z = dn.lerp(t.transform.fR.z, t.transform.tR.z, this.energy);
                break;
            case"add":
                t.rotation.add(t.transform.addR);
                break
        }
    }

    static fromJSON(t) {
        const {x: e, y: n, z: s, life: r, easing: o, isEnabled: a = !0} = t;
        return new K0(e, n, s, r, _i(o), a)
    }
}

class Mf extends yi {
    constructor(t, e, n, s, r = !0) {
        super(n, s, ZE, r), this.reset(t, e)
    }

    get same() {
        return this._same
    }

    set same(t) {
        this._same = t
    }

    reset(t, e, n, s) {
        this.same = e == null, this.scaleA = Kn(t || 1), this.scaleB = Kn(e), n && super.reset(n, s)
    }

    initialize(t) {
        t.transform.scaleA = this.scaleA.getValue(), t.transform.oldRadius = t.radius, t.transform.scaleB = this.same ? t.transform.scaleA : this.scaleB.getValue()
    }

    mutate(t, e, n) {
        this.energize(t, e, n), t.scale = dn.lerp(t.transform.scaleA, t.transform.scaleB, this.energy), t.scale < 5e-4 && (t.scale = 0), t.radius = t.transform.oldRadius * t.scale
    }

    static fromJSON(t) {
        const {scaleA: e, scaleB: n, life: s, easing: r, isEnabled: o = !0} = t;
        return new Mf(e, n, s, _i(r), o)
    }
}

class J0 extends yi {
    constructor(t, e, n, s, r, o, a, l = !0) {
        super(o, a, jE, l), this.reset(t, e, n, s, r)
    }

    reset(t, e, n, s, r) {
        this.pos ? this.pos.set(t, e, n) : this.pos = new ye(t, e, n), this.spring = s || .1, this.friction = r || .98
    }

    mutate(t, e, n) {
        this.energize(t, e, n), t.velocity.x += (this.pos.x - t.position.x) * this.spring, t.velocity.y += (this.pos.y - t.position.y) * this.spring, t.velocity.z += (this.pos.z - t.position.z) * this.spring
    }

    static fromJSON(t) {
        const {x: e, y: n, z: s, spring: r, friction: o, life: a, easing: l, isEnabled: c = !0} = t;
        return new J0(e, n, s, r, o, a, _i(l), c)
    }
}

const PS = Object.freeze(Object.defineProperty({
    __proto__: null,
    Alpha: X0,
    Attraction: vf,
    Behaviour: yi,
    Collision: zF,
    Color: wf,
    CrossZone: Z0,
    Force: bf,
    Gravity: Ef,
    RandomDrift: Sf,
    Repulsion: j0,
    Rotate: K0,
    Scale: Mf,
    Spring: J0
}, Symbol.toStringTag, {value: "Module"})), BF = i => jo.fromJSON(i), kF = (i, t) => {
    const e = [];
    return i.forEach(n => {
        const {type: s, properties: r} = n;
        if (!Im.includes(s)) throw new Error(`The initializer type ${s} is invalid or not yet supported`);
        rS.includes(s) ? e.push(pd[s].fromJSON(r, t)) : e.push(pd[s].fromJSON(r))
    }), e
}, E1 = i => {
    const t = [];
    return i.forEach(e => {
        const {type: n, properties: s} = e;
        if (!fS.includes(n)) throw new Error(`The behaviour type ${n} is invalid or not yet supported`);
        t.push(PS[n].fromJSON(s))
    }), t
}, UF = (i, t, e, n) => {
    const {preParticles: s = B0, integrationType: r = uS, emitters: o = []} = i, a = new e(t, s, r);
    return o.forEach(l => {
        const c = new n, {
            rate: h,
            rotation: u,
            initializers: d,
            behaviours: f,
            emitterBehaviours: g = [],
            position: m,
            totalEmitTimes: p = 1 / 0,
            life: _ = 1 / 0
        } = l;
        c.setRate(BF(h)).setRotation(u).setInitializers(kF(d, t)).setBehaviours(E1(f)).setEmitterBehaviours(E1(g)).setPosition(m).emit(p, _), a.addEmitter(c)
    }), a
};

function S1(i, t) {
    var e = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        t && (n = n.filter(function (s) {
            return Object.getOwnPropertyDescriptor(i, s).enumerable
        })), e.push.apply(e, n)
    }
    return e
}

function gd(i) {
    for (var t = 1; t < arguments.length; t++) {
        var e = arguments[t] != null ? arguments[t] : {};
        t % 2 ? S1(Object(e), !0).forEach(function (n) {
            Ah(i, n, e[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : S1(Object(e)).forEach(function (n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        })
    }
    return i
}

const GF = {shouldAutoEmit: !0}, VF = i => jo.fromJSON(i), HF = (i, t) => new Promise((e, n) => {
    if (!i.length) return e([]);
    const s = i.length, r = [], o = i.filter(({properties: l}) => !l.texture),
        a = i.filter(({properties: l}) => l.texture);
    o.forEach(l => {
        const {type: c, properties: h} = l;
        if (!Im.includes(c)) return n(`The initializer type ${c} is invalid or not yet supported`);
        if (rS.includes(c) ? r.push(pd[c].fromJSON(h, t)) : r.push(pd[c].fromJSON(h)), r.length === s) return e(r)
    }), a.forEach(l => {
        const {type: c, properties: h, properties: {texture: u}} = l, d = new t.TextureLoader;
        if (!Im.includes(c)) return n(`The initializer type ${c} is invalid or not yet supported`);
        d.load(u, f => {
            if (r.push(_f.fromJSON(gd(gd({}, h), {}, {loadedTexture: f}), t)), r.length === s) return e(r)
        }, void 0, n)
    })
}), M1 = i => new Promise((t, e) => {
    if (!i.length) return t([]);
    const n = i.length, s = [];
    i.forEach(r => {
        const {type: o, properties: a} = r;
        if (!fS.includes(o)) return e(`The behaviour type ${o} is invalid or not yet supported`);
        if (s.push(PS[o].fromJSON(a)), s.length === n) return t(s)
    })
}), $F = (i, t, e, n) => new Promise((s, r) => {
    if (!i.length) return s([]);
    const o = [], a = i.length;
    if (!a) return s(o);
    i.forEach(l => {
        const c = new t, {
            rate: h,
            rotation: u,
            initializers: d,
            behaviours: f,
            emitterBehaviours: g = [],
            position: m,
            totalEmitTimes: p = 1 / 0,
            life: _ = 1 / 0
        } = l;
        c.setRate(VF(h)).setRotation(u).setPosition(m), HF(d, e).then(x => (c.setInitializers(x), M1(f))).then(x => (c.setBehaviours(x), M1(g))).then(x => (c.setEmitterBehaviours(x), Promise.resolve(c))).then(x => {
            if (o.push(n ? x.emit(p, _) : x.setTotalEmitTimes(p).setLife(_)), o.length === a) return s(o)
        }).catch(r)
    })
}), WF = (i, t, e, n, s = {}) => new Promise((r, o) => {
    const {preParticles: a = B0, integrationType: l = uS, emitters: c = []} = i,
        h = new e(a, l), {shouldAutoEmit: u} = gd(gd({}, GF), s);
    $F(c, n, t, u).then(d => {
        const f = d.length;
        if (!f) return r(h);
        d.forEach(g => {
            h.addEmitter(g), h.emitters.length === f && r(h)
        })
    }).catch(o)
});
let qF = class Fm {
    constructor(t = B0, e = dd) {
        this.type = cF, this.canUpdate = !0, this.preParticles = t, this.integrationType = e, this.emitters = [], this.renderers = [], this.pool = new Cm, this.eventDispatcher = new TS
    }

    static fromJSON(t, e) {
        return UF(t, e, Fm, Om)
    }

    static fromJSONAsync(t, e, n) {
        return WF(t, e, Fm, Om, n)
    }

    dispatch(t, e = this) {
        this.eventDispatcher.dispatchEvent(t, e)
    }

    addRenderer(t) {
        return this.renderers.push(t), t.init(this), this
    }

    removeRenderer(t) {
        return this.renderers.splice(this.renderers.indexOf(t), 1), t.remove(this), this
    }

    addEmitter(t) {
        const e = this.emitters.length;
        return t.parent = this, t.index = e, this.emitters.push(t), this.dispatch(hF, t), this
    }

    removeEmitter(t) {
        return t.parent !== this ? this : (t.parent = null, t.index = void 0, this.emitters.splice(this.emitters.indexOf(t), 1), this.dispatch(uF, t), this)
    }

    emit({onStart: t, onUpdate: e, onEnd: n}) {
        t && t(), e && this.eventDispatcher.addEventListener(Pm, e);
        const s = this.emitters.map(r => {
            const {life: o} = r;
            return o === 1 / 0 ? (n && n(), r.experimental_emit(), Promise.resolve()) : new Promise(a => {
                r.addOnEmitterDeadEventListener(() => {
                    n && n(), a()
                }), r.experimental_emit()
            })
        });
        try {
            return Promise.all(s)
        } catch (r) {
            console.warn(r)
        }
    }

    update(t = Tm) {
        const e = t || Tm;
        if (this.canUpdate) {
            if (e > 0) {
                let n = this.emitters.length;
                for (; n--;) {
                    const s = this.emitters[n];
                    s.update(e), s.isEmitting && this.dispatch(Pm)
                }
            }
            this.dispatch(dF)
        }
        return Promise.resolve()
    }

    getCount() {
        const t = this.emitters.length;
        let e = 0, n;
        for (n = 0; n < t; n++) e += this.emitters[n].particles.length;
        return e
    }

    destroy() {
        const t = this.emitters.length;
        this.canUpdate = !1;
        for (let e = 0; e < t; e++) this.emitters[e] && this.emitters[e].destroy(), delete this.emitters[e];
        for (let e = 0; e < t; e++) this.renderers[e] && this.renderers[e].destroy && (this.renderers[e].destroy(), delete this.renderers[e]);
        this.emitters.length = 0, this.pool.destroy(), this.canUpdate = !0
    }
};

class YF {
    constructor(t = t3) {
        this.type = t
    }

    init(t) {
        var e = this;
        this.system = t, this.system.eventDispatcher.addEventListener(Pm, function (n) {
            e.onSystemUpdate.call(e, n)
        }), this.system.eventDispatcher.addEventListener(Rm, function (n) {
            e.onParticleCreated.call(e, n)
        }), this.system.eventDispatcher.addEventListener(Lm, function (n) {
            e.onParticleUpdate.call(e, n)
        }), this.system.eventDispatcher.addEventListener(Nm, function (n) {
            e.onParticleDead.call(e, n)
        }), this.logRendererType()
    }

    remove() {
        this.system = null
    }

    onParticleCreated(t) {
    }

    onParticleUpdate(t) {
    }

    onParticleDead(t) {
    }

    onSystemUpdate(t) {
    }

    logRendererType() {
        s3 && console.log(`${this.type}`)
    }
}

class XF extends YF {
    constructor(t, e) {
        super(n3), this.container = t, this._targetPool = new Cm, this._materialPool = new Cm, this._body = new e.Mesh(new e.BoxGeometry(50, 50, 50), new e.MeshLambertMaterial({color: "#ff0000"}))
    }

    isThreeSprite(t) {
        return t.target.isSprite
    }

    onSystemUpdate() {
    }

    onParticleCreated(t) {
        t.target || (t.body || (t.body = this._body), t.target = this._targetPool.get(t.body), (t.useAlpha || t.useColor) && (t.target.material.__puid = pS.id(t.body.material), t.target.material = this._materialPool.get(t.target.material))), t.target && (t.target.position.copy(t.position), this.container.add(t.target))
    }

    onParticleUpdate(t) {
        const {target: e, useAlpha: n, useColor: s, rotation: r} = t;
        e && (e.position.copy(t.position), this.isThreeSprite(t) || e.rotation.set(r.x, r.y, r.z), this.scale(t), n && (e.material.opacity = t.alpha, e.material.transparent = !0), s && e.material.color.copy(t.color))
    }

    scale(t) {
        t.target.scale.set(t.scale, t.scale, t.scale)
    }

    onParticleDead(t) {
        t.target && ((t.useAlpha || t.useColor) && this._materialPool.expire(t.target.material), this._targetPool.expire(t.target), this.container.remove(t.target), t.target = null)
    }
}

class ZF extends XF {
    constructor(t, e) {
        super(t, e), this.type = e3, this._body = new e.Sprite(new e.SpriteMaterial({color: 16777215}))
    }

    scale(t) {
        t.target.scale.set(t.scale * t.radius, t.scale * t.radius, 1)
    }
}

const jF = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU9TtSIVBTsUEclQnSyIijhKFYtgobQVWnUweemP0KQhSXFxFFwLDv4sVh1cnHV1cBUEwR8QJ0cnRRcp8b6k0CLGB5f3cd47h/vuA4R6malmxzigapaRisfEbG5FDLyiC/1UYQxLzNQT6YUMPNfXPXx8v4vyLO97f65eJW8ywCcSzzLdsIjXiac3LZ3zPnGIlSSF+Jx4zKAGiR+5Lrv8xrnosMAzQ0YmNUccIhaLbSy3MSsZKvEUcURRNcoXsi4rnLc4q+Uqa/bJXxjMa8tprlMNIY5FJJCECBlVbKAMC1HaNVJMpOg85uEfdPxJcsnk2gAjxzwqUCE5fvA/+D1bszA54SYFY0Dni21/jACBXaBRs+3vY9tunAD+Z+BKa/krdWDmk/RaS4scAX3bwMV1S5P3gMsdIPykS4bkSH4qoVAA3s/om3LAwC3Qs+rOrXmO0wcgQ7NaugEODoHRImWveby7u31u/95pzu8HVxJynNOZVncAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfkBhAHBw9E6czYAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAxJJREFUWMPNl91O20AQhb9xHJMENQ1pQVAB6kWlvv/79KKiCCooCYTGCXbi7UXPosFNSgxFJdIKZO/OOXN2/mw84RdCSPSvxUcAZlY1tWUNQNtAC8h0rg1EIhVQikgBLM2s/CcEBJwBPWAbeAOkepZpW6G1AG6BKZADxWNE7BGZM6ALDIEdraHIbNUI3Al0BIy1RsBMRKqNCYQQUgEPgD2tA+Ad8FYqdGoE5vL+BrgCzoELrWtgZmaLOla6Brwnb4+1DrR2gb7e9xQTAEt5nwMT4FJKRbVOgHEIIa+TSFfI3nXgn4CPwCGwLwW2nfc+CKMKU+0bSKnsIUSY+uuoK5DpYAT/DBwBH4D38r6jDEhrabhQJsxFsqe9W85+5fY8JKBo7+q+j+X5kbzfE7Gu8zypka+0YnCmbs+dFMqBnyGE+zRNa94PXcAdyvM9Xcm2PG/J81UEgp63nDqVC9CRArKQEr8JyPsYeDHg9iX7QOCZDCdrMsg/r19NLuCRAnQSQijMrIyHWgLZUQDt6m9fsrcduK1JX3PKtHSmKxveZlSz5Vlnitih8rxfi3YPvkl1TVzZ7shWX7aHPjsSpZ7pOnp62XPRnjTpGSuItGXL204BCyEkUYFY77fcZh/JTUmYO5e6XtJxWdLGGU5cc2kqedMryVwqW8J//iVKlcq11EK1Peb1c3/R/rKGUQH3k03pWuo89nLlcPUEMsGdW7gqOHdVsQRI1Bh8wbh1m8tnKBFqtd/bXgDBzKrE9fNYKm/UUqc62PRK6pLHDjmR7ZGwCt8Llto01jBx6VpvVqvt60pxcLV/Kc9nAo42r4Qx1Z7fBMysDCHkenmuajXwRcPVi8eaUQSfqv7/AL7L7rkw8lXdsJA8F65cdhxQ2LAdF/L8WrbOgFM3oo2i/A8ISIWZNvVcZcRF86YDyUSenwHfgK8ayy40G5brJqJCzE/cM5+am45kV5L9VOBfZPPae/8HATOrpMK4RupWh5sMpfHOT+JQKu+rv07FZrZQQMZ0irP+6CXG8tf5YfIqPs1ezcfpS3+e/wL3l30p5NQvFwAAAABJRU5ErkJggg==";

class KF extends Event {
    constructor(e, n) {
        super(e);
        z(this, "viewer");
        this.viewer = n.viewer
    }
}

class JF extends KF {
    constructor(e, n) {
        super(e, {viewer: n.viewer});
        z(this, "floorId");
        z(this, "position");
        z(this, "mouseEvent");
        this.floorId = n.floorId, this.position = n.position, this.mouseEvent = n.mouseEvent
    }
}

class Ds extends EventTarget {
    constructor(e) {
        super();
        z(this, "element");
        z(this, "archScene");
        z(this, "info3dScene");
        z(this, "info2dScene");
        z(this, "renderer");
        z(this, "dummyRenderer");
        z(this, "dirLight");
        z(this, "dirLight2");
        z(this, "ambientLight");
        z(this, "ambientLight2");
        z(this, "camera");
        z(this, "controls");
        z(this, "clock");
        z(this, "animations");
        z(this, "raycaster");
        z(this, "renderWidth");
        z(this, "renderHeight");
        z(this, "sceneBoundingBox");
        z(this, "floorIdInfos");
        z(this, "layers");
        z(this, "floorPositionSelectionEnabled");
        z(this, "positionSelectionFloorIds");
        z(this, "floorPositionSelectionPoint");
        z(this, "xrayMaterial");
        z(this, "rafId", 0);
        z(this, "tempV");
        z(this, "_cb", null);
        z(this, "particleSystem");
        z(this, "composer");
        z(this, "renderPass");
        z(this, "bloomPass");
        z(this, "bloom", !1);
        z(this, "boundOnClick");
        z(this, "boundOnResize");
        this.tempV = new C, this.element = e, this.archScene = new Sc, this.info3dScene = new Sc, this.info2dScene = new Sc, this.renderWidth = 640, this.renderHeight = 480, this.sceneBoundingBox = new fi, this.floorIdInfos = new Map, this.layers = new Map, this.floorPositionSelectionEnabled = !1, this.positionSelectionFloorIds = [], this.floorPositionSelectionPoint = new C, this.boundOnClick = this.onMouseClick.bind(this), this.boundOnResize = this.onWindowResize.bind(this), this.renderer = new c0({antialias: !0}), this.renderer.setClearColor("gray"), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.renderWidth, this.renderHeight), this.renderer.autoClear = !1, this.renderer.physicallyCorrectLights = !0, this.renderer.outputEncoding = Ee, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = Xm, this.renderer.shadowMap.autoUpdate = !1, this.element.appendChild(this.renderer.domElement), this.dummyRenderer = new BN, this.ambientLight = new P0(16777215, 1), this.ambientLight2 = this.ambientLight.clone(), this.archScene.add(this.ambientLight), this.info3dScene.add(this.ambientLight2), this.dirLight = new af(16777215, 2.5), this.dirLight2 = this.dirLight.clone(), this.dirLight.castShadow = !0, this.dirLight.shadow.bias = -1e-4, this.dirLight.shadow.mapSize.width = 2048, this.dirLight.shadow.mapSize.height = 2048, this.dirLight.shadow.camera.near = 1, this.dirLight.shadow.camera.far = 1e3, this.dirLight.shadow.camera.right = 50, this.dirLight.shadow.camera.left = -50, this.dirLight.shadow.camera.top = 50, this.dirLight.shadow.camera.bottom = -50, this.dirLight.shadow.camera.updateProjectionMatrix(), this.archScene.add(this.dirLight), this.archScene.add(this.dirLight.target), this.info3dScene.add(this.dirLight2), this.info3dScene.add(this.dirLight2.target), this.camera = new bn(60, window.innerWidth / window.innerHeight, 1, 1e3), this.camera.position.set(0, 50, 50), this.controls = new zN(this.camera, this.renderer.domElement), this.controls.addEventListener("change", n => {
            this.camera.getWorldDirection(this.tempV), this.tempV.multiplyScalar(50).add(this.camera.position), this.dirLight.target.position.copy(this.tempV), this.dirLight.position.copy(this.tempV), this.dirLight.position.add(new C(5 * 10, 10 * 10, 7.5 * 10)), this.renderer.shadowMap.needsUpdate = !0
        }), this.clock = new hf(!0), this.animations = new Map, this.raycaster = new OE, this.xrayMaterial = new rn({
            color: 7653341,
            opacity: .15,
            blending: Or,
            transparent: !0,
            depthWrite: !1,
            depthTest: !1
        }), this.composer = new WN(this.renderer), this.composer.setSize(this.renderWidth, this.renderHeight), this.composer.renderToScreen = !0, this.renderPass = new qN(this.archScene, this.camera), this.bloomPass = new hl(new j(window.innerWidth, window.innerHeight), 1.5, .4, .85), this.bloomPass.threshold = 0, this.bloomPass.strength = .4, this.bloomPass.radius = 0, this.renderer.toneMappingExposure = Math.pow(1.5, 4), this.composer.addPass(this.renderPass), this.composer.addPass(this.bloomPass), window.addEventListener("resize", this.boundOnResize, !1), window.setTimeout(() => {
            this.onWindowResize()
        }, 100)
    }

    testParticle() {
        this.particleSystem = new qF;
        let e = new tf({map: new T0().load(jF), color: 16711680, blending: Rc, fog: !0}), n = new Om;
        n.setRate(new jo(new Xs(10, 15), new Xs(.05, .1))).addInitializers([new ff(e), new gf(1), new pf(1, 3), new $0(new mf(20)), new xf(new Xs(500, 800), new ye(0, 1, 0), 30)]).addBehaviours([new Sf(10, 10, 10, .05), new Mf(new Xs(2, 3.5), 0), new Ef(6), new wf("#FF0026", ["#ffff00", "#ffff11"], 1 / 0, Ic.easeOutSine)]).setPosition({
            x: 0,
            y: 0
        }).emit(), this.particleSystem.addEmitter(n), this.particleSystem.addRenderer(new ZF(this.info3dScene, FN));
        let s = new ge(new Vi(1, 1, 1), new rn({color: "red"}));
        this.info3dScene.add(s)
    }

    static ReleaseMaterial(e) {
        e != null && (Array.isArray(e) ? e.forEach(n => this.ReleaseMaterial(n)) : (e instanceof Zn || e instanceof rn) && (e.map != null && (e.map.dispose(), e.map = null), e.dispose()))
    }

    static ReleaseBufferGeometry(e) {
        e != null && e.dispose()
    }

    static ReleaseObject3D(e) {
        for (let s = e.children.length - 1; s >= 0; --s) this.ReleaseObject3D(e.children[s]);
        e.parent != null && e.removeFromParent();
        let n = Object.keys(e.userData);
        for (let s of n) delete e.userData[s];
        e instanceof ge && (this.ReleaseMaterial(e.material), e.material = null, this.ReleaseBufferGeometry(e.geometry), e.geometry = null)
    }

    release() {
        this.stopRender(), window.removeEventListener("resize", this.boundOnResize), this.disableFloorPositionSelection(), this.cleanUpScene(), this.xrayMaterial.dispose(), this.clock.stop(), this.renderer.dispose()
    }

    onWindowResize() {
        this.renderWidth = this.element.clientWidth, this.renderHeight = this.element.clientHeight, this.camera.aspect = this.renderWidth / this.renderHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(this.renderWidth, this.renderHeight), this.dummyRenderer.setSize(this.renderWidth, this.renderHeight), this.composer.setSize(this.renderWidth, this.renderHeight), this.bloomPass.setSize(this.renderWidth, this.renderHeight)
    }

    startRender() {
        this.rafId == 0 && this.render()
    }

    stopRender() {
        this.rafId != 0 && (cancelAnimationFrame(this.rafId), this.rafId = 0)
    }

    addUpdateCallback(e) {
        this._cb = e
    }

    render() {
        const e = this.clock.getDelta();
        this.rafId = requestAnimationFrame(this.render.bind(this)), this._cb && this._cb(e), this.animations.forEach(n => {
            n.mixer.update(e)
        }), this.controls.update(), this.renderer.clear(!0, !0, !0), this.renderer.render(this.archScene, this.camera), this.renderer.render(this.info3dScene, this.camera), this.dummyRenderer.render(this.info2dScene, this.camera), this.bloom && this.composer.render()
    }

    setUpdateShadowNeeded() {
        this.renderer.shadowMap.needsUpdate = !0
    }

    addAnimation(e, n, s) {
        if (this.animations.has(e)) throw "Viewer.addAnimation: ID가 이미 존재합니다:" + e;
        this.animations.set(e, {mixer: new NE(n), clips: s})
    }

    removeAnimation(e) {
        this.stopAnimation(e), this.animations.delete(e)
    }

    playAnimation(e, n) {
        if (!this.animations.has(e)) return;
        let s = this.animations.get(e);
        if (s == null) return;
        let r = Wr.findByName(s.clips, n);
        r != null ? s.mixer.clipAction(r).play() : console.error("Viewer.playAnimation: 다음 애니메이션이 존재하지 않습니다:", e, n)
    }

    stopAnimation(e, n) {
        if (!this.animations.has(e)) return;
        let s = this.animations.get(e);
        if (s != null) if (n != null) {
            let r = Wr.findByName(s.clips, n);
            r != null ? s.mixer.clipAction(r).stop() : console.error("Viewer.stopAnimation: 애니메이션이 존재하지 않습니다:", e, n)
        } else s.mixer.stopAllAction()
    }

    stopAllAnimations() {
        for (let [e, n] of this.animations) n.mixer.stopAllAction()
    }

    initScene(e) {
        this.cleanUpScene(), this.floorIdInfos.clear(), [...e.floors.values()].forEach(n => {
            this.floorIdInfos.set(n.id, {
                elevation: n.elevation,
                plane: new er(new C(0, 1, 0), n.elevation),
                visible: !0
            })
        })
    }

    cleanUpScene() {
        this.archScene.remove(this.ambientLight), this.info3dScene.remove(this.ambientLight2), this.archScene.remove(this.dirLight), this.archScene.remove(this.dirLight.target), this.info3dScene.remove(this.dirLight2), this.info3dScene.remove(this.dirLight2.target), this.sceneBoundingBox.makeEmpty(), this.stopAllAnimations(), this.animations.clear(), this.layers.forEach(e => e.dispose()), this.layers.clear(), Ds.ReleaseObject3D(this.archScene), Ds.ReleaseObject3D(this.info3dScene), Ds.ReleaseObject3D(this.info2dScene), this.archScene.add(this.ambientLight), this.info3dScene.add(this.ambientLight2), this.archScene.add(this.dirLight), this.archScene.add(this.dirLight.target), this.info3dScene.add(this.dirLight2), this.info3dScene.add(this.dirLight2.target)
    }

    createGlobalLayer({name: e, visualizationType: n, useBoundingBox: s}) {
        return this.createLayer({name: e, visualizationType: n, useBoundingBox: s, coverage: mc.Global})
    }

    createFloorLayer({name: e, visualizationType: n, useBoundingBox: s}) {
        return this.createLayer({name: e, visualizationType: n, useBoundingBox: s, coverage: mc.Floor})
    }

    createLayer({name: e, visualizationType: n, coverage: s, useBoundingBox: r}) {
        if (this.floorIdInfos.size === 0) throw "Viewer.createLayer: 층 정보가 없습니다. initScene을 수행하지 않은 것 같습니다.";
        let o = this.layers.get(e);
        if (o != null) return o;
        let a = null;
        switch (n) {
            case Ua.Architecture:
                a = this.archScene;
                break;
            case Ua.Information3D:
                a = this.info3dScene;
                break;
            case Ua.Information2D:
                a = this.info2dScene;
                break;
            default:
                throw "Viewer.createLayer: 잘못된 visualizationType 지정"
        }
        switch (s) {
            case mc.Global:
                o = new GN({viewer: this, name: e, parentScene: a, useBoundingBox: r, visualizationType: n});
                break;
            case mc.Floor:
                o = new Zp({
                    viewer: this,
                    name: e,
                    parentScene: a,
                    floorIdElevations: [...this.floorIdInfos.entries()].map(([l, c]) => ({
                        floorId: l,
                        elevation: c.elevation
                    })),
                    useBoundingBox: r,
                    visualizationType: n
                });
                break;
            default:
                throw "Viewer.createLayer: 잘못된 coverage 지정"
        }
        if (o instanceof Zp) for (let [l, c] of this.floorIdInfos) o.setFloorVisible(l, c.visible);
        return this.layers.set(e, o), o
    }

    getLayer(e) {
        return this.layers.get(e) ?? null
    }

    * getLayers({visualizationType: e, coverage: n}) {
        for (let [s, r] of this.layers) {
            let o = !0;
            e != null && (o = r.visualizationType === e), o && n != null && (o = r.coverage === n), o === !0 && (yield[s, r])
        }
    }

    removeLayer(e) {
        const n = this.layers.get(e);
        n != null && (n.dispose(), this.layers.delete(e))
    }

    setLayerVisible(e, n) {
        var s;
        (s = this.layers.get(e)) == null || s.setVisible(n !== !1)
    }

    isLayerVisible(e) {
        var n;
        return ((n = this.layers.get(e)) == null ? void 0 : n.isVisible()) === !0
    }

    setFloorVisible(e, n) {
        for (let [r, o] of this.layers) o instanceof Zp && o.setFloorVisible(e, n);
        const s = this.floorIdInfos.get(e);
        s != null && (s.visible = n !== !1)
    }

    setAllFloorVisible(e) {
        for (let [n, s] of this.floorIdInfos) this.setFloorVisible(n, e)
    }

    isFloorVisible(e) {
        const n = this.floorIdInfos.get(e);
        return n != null ? n.visible : !1
    }

    updateSceneBoundingBox(e = !0) {
        this.sceneBoundingBox.makeEmpty();
        for (let [, n] of this.layers) e === !0 && !n.isVisible() || n.layerBoundingBox.isEmpty() || this.sceneBoundingBox.union(n.layerBoundingBox)
    }

    adjustCameraHeight() {
        if (this.sceneBoundingBox.isEmpty()) {
            this.controls.target.set(0, 0, 0);
            return
        }
        let e = new C;
        this.sceneBoundingBox.getCenter(e), e.sub(this.controls.target), this.controls.target.y += e.y, this.camera.position.y += e.y
    }

    updateOrbitCenter() {
        if (this.sceneBoundingBox.isEmpty()) {
            this.controls.target.set(0, 0, 0);
            return
        }
        let e = new C;
        this.sceneBoundingBox.getCenter(e), e.sub(this.controls.target), this.controls.target.add(e), this.camera.position.add(e), this.camera.lookAt(this.controls.target)
    }

    updateRaycaster(e) {
        const n = e.offsetX / this.renderWidth * 2 - 1, s = -(e.offsetY / this.renderHeight) * 2 + 1;
        return this.raycaster.setFromCamera({x: n, y: s}, this.camera), this.raycaster
    }

    onMouseClick(e) {
        var n;
        if (this.floorPositionSelectionEnabled === !0) {
            e.preventDefault(), e.stopPropagation();
            const s = this.updateRaycaster(e);
            for (let r of this.positionSelectionFloorIds) {
                const o = (n = this.floorIdInfos.get(r)) == null ? void 0 : n.plane;
                o != null && s.ray.intersectPlane(o, this.floorPositionSelectionPoint) != null && this.dispatchEvent(new JF("floorpositionselect", {
                    viewer: this,
                    floorId: r,
                    position: this.floorPositionSelectionPoint,
                    mouseEvent: e
                }))
            }
        }
    }

    enableFloorPositionSelection(...e) {
        this.positionSelectionFloorIds.length = 0, this.positionSelectionFloorIds.push(...e), this.renderer.domElement.addEventListener("click", this.boundOnClick, !1), this.floorPositionSelectionEnabled = !0
    }

    disableFloorPositionSelection() {
        this.floorPositionSelectionEnabled = !1, this.renderer.domElement.removeEventListener("click", this.boundOnClick)
    }

    setXrayMode(e = !0) {
        e === !0 ? this.archScene.overrideMaterial = this.xrayMaterial : this.archScene.overrideMaterial = null
    }

    isXrayMode() {
        return this.archScene.overrideMaterial === this.xrayMaterial
    }

    setBackgroundColor(e = "gray") {
        this.renderer.setClearColor(e)
    }

    setBloomEffect() {
        return this.bloom = !this.bloom, this.bloom
    }

    setInfo2dRenderCallback(e) {
        this.dummyRenderer.setRenderCallback(e)
    }
}

var Je = (i => (i.BVError = "bv-error", i.BVResult = "bv-result", i.BVGetStatus = "bv-get-status", i.BVGetStatusResult = "bv-get-status-result", i.BVReportStatus = "bv-report-status", i.BVInit = "bv-init", i.BVRelease = "bv-release", i.BVLoadBuilding = "bv-load-building", i.BVLoadBuildingResult = "bv-load-building-result", i.BVSetFloorVisible = "bv-set-floor-visible", i.BVSetFloorVisibleResult = "bv-floor-visible-result", i.BVSetAllFloorVisible = "bv-set-all-floor-visible", i.BVSetAllFloorVisibleResult = "bv-set-all-floor-visible-result", i.BVGetFloors = "bv-get-floors", i.BVGetFloorsResult = "bv-get-floors-result", i.BVCleanup = "bv-cleanup", i.BVSetPoiStatus = "bv-set-poi-status", i.BVGetAllPoi = "bv-get-all-poi", i.BVGetAllPoiResult = "bv-get-all-poi-result", i.BVPoiSelectionChanged = "bv-poi-selection-changed", i.BVClickPosition = "bv-click-position", i))(Je || {}),
    Ch = (i => (i.NotReady = "not-ready", i.Ready = "ready", i.Initialized = "initialized", i.Released = "released", i))(Ch || {});

class pr {
    constructor(t) {
        z(this, "id");
        z(this, "name");
        z(this, "_floor");
        z(this, "properties");
        z(this, "groupIds");
        z(this, "userData");
        this.id = t.id, this.name = t.name ?? null, this._floor = new WeakRef(t.floor), this.properties = t.properties ?? null, this.groupIds = new Set, this.userData = null
    }

    get floor() {
        const t = this._floor.deref();
        if (t == null) throw "BimsElement.floor: GC 후 참조 발생";
        return t
    }

    get building() {
        const t = this.floor.building;
        if (t == null) throw "BimsElement.building: GC 후 참조 발생";
        return t
    }

    get floorElevation() {
        return this.floor.elevation
    }

    addGroup(t) {
        this.groupIds.has(t.id) || this.groupIds.add(t.id)
    }

    getGroupById(t) {
        return this.building.groups.get(t) ?? null
    }

    * getGroups() {
        for (const t of this.groupIds) {
            const e = this.building.groups.get(t);
            e != null && (yield e)
        }
    }

    get groups() {
        return this.getGroups()
    }
}

class Qp {
    static equalsWithTolerance(t, e, n) {
        return Math.abs(t - e) <= n
    }
}

class js extends Error {
    constructor(t) {
        super(t), this.name = Object.keys({Exception: js})[0]
    }

    toString() {
        return this.message
    }
}

class jt extends js {
    constructor(t) {
        super(t), this.name = Object.keys({IllegalArgumentException: jt})[0]
    }
}

class bo {
    constructor(t, e) {
        this.low = e || 0, this.high = t || 0
    }

    static toBinaryString(t) {
        let e, n = "";
        for (e = 2147483648; e > 0; e >>>= 1) n += (t.high & e) === e ? "1" : "0";
        for (e = 2147483648; e > 0; e >>>= 1) n += (t.low & e) === e ? "1" : "0";
        return n
    }
}

function St() {
}

St.NaN = NaN;
St.isNaN = i => Number.isNaN(i);
St.isInfinite = i => !Number.isFinite(i);
St.MAX_VALUE = Number.MAX_VALUE;
St.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
St.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
typeof Float64Array == "function" && typeof Int32Array == "function" ? function () {
    const e = new Float64Array(1), n = new Int32Array(e.buffer);
    St.doubleToLongBits = function (s) {
        e[0] = s;
        let r = n[0] | 0, o = n[1] | 0;
        return (o & 2146435072) === 2146435072 && o & 1048575 && r !== 0 && (r = 0, o = 2146959360), new bo(o, r)
    }, St.longBitsToDouble = function (s) {
        return n[0] = s.low, n[1] = s.high, e[0]
    }
}() : function () {
    const t = Math.log2, e = Math.floor, n = Math.pow, s = function () {
        for (let r = 53; r > 0; r--) {
            const o = n(2, r) - 1;
            if (e(t(o)) + 1 === r) return o
        }
        return 0
    }();
    St.doubleToLongBits = function (r) {
        let o, a, l, c, h, u, d, f, g;
        if (r < 0 || 1 / r === Number.NEGATIVE_INFINITY ? (u = 1 << 31, r = -r) : u = 0, r === 0) return g = 0, f = u, new bo(f, g);
        if (r === 1 / 0) return g = 0, f = u | 2146435072, new bo(f, g);
        if (r !== r) return g = 0, f = 2146959360, new bo(f, g);
        if (c = 0, g = 0, o = e(r), o > 1) if (o <= s) c = e(t(o)), c <= 20 ? (g = 0, f = o << 20 - c & 1048575) : (l = c - 20, a = n(2, l), g = o % a << 32 - l, f = o / a & 1048575); else for (l = o, g = 0; a = l / 2, l = e(a), l !== 0;) c++, g >>>= 1, g |= (f & 1) << 31, f >>>= 1, a !== l && (f |= 524288);
        if (d = c + 1023, h = o === 0, o = r - o, c < 52 && o !== 0) for (l = 0; ;) {
            if (a = o * 2, a >= 1 ? (o = a - 1, h ? (d--, h = !1) : (l <<= 1, l |= 1, c++)) : (o = a, h ? --d === 0 && (c++, h = !1) : (l <<= 1, c++)), c === 20) f |= l, l = 0; else if (c === 52) {
                g |= l;
                break
            }
            if (a === 1) {
                c < 20 ? f |= l << 20 - c : c < 52 && (g |= l << 52 - c);
                break
            }
        }
        return f |= d << 20, f |= u, new bo(f, g)
    }, St.longBitsToDouble = function (r) {
        let o, a, l, c;
        const h = r.high, u = r.low, d = h & 1 << 31 ? -1 : 1;
        for (l = ((h & 2146435072) >> 20) - 1023, c = 0, a = 1 << 19, o = 1; o <= 20; o++) h & a && (c += n(2, -o)), a >>>= 1;
        for (a = 1 << 31, o = 21; o <= 52; o++) u & a && (c += n(2, -o)), a >>>= 1;
        if (l === -1023) {
            if (c === 0) return d * 0;
            l = -1022
        } else {
            if (l === 1023 + 1) return c === 0 ? d / 0 : NaN;
            c += 1
        }
        return d * c * n(2, l)
    }
}();

function Es() {
}

function Ph() {
}

function Kr() {
}

function Ss() {
}

class vs extends js {
    constructor(t) {
        super(t), this.name = Object.keys({RuntimeException: vs})[0]
    }
}

class Da extends vs {
    constructor() {
        super(), Da.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (arguments.length === 0) vs.constructor_.call(this); else if (arguments.length === 1) {
            const t = arguments[0];
            vs.constructor_.call(this, t)
        }
    }
}

class $t {
    static shouldNeverReachHere() {
        if (arguments.length === 0) $t.shouldNeverReachHere(null); else if (arguments.length === 1) {
            const t = arguments[0];
            throw new Da("Should never reach here" + (t !== null ? ": " + t : ""))
        }
    }

    static isTrue() {
        if (arguments.length === 1) {
            const t = arguments[0];
            $t.isTrue(t, null)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            if (!t) throw e === null ? new Da : new Da(e)
        }
    }

    static equals() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            $t.equals(t, e, null)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            if (!e.equals(t)) throw new Da("Expected " + t + " but encountered " + e + (n !== null ? ": " + n : ""))
        }
    }
}

const RS = new ArrayBuffer(8), QF = new Float64Array(RS), T1 = new Int32Array(RS);

class F {
    constructor() {
        F.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this.x = null, this.y = null, this.z = null, arguments.length === 0) F.constructor_.call(this, 0, 0); else if (arguments.length === 1) {
            const t = arguments[0];
            F.constructor_.call(this, t.x, t.y, t.getZ())
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            F.constructor_.call(this, t, e, F.NULL_ORDINATE)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this.x = t, this.y = e, this.z = n
        }
    }

    static hashCode(t) {
        return QF[0] = t, T1[0] ^ T1[1]
    }

    getM() {
        return St.NaN
    }

    setOrdinate(t, e) {
        switch (t) {
            case F.X:
                this.x = e;
                break;
            case F.Y:
                this.y = e;
                break;
            case F.Z:
                this.setZ(e);
                break;
            default:
                throw new jt("Invalid ordinate index: " + t)
        }
    }

    equals2D() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return !(this.x !== t.x || this.y !== t.y)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return !(!Qp.equalsWithTolerance(this.x, t.x, e) || !Qp.equalsWithTolerance(this.y, t.y, e))
        }
    }

    setM(t) {
        throw new jt("Invalid ordinate index: " + F.M)
    }

    getZ() {
        return this.z
    }

    getOrdinate(t) {
        switch (t) {
            case F.X:
                return this.x;
            case F.Y:
                return this.y;
            case F.Z:
                return this.getZ()
        }
        throw new jt("Invalid ordinate index: " + t)
    }

    equals3D(t) {
        return this.x === t.x && this.y === t.y && (this.getZ() === t.getZ() || St.isNaN(this.getZ()) && St.isNaN(t.getZ()))
    }

    equals(t) {
        return t instanceof F ? this.equals2D(t) : !1
    }

    equalInZ(t, e) {
        return Qp.equalsWithTolerance(this.getZ(), t.getZ(), e)
    }

    setX(t) {
        this.x = t
    }

    compareTo(t) {
        const e = t;
        return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
    }

    getX() {
        return this.x
    }

    setZ(t) {
        this.z = t
    }

    clone() {
        try {
            return null
        } catch (t) {
            if (t instanceof CloneNotSupportedException) return $t.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
            throw t
        } finally {
        }
    }

    copy() {
        return new F(this)
    }

    toString() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")"
    }

    distance3D(t) {
        const e = this.x - t.x, n = this.y - t.y, s = this.getZ() - t.getZ();
        return Math.sqrt(e * e + n * n + s * s)
    }

    getY() {
        return this.y
    }

    setY(t) {
        this.y = t
    }

    distance(t) {
        const e = this.x - t.x, n = this.y - t.y;
        return Math.sqrt(e * e + n * n)
    }

    hashCode() {
        let t = 17;
        return t = 37 * t + F.hashCode(this.x), t = 37 * t + F.hashCode(this.y), t
    }

    setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ()
    }

    get interfaces_() {
        return [Es, Ph, Ss]
    }
}

class Eo {
    constructor() {
        Eo.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._dimensionsToTest = 2, arguments.length === 0) Eo.constructor_.call(this, 2); else if (arguments.length === 1) {
            const t = arguments[0];
            if (t !== 2 && t !== 3) throw new jt("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = t
        }
    }

    static compare(t, e) {
        return t < e ? -1 : t > e ? 1 : St.isNaN(t) ? St.isNaN(e) ? 0 : -1 : St.isNaN(e) ? 1 : 0
    }

    compare(t, e) {
        const n = Eo.compare(t.x, e.x);
        if (n !== 0) return n;
        const s = Eo.compare(t.y, e.y);
        return s !== 0 ? s : this._dimensionsToTest <= 2 ? 0 : Eo.compare(t.getZ(), e.getZ())
    }

    get interfaces_() {
        return [Kr]
    }
}

F.DimensionalComparator = Eo;
F.NULL_ORDINATE = St.NaN;
F.X = 0;
F.Y = 1;
F.Z = 2;
F.M = 3;

class hs extends F {
    constructor() {
        super(), hs.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (arguments.length === 0) F.constructor_.call(this); else if (arguments.length === 1) {
            if (arguments[0] instanceof hs) {
                const t = arguments[0];
                F.constructor_.call(this, t.x, t.y)
            } else if (arguments[0] instanceof F) {
                const t = arguments[0];
                F.constructor_.call(this, t.x, t.y)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            F.constructor_.call(this, t, e, F.NULL_ORDINATE)
        }
    }

    setOrdinate(t, e) {
        switch (t) {
            case hs.X:
                this.x = e;
                break;
            case hs.Y:
                this.y = e;
                break;
            default:
                throw new jt("Invalid ordinate index: " + t)
        }
    }

    getZ() {
        return F.NULL_ORDINATE
    }

    getOrdinate(t) {
        switch (t) {
            case hs.X:
                return this.x;
            case hs.Y:
                return this.y
        }
        throw new jt("Invalid ordinate index: " + t)
    }

    setZ(t) {
        throw new jt("CoordinateXY dimension 2 does not support z-ordinate")
    }

    copy() {
        return new hs(this)
    }

    toString() {
        return "(" + this.x + ", " + this.y + ")"
    }

    setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ()
    }
}

hs.X = 0;
hs.Y = 1;
hs.Z = -1;
hs.M = -1;

class Bn extends F {
    constructor() {
        super(), Bn.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._m = null, arguments.length === 0) F.constructor_.call(this), this._m = 0; else if (arguments.length === 1) {
            if (arguments[0] instanceof Bn) {
                const t = arguments[0];
                F.constructor_.call(this, t.x, t.y), this._m = t._m
            } else if (arguments[0] instanceof F) {
                const t = arguments[0];
                F.constructor_.call(this, t.x, t.y), this._m = this.getM()
            }
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            F.constructor_.call(this, t, e, F.NULL_ORDINATE), this._m = n
        }
    }

    getM() {
        return this._m
    }

    setOrdinate(t, e) {
        switch (t) {
            case Bn.X:
                this.x = e;
                break;
            case Bn.Y:
                this.y = e;
                break;
            case Bn.M:
                this._m = e;
                break;
            default:
                throw new jt("Invalid ordinate index: " + t)
        }
    }

    setM(t) {
        this._m = t
    }

    getZ() {
        return F.NULL_ORDINATE
    }

    getOrdinate(t) {
        switch (t) {
            case Bn.X:
                return this.x;
            case Bn.Y:
                return this.y;
            case Bn.M:
                return this._m
        }
        throw new jt("Invalid ordinate index: " + t)
    }

    setZ(t) {
        throw new jt("CoordinateXY dimension 2 does not support z-ordinate")
    }

    copy() {
        return new Bn(this)
    }

    toString() {
        return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")"
    }

    setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM()
    }
}

Bn.X = 0;
Bn.Y = 1;
Bn.Z = -1;
Bn.M = 2;

class Fo extends F {
    constructor() {
        super(), Fo.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._m = null, arguments.length === 0) F.constructor_.call(this), this._m = 0; else if (arguments.length === 1) {
            if (arguments[0] instanceof Fo) {
                const t = arguments[0];
                F.constructor_.call(this, t), this._m = t._m
            } else if (arguments[0] instanceof F) {
                const t = arguments[0];
                F.constructor_.call(this, t), this._m = this.getM()
            }
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            F.constructor_.call(this, t, e, n), this._m = s
        }
    }

    getM() {
        return this._m
    }

    setOrdinate(t, e) {
        switch (t) {
            case F.X:
                this.x = e;
                break;
            case F.Y:
                this.y = e;
                break;
            case F.Z:
                this.z = e;
                break;
            case F.M:
                this._m = e;
                break;
            default:
                throw new jt("Invalid ordinate index: " + t)
        }
    }

    setM(t) {
        this._m = t
    }

    getOrdinate(t) {
        switch (t) {
            case F.X:
                return this.x;
            case F.Y:
                return this.y;
            case F.Z:
                return this.getZ();
            case F.M:
                return this.getM()
        }
        throw new jt("Invalid ordinate index: " + t)
    }

    copy() {
        return new Fo(this)
    }

    toString() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")"
    }

    setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM()
    }
}

function At(i, t) {
    return i.interfaces_ && i.interfaces_.indexOf(t) > -1
}

class fn {
    add() {
    }

    addAll() {
    }

    isEmpty() {
    }

    iterator() {
    }

    size() {
    }

    toArray() {
    }

    remove() {
    }
}

class Tf extends js {
    constructor(t) {
        super(t), this.name = Object.keys({IndexOutOfBoundsException: Tf})[0]
    }
}

class Bs extends fn {
    get() {
    }

    set() {
    }

    isEmpty() {
    }
}

class Ll extends js {
    constructor(t) {
        super(t), this.name = Object.keys({NoSuchElementException: Ll})[0]
    }
}

class ct extends Bs {
    constructor(t) {
        super(), this.array = [], t instanceof fn && this.addAll(t)
    }

    get interfaces_() {
        return [Bs, fn]
    }

    ensureCapacity() {
    }

    add(t) {
        return arguments.length === 1 ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0
    }

    clear() {
        this.array = []
    }

    addAll(t) {
        for (const e of t) this.array.push(e)
    }

    set(t, e) {
        const n = this.array[t];
        return this.array[t] = e, n
    }

    iterator() {
        return new tz(this)
    }

    get(t) {
        if (t < 0 || t >= this.size()) throw new Tf;
        return this.array[t]
    }

    isEmpty() {
        return this.array.length === 0
    }

    sort(t) {
        t ? this.array.sort((e, n) => t.compare(e, n)) : this.array.sort()
    }

    size() {
        return this.array.length
    }

    toArray() {
        return this.array.slice()
    }

    remove(t) {
        for (let e = 0, n = this.array.length; e < n; e++) if (this.array[e] === t) return !!this.array.splice(e, 1);
        return !1
    }

    [Symbol.iterator]() {
        return this.array.values()
    }
}

class tz {
    constructor(t) {
        this.arrayList = t, this.position = 0
    }

    next() {
        if (this.position === this.arrayList.size()) throw new Ll;
        return this.arrayList.get(this.position++)
    }

    hasNext() {
        return this.position < this.arrayList.size()
    }

    set(t) {
        return this.arrayList.set(this.position - 1, t)
    }

    remove() {
        this.arrayList.remove(this.arrayList.get(this.position))
    }
}

class ui extends ct {
    constructor() {
        super(), ui.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (arguments.length !== 0) {
            if (arguments.length === 1) {
                const t = arguments[0];
                this.ensureCapacity(t.length), this.add(t, !0)
            } else if (arguments.length === 2) {
                const t = arguments[0], e = arguments[1];
                this.ensureCapacity(t.length), this.add(t, e)
            }
        }
    }

    getCoordinate(t) {
        return this.get(t)
    }

    addAll() {
        if (arguments.length === 2 && typeof arguments[1] == "boolean" && At(arguments[0], fn)) {
            const t = arguments[0], e = arguments[1];
            let n = !1;
            for (let s = t.iterator(); s.hasNext();) this.add(s.next(), e), n = !0;
            return n
        } else return super.addAll.apply(this, arguments)
    }

    clone() {
        const t = super.clone.call(this);
        for (let e = 0; e < this.size(); e++) t.add(e, this.get(e).clone());
        return t
    }

    toCoordinateArray() {
        if (arguments.length === 0) return this.toArray(ui.coordArrayType);
        if (arguments.length === 1) {
            if (arguments[0]) return this.toArray(ui.coordArrayType);
            const e = this.size(), n = new Array(e).fill(null);
            for (let s = 0; s < e; s++) n[s] = this.get(e - s - 1);
            return n
        }
    }

    add() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return super.add.call(this, t)
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
                const t = arguments[0], e = arguments[1];
                return this.add(t, e, !0), !0
            } else if (arguments[0] instanceof F && typeof arguments[1] == "boolean") {
                const t = arguments[0];
                if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(t)) return null;
                super.add.call(this, t)
            } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
                const t = arguments[0], e = arguments[1];
                return this.add(t, e), !0
            }
        } else if (arguments.length === 3) {
            if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
                const t = arguments[0], e = arguments[1];
                if (arguments[2]) for (let s = 0; s < t.length; s++) this.add(t[s], e); else for (let s = t.length - 1; s >= 0; s--) this.add(t[s], e);
                return !0
            } else if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof F) {
                const t = arguments[0], e = arguments[1];
                if (!arguments[2]) {
                    const s = this.size();
                    if (s > 0 && (t > 0 && this.get(t - 1).equals2D(e) || t < s && this.get(t).equals2D(e))) return null
                }
                super.add.call(this, t, e)
            }
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            let r = 1;
            n > s && (r = -1);
            for (let o = n; o !== s; o += r) this.add(t[o], e);
            return !0
        }
    }

    closeRing() {
        if (this.size() > 0) {
            const t = this.get(0).copy();
            this.add(t, !1)
        }
    }
}

ui.coordArrayType = new Array(0).fill(null);

class Nl {
    filter(t, e) {
    }

    isDone() {
    }

    isGeometryChanged() {
    }
}

class Kt {
    constructor() {
        Kt.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init(); else if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
                const t = arguments[0];
                this.init(t.x, t.x, t.y, t.y)
            } else if (arguments[0] instanceof Kt) {
                const t = arguments[0];
                this.init(t)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.init(t.x, e.x, t.y, e.y)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            this.init(t, e, n, s)
        }
    }

    static intersects() {
        if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            let r = Math.min(n.x, s.x), o = Math.max(n.x, s.x), a = Math.min(t.x, e.x), l = Math.max(t.x, e.x);
            return !(a > o || l < r || (r = Math.min(n.y, s.y), o = Math.max(n.y, s.y), a = Math.min(t.y, e.y), l = Math.max(t.y, e.y), a > o) || l < r)
        }
    }

    getArea() {
        return this.getWidth() * this.getHeight()
    }

    equals(t) {
        if (!(t instanceof Kt)) return !1;
        const e = t;
        return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY()
    }

    intersection(t) {
        if (this.isNull() || t.isNull() || !this.intersects(t)) return new Kt;
        const e = this._minx > t._minx ? this._minx : t._minx, n = this._miny > t._miny ? this._miny : t._miny,
            s = this._maxx < t._maxx ? this._maxx : t._maxx, r = this._maxy < t._maxy ? this._maxy : t._maxy;
        return new Kt(e, s, n, r)
    }

    isNull() {
        return this._maxx < this._minx
    }

    getMaxX() {
        return this._maxx
    }

    covers() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
                const t = arguments[0];
                return this.covers(t.x, t.y)
            } else if (arguments[0] instanceof Kt) {
                const t = arguments[0];
                return this.isNull() || t.isNull() ? !1 : t.getMinX() >= this._minx && t.getMaxX() <= this._maxx && t.getMinY() >= this._miny && t.getMaxY() <= this._maxy
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return this.isNull() ? !1 : t >= this._minx && t <= this._maxx && e >= this._miny && e <= this._maxy
        }
    }

    intersects() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Kt) {
                const t = arguments[0];
                return this.isNull() || t.isNull() ? !1 : !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny)
            } else if (arguments[0] instanceof F) {
                const t = arguments[0];
                return this.intersects(t.x, t.y)
            }
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof F && arguments[1] instanceof F) {
                const t = arguments[0], e = arguments[1];
                return !(this.isNull() || (t.x < e.x ? t.x : e.x) > this._maxx || (t.x > e.x ? t.x : e.x) < this._minx || (t.y < e.y ? t.y : e.y) > this._maxy || (t.y > e.y ? t.y : e.y) < this._miny)
            } else if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
                const t = arguments[0], e = arguments[1];
                return this.isNull() ? !1 : !(t > this._maxx || t < this._minx || e > this._maxy || e < this._miny)
            }
        }
    }

    getMinY() {
        return this._miny
    }

    getDiameter() {
        if (this.isNull()) return 0;
        const t = this.getWidth(), e = this.getHeight();
        return Math.sqrt(t * t + e * e)
    }

    getMinX() {
        return this._minx
    }

    expandToInclude() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
                const t = arguments[0];
                this.expandToInclude(t.x, t.y)
            } else if (arguments[0] instanceof Kt) {
                const t = arguments[0];
                if (t.isNull()) return null;
                this.isNull() ? (this._minx = t.getMinX(), this._maxx = t.getMaxX(), this._miny = t.getMinY(), this._maxy = t.getMaxY()) : (t._minx < this._minx && (this._minx = t._minx), t._maxx > this._maxx && (this._maxx = t._maxx), t._miny < this._miny && (this._miny = t._miny), t._maxy > this._maxy && (this._maxy = t._maxy))
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.isNull() ? (this._minx = t, this._maxx = t, this._miny = e, this._maxy = e) : (t < this._minx && (this._minx = t), t > this._maxx && (this._maxx = t), e < this._miny && (this._miny = e), e > this._maxy && (this._maxy = e))
        }
    }

    minExtent() {
        if (this.isNull()) return 0;
        const t = this.getWidth(), e = this.getHeight();
        return t < e ? t : e
    }

    getWidth() {
        return this.isNull() ? 0 : this._maxx - this._minx
    }

    compareTo(t) {
        const e = t;
        return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0
    }

    translate(t, e) {
        if (this.isNull()) return null;
        this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
    }

    copy() {
        return new Kt(this)
    }

    toString() {
        return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]"
    }

    setToNull() {
        this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1
    }

    disjoint(t) {
        return this.isNull() || t.isNull() ? !0 : t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny
    }

    getHeight() {
        return this.isNull() ? 0 : this._maxy - this._miny
    }

    maxExtent() {
        if (this.isNull()) return 0;
        const t = this.getWidth(), e = this.getHeight();
        return t > e ? t : e
    }

    expandBy() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.expandBy(t, t)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            if (this.isNull()) return null;
            this._minx -= t, this._maxx += t, this._miny -= e, this._maxy += e, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull()
        }
    }

    contains() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Kt) {
                const t = arguments[0];
                return this.covers(t)
            } else if (arguments[0] instanceof F) {
                const t = arguments[0];
                return this.covers(t)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return this.covers(t, e)
        }
    }

    centre() {
        return this.isNull() ? null : new F((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
    }

    init() {
        if (arguments.length === 0) this.setToNull(); else if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
                const t = arguments[0];
                this.init(t.x, t.x, t.y, t.y)
            } else if (arguments[0] instanceof Kt) {
                const t = arguments[0];
                this._minx = t._minx, this._maxx = t._maxx, this._miny = t._miny, this._maxy = t._maxy
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.init(t.x, e.x, t.y, e.y)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            t < e ? (this._minx = t, this._maxx = e) : (this._minx = e, this._maxx = t), n < s ? (this._miny = n, this._maxy = s) : (this._miny = s, this._maxy = n)
        }
    }

    getMaxY() {
        return this._maxy
    }

    distance(t) {
        if (this.intersects(t)) return 0;
        let e = 0;
        this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
        let n = 0;
        return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), e === 0 ? n : n === 0 ? e : Math.sqrt(e * e + n * n)
    }

    hashCode() {
        let t = 17;
        return t = 37 * t + F.hashCode(this._minx), t = 37 * t + F.hashCode(this._maxx), t = 37 * t + F.hashCode(this._miny), t = 37 * t + F.hashCode(this._maxy), t
    }

    get interfaces_() {
        return [Es, Ss]
    }
}

class Xc {
    constructor(t) {
        this.str = t
    }

    append(t) {
        this.str += t
    }

    setCharAt(t, e) {
        this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
    }

    toString() {
        return this.str
    }
}

class dl {
    constructor(t) {
        this.value = t
    }

    intValue() {
        return this.value
    }

    compareTo(t) {
        return this.value < t ? -1 : this.value > t ? 1 : 0
    }

    static compare(t, e) {
        return t < e ? -1 : t > e ? 1 : 0
    }

    static isNan(t) {
        return Number.isNaN(t)
    }

    static valueOf(t) {
        return new dl(t)
    }
}

class zm {
    static isWhitespace(t) {
        return t <= 32 && t >= 0 || t === 127
    }

    static toUpperCase(t) {
        return t.toUpperCase()
    }
}

class qr extends js {
    constructor(t) {
        super(t), this.name = Object.keys({IllegalStateException: qr})[0]
    }
}

class Z {
    constructor() {
        Z.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0); else if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
                const t = arguments[0];
                this.init(t)
            } else if (arguments[0] instanceof Z) {
                const t = arguments[0];
                this.init(t)
            } else if (typeof arguments[0] == "string") {
                const t = arguments[0];
                Z.constructor_.call(this, Z.parse(t))
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.init(t, e)
        }
    }

    static determinant() {
        if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            return Z.determinant(Z.valueOf(t), Z.valueOf(e), Z.valueOf(n), Z.valueOf(s))
        } else if (arguments[3] instanceof Z && arguments[2] instanceof Z && arguments[0] instanceof Z && arguments[1] instanceof Z) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            return t.multiply(s).selfSubtract(e.multiply(n))
        }
    }

    static sqr(t) {
        return Z.valueOf(t).selfMultiply(t)
    }

    static valueOf() {
        if (typeof arguments[0] == "string") {
            const t = arguments[0];
            return Z.parse(t)
        } else if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return new Z(t)
        }
    }

    static sqrt(t) {
        return Z.valueOf(t).sqrt()
    }

    static parse(t) {
        let e = 0;
        const n = t.length;
        for (; zm.isWhitespace(t.charAt(e));) e++;
        let s = !1;
        if (e < n) {
            const d = t.charAt(e);
            (d === "-" || d === "+") && (e++, d === "-" && (s = !0))
        }
        const r = new Z;
        let o = 0, a = 0, l = 0, c = !1;
        for (; !(e >= n);) {
            const d = t.charAt(e);
            if (e++, zm.isDigit(d)) {
                const f = d - "0";
                r.selfMultiply(Z.TEN), r.selfAdd(f), o++;
                continue
            }
            if (d === ".") {
                a = o, c = !0;
                continue
            }
            if (d === "e" || d === "E") {
                const f = t.substring(e);
                try {
                    l = dl.parseInt(f)
                } catch (g) {
                    throw g instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + f + " in string " + t) : g
                } finally {
                }
                break
            }
            throw new NumberFormatException("Unexpected character '" + d + "' at position " + e + " in string " + t)
        }
        let h = r;
        c || (a = o);
        const u = o - a - l;
        if (u === 0) h = r; else if (u > 0) {
            const d = Z.TEN.pow(u);
            h = r.divide(d)
        } else if (u < 0) {
            const d = Z.TEN.pow(-u);
            h = r.multiply(d)
        }
        return s ? h.negate() : h
    }

    static createNaN() {
        return new Z(St.NaN, St.NaN)
    }

    static copy(t) {
        return new Z(t)
    }

    static magnitude(t) {
        const e = Math.abs(t), n = Math.log(e) / Math.log(10);
        let s = Math.trunc(Math.floor(n));
        return Math.pow(10, s) * 10 <= e && (s += 1), s
    }

    static stringOfChar(t, e) {
        const n = new Xc;
        for (let s = 0; s < e; s++) n.append(t);
        return n.toString()
    }

    le(t) {
        return this._hi < t._hi || this._hi === t._hi && this._lo <= t._lo
    }

    extractSignificantDigits(t, e) {
        let n = this.abs(), s = Z.magnitude(n._hi);
        const r = Z.TEN.pow(s);
        n = n.divide(r), n.gt(Z.TEN) ? (n = n.divide(Z.TEN), s += 1) : n.lt(Z.ONE) && (n = n.multiply(Z.TEN), s -= 1);
        const o = s + 1, a = new Xc, l = Z.MAX_PRINT_DIGITS - 1;
        for (let c = 0; c <= l; c++) {
            t && c === o && a.append(".");
            const h = Math.trunc(n._hi);
            if (h < 0) break;
            let u = !1, d = 0;
            h > 9 ? (u = !0, d = "9") : d = "0" + h, a.append(d), n = n.subtract(Z.valueOf(h)).multiply(Z.TEN), u && n.selfAdd(Z.TEN);
            let f = !0;
            const g = Z.magnitude(n._hi);
            if (g < 0 && Math.abs(g) >= l - c && (f = !1), !f) break
        }
        return e[0] = s, a.toString()
    }

    sqr() {
        return this.multiply(this)
    }

    doubleValue() {
        return this._hi + this._lo
    }

    subtract() {
        if (arguments[0] instanceof Z) {
            const t = arguments[0];
            return this.add(t.negate())
        } else if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return this.add(-t)
        }
    }

    equals() {
        if (arguments.length === 1 && arguments[0] instanceof Z) {
            const t = arguments[0];
            return this._hi === t._hi && this._lo === t._lo
        }
    }

    isZero() {
        return this._hi === 0 && this._lo === 0
    }

    selfSubtract() {
        if (arguments[0] instanceof Z) {
            const t = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo)
        } else if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t, 0)
        }
    }

    getSpecialNumberString() {
        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
    }

    min(t) {
        return this.le(t) ? this : t
    }

    selfDivide() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Z) {
                const t = arguments[0];
                return this.selfDivide(t._hi, t._lo)
            } else if (typeof arguments[0] == "number") {
                const t = arguments[0];
                return this.selfDivide(t, 0)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            let n = null, s = null, r = null, o = null, a = null, l = null, c = null, h = null;
            return a = this._hi / t, l = Z.SPLIT * a, n = l - a, h = Z.SPLIT * t, n = l - n, s = a - n, r = h - t, c = a * t, r = h - r, o = t - r, h = n * r - c + n * o + s * r + s * o, l = (this._hi - c - h + this._lo - a * e) / t, h = a + l, this._hi = h, this._lo = a - h + l, this
        }
    }

    dump() {
        return "DD<" + this._hi + ", " + this._lo + ">"
    }

    divide() {
        if (arguments[0] instanceof Z) {
            const t = arguments[0];
            let e = null, n = null, s = null, r = null, o = null, a = null, l = null, c = null;
            o = this._hi / t._hi, a = Z.SPLIT * o, e = a - o, c = Z.SPLIT * t._hi, e = a - e, n = o - e, s = c - t._hi, l = o * t._hi, s = c - s, r = t._hi - s, c = e * s - l + e * r + n * s + n * r, a = (this._hi - l - c + this._lo - o * t._lo) / t._hi, c = o + a;
            const h = c, u = o - c + a;
            return new Z(h, u)
        } else if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return St.isNaN(t) ? Z.createNaN() : Z.copy(this).selfDivide(t, 0)
        }
    }

    ge(t) {
        return this._hi > t._hi || this._hi === t._hi && this._lo >= t._lo
    }

    pow(t) {
        if (t === 0) return Z.valueOf(1);
        let e = new Z(this), n = Z.valueOf(1), s = Math.abs(t);
        if (s > 1) for (; s > 0;) s % 2 === 1 && n.selfMultiply(e), s /= 2, s > 0 && (e = e.sqr()); else n = e;
        return t < 0 ? n.reciprocal() : n
    }

    ceil() {
        if (this.isNaN()) return Z.NaN;
        const t = Math.ceil(this._hi);
        let e = 0;
        return t === this._hi && (e = Math.ceil(this._lo)), new Z(t, e)
    }

    compareTo(t) {
        const e = t;
        return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0
    }

    rint() {
        return this.isNaN() ? this : this.add(.5).floor()
    }

    setValue() {
        if (arguments[0] instanceof Z) {
            const t = arguments[0];
            return this.init(t), this
        } else if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return this.init(t), this
        }
    }

    max(t) {
        return this.ge(t) ? this : t
    }

    sqrt() {
        if (this.isZero()) return Z.valueOf(0);
        if (this.isNegative()) return Z.NaN;
        const t = 1 / Math.sqrt(this._hi), e = this._hi * t, n = Z.valueOf(e),
            r = this.subtract(n.sqr())._hi * (t * .5);
        return n.add(r)
    }

    selfAdd() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Z) {
                const t = arguments[0];
                return this.selfAdd(t._hi, t._lo)
            } else if (typeof arguments[0] == "number") {
                const t = arguments[0];
                let e = null, n = null, s = null, r = null, o = null, a = null;
                return s = this._hi + t, o = s - this._hi, r = s - o, r = t - o + (this._hi - r), a = r + this._lo, e = s + a, n = a + (s - e), this._hi = e + n, this._lo = n + (e - this._hi), this
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            let n = null, s = null, r = null, o = null, a = null, l = null, c = null, h = null;
            a = this._hi + t, r = this._lo + e, c = a - this._hi, h = r - this._lo, l = a - c, o = r - h, l = t - c + (this._hi - l), o = e - h + (this._lo - o), c = l + r, n = a + c, s = c + (a - n), c = o + s;
            const u = n + c, d = c + (n - u);
            return this._hi = u, this._lo = d, this
        }
    }

    selfMultiply() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Z) {
                const t = arguments[0];
                return this.selfMultiply(t._hi, t._lo)
            } else if (typeof arguments[0] == "number") {
                const t = arguments[0];
                return this.selfMultiply(t, 0)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            let n = null, s = null, r = null, o = null, a = null, l = null;
            a = Z.SPLIT * this._hi, n = a - this._hi, l = Z.SPLIT * t, n = a - n, s = this._hi - n, r = l - t, a = this._hi * t, r = l - r, o = t - r, l = n * r - a + n * o + s * r + s * o + (this._hi * e + this._lo * t);
            const c = a + l;
            n = a - c;
            const h = l + n;
            return this._hi = c, this._lo = h, this
        }
    }

    selfSqr() {
        return this.selfMultiply(this)
    }

    floor() {
        if (this.isNaN()) return Z.NaN;
        const t = Math.floor(this._hi);
        let e = 0;
        return t === this._hi && (e = Math.floor(this._lo)), new Z(t, e)
    }

    negate() {
        return this.isNaN() ? this : new Z(-this._hi, -this._lo)
    }

    clone() {
        try {
            return null
        } catch (t) {
            if (t instanceof CloneNotSupportedException) return null;
            throw t
        } finally {
        }
    }

    multiply() {
        if (arguments[0] instanceof Z) {
            const t = arguments[0];
            return t.isNaN() ? Z.createNaN() : Z.copy(this).selfMultiply(t)
        } else if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return St.isNaN(t) ? Z.createNaN() : Z.copy(this).selfMultiply(t, 0)
        }
    }

    isNaN() {
        return St.isNaN(this._hi)
    }

    intValue() {
        return Math.trunc(this._hi)
    }

    toString() {
        const t = Z.magnitude(this._hi);
        return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation()
    }

    toStandardNotation() {
        const t = this.getSpecialNumberString();
        if (t !== null) return t;
        const e = new Array(1).fill(null), n = this.extractSignificantDigits(!0, e), s = e[0] + 1;
        let r = n;
        if (n.charAt(0) === ".") r = "0" + n; else if (s < 0) r = "0." + Z.stringOfChar("0", -s) + n; else if (n.indexOf(".") === -1) {
            const o = s - n.length, a = Z.stringOfChar("0", o);
            r = n + a + ".0"
        }
        return this.isNegative() ? "-" + r : r
    }

    reciprocal() {
        let t = null, e = null, n = null, s = null, r = null, o = null, a = null, l = null;
        r = 1 / this._hi, o = Z.SPLIT * r, t = o - r, l = Z.SPLIT * this._hi, t = o - t, e = r - t, n = l - this._hi, a = r * this._hi, n = l - n, s = this._hi - n, l = t * n - a + t * s + e * n + e * s, o = (1 - a - l - r * this._lo) / this._hi;
        const c = r + o, h = r - c + o;
        return new Z(c, h)
    }

    toSciNotation() {
        if (this.isZero()) return Z.SCI_NOT_ZERO;
        const t = this.getSpecialNumberString();
        if (t !== null) return t;
        const e = new Array(1).fill(null), n = this.extractSignificantDigits(!1, e), s = Z.SCI_NOT_EXPONENT_CHAR + e[0];
        if (n.charAt(0) === "0") throw new qr("Found leading zero: " + n);
        let r = "";
        n.length > 1 && (r = n.substring(1));
        const o = n.charAt(0) + "." + r;
        return this.isNegative() ? "-" + o + s : o + s
    }

    abs() {
        return this.isNaN() ? Z.NaN : this.isNegative() ? this.negate() : new Z(this)
    }

    isPositive() {
        return this._hi > 0 || this._hi === 0 && this._lo > 0
    }

    lt(t) {
        return this._hi < t._hi || this._hi === t._hi && this._lo < t._lo
    }

    add() {
        if (arguments[0] instanceof Z) {
            const t = arguments[0];
            return Z.copy(this).selfAdd(t)
        } else if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return Z.copy(this).selfAdd(t)
        }
    }

    init() {
        if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
                const t = arguments[0];
                this._hi = t, this._lo = 0
            } else if (arguments[0] instanceof Z) {
                const t = arguments[0];
                this._hi = t._hi, this._lo = t._lo
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._hi = t, this._lo = e
        }
    }

    gt(t) {
        return this._hi > t._hi || this._hi === t._hi && this._lo > t._lo
    }

    isNegative() {
        return this._hi < 0 || this._hi === 0 && this._lo < 0
    }

    trunc() {
        return this.isNaN() ? Z.NaN : this.isPositive() ? this.floor() : this.ceil()
    }

    signum() {
        return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0
    }

    get interfaces_() {
        return [Ss, Es, Ph]
    }
}

Z.PI = new Z(3.141592653589793, 12246467991473532e-32);
Z.TWO_PI = new Z(6.283185307179586, 24492935982947064e-32);
Z.PI_2 = new Z(1.5707963267948966, 6123233995736766e-32);
Z.E = new Z(2.718281828459045, 14456468917292502e-32);
Z.NaN = new Z(St.NaN, St.NaN);
Z.EPS = 123259516440783e-46;
Z.SPLIT = 134217729;
Z.MAX_PRINT_DIGITS = 32;
Z.TEN = Z.valueOf(10);
Z.ONE = Z.valueOf(1);
Z.SCI_NOT_EXPONENT_CHAR = "E";
Z.SCI_NOT_ZERO = "0.0E0";

class Mi {
    static orientationIndex(t, e, n) {
        const s = Mi.orientationIndexFilter(t, e, n);
        if (s <= 1) return s;
        const r = Z.valueOf(e.x).selfAdd(-t.x), o = Z.valueOf(e.y).selfAdd(-t.y), a = Z.valueOf(n.x).selfAdd(-e.x),
            l = Z.valueOf(n.y).selfAdd(-e.y);
        return r.selfMultiply(l).selfSubtract(o.selfMultiply(a)).signum()
    }

    static signOfDet2x2() {
        if (arguments[3] instanceof Z && arguments[2] instanceof Z && arguments[0] instanceof Z && arguments[1] instanceof Z) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            return t.multiply(s).selfSubtract(e.multiply(n)).signum()
        } else if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = Z.valueOf(t),
                o = Z.valueOf(e), a = Z.valueOf(n), l = Z.valueOf(s);
            return r.multiply(l).selfSubtract(o.multiply(a)).signum()
        }
    }

    static intersection(t, e, n, s) {
        const r = new Z(t.y).selfSubtract(e.y), o = new Z(e.x).selfSubtract(t.x),
            a = new Z(t.x).selfMultiply(e.y).selfSubtract(new Z(e.x).selfMultiply(t.y)),
            l = new Z(n.y).selfSubtract(s.y), c = new Z(s.x).selfSubtract(n.x),
            h = new Z(n.x).selfMultiply(s.y).selfSubtract(new Z(s.x).selfMultiply(n.y)),
            u = o.multiply(h).selfSubtract(c.multiply(a)), d = l.multiply(a).selfSubtract(r.multiply(h)),
            f = r.multiply(c).selfSubtract(l.multiply(o)), g = u.selfDivide(f).doubleValue(),
            m = d.selfDivide(f).doubleValue();
        return St.isNaN(g) || St.isInfinite(g) || St.isNaN(m) || St.isInfinite(m) ? null : new F(g, m)
    }

    static orientationIndexFilter(t, e, n) {
        let s = null;
        const r = (t.x - n.x) * (e.y - n.y), o = (t.y - n.y) * (e.x - n.x), a = r - o;
        if (r > 0) {
            if (o <= 0) return Mi.signum(a);
            s = r + o
        } else if (r < 0) {
            if (o >= 0) return Mi.signum(a);
            s = -r - o
        } else return Mi.signum(a);
        const l = Mi.DP_SAFE_EPSILON * s;
        return a >= l || -a >= l ? Mi.signum(a) : 2
    }

    static signum(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
    }
}

Mi.DP_SAFE_EPSILON = 1e-15;

class pe {
    getM(t) {
        if (this.hasM()) {
            const e = this.getDimension() - this.getMeasures();
            return this.getOrdinate(t, e)
        } else return St.NaN
    }

    setOrdinate(t, e, n) {
    }

    getZ(t) {
        return this.hasZ() ? this.getOrdinate(t, 2) : St.NaN
    }

    size() {
    }

    getOrdinate(t, e) {
    }

    getCoordinate() {
    }

    getCoordinateCopy(t) {
    }

    createCoordinate() {
    }

    getDimension() {
    }

    hasM() {
        return this.getMeasures() > 0
    }

    getX(t) {
    }

    hasZ() {
        return this.getDimension() - this.getMeasures() > 2
    }

    getMeasures() {
        return 0
    }

    expandEnvelope(t) {
    }

    copy() {
    }

    getY(t) {
    }

    toCoordinateArray() {
    }

    get interfaces_() {
        return [Ph]
    }
}

pe.X = 0;
pe.Y = 1;
pe.Z = 2;
pe.M = 3;

class Dt {
    static index(t, e, n) {
        return Mi.orientationIndex(t, e, n)
    }

    static isCCW() {
        if (arguments[0] instanceof Array) {
            const t = arguments[0], e = t.length - 1;
            if (e < 3) throw new jt("Ring has fewer than 4 points, so orientation cannot be determined");
            let n = t[0], s = 0;
            for (let u = 1; u <= e; u++) {
                const d = t[u];
                d.y > n.y && (n = d, s = u)
            }
            let r = s;
            do r = r - 1, r < 0 && (r = e); while (t[r].equals2D(n) && r !== s);
            let o = s;
            do o = (o + 1) % e; while (t[o].equals2D(n) && o !== s);
            const a = t[r], l = t[o];
            if (a.equals2D(n) || l.equals2D(n) || a.equals2D(l)) return !1;
            const c = Dt.index(a, n, l);
            let h = null;
            return c === 0 ? h = a.x > l.x : h = c > 0, h
        } else if (At(arguments[0], pe)) {
            const t = arguments[0], e = t.size() - 1;
            if (e < 3) throw new jt("Ring has fewer than 4 points, so orientation cannot be determined");
            let n = t.getCoordinate(0), s = 0;
            for (let u = 1; u <= e; u++) {
                const d = t.getCoordinate(u);
                d.y > n.y && (n = d, s = u)
            }
            let r = null, o = s;
            do o = o - 1, o < 0 && (o = e), r = t.getCoordinate(o); while (r.equals2D(n) && o !== s);
            let a = null, l = s;
            do l = (l + 1) % e, a = t.getCoordinate(l); while (a.equals2D(n) && l !== s);
            if (r.equals2D(n) || a.equals2D(n) || r.equals2D(a)) return !1;
            const c = Dt.index(r, n, a);
            let h = null;
            return c === 0 ? h = r.x > a.x : h = c > 0, h
        }
    }
}

Dt.CLOCKWISE = -1;
Dt.RIGHT = Dt.CLOCKWISE;
Dt.COUNTERCLOCKWISE = 1;
Dt.LEFT = Dt.COUNTERCLOCKWISE;
Dt.COLLINEAR = 0;
Dt.STRAIGHT = Dt.COLLINEAR;

class Q0 {
    static intersection(t, e, n, s) {
        const r = t.x < e.x ? t.x : e.x, o = t.y < e.y ? t.y : e.y, a = t.x > e.x ? t.x : e.x,
            l = t.y > e.y ? t.y : e.y, c = n.x < s.x ? n.x : s.x, h = n.y < s.y ? n.y : s.y, u = n.x > s.x ? n.x : s.x,
            d = n.y > s.y ? n.y : s.y, f = r > c ? r : c, g = a < u ? a : u, m = o > h ? o : h, p = l < d ? l : d,
            _ = (f + g) / 2, x = (m + p) / 2, y = t.x - _, v = t.y - x, w = e.x - _, E = e.y - x, S = n.x - _,
            b = n.y - x, M = s.x - _, I = s.y - x, N = v - E, B = w - y, D = y * E - w * v, L = b - I, k = M - S,
            G = S * I - M * b, Q = B * G - k * D, q = L * D - N * G, at = N * k - L * B, lt = Q / at, wt = q / at;
        return St.isNaN(lt) || St.isInfinite(lt) || St.isNaN(wt) || St.isInfinite(wt) ? null : new F(lt + _, wt + x)
    }
}

class ws {
    static arraycopy(t, e, n, s, r) {
        let o = 0;
        for (let a = e; a < e + r; a++) n[s + o] = t[a], o++
    }

    static getProperty(t) {
        return {
            "line.separator": `
`
        }[t]
    }
}

class Vo {
    static log10(t) {
        const e = Math.log(t);
        return St.isInfinite(e) || St.isNaN(e) ? e : e / Vo.LOG_10
    }

    static min(t, e, n, s) {
        let r = t;
        return e < r && (r = e), n < r && (r = n), s < r && (r = s), r
    }

    static clamp() {
        if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            return t < e ? e : t > n ? n : t
        } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            return t < e ? e : t > n ? n : t
        }
    }

    static wrap(t, e) {
        return t < 0 ? e - -t % e : t % e
    }

    static max() {
        if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            let s = t;
            return e > s && (s = e), n > s && (s = n), s
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            let r = t;
            return e > r && (r = e), n > r && (r = n), s > r && (r = s), r
        }
    }

    static average(t, e) {
        return (t + e) / 2
    }
}

Vo.LOG_10 = Math.log(10);

class vn {
    static segmentToSegment(t, e, n, s) {
        if (t.equals(e)) return vn.pointToSegment(t, n, s);
        if (n.equals(s)) return vn.pointToSegment(s, t, e);
        let r = !1;
        if (!Kt.intersects(t, e, n, s)) r = !0; else {
            const o = (e.x - t.x) * (s.y - n.y) - (e.y - t.y) * (s.x - n.x);
            if (o === 0) r = !0; else {
                const a = (t.y - n.y) * (s.x - n.x) - (t.x - n.x) * (s.y - n.y),
                    c = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / o, h = a / o;
                (h < 0 || h > 1 || c < 0 || c > 1) && (r = !0)
            }
        }
        return r ? Vo.min(vn.pointToSegment(t, n, s), vn.pointToSegment(e, n, s), vn.pointToSegment(n, t, e), vn.pointToSegment(s, t, e)) : 0
    }

    static pointToSegment(t, e, n) {
        if (e.x === n.x && e.y === n.y) return t.distance(e);
        const s = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
            r = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / s;
        if (r <= 0) return t.distance(e);
        if (r >= 1) return t.distance(n);
        const o = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / s;
        return Math.abs(o) * Math.sqrt(s)
    }

    static pointToLinePerpendicular(t, e, n) {
        const s = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
            r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / s;
        return Math.abs(r) * Math.sqrt(s)
    }

    static pointToSegmentString(t, e) {
        if (e.length === 0) throw new jt("Line array must contain at least one vertex");
        let n = t.distance(e[0]);
        for (let s = 0; s < e.length - 1; s++) {
            const r = vn.pointToSegment(t, e[s], e[s + 1]);
            r < n && (n = r)
        }
        return n
    }
}

class LS {
    create() {
        if (arguments.length === 1) arguments[0] instanceof Array || At(arguments[0], pe); else if (arguments.length !== 2) {
            if (arguments.length === 3) {
                const t = arguments[0], e = arguments[1];
                return this.create(t, e)
            }
        }
    }
}

class Ol {
    filter(t) {
    }
}

class it {
    constructor() {
        it.constructor_.apply(this, arguments)
    }

    isGeometryCollection() {
        return this.getTypeCode() === it.TYPECODE_GEOMETRYCOLLECTION
    }

    getFactory() {
        return this._factory
    }

    getGeometryN(t) {
        return this
    }

    getArea() {
        return 0
    }

    isRectangle() {
        return !1
    }

    equalsExact(t) {
        return this === t || this.equalsExact(t, 0)
    }

    geometryChanged() {
        this.apply(it.geometryChangedFilter)
    }

    geometryChangedAction() {
        this._envelope = null
    }

    equalsNorm(t) {
        return t === null ? !1 : this.norm().equalsExact(t.norm())
    }

    getLength() {
        return 0
    }

    getNumGeometries() {
        return 1
    }

    compareTo() {
        let t;
        if (arguments.length === 1) {
            const e = arguments[0];
            return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e)
        } else if (arguments.length === 2) {
            const e = arguments[0], n = arguments[1];
            return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e, n)
        }
    }

    getUserData() {
        return this._userData
    }

    getSRID() {
        return this._SRID
    }

    getEnvelope() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal())
    }

    static checkNotGeometryCollection(t) {
        if (t.getTypeCode() === it.TYPECODE_GEOMETRYCOLLECTION) throw new jt("This method does not support GeometryCollection arguments")
    }

    equal(t, e, n) {
        return n === 0 ? t.equals(e) : t.distance(e) <= n
    }

    norm() {
        const t = this.copy();
        return t.normalize(), t
    }

    reverse() {
        const t = this.reverseInternal();
        return this.envelope != null && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t
    }

    copy() {
        const t = this.copyInternal();
        return t.envelope = this._envelope == null ? null : this._envelope.copy(), t._SRID = this._SRID, t._userData = this._userData, t
    }

    getPrecisionModel() {
        return this._factory.getPrecisionModel()
    }

    getEnvelopeInternal() {
        return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new Kt(this._envelope)
    }

    setSRID(t) {
        this._SRID = t
    }

    setUserData(t) {
        this._userData = t
    }

    compare(t, e) {
        const n = t.iterator(), s = e.iterator();
        for (; n.hasNext() && s.hasNext();) {
            const r = n.next(), o = s.next(), a = r.compareTo(o);
            if (a !== 0) return a
        }
        return n.hasNext() ? 1 : s.hasNext() ? -1 : 0
    }

    hashCode() {
        return this.getEnvelopeInternal().hashCode()
    }

    isEquivalentClass(t) {
        return this.getClass() === t.getClass()
    }

    isGeometryCollectionOrDerived() {
        return this.getTypeCode() === it.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === it.TYPECODE_MULTIPOINT || this.getTypeCode() === it.TYPECODE_MULTILINESTRING || this.getTypeCode() === it.TYPECODE_MULTIPOLYGON
    }

    get interfaces_() {
        return [Ph, Es, Ss]
    }

    getClass() {
        return it
    }

    static hasNonEmptyElements(t) {
        for (let e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;
        return !1
    }

    static hasNullElements(t) {
        for (let e = 0; e < t.length; e++) if (t[e] === null) return !0;
        return !1
    }
}

it.constructor_ = function (i) {
    i && (this._envelope = null, this._userData = null, this._factory = i, this._SRID = i.getSRID())
};
it.TYPECODE_POINT = 0;
it.TYPECODE_MULTIPOINT = 1;
it.TYPECODE_LINESTRING = 2;
it.TYPECODE_LINEARRING = 3;
it.TYPECODE_MULTILINESTRING = 4;
it.TYPECODE_POLYGON = 5;
it.TYPECODE_MULTIPOLYGON = 6;
it.TYPECODE_GEOMETRYCOLLECTION = 7;
it.TYPENAME_POINT = "Point";
it.TYPENAME_MULTIPOINT = "MultiPoint";
it.TYPENAME_LINESTRING = "LineString";
it.TYPENAME_LINEARRING = "LinearRing";
it.TYPENAME_MULTILINESTRING = "MultiLineString";
it.TYPENAME_POLYGON = "Polygon";
it.TYPENAME_MULTIPOLYGON = "MultiPolygon";
it.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection";
it.geometryChangedFilter = {
    get interfaces_() {
        return [Ol]
    }, filter(i) {
        i.geometryChangedAction()
    }
};

class Dl {
    filter(t) {
    }
}

class ez {
    static ofLine(t) {
        const e = t.size();
        if (e <= 1) return 0;
        let n = 0;
        const s = new F;
        t.getCoordinate(0, s);
        let r = s.x, o = s.y;
        for (let a = 1; a < e; a++) {
            t.getCoordinate(a, s);
            const l = s.x, c = s.y, h = l - r, u = c - o;
            n += Math.sqrt(h * h + u * u), r = l, o = c
        }
        return n
    }
}

class NS {
}

class cn {
    static copyCoord(t, e, n, s) {
        const r = Math.min(t.getDimension(), n.getDimension());
        for (let o = 0; o < r; o++) n.setOrdinate(s, o, t.getOrdinate(e, o))
    }

    static isRing(t) {
        const e = t.size();
        return e === 0 ? !0 : e <= 3 ? !1 : t.getOrdinate(0, pe.X) === t.getOrdinate(e - 1, pe.X) && t.getOrdinate(0, pe.Y) === t.getOrdinate(e - 1, pe.Y)
    }

    static scroll() {
        if (arguments.length === 2) {
            if (At(arguments[0], pe) && Number.isInteger(arguments[1])) {
                const t = arguments[0], e = arguments[1];
                cn.scroll(t, e, cn.isRing(t))
            } else if (At(arguments[0], pe) && arguments[1] instanceof F) {
                const t = arguments[0], e = arguments[1], n = cn.indexOf(e, t);
                if (n <= 0) return null;
                cn.scroll(t, n)
            }
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            if (e <= 0) return null;
            const r = t.copy(), o = n ? t.size() - 1 : t.size();
            for (let a = 0; a < o; a++) for (let l = 0; l < t.getDimension(); l++) t.setOrdinate(a, l, r.getOrdinate((e + a) % o, l));
            if (n) for (let a = 0; a < t.getDimension(); a++) t.setOrdinate(o, a, t.getOrdinate(0, a))
        }
    }

    static isEqual(t, e) {
        const n = t.size(), s = e.size();
        if (n !== s) return !1;
        const r = Math.min(t.getDimension(), e.getDimension());
        for (let o = 0; o < n; o++) for (let a = 0; a < r; a++) {
            const l = t.getOrdinate(o, a), c = e.getOrdinate(o, a);
            if (t.getOrdinate(o, a) !== e.getOrdinate(o, a) && !(St.isNaN(l) && St.isNaN(c))) return !1
        }
        return !0
    }

    static minCoordinateIndex() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return cn.minCoordinateIndex(t, 0, t.size() - 1)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            let s = -1, r = null;
            for (let o = e; o <= n; o++) {
                const a = t.getCoordinate(o);
                (r === null || r.compareTo(a) > 0) && (r = a, s = o)
            }
            return s
        }
    }

    static extend(t, e, n) {
        const s = t.create(n, e.getDimension()), r = e.size();
        if (cn.copy(e, 0, s, 0, r), r > 0) for (let o = r; o < n; o++) cn.copy(e, r - 1, s, o, 1);
        return s
    }

    static reverse(t) {
        const e = t.size() - 1, n = Math.trunc(e / 2);
        for (let s = 0; s <= n; s++) cn.swap(t, s, e - s)
    }

    static swap(t, e, n) {
        if (e === n) return null;
        for (let s = 0; s < t.getDimension(); s++) {
            const r = t.getOrdinate(e, s);
            t.setOrdinate(e, s, t.getOrdinate(n, s)), t.setOrdinate(n, s, r)
        }
    }

    static copy(t, e, n, s, r) {
        for (let o = 0; o < r; o++) cn.copyCoord(t, e + o, n, s + o)
    }

    static ensureValidRing(t, e) {
        const n = e.size();
        return n === 0 ? e : n <= 3 ? cn.createClosedRing(t, e, 4) : e.getOrdinate(0, pe.X) === e.getOrdinate(n - 1, pe.X) && e.getOrdinate(0, pe.Y) === e.getOrdinate(n - 1, pe.Y) ? e : cn.createClosedRing(t, e, n + 1)
    }

    static indexOf(t, e) {
        for (let n = 0; n < e.size(); n++) if (t.x === e.getOrdinate(n, pe.X) && t.y === e.getOrdinate(n, pe.Y)) return n;
        return -1
    }

    static createClosedRing(t, e, n) {
        const s = t.create(n, e.getDimension()), r = e.size();
        cn.copy(e, 0, s, 0, r);
        for (let o = r; o < n; o++) cn.copy(e, 0, s, o, 1);
        return s
    }

    static minCoordinate(t) {
        let e = null;
        for (let n = 0; n < t.size(); n++) {
            const s = t.getCoordinate(n);
            (e === null || e.compareTo(s) > 0) && (e = s)
        }
        return e
    }
}

class Js extends js {
    constructor(t) {
        super(t), this.name = Object.keys({UnsupportedOperationException: Js})[0]
    }
}

class rt {
    static toDimensionSymbol(t) {
        switch (t) {
            case rt.FALSE:
                return rt.SYM_FALSE;
            case rt.TRUE:
                return rt.SYM_TRUE;
            case rt.DONTCARE:
                return rt.SYM_DONTCARE;
            case rt.P:
                return rt.SYM_P;
            case rt.L:
                return rt.SYM_L;
            case rt.A:
                return rt.SYM_A
        }
        throw new jt("Unknown dimension value: " + t)
    }

    static toDimensionValue(t) {
        switch (zm.toUpperCase(t)) {
            case rt.SYM_FALSE:
                return rt.FALSE;
            case rt.SYM_TRUE:
                return rt.TRUE;
            case rt.SYM_DONTCARE:
                return rt.DONTCARE;
            case rt.SYM_P:
                return rt.P;
            case rt.SYM_L:
                return rt.L;
            case rt.SYM_A:
                return rt.A
        }
        throw new jt("Unknown dimension symbol: " + t)
    }
}

rt.P = 0;
rt.L = 1;
rt.A = 2;
rt.FALSE = -1;
rt.TRUE = -2;
rt.DONTCARE = -3;
rt.SYM_FALSE = "F";
rt.SYM_TRUE = "T";
rt.SYM_DONTCARE = "*";
rt.SYM_P = "0";
rt.SYM_L = "1";
rt.SYM_A = "2";

class Jr {
    filter(t) {
    }
}

class Te extends it {
    constructor() {
        super(), Te.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._points = null, arguments.length !== 0) {
            if (arguments.length === 2) {
                const t = arguments[0], e = arguments[1];
                it.constructor_.call(this, e), this.init(t)
            }
        }
    }

    computeEnvelopeInternal() {
        return this.isEmpty() ? new Kt : this._points.expandEnvelope(new Kt)
    }

    isRing() {
        return this.isClosed() && this.isSimple()
    }

    getCoordinates() {
        return this._points.toCoordinateArray()
    }

    copyInternal() {
        return new Te(this._points.copy(), this._factory)
    }

    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
            const t = arguments[0], e = arguments[1];
            if (!this.isEquivalentClass(t)) return !1;
            const n = t;
            if (this._points.size() !== n._points.size()) return !1;
            for (let s = 0; s < this._points.size(); s++) if (!this.equal(this._points.getCoordinate(s), n._points.getCoordinate(s), e)) return !1;
            return !0
        } else return super.equalsExact.apply(this, arguments)
    }

    normalize() {
        for (let t = 0; t < Math.trunc(this._points.size() / 2); t++) {
            const e = this._points.size() - 1 - t;
            if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) {
                if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) {
                    const n = this._points.copy();
                    cn.reverse(n), this._points = n
                }
                return null
            }
        }
    }

    getCoordinate() {
        return this.isEmpty() ? null : this._points.getCoordinate(0)
    }

    getBoundaryDimension() {
        return this.isClosed() ? rt.FALSE : 0
    }

    isClosed() {
        return this.isEmpty() ? !1 : this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
    }

    reverseInternal() {
        const t = this._points.copy();
        return cn.reverse(t), this.getFactory().createLineString(t)
    }

    getEndPoint() {
        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
    }

    getTypeCode() {
        return it.TYPECODE_LINESTRING
    }

    getDimension() {
        return 1
    }

    getLength() {
        return ez.ofLine(this._points)
    }

    getNumPoints() {
        return this._points.size()
    }

    compareToSameClass() {
        if (arguments.length === 1) {
            const e = arguments[0];
            let n = 0, s = 0;
            for (; n < this._points.size() && s < e._points.size();) {
                const r = this._points.getCoordinate(n).compareTo(e._points.getCoordinate(s));
                if (r !== 0) return r;
                n++, s++
            }
            return n < this._points.size() ? 1 : s < e._points.size() ? -1 : 0
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t;
            return e.compare(this._points, n._points)
        }
    }

    apply() {
        if (At(arguments[0], Dl)) {
            const t = arguments[0];
            for (let e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e))
        } else if (At(arguments[0], Nl)) {
            const t = arguments[0];
            if (this._points.size() === 0) return null;
            for (let e = 0; e < this._points.size() && (t.filter(this._points, e), !t.isDone()); e++) ;
            t.isGeometryChanged() && this.geometryChanged()
        } else At(arguments[0], Jr) ? arguments[0].filter(this) : At(arguments[0], Ol) && arguments[0].filter(this)
    }

    getBoundary() {
        throw new Js
    }

    isEquivalentClass(t) {
        return t instanceof Te
    }

    getCoordinateN(t) {
        return this._points.getCoordinate(t)
    }

    getGeometryType() {
        return it.TYPENAME_LINESTRING
    }

    getCoordinateSequence() {
        return this._points
    }

    isEmpty() {
        return this._points.size() === 0
    }

    init(t) {
        if (t === null && (t = this.getFactory().getCoordinateSequenceFactory().create([])), t.size() === 1) throw new jt("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
        this._points = t
    }

    isCoordinate(t) {
        for (let e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;
        return !1
    }

    getStartPoint() {
        return this.isEmpty() ? null : this.getPointN(0)
    }

    getPointN(t) {
        return this.getFactory().createPoint(this._points.getCoordinate(t))
    }

    get interfaces_() {
        return [NS]
    }
}

class OS {
}

class on extends it {
    constructor() {
        super(), on.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._coordinates = null;
        const t = arguments[0], e = arguments[1];
        it.constructor_.call(this, e), this.init(t)
    }

    computeEnvelopeInternal() {
        if (this.isEmpty()) return new Kt;
        const t = new Kt;
        return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t
    }

    getCoordinates() {
        return this.isEmpty() ? [] : [this.getCoordinate()]
    }

    copyInternal() {
        return new on(this._coordinates.copy(), this._factory)
    }

    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
            const t = arguments[0], e = arguments[1];
            return this.isEquivalentClass(t) ? this.isEmpty() && t.isEmpty() ? !0 : this.isEmpty() !== t.isEmpty() ? !1 : this.equal(t.getCoordinate(), this.getCoordinate(), e) : !1
        } else return super.equalsExact.apply(this, arguments)
    }

    normalize() {
    }

    getCoordinate() {
        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null
    }

    getBoundaryDimension() {
        return rt.FALSE
    }

    reverseInternal() {
        return this.getFactory().createPoint(this._coordinates.copy())
    }

    getTypeCode() {
        return it.TYPECODE_POINT
    }

    getDimension() {
        return 0
    }

    getNumPoints() {
        return this.isEmpty() ? 0 : 1
    }

    getX() {
        if (this.getCoordinate() === null) throw new qr("getX called on empty Point");
        return this.getCoordinate().x
    }

    compareToSameClass() {
        if (arguments.length === 1) {
            const e = arguments[0];
            return this.getCoordinate().compareTo(e.getCoordinate())
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t;
            return e.compare(this._coordinates, n._coordinates)
        }
    }

    apply() {
        if (At(arguments[0], Dl)) {
            const t = arguments[0];
            if (this.isEmpty()) return null;
            t.filter(this.getCoordinate())
        } else if (At(arguments[0], Nl)) {
            const t = arguments[0];
            if (this.isEmpty()) return null;
            t.filter(this._coordinates, 0), t.isGeometryChanged() && this.geometryChanged()
        } else At(arguments[0], Jr) ? arguments[0].filter(this) : At(arguments[0], Ol) && arguments[0].filter(this)
    }

    getBoundary() {
        return this.getFactory().createGeometryCollection()
    }

    getGeometryType() {
        return it.TYPENAME_POINT
    }

    getCoordinateSequence() {
        return this._coordinates
    }

    getY() {
        if (this.getCoordinate() === null) throw new qr("getY called on empty Point");
        return this.getCoordinate().y
    }

    isEmpty() {
        return this._coordinates.size() === 0
    }

    init(t) {
        t === null && (t = this.getFactory().getCoordinateSequenceFactory().create([])), $t.isTrue(t.size() <= 1), this._coordinates = t
    }

    isSimple() {
        return !0
    }

    get interfaces_() {
        return [OS]
    }
}

class Zc {
    static ofRing() {
        if (arguments[0] instanceof Array) {
            const t = arguments[0];
            return Math.abs(Zc.ofRingSigned(t))
        } else if (At(arguments[0], pe)) {
            const t = arguments[0];
            return Math.abs(Zc.ofRingSigned(t))
        }
    }

    static ofRingSigned() {
        if (arguments[0] instanceof Array) {
            const t = arguments[0];
            if (t.length < 3) return 0;
            let e = 0;
            const n = t[0].x;
            for (let s = 1; s < t.length - 1; s++) {
                const r = t[s].x - n, o = t[s + 1].y, a = t[s - 1].y;
                e += r * (a - o)
            }
            return e / 2
        } else if (At(arguments[0], pe)) {
            const t = arguments[0], e = t.size();
            if (e < 3) return 0;
            const n = new F, s = new F, r = new F;
            t.getCoordinate(0, s), t.getCoordinate(1, r);
            const o = s.x;
            r.x -= o;
            let a = 0;
            for (let l = 1; l < e - 1; l++) n.y = s.y, s.x = r.x, s.y = r.y, t.getCoordinate(l + 1, r), r.x -= o, a += s.x * (n.y - r.y);
            return a / 2
        }
    }
}

class Fr {
    static sort() {
        const t = arguments[0];
        if (arguments.length === 1) t.sort((e, n) => e.compareTo(n)); else if (arguments.length === 2) t.sort((e, n) => arguments[1].compare(e, n)); else if (arguments.length === 3) {
            const e = t.slice(arguments[1], arguments[2]);
            e.sort();
            const n = t.slice(0, arguments[1]).concat(e, t.slice(arguments[2], t.length));
            t.splice(0, t.length);
            for (const s of n) t.push(s)
        } else if (arguments.length === 4) {
            const e = t.slice(arguments[1], arguments[2]);
            e.sort((s, r) => arguments[3].compare(s, r));
            const n = t.slice(0, arguments[1]).concat(e, t.slice(arguments[2], t.length));
            t.splice(0, t.length);
            for (const s of n) t.push(s)
        }
    }

    static asList(t) {
        const e = new ct;
        for (const n of t) e.add(n);
        return e
    }

    static copyOf(t, e) {
        return t.slice(0, e)
    }
}

class Ko {
}

class $e extends it {
    constructor() {
        super(), $e.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._shell = null, this._holes = null;
        let t = arguments[0], e = arguments[1], n = arguments[2];
        if (it.constructor_.call(this, n), t === null && (t = this.getFactory().createLinearRing()), e === null && (e = []), it.hasNullElements(e)) throw new jt("holes must not contain null elements");
        if (t.isEmpty() && it.hasNonEmptyElements(e)) throw new jt("shell is empty but holes are not");
        this._shell = t, this._holes = e
    }

    computeEnvelopeInternal() {
        return this._shell.getEnvelopeInternal()
    }

    getCoordinates() {
        if (this.isEmpty()) return [];
        const t = new Array(this.getNumPoints()).fill(null);
        let e = -1;
        const n = this._shell.getCoordinates();
        for (let s = 0; s < n.length; s++) e++, t[e] = n[s];
        for (let s = 0; s < this._holes.length; s++) {
            const r = this._holes[s].getCoordinates();
            for (let o = 0; o < r.length; o++) e++, t[e] = r[o]
        }
        return t
    }

    getArea() {
        let t = 0;
        t += Zc.ofRing(this._shell.getCoordinateSequence());
        for (let e = 0; e < this._holes.length; e++) t -= Zc.ofRing(this._holes[e].getCoordinateSequence());
        return t
    }

    copyInternal() {
        const t = this._shell.copy(), e = new Array(this._holes.length).fill(null);
        for (let n = 0; n < this._holes.length; n++) e[n] = this._holes[n].copy();
        return new $e(t, e, this._factory)
    }

    isRectangle() {
        if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return !1;
        const t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal();
        for (let r = 0; r < 5; r++) {
            const o = t.getX(r);
            if (!(o === e.getMinX() || o === e.getMaxX())) return !1;
            const a = t.getY(r);
            if (!(a === e.getMinY() || a === e.getMaxY())) return !1
        }
        let n = t.getX(0), s = t.getY(0);
        for (let r = 1; r <= 4; r++) {
            const o = t.getX(r), a = t.getY(r);
            if (o !== n === (a !== s)) return !1;
            n = o, s = a
        }
        return !0
    }

    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
            const t = arguments[0], e = arguments[1];
            if (!this.isEquivalentClass(t)) return !1;
            const n = t, s = this._shell, r = n._shell;
            if (!s.equalsExact(r, e) || this._holes.length !== n._holes.length) return !1;
            for (let o = 0; o < this._holes.length; o++) if (!this._holes[o].equalsExact(n._holes[o], e)) return !1;
            return !0
        } else return super.equalsExact.apply(this, arguments)
    }

    normalize() {
        if (arguments.length === 0) {
            this._shell = this.normalized(this._shell, !0);
            for (let t = 0; t < this._holes.length; t++) this._holes[t] = this.normalized(this._holes[t], !1);
            Fr.sort(this._holes)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            if (t.isEmpty()) return null;
            const n = t.getCoordinateSequence(), s = cn.minCoordinateIndex(n, 0, n.size() - 2);
            cn.scroll(n, s, !0), Dt.isCCW(n) === e && cn.reverse(n)
        }
    }

    getCoordinate() {
        return this._shell.getCoordinate()
    }

    getNumInteriorRing() {
        return this._holes.length
    }

    getBoundaryDimension() {
        return 1
    }

    reverseInternal() {
        const t = this.getExteriorRing().reverse(), e = new Array(this.getNumInteriorRing()).fill(null);
        for (let n = 0; n < e.length; n++) e[n] = this.getInteriorRingN(n).reverse();
        return this.getFactory().createPolygon(t, e)
    }

    getTypeCode() {
        return it.TYPECODE_POLYGON
    }

    getDimension() {
        return 2
    }

    getLength() {
        let t = 0;
        t += this._shell.getLength();
        for (let e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();
        return t
    }

    getNumPoints() {
        let t = this._shell.getNumPoints();
        for (let e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();
        return t
    }

    convexHull() {
        return this.getExteriorRing().convexHull()
    }

    normalized(t, e) {
        const n = t.copy();
        return this.normalize(n, e), n
    }

    compareToSameClass() {
        if (arguments.length === 1) {
            const t = arguments[0], e = this._shell, n = t._shell;
            return e.compareToSameClass(n)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t, s = this._shell, r = n._shell,
                o = s.compareToSameClass(r, e);
            if (o !== 0) return o;
            const a = this.getNumInteriorRing(), l = n.getNumInteriorRing();
            let c = 0;
            for (; c < a && c < l;) {
                const h = this.getInteriorRingN(c), u = n.getInteriorRingN(c), d = h.compareToSameClass(u, e);
                if (d !== 0) return d;
                c++
            }
            return c < a ? 1 : c < l ? -1 : 0
        }
    }

    apply() {
        if (At(arguments[0], Dl)) {
            const t = arguments[0];
            this._shell.apply(t);
            for (let e = 0; e < this._holes.length; e++) this._holes[e].apply(t)
        } else if (At(arguments[0], Nl)) {
            const t = arguments[0];
            if (this._shell.apply(t), !t.isDone()) for (let e = 0; e < this._holes.length && (this._holes[e].apply(t), !t.isDone()); e++) ;
            t.isGeometryChanged() && this.geometryChanged()
        } else if (At(arguments[0], Jr)) arguments[0].filter(this); else if (At(arguments[0], Ol)) {
            const t = arguments[0];
            t.filter(this), this._shell.apply(t);
            for (let e = 0; e < this._holes.length; e++) this._holes[e].apply(t)
        }
    }

    getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        const t = new Array(this._holes.length + 1).fill(null);
        t[0] = this._shell;
        for (let e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];
        return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
    }

    getGeometryType() {
        return it.TYPENAME_POLYGON
    }

    getExteriorRing() {
        return this._shell
    }

    isEmpty() {
        return this._shell.isEmpty()
    }

    getInteriorRingN(t) {
        return this._holes[t]
    }

    get interfaces_() {
        return [Ko]
    }
}

class DS extends fn {
    contains() {
    }
}

class nz extends DS {
}

class Ho extends nz {
    constructor(t) {
        super(), this.array = [], t instanceof fn && this.addAll(t)
    }

    contains(t) {
        for (const e of this.array) if (e.compareTo(t) === 0) return !0;
        return !1
    }

    add(t) {
        if (this.contains(t)) return !1;
        for (let e = 0, n = this.array.length; e < n; e++) if (this.array[e].compareTo(t) === 1) return !!this.array.splice(e, 0, t);
        return this.array.push(t), !0
    }

    addAll(t) {
        for (const e of t) this.add(e);
        return !0
    }

    remove() {
        throw new Js
    }

    size() {
        return this.array.length
    }

    isEmpty() {
        return this.array.length === 0
    }

    toArray() {
        return this.array.slice()
    }

    iterator() {
        return new sz(this.array)
    }
}

class sz {
    constructor(t) {
        this.array = t, this.position = 0
    }

    next() {
        if (this.position === this.array.length) throw new Ll;
        return this.array[this.position++]
    }

    hasNext() {
        return this.position < this.array.length
    }

    remove() {
        throw new Js
    }
}

class Ie extends it {
    constructor() {
        super(), Ie.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._geometries = null, arguments.length !== 0) {
            if (arguments.length === 2) {
                let t = arguments[0], e = arguments[1];
                if (it.constructor_.call(this, e), t === null && (t = []), it.hasNullElements(t)) throw new jt("geometries must not contain null elements");
                this._geometries = t
            }
        }
    }

    computeEnvelopeInternal() {
        const t = new Kt;
        for (let e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());
        return t
    }

    getGeometryN(t) {
        return this._geometries[t]
    }

    getCoordinates() {
        const t = new Array(this.getNumPoints()).fill(null);
        let e = -1;
        for (let n = 0; n < this._geometries.length; n++) {
            const s = this._geometries[n].getCoordinates();
            for (let r = 0; r < s.length; r++) e++, t[e] = s[r]
        }
        return t
    }

    getArea() {
        let t = 0;
        for (let e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();
        return t
    }

    copyInternal() {
        const t = new Array(this._geometries.length).fill(null);
        for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
        return new Ie(t, this._factory)
    }

    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
            const t = arguments[0], e = arguments[1];
            if (!this.isEquivalentClass(t)) return !1;
            const n = t;
            if (this._geometries.length !== n._geometries.length) return !1;
            for (let s = 0; s < this._geometries.length; s++) if (!this._geometries[s].equalsExact(n._geometries[s], e)) return !1;
            return !0
        } else return super.equalsExact.apply(this, arguments)
    }

    normalize() {
        for (let t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();
        Fr.sort(this._geometries)
    }

    getCoordinate() {
        return this.isEmpty() ? null : this._geometries[0].getCoordinate()
    }

    getBoundaryDimension() {
        let t = rt.FALSE;
        for (let e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());
        return t
    }

    reverseInternal() {
        const t = this._geometries.length, e = new ct(t);
        for (let n = 0; n < t; n++) e.add(this._geometries[n].reverse());
        return this.getFactory().buildGeometry(e)
    }

    getTypeCode() {
        return it.TYPECODE_GEOMETRYCOLLECTION
    }

    getDimension() {
        let t = rt.FALSE;
        for (let e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());
        return t
    }

    getLength() {
        let t = 0;
        for (let e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();
        return t
    }

    getNumPoints() {
        let t = 0;
        for (let e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();
        return t
    }

    getNumGeometries() {
        return this._geometries.length
    }

    compareToSameClass() {
        if (arguments.length === 1) {
            const t = arguments[0], e = new Ho(Fr.asList(this._geometries)), n = new Ho(Fr.asList(t._geometries));
            return this.compare(e, n)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t, s = this.getNumGeometries(), r = n.getNumGeometries();
            let o = 0;
            for (; o < s && o < r;) {
                const a = this.getGeometryN(o), l = n.getGeometryN(o), c = a.compareToSameClass(l, e);
                if (c !== 0) return c;
                o++
            }
            return o < s ? 1 : o < r ? -1 : 0
        }
    }

    apply() {
        if (At(arguments[0], Dl)) {
            const t = arguments[0];
            for (let e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t)
        } else if (At(arguments[0], Nl)) {
            const t = arguments[0];
            if (this._geometries.length === 0) return null;
            for (let e = 0; e < this._geometries.length && (this._geometries[e].apply(t), !t.isDone()); e++) ;
            t.isGeometryChanged() && this.geometryChanged()
        } else if (At(arguments[0], Jr)) {
            const t = arguments[0];
            t.filter(this);
            for (let e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t)
        } else if (At(arguments[0], Ol)) {
            const t = arguments[0];
            t.filter(this);
            for (let e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t)
        }
    }

    getBoundary() {
        return it.checkNotGeometryCollection(this), $t.shouldNeverReachHere(), null
    }

    getGeometryType() {
        return it.TYPENAME_GEOMETRYCOLLECTION
    }

    isEmpty() {
        for (let t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;
        return !0
    }
}

class di extends Ie {
    constructor() {
        super(), di.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0], e = arguments[1];
        Ie.constructor_.call(this, t, e)
    }

    copyInternal() {
        const t = new Array(this._geometries.length).fill(null);
        for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
        return new di(t, this._factory)
    }

    isValid() {
        return !0
    }

    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
            const t = arguments[0], e = arguments[1];
            return this.isEquivalentClass(t) ? super.equalsExact.call(this, t, e) : !1
        } else return super.equalsExact.apply(this, arguments)
    }

    getCoordinate() {
        if (arguments.length === 1 && Number.isInteger(arguments[0])) {
            const t = arguments[0];
            return this._geometries[t].getCoordinate()
        } else return super.getCoordinate.apply(this, arguments)
    }

    getBoundaryDimension() {
        return rt.FALSE
    }

    getTypeCode() {
        return it.TYPECODE_MULTIPOINT
    }

    getDimension() {
        return 0
    }

    getBoundary() {
        return this.getFactory().createGeometryCollection()
    }

    getGeometryType() {
        return it.TYPENAME_MULTIPOINT
    }

    get interfaces_() {
        return [OS]
    }
}

class Un extends Te {
    constructor() {
        super(), Un.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0], e = arguments[1];
        Te.constructor_.call(this, t, e), this.validateConstruction()
    }

    copyInternal() {
        return new Un(this._points.copy(), this._factory)
    }

    getBoundaryDimension() {
        return rt.FALSE
    }

    isClosed() {
        return this.isEmpty() ? !0 : super.isClosed.call(this)
    }

    reverseInternal() {
        const t = this._points.copy();
        return cn.reverse(t), this.getFactory().createLinearRing(t)
    }

    getTypeCode() {
        return it.TYPECODE_LINEARRING
    }

    validateConstruction() {
        if (!this.isEmpty() && !super.isClosed.call(this)) throw new jt("Points of LinearRing do not form a closed linestring");
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < Un.MINIMUM_VALID_SIZE) throw new jt("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)")
    }

    getGeometryType() {
        return it.TYPENAME_LINEARRING
    }
}

Un.MINIMUM_VALID_SIZE = 4;

class fl {
    static measures(t) {
        return t instanceof hs ? 0 : t instanceof Bn || t instanceof Fo ? 1 : (t instanceof F, 0)
    }

    static dimension(t) {
        return t instanceof hs ? 2 : t instanceof Bn ? 3 : t instanceof Fo ? 4 : (t instanceof F, 3)
    }

    static create() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return fl.create(t, 0)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return t === 2 ? new hs : t === 3 && e === 0 ? new F : t === 3 && e === 1 ? new Bn : t === 4 && e === 1 ? new Fo : new F
        }
    }
}

class ze {
    static isRing(t) {
        return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]))
    }

    static ptNotInList(t, e) {
        for (let n = 0; n < t.length; n++) {
            const s = t[n];
            if (ze.indexOf(s, e) < 0) return s
        }
        return null
    }

    static scroll(t, e) {
        const n = ze.indexOf(e, t);
        if (n < 0) return null;
        const s = new Array(t.length).fill(null);
        ws.arraycopy(t, n, s, 0, t.length - n), ws.arraycopy(t, 0, s, t.length - n, n), ws.arraycopy(s, 0, t, 0, t.length)
    }

    static equals() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            if (t === e) return !0;
            if (t === null || e === null || t.length !== e.length) return !1;
            for (let n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;
            return !0
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            if (t === e) return !0;
            if (t === null || e === null || t.length !== e.length) return !1;
            for (let s = 0; s < t.length; s++) if (n.compare(t[s], e[s]) !== 0) return !1;
            return !0
        }
    }

    static intersection(t, e) {
        const n = new ui;
        for (let s = 0; s < t.length; s++) e.intersects(t[s]) && n.add(t[s], !0);
        return n.toCoordinateArray()
    }

    static measures(t) {
        if (t === null || t.length === 0) return 0;
        let e = 0;
        for (const n of t) e = Math.max(e, fl.measures(n));
        return e
    }

    static hasRepeatedPoints(t) {
        for (let e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;
        return !1
    }

    static removeRepeatedPoints(t) {
        return ze.hasRepeatedPoints(t) ? new ui(t, !1).toCoordinateArray() : t
    }

    static reverse(t) {
        const e = t.length - 1, n = Math.trunc(e / 2);
        for (let s = 0; s <= n; s++) {
            const r = t[s];
            t[s] = t[e - s], t[e - s] = r
        }
    }

    static removeNull(t) {
        let e = 0;
        for (let r = 0; r < t.length; r++) t[r] !== null && e++;
        const n = new Array(e).fill(null);
        if (e === 0) return n;
        let s = 0;
        for (let r = 0; r < t.length; r++) t[r] !== null && (n[s++] = t[r]);
        return n
    }

    static copyDeep() {
        if (arguments.length === 1) {
            const t = arguments[0], e = new Array(t.length).fill(null);
            for (let n = 0; n < t.length; n++) e[n] = t[n].copy();
            return e
        } else if (arguments.length === 5) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = arguments[4];
            for (let o = 0; o < r; o++) n[s + o] = t[e + o].copy()
        }
    }

    static isEqualReversed(t, e) {
        for (let n = 0; n < t.length; n++) {
            const s = t[n], r = e[t.length - n - 1];
            if (s.compareTo(r) !== 0) return !1
        }
        return !0
    }

    static envelope(t) {
        const e = new Kt;
        for (let n = 0; n < t.length; n++) e.expandToInclude(t[n]);
        return e
    }

    static toCoordinateArray(t) {
        return t.toArray(ze.coordArrayType)
    }

    static dimension(t) {
        if (t === null || t.length === 0) return 3;
        let e = 0;
        for (const n of t) e = Math.max(e, fl.dimension(n));
        return e
    }

    static atLeastNCoordinatesOrNothing(t, e) {
        return e.length >= t ? e : []
    }

    static indexOf(t, e) {
        for (let n = 0; n < e.length; n++) if (t.equals(e[n])) return n;
        return -1
    }

    static increasingDirection(t) {
        for (let e = 0; e < Math.trunc(t.length / 2); e++) {
            const n = t.length - 1 - e, s = t[e].compareTo(t[n]);
            if (s !== 0) return s
        }
        return 1
    }

    static compare(t, e) {
        let n = 0;
        for (; n < t.length && n < e.length;) {
            const s = t[n].compareTo(e[n]);
            if (s !== 0) return s;
            n++
        }
        return n < e.length ? -1 : n < t.length ? 1 : 0
    }

    static minCoordinate(t) {
        let e = null;
        for (let n = 0; n < t.length; n++) (e === null || e.compareTo(t[n]) > 0) && (e = t[n]);
        return e
    }

    static extract(t, e, n) {
        e = Vo.clamp(e, 0, t.length), n = Vo.clamp(n, -1, t.length);
        let s = n - e + 1;
        n < 0 && (s = 0), e >= t.length && (s = 0), n < e && (s = 0);
        const r = new Array(s).fill(null);
        if (s === 0) return r;
        let o = 0;
        for (let a = e; a <= n; a++) r[o++] = t[a];
        return r
    }
}

class iz {
    compare(t, e) {
        const n = t, s = e;
        return ze.compare(n, s)
    }

    get interfaces_() {
        return [Kr]
    }
}

class rz {
    compare(t, e) {
        const n = t, s = e;
        if (n.length < s.length) return -1;
        if (n.length > s.length) return 1;
        if (n.length === 0) return 0;
        const r = ze.compare(n, s);
        return ze.isEqualReversed(n, s) ? 0 : r
    }

    OLDcompare(t, e) {
        const n = t, s = e;
        if (n.length < s.length) return -1;
        if (n.length > s.length) return 1;
        if (n.length === 0) return 0;
        const r = ze.increasingDirection(n), o = ze.increasingDirection(s);
        let a = r > 0 ? 0 : n.length - 1, l = o > 0 ? 0 : n.length - 1;
        for (let c = 0; c < n.length; c++) {
            const h = n[a].compareTo(s[l]);
            if (h !== 0) return h;
            a += r, l += o
        }
        return 0
    }

    get interfaces_() {
        return [Kr]
    }
}

ze.ForwardComparator = iz;
ze.BidirectionalComparator = rz;
ze.coordArrayType = new Array(0).fill(null);

class If {
    constructor(t) {
        this.str = t
    }

    append(t) {
        this.str += t
    }

    setCharAt(t, e) {
        this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
    }

    toString() {
        return this.str
    }
}

class hi {
    constructor() {
        hi.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._dimension = 3, this._measures = 0, this._coordinates = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const t = arguments[0];
                hi.constructor_.call(this, t, ze.dimension(t), ze.measures(t))
            } else if (Number.isInteger(arguments[0])) {
                const t = arguments[0];
                this._coordinates = new Array(t).fill(null);
                for (let e = 0; e < t; e++) this._coordinates[e] = new F
            } else if (At(arguments[0], pe)) {
                const t = arguments[0];
                if (t === null) return this._coordinates = new Array(0).fill(null), null;
                this._dimension = t.getDimension(), this._measures = t.getMeasures(), this._coordinates = new Array(t.size()).fill(null);
                for (let e = 0; e < this._coordinates.length; e++) this._coordinates[e] = t.getCoordinateCopy(e)
            }
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                const t = arguments[0], e = arguments[1];
                hi.constructor_.call(this, t, e, ze.measures(t))
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                const t = arguments[0], e = arguments[1];
                this._coordinates = new Array(t).fill(null), this._dimension = e;
                for (let n = 0; n < t; n++) this._coordinates[n] = fl.create(e)
            }
        } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                this._dimension = e, this._measures = n, t === null ? this._coordinates = new Array(0).fill(null) : this._coordinates = t
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                this._coordinates = new Array(t).fill(null), this._dimension = e, this._measures = n;
                for (let s = 0; s < t; s++) this._coordinates[s] = this.createCoordinate()
            }
        }
    }

    getM(t) {
        return this.hasM() ? this._coordinates[t].getM() : St.NaN
    }

    setOrdinate(t, e, n) {
        switch (e) {
            case pe.X:
                this._coordinates[t].x = n;
                break;
            case pe.Y:
                this._coordinates[t].y = n;
                break;
            default:
                this._coordinates[t].setOrdinate(e, n)
        }
    }

    getZ(t) {
        return this.hasZ() ? this._coordinates[t].getZ() : St.NaN
    }

    size() {
        return this._coordinates.length
    }

    getOrdinate(t, e) {
        switch (e) {
            case pe.X:
                return this._coordinates[t].x;
            case pe.Y:
                return this._coordinates[t].y;
            default:
                return this._coordinates[t].getOrdinate(e)
        }
    }

    getCoordinate() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return this._coordinates[t]
        } else if (arguments.length === 2) {
            const t = arguments[0];
            arguments[1].setCoordinate(this._coordinates[t])
        }
    }

    getCoordinateCopy(t) {
        const e = this.createCoordinate();
        return e.setCoordinate(this._coordinates[t]), e
    }

    createCoordinate() {
        return fl.create(this.getDimension(), this.getMeasures())
    }

    getDimension() {
        return this._dimension
    }

    getX(t) {
        return this._coordinates[t].x
    }

    getMeasures() {
        return this._measures
    }

    expandEnvelope(t) {
        for (let e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);
        return t
    }

    copy() {
        const t = new Array(this.size()).fill(null);
        for (let e = 0; e < this._coordinates.length; e++) {
            const n = this.createCoordinate();
            n.setCoordinate(this._coordinates[e]), t[e] = n
        }
        return new hi(t, this._dimension, this._measures)
    }

    toString() {
        if (this._coordinates.length > 0) {
            const t = new If(17 * this._coordinates.length);
            t.append("("), t.append(this._coordinates[0]);
            for (let e = 1; e < this._coordinates.length; e++) t.append(", "), t.append(this._coordinates[e]);
            return t.append(")"), t.toString()
        } else return "()"
    }

    getY(t) {
        return this._coordinates[t].y
    }

    toCoordinateArray() {
        return this._coordinates
    }

    get interfaces_() {
        return [pe, Ss]
    }
}

class pl {
    static instance() {
        return pl.instanceObject
    }

    readResolve() {
        return pl.instance()
    }

    create() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const t = arguments[0];
                return new hi(t)
            } else if (At(arguments[0], pe)) {
                const t = arguments[0];
                return new hi(t)
            }
        } else if (arguments.length === 2) {
            let t = arguments[0], e = arguments[1];
            return e > 3 && (e = 3), e < 2 && (e = 2), new hi(t, e)
        } else if (arguments.length === 3) {
            let t = arguments[0], e = arguments[1], n = arguments[2], s = e - n;
            return n > 1 && (n = 1), s > 3 && (s = 3), s < 2 && (s = 2), new hi(t, s + n, n)
        }
    }

    get interfaces_() {
        return [LS, Ss]
    }
}

pl.instanceObject = new pl;

class bs extends Ie {
    constructor() {
        super(), bs.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0], e = arguments[1];
        Ie.constructor_.call(this, t, e)
    }

    copyInternal() {
        const t = new Array(this._geometries.length).fill(null);
        for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
        return new bs(t, this._factory)
    }

    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
            const t = arguments[0], e = arguments[1];
            return this.isEquivalentClass(t) ? super.equalsExact.call(this, t, e) : !1
        } else return super.equalsExact.apply(this, arguments)
    }

    getBoundaryDimension() {
        return 1
    }

    getTypeCode() {
        return it.TYPECODE_MULTIPOLYGON
    }

    getDimension() {
        return 2
    }

    getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        const t = new ct;
        for (let n = 0; n < this._geometries.length; n++) {
            const r = this._geometries[n].getBoundary();
            for (let o = 0; o < r.getNumGeometries(); o++) t.add(r.getGeometryN(o))
        }
        const e = new Array(t.size()).fill(null);
        return this.getFactory().createMultiLineString(t.toArray(e))
    }

    getGeometryType() {
        return it.TYPENAME_MULTIPOLYGON
    }

    get interfaces_() {
        return [Ko]
    }
}

class FS {
    get() {
    }

    put() {
    }

    size() {
    }

    values() {
    }

    entrySet() {
    }
}

class Rh extends DS {
    constructor(t) {
        super(), this.map = new Map, t instanceof fn && this.addAll(t)
    }

    contains(t) {
        const e = t.hashCode ? t.hashCode() : t;
        return !!this.map.has(e)
    }

    add(t) {
        const e = t.hashCode ? t.hashCode() : t;
        return this.map.has(e) ? !1 : !!this.map.set(e, t)
    }

    addAll(t) {
        for (const e of t) this.add(e);
        return !0
    }

    remove() {
        throw new Js
    }

    size() {
        return this.map.size
    }

    isEmpty() {
        return this.map.size === 0
    }

    toArray() {
        return Array.from(this.map.values())
    }

    iterator() {
        return new oz(this.map)
    }

    [Symbol.iterator]() {
        return this.map
    }
}

class oz {
    constructor(t) {
        this.iterator = t.values();
        const {done: e, value: n} = this.iterator.next();
        this.done = e, this.value = n
    }

    next() {
        if (this.done) throw new Ll;
        const t = this.value, {done: e, value: n} = this.iterator.next();
        return this.done = e, this.value = n, t
    }

    hasNext() {
        return !this.done
    }

    remove() {
        throw new Js
    }
}

class zS extends FS {
    constructor() {
        super(), this.map = new Map
    }

    get(t) {
        return this.map.get(t) || null
    }

    put(t, e) {
        return this.map.set(t, e), e
    }

    values() {
        const t = new ct, e = this.map.values();
        let n = e.next();
        for (; !n.done;) t.add(n.value), n = e.next();
        return t
    }

    entrySet() {
        const t = new Rh;
        return this.map.entries().forEach(e => t.add(e)), t
    }

    size() {
        return this.map.size()
    }
}

class Pe {
    constructor() {
        Pe.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = Pe.FLOATING; else if (arguments.length === 1) {
            if (arguments[0] instanceof Li) {
                const t = arguments[0];
                this._modelType = t, t === Pe.FIXED && this.setScale(1)
            } else if (typeof arguments[0] == "number") {
                const t = arguments[0];
                this._modelType = Pe.FIXED, this.setScale(t)
            } else if (arguments[0] instanceof Pe) {
                const t = arguments[0];
                this._modelType = t._modelType, this._scale = t._scale
            }
        }
    }

    static mostPrecise(t, e) {
        return t.compareTo(e) >= 0 ? t : e
    }

    equals(t) {
        if (!(t instanceof Pe)) return !1;
        const e = t;
        return this._modelType === e._modelType && this._scale === e._scale
    }

    compareTo(t) {
        const e = t, n = this.getMaximumSignificantDigits(), s = e.getMaximumSignificantDigits();
        return dl.compare(n, s)
    }

    getScale() {
        return this._scale
    }

    isFloating() {
        return this._modelType === Pe.FLOATING || this._modelType === Pe.FLOATING_SINGLE
    }

    getType() {
        return this._modelType
    }

    toString() {
        let t = "UNKNOWN";
        return this._modelType === Pe.FLOATING ? t = "Floating" : this._modelType === Pe.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === Pe.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t
    }

    makePrecise() {
        if (typeof arguments[0] == "number") {
            const t = arguments[0];
            return St.isNaN(t) || this._modelType === Pe.FLOATING_SINGLE ? t : this._modelType === Pe.FIXED ? Math.round(t * this._scale) / this._scale : t
        } else if (arguments[0] instanceof F) {
            const t = arguments[0];
            if (this._modelType === Pe.FLOATING) return null;
            t.x = this.makePrecise(t.x), t.y = this.makePrecise(t.y)
        }
    }

    getMaximumSignificantDigits() {
        let t = 16;
        return this._modelType === Pe.FLOATING ? t = 16 : this._modelType === Pe.FLOATING_SINGLE ? t = 6 : this._modelType === Pe.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t
    }

    setScale(t) {
        this._scale = Math.abs(t)
    }

    get interfaces_() {
        return [Ss, Es]
    }
}

class Li {
    constructor() {
        Li.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._name = null;
        const t = arguments[0];
        this._name = t, Li.nameToTypeMap.put(t, this)
    }

    readResolve() {
        return Li.nameToTypeMap.get(this._name)
    }

    toString() {
        return this._name
    }

    get interfaces_() {
        return [Ss]
    }
}

Li.nameToTypeMap = new zS;
Pe.Type = Li;
Pe.FIXED = new Li("FIXED");
Pe.FLOATING = new Li("FLOATING");
Pe.FLOATING_SINGLE = new Li("FLOATING SINGLE");
Pe.maximumPreciseValue = 9007199254740992;

class Ks extends Ie {
    constructor() {
        super(), Ks.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0], e = arguments[1];
        Ie.constructor_.call(this, t, e)
    }

    copyInternal() {
        const t = new Array(this._geometries.length).fill(null);
        for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();
        return new Ks(t, this._factory)
    }

    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
            const t = arguments[0], e = arguments[1];
            return this.isEquivalentClass(t) ? super.equalsExact.call(this, t, e) : !1
        } else return super.equalsExact.apply(this, arguments)
    }

    getBoundaryDimension() {
        return this.isClosed() ? rt.FALSE : 0
    }

    isClosed() {
        if (this.isEmpty()) return !1;
        for (let t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;
        return !0
    }

    getTypeCode() {
        return it.TYPECODE_MULTILINESTRING
    }

    getDimension() {
        return 1
    }

    getBoundary() {
        throw new Js
    }

    getGeometryType() {
        return it.TYPENAME_MULTILINESTRING
    }

    get interfaces_() {
        return [NS]
    }
}

class hn {
    constructor() {
        hn.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, arguments.length === 0) hn.constructor_.call(this, new Pe, 0); else if (arguments.length === 1) {
            if (At(arguments[0], LS)) {
                const t = arguments[0];
                hn.constructor_.call(this, new Pe, 0, t)
            } else if (arguments[0] instanceof Pe) {
                const t = arguments[0];
                hn.constructor_.call(this, t, 0, hn.getDefaultCoordinateSequenceFactory())
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            hn.constructor_.call(this, t, e, hn.getDefaultCoordinateSequenceFactory())
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._precisionModel = t, this._coordinateSequenceFactory = n, this._SRID = e
        }
    }

    static toMultiPolygonArray(t) {
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static toGeometryArray(t) {
        if (t === null) return null;
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static getDefaultCoordinateSequenceFactory() {
        return pl.instance()
    }

    static toMultiLineStringArray(t) {
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static toLineStringArray(t) {
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static toMultiPointArray(t) {
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static toLinearRingArray(t) {
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static toPointArray(t) {
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static toPolygonArray(t) {
        const e = new Array(t.size()).fill(null);
        return t.toArray(e)
    }

    static createPointFromInternalCoord(t, e) {
        return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
    }

    createEmpty(t) {
        switch (t) {
            case-1:
                return this.createGeometryCollection();
            case 0:
                return this.createPoint();
            case 1:
                return this.createLineString();
            case 2:
                return this.createPolygon();
            default:
                throw new jt("Invalid dimension: " + t)
        }
    }

    toGeometry(t) {
        return t.isNull() ? this.createPoint() : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new F(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new F(t.getMinX(), t.getMinY()), new F(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new F(t.getMinX(), t.getMinY()), new F(t.getMinX(), t.getMaxY()), new F(t.getMaxX(), t.getMaxY()), new F(t.getMaxX(), t.getMinY()), new F(t.getMinX(), t.getMinY())]), null)
    }

    createLineString() {
        if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const t = arguments[0];
                return this.createLineString(t !== null ? this.getCoordinateSequenceFactory().create(t) : null)
            } else if (At(arguments[0], pe)) {
                const t = arguments[0];
                return new Te(t, this)
            }
        }
    }

    createMultiLineString() {
        if (arguments.length === 0) return new Ks(null, this);
        if (arguments.length === 1) {
            const t = arguments[0];
            return new Ks(t, this)
        }
    }

    buildGeometry(t) {
        let e = null, n = !1, s = !1;
        for (let a = t.iterator(); a.hasNext();) {
            const l = a.next(), c = l.getTypeCode();
            e === null && (e = c), c !== e && (n = !0), l instanceof Ie && (s = !0)
        }
        if (e === null) return this.createGeometryCollection();
        if (n || s) return this.createGeometryCollection(hn.toGeometryArray(t));
        const r = t.iterator().next();
        if (t.size() > 1) {
            if (r instanceof $e) return this.createMultiPolygon(hn.toPolygonArray(t));
            if (r instanceof Te) return this.createMultiLineString(hn.toLineStringArray(t));
            if (r instanceof on) return this.createMultiPoint(hn.toPointArray(t));
            $t.shouldNeverReachHere("Unhandled geometry type: " + r.getGeometryType())
        }
        return r
    }

    createMultiPointFromCoords(t) {
        return this.createMultiPoint(t !== null ? this.getCoordinateSequenceFactory().create(t) : null)
    }

    createPoint() {
        if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
            if (arguments[0] instanceof F) {
                const t = arguments[0];
                return this.createPoint(t !== null ? this.getCoordinateSequenceFactory().create([t]) : null)
            } else if (At(arguments[0], pe)) {
                const t = arguments[0];
                return new on(t, this)
            }
        }
    }

    getCoordinateSequenceFactory() {
        return this._coordinateSequenceFactory
    }

    createPolygon() {
        if (arguments.length === 0) return this.createPolygon(null, null);
        if (arguments.length === 1) {
            if (At(arguments[0], pe)) {
                const t = arguments[0];
                return this.createPolygon(this.createLinearRing(t))
            } else if (arguments[0] instanceof Array) {
                const t = arguments[0];
                return this.createPolygon(this.createLinearRing(t))
            } else if (arguments[0] instanceof Un) {
                const t = arguments[0];
                return this.createPolygon(t, null)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return new $e(t, e, this)
        }
    }

    getSRID() {
        return this._SRID
    }

    createGeometryCollection() {
        if (arguments.length === 0) return new Ie(null, this);
        if (arguments.length === 1) {
            const t = arguments[0];
            return new Ie(t, this)
        }
    }

    getPrecisionModel() {
        return this._precisionModel
    }

    createLinearRing() {
        if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const t = arguments[0];
                return this.createLinearRing(t !== null ? this.getCoordinateSequenceFactory().create(t) : null)
            } else if (At(arguments[0], pe)) {
                const t = arguments[0];
                return new Un(t, this)
            }
        }
    }

    createMultiPolygon() {
        if (arguments.length === 0) return new bs(null, this);
        if (arguments.length === 1) {
            const t = arguments[0];
            return new bs(t, this)
        }
    }

    createMultiPoint() {
        if (arguments.length === 0) return new di(null, this);
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const t = arguments[0];
                return new di(t, this)
            } else if (At(arguments[0], pe)) {
                const t = arguments[0];
                if (t === null) return this.createMultiPoint(new Array(0).fill(null));
                const e = new Array(t.size()).fill(null);
                for (let n = 0; n < t.size(); n++) {
                    const s = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures());
                    cn.copy(t, n, s, 0, 1), e[n] = this.createPoint(s)
                }
                return this.createMultiPoint(e)
            }
        }
    }

    get interfaces_() {
        return [Ss]
    }
}

const va = {XY: "XY", XYZ: "XYZ", XYM: "XYM", XYZM: "XYZM"}, I1 = {
        POINT: "Point",
        LINE_STRING: "LineString",
        LINEAR_RING: "LinearRing",
        POLYGON: "Polygon",
        MULTI_POINT: "MultiPoint",
        MULTI_LINE_STRING: "MultiLineString",
        MULTI_POLYGON: "MultiPolygon",
        GEOMETRY_COLLECTION: "GeometryCollection",
        CIRCLE: "Circle"
    }, BS = "EMPTY", kS = "Z", US = "M", az = "ZM",
    Ce = {TEXT: 1, LEFT_PAREN: 2, RIGHT_PAREN: 3, NUMBER: 4, COMMA: 5, EOF: 6};
for (const i in I1) I1[i].toUpperCase();

class lz {
    constructor(t) {
        this.wkt = t, this.index_ = -1
    }

    isAlpha_(t) {
        return t >= "a" && t <= "z" || t >= "A" && t <= "Z"
    }

    isNumeric_(t, e) {
        const n = e !== void 0 ? e : !1;
        return t >= "0" && t <= "9" || t == "." && !n
    }

    isWhiteSpace_(t) {
        return t == " " || t == "	" || t == "\r" || t == `
`
    }

    nextChar_() {
        return this.wkt.charAt(++this.index_)
    }

    nextToken() {
        const t = this.nextChar_(), e = this.index_;
        let n = t, s;
        if (t == "(") s = Ce.LEFT_PAREN; else if (t == ",") s = Ce.COMMA; else if (t == ")") s = Ce.RIGHT_PAREN; else if (this.isNumeric_(t) || t == "-") s = Ce.NUMBER, n = this.readNumber_(); else if (this.isAlpha_(t)) s = Ce.TEXT, n = this.readText_(); else {
            if (this.isWhiteSpace_(t)) return this.nextToken();
            if (t === "") s = Ce.EOF; else throw new Error("Unexpected character: " + t)
        }
        return {position: e, value: n, type: s}
    }

    readNumber_() {
        let t;
        const e = this.index_;
        let n = !1, s = !1;
        do t == "." ? n = !0 : (t == "e" || t == "E") && (s = !0), t = this.nextChar_(); while (this.isNumeric_(t, n) || !s && (t == "e" || t == "E") || s && (t == "-" || t == "+"));
        return parseFloat(this.wkt.substring(e, this.index_--))
    }

    readText_() {
        let t;
        const e = this.index_;
        do t = this.nextChar_(); while (this.isAlpha_(t));
        return this.wkt.substring(e, this.index_--).toUpperCase()
    }
}

class cz {
    constructor(t, e) {
        this.lexer_ = t, this.token_, this.layout_ = va.XY, this.factory = e
    }

    consume_() {
        this.token_ = this.lexer_.nextToken()
    }

    isTokenType(t) {
        return this.token_.type == t
    }

    match(t) {
        const e = this.isTokenType(t);
        return e && this.consume_(), e
    }

    parse() {
        return this.consume_(), this.parseGeometry_()
    }

    parseGeometryLayout_() {
        let t = va.XY;
        const e = this.token_;
        if (this.isTokenType(Ce.TEXT)) {
            const n = e.value;
            n === kS ? t = va.XYZ : n === US ? t = va.XYM : n === az && (t = va.XYZM), t !== va.XY && this.consume_()
        }
        return t
    }

    parseGeometryCollectionText_() {
        if (this.match(Ce.LEFT_PAREN)) {
            const t = [];
            do t.push(this.parseGeometry_()); while (this.match(Ce.COMMA));
            if (this.match(Ce.RIGHT_PAREN)) return t
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_())
    }

    parsePointText_() {
        if (this.match(Ce.LEFT_PAREN)) {
            const t = this.parsePoint_();
            if (this.match(Ce.RIGHT_PAREN)) return t
        } else if (this.isEmptyGeometry_()) return null;
        throw new Error(this.formatErrorMessage_())
    }

    parseLineStringText_() {
        if (this.match(Ce.LEFT_PAREN)) {
            const t = this.parsePointList_();
            if (this.match(Ce.RIGHT_PAREN)) return t
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_())
    }

    parsePolygonText_() {
        if (this.match(Ce.LEFT_PAREN)) {
            const t = this.parseLineStringTextList_();
            if (this.match(Ce.RIGHT_PAREN)) return t
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_())
    }

    parseMultiPointText_() {
        if (this.match(Ce.LEFT_PAREN)) {
            let t;
            if (this.token_.type == Ce.LEFT_PAREN ? t = this.parsePointTextList_() : t = this.parsePointList_(), this.match(Ce.RIGHT_PAREN)) return t
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_())
    }

    parseMultiLineStringText_() {
        if (this.match(Ce.LEFT_PAREN)) {
            const t = this.parseLineStringTextList_();
            if (this.match(Ce.RIGHT_PAREN)) return t
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_())
    }

    parseMultiPolygonText_() {
        if (this.match(Ce.LEFT_PAREN)) {
            const t = this.parsePolygonTextList_();
            if (this.match(Ce.RIGHT_PAREN)) return t
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_())
    }

    parsePoint_() {
        const t = [], e = this.layout_.length;
        for (let n = 0; n < e; ++n) {
            const s = this.token_;
            if (this.match(Ce.NUMBER)) t.push(s.value); else break
        }
        if (t.length == e) return t;
        throw new Error(this.formatErrorMessage_())
    }

    parsePointList_() {
        const t = [this.parsePoint_()];
        for (; this.match(Ce.COMMA);) t.push(this.parsePoint_());
        return t
    }

    parsePointTextList_() {
        const t = [this.parsePointText_()];
        for (; this.match(Ce.COMMA);) t.push(this.parsePointText_());
        return t
    }

    parseLineStringTextList_() {
        const t = [this.parseLineStringText_()];
        for (; this.match(Ce.COMMA);) t.push(this.parseLineStringText_());
        return t
    }

    parsePolygonTextList_() {
        const t = [this.parsePolygonText_()];
        for (; this.match(Ce.COMMA);) t.push(this.parsePolygonText_());
        return t
    }

    isEmptyGeometry_() {
        const t = this.isTokenType(Ce.TEXT) && this.token_.value == BS;
        return t && this.consume_(), t
    }

    formatErrorMessage_() {
        return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`"
    }

    parseGeometry_() {
        const t = this.factory, e = r => new F(...r), n = r => {
            const o = r.map(a => t.createLinearRing(a.map(e)));
            return o.length > 1 ? t.createPolygon(o[0], o.slice(1)) : t.createPolygon(o[0])
        }, s = this.token_;
        if (this.match(Ce.TEXT)) {
            const r = s.value;
            if (this.layout_ = this.parseGeometryLayout_(), r == "GEOMETRYCOLLECTION") {
                const o = this.parseGeometryCollectionText_();
                return t.createGeometryCollection(o)
            } else switch (r) {
                case"POINT": {
                    const o = this.parsePointText_();
                    return o ? t.createPoint(new F(...o)) : t.createPoint()
                }
                case"LINESTRING": {
                    const a = this.parseLineStringText_().map(e);
                    return t.createLineString(a)
                }
                case"LINEARRING": {
                    const a = this.parseLineStringText_().map(e);
                    return t.createLinearRing(a)
                }
                case"POLYGON": {
                    const o = this.parsePolygonText_();
                    return !o || o.length === 0 ? t.createPolygon() : n(o)
                }
                case"MULTIPOINT": {
                    const o = this.parseMultiPointText_();
                    if (!o || o.length === 0) return t.createMultiPoint();
                    const a = o.map(e).map(l => t.createPoint(l));
                    return t.createMultiPoint(a)
                }
                case"MULTILINESTRING": {
                    const a = this.parseMultiLineStringText_().map(l => t.createLineString(l.map(e)));
                    return t.createMultiLineString(a)
                }
                case"MULTIPOLYGON": {
                    const o = this.parseMultiPolygonText_();
                    if (!o || o.length === 0) return t.createMultiPolygon();
                    const a = o.map(n);
                    return t.createMultiPolygon(a)
                }
                default:
                    throw new Error("Invalid geometry type: " + r)
            }
        }
        throw new Error(this.formatErrorMessage_())
    }
}

function GS(i) {
    if (i.isEmpty()) return "";
    const t = i.getCoordinate(), e = [t.x, t.y];
    return t.z !== void 0 && !Number.isNaN(t.z) && e.push(t.z), t.m !== void 0 && !Number.isNaN(t.m) && e.push(t.m), e.join(" ")
}

function hz(i) {
    const t = [];
    for (let e = 0, n = i.getNumGeometries(); e < n; ++e) t.push("(" + GS(i.getGeometryN(e)) + ")");
    return t.join(", ")
}

function uz(i) {
    const t = [];
    for (let e = 0, n = i.getNumGeometries(); e < n; ++e) t.push(HS(i.getGeometryN(e)));
    return t.join(", ")
}

function jc(i) {
    const t = i.getCoordinates().map(n => {
        const s = [n.x, n.y];
        return n.z !== void 0 && !Number.isNaN(n.z) && s.push(n.z), n.m !== void 0 && !Number.isNaN(n.m) && s.push(n.m), s
    }), e = [];
    for (let n = 0, s = t.length; n < s; ++n) e.push(t[n].join(" "));
    return e.join(", ")
}

function dz(i) {
    const t = [];
    for (let e = 0, n = i.getNumGeometries(); e < n; ++e) t.push("(" + jc(i.getGeometryN(e)) + ")");
    return t.join(", ")
}

function VS(i) {
    const t = [];
    t.push("(" + jc(i.getExteriorRing()) + ")");
    for (let e = 0, n = i.getNumInteriorRing(); e < n; ++e) t.push("(" + jc(i.getInteriorRingN(e)) + ")");
    return t.join(", ")
}

function fz(i) {
    const t = [];
    for (let e = 0, n = i.getNumGeometries(); e < n; ++e) t.push("(" + VS(i.getGeometryN(e)) + ")");
    return t.join(", ")
}

function pz(i) {
    let t = "";
    if (i.isEmpty()) return t;
    const e = i.getCoordinate();
    return e.z !== void 0 && !Number.isNaN(e.z) && (t += kS), e.m !== void 0 && !Number.isNaN(e.m) && (t += US), t
}

const gz = {
    Point: GS,
    LineString: jc,
    LinearRing: jc,
    Polygon: VS,
    MultiPoint: hz,
    MultiLineString: dz,
    MultiPolygon: fz,
    GeometryCollection: uz
};

function HS(i) {
    let t = i.getGeometryType();
    const e = gz[t];
    t = t.toUpperCase();
    const n = pz(i);
    if (n.length > 0 && (t += " " + n), i.isEmpty()) return t + " " + BS;
    const s = e(i);
    return t + " (" + s + ")"
}

class mz {
    constructor(t) {
        this.geometryFactory = t || new hn, this.precisionModel = this.geometryFactory.getPrecisionModel()
    }

    read(t) {
        const e = new lz(t);
        return new cz(e, this.geometryFactory).parse()
    }

    write(t) {
        return HS(t)
    }
}

class Bi {
    constructor(t) {
        this.parser = new mz(t)
    }

    write(t) {
        return this.parser.write(t)
    }

    static toLineString(t, e) {
        if (arguments.length !== 2) throw new Error("Not implemented");
        return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
    }
}

class Oe {
    constructor() {
        Oe.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._result = null, this._inputLines = Array(2).fill().map(() => Array(2)), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new F, this._intPt[1] = new F, this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0
    }

    static computeEdgeDistance(t, e, n) {
        const s = Math.abs(n.x - e.x), r = Math.abs(n.y - e.y);
        let o = -1;
        if (t.equals(e)) o = 0; else if (t.equals(n)) s > r ? o = s : o = r; else {
            const a = Math.abs(t.x - e.x), l = Math.abs(t.y - e.y);
            s > r ? o = a : o = l, o === 0 && !t.equals(e) && (o = Math.max(a, l))
        }
        return $t.isTrue(!(o === 0 && !t.equals(e)), "Bad distance calculation"), o
    }

    static nonRobustComputeEdgeDistance(t, e, n) {
        const s = t.x - e.x, r = t.y - e.y, o = Math.sqrt(s * s + r * r);
        return $t.isTrue(!(o === 0 && !t.equals(e)), "Invalid distance calculation"), o
    }

    getIndexAlongSegment(t, e) {
        return this.computeIntLineIndex(), this._intLineIndex[t][e]
    }

    getTopologySummary() {
        const t = new If;
        return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString()
    }

    computeIntersection(t, e, n, s) {
        this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = s, this._result = this.computeIntersect(t, e, n, s)
    }

    getIntersectionNum() {
        return this._result
    }

    computeIntLineIndex() {
        if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(() => Array(2)), this.computeIntLineIndex(0), this.computeIntLineIndex(1)); else if (arguments.length === 1) {
            const t = arguments[0], e = this.getEdgeDistance(t, 0), n = this.getEdgeDistance(t, 1);
            e > n ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0)
        }
    }

    isProper() {
        return this.hasIntersection() && this._isProper
    }

    setPrecisionModel(t) {
        this._precisionModel = t
    }

    isInteriorIntersection() {
        if (arguments.length === 0) return !!(this.isInteriorIntersection(0) || this.isInteriorIntersection(1));
        if (arguments.length === 1) {
            const t = arguments[0];
            for (let e = 0; e < this._result; e++) if (!(this._intPt[e].equals2D(this._inputLines[t][0]) || this._intPt[e].equals2D(this._inputLines[t][1]))) return !0;
            return !1
        }
    }

    getIntersection(t) {
        return this._intPt[t]
    }

    isEndPoint() {
        return this.hasIntersection() && !this._isProper
    }

    hasIntersection() {
        return this._result !== Oe.NO_INTERSECTION
    }

    getEdgeDistance(t, e) {
        return Oe.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1])
    }

    isCollinear() {
        return this._result === Oe.COLLINEAR_INTERSECTION
    }

    toString() {
        return Bi.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Bi.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
    }

    getEndpoint(t, e) {
        return this._inputLines[t][e]
    }

    isIntersection(t) {
        for (let e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;
        return !1
    }

    getIntersectionAlongSegment(t, e) {
        return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]]
    }
}

Oe.DONT_INTERSECT = 0;
Oe.DO_INTERSECT = 1;
Oe.COLLINEAR = 2;
Oe.NO_INTERSECTION = 0;
Oe.POINT_INTERSECTION = 1;
Oe.COLLINEAR_INTERSECTION = 2;

class Gn extends Oe {
    constructor() {
        super()
    }

    static nearestEndpoint(t, e, n, s) {
        let r = t, o = vn.pointToSegment(t, n, s), a = vn.pointToSegment(e, n, s);
        return a < o && (o = a, r = e), a = vn.pointToSegment(n, t, e), a < o && (o = a, r = n), a = vn.pointToSegment(s, t, e), a < o && (o = a, r = s), r
    }

    isInSegmentEnvelopes(t) {
        const e = new Kt(this._inputLines[0][0], this._inputLines[0][1]),
            n = new Kt(this._inputLines[1][0], this._inputLines[1][1]);
        return e.contains(t) && n.contains(t)
    }

    computeIntersection() {
        if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            if (this._isProper = !1, Kt.intersects(e, n, t) && Dt.index(e, n, t) === 0 && Dt.index(n, e, t) === 0) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this._result = Oe.POINT_INTERSECTION, null;
            this._result = Oe.NO_INTERSECTION
        } else return super.computeIntersection.apply(this, arguments)
    }

    intersection(t, e, n, s) {
        let r = this.intersectionSafe(t, e, n, s);
        return this.isInSegmentEnvelopes(r) || (r = new F(Gn.nearestEndpoint(t, e, n, s))), this._precisionModel !== null && this._precisionModel.makePrecise(r), r
    }

    checkDD(t, e, n, s, r) {
        const o = Mi.intersection(t, e, n, s), a = this.isInSegmentEnvelopes(o);
        ws.out.println("DD in env = " + a + "  --------------------- " + o), r.distance(o) > 1e-4 && ws.out.println("Distance = " + r.distance(o))
    }

    intersectionSafe(t, e, n, s) {
        let r = Q0.intersection(t, e, n, s);
        return r === null && (r = Gn.nearestEndpoint(t, e, n, s)), r
    }

    computeCollinearIntersection(t, e, n, s) {
        const r = Kt.intersects(t, e, n), o = Kt.intersects(t, e, s), a = Kt.intersects(n, s, t),
            l = Kt.intersects(n, s, e);
        return r && o ? (this._intPt[0] = n, this._intPt[1] = s, Oe.COLLINEAR_INTERSECTION) : a && l ? (this._intPt[0] = t, this._intPt[1] = e, Oe.COLLINEAR_INTERSECTION) : r && a ? (this._intPt[0] = n, this._intPt[1] = t, n.equals(t) && !o && !l ? Oe.POINT_INTERSECTION : Oe.COLLINEAR_INTERSECTION) : r && l ? (this._intPt[0] = n, this._intPt[1] = e, n.equals(e) && !o && !a ? Oe.POINT_INTERSECTION : Oe.COLLINEAR_INTERSECTION) : o && a ? (this._intPt[0] = s, this._intPt[1] = t, s.equals(t) && !r && !l ? Oe.POINT_INTERSECTION : Oe.COLLINEAR_INTERSECTION) : o && l ? (this._intPt[0] = s, this._intPt[1] = e, s.equals(e) && !r && !a ? Oe.POINT_INTERSECTION : Oe.COLLINEAR_INTERSECTION) : Oe.NO_INTERSECTION
    }

    computeIntersect(t, e, n, s) {
        if (this._isProper = !1, !Kt.intersects(t, e, n, s)) return Oe.NO_INTERSECTION;
        const r = Dt.index(t, e, n), o = Dt.index(t, e, s);
        if (r > 0 && o > 0 || r < 0 && o < 0) return Oe.NO_INTERSECTION;
        const a = Dt.index(n, s, t), l = Dt.index(n, s, e);
        return a > 0 && l > 0 || a < 0 && l < 0 ? Oe.NO_INTERSECTION : r === 0 && o === 0 && a === 0 && l === 0 ? this.computeCollinearIntersection(t, e, n, s) : (r === 0 || o === 0 || a === 0 || l === 0 ? (this._isProper = !1, t.equals2D(n) || t.equals2D(s) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(s) ? this._intPt[0] = e : r === 0 ? this._intPt[0] = new F(n) : o === 0 ? this._intPt[0] = new F(s) : a === 0 ? this._intPt[0] = new F(t) : l === 0 && (this._intPt[0] = new F(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, s)), Oe.POINT_INTERSECTION)
    }
}

class Re {
    constructor() {
        Re.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this.p0 = null, this.p1 = null, arguments.length === 0) Re.constructor_.call(this, new F, new F); else if (arguments.length === 1) {
            const t = arguments[0];
            Re.constructor_.call(this, t.p0, t.p1)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.p0 = t, this.p1 = e
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            Re.constructor_.call(this, new F(t, e), new F(n, s))
        }
    }

    static midPoint(t, e) {
        return new F((t.x + e.x) / 2, (t.y + e.y) / 2)
    }

    minX() {
        return Math.min(this.p0.x, this.p1.x)
    }

    orientationIndex() {
        if (arguments[0] instanceof Re) {
            const t = arguments[0], e = Dt.index(this.p0, this.p1, t.p0), n = Dt.index(this.p0, this.p1, t.p1);
            return e >= 0 && n >= 0 || e <= 0 && n <= 0 ? Math.max(e, n) : 0
        } else if (arguments[0] instanceof F) {
            const t = arguments[0];
            return Dt.index(this.p0, this.p1, t)
        }
    }

    toGeometry(t) {
        return t.createLineString([this.p0, this.p1])
    }

    isVertical() {
        return this.p0.x === this.p1.x
    }

    equals(t) {
        if (!(t instanceof Re)) return !1;
        const e = t;
        return this.p0.equals(e.p0) && this.p1.equals(e.p1)
    }

    intersection(t) {
        const e = new Gn;
        return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null
    }

    project() {
        if (arguments[0] instanceof F) {
            const t = arguments[0];
            if (t.equals(this.p0) || t.equals(this.p1)) return new F(t);
            const e = this.projectionFactor(t), n = new F;
            return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n
        } else if (arguments[0] instanceof Re) {
            const t = arguments[0], e = this.projectionFactor(t.p0), n = this.projectionFactor(t.p1);
            if (e >= 1 && n >= 1 || e <= 0 && n <= 0) return null;
            let s = this.project(t.p0);
            e < 0 && (s = this.p0), e > 1 && (s = this.p1);
            let r = this.project(t.p1);
            return n < 0 && (r = this.p0), n > 1 && (r = this.p1), new Re(s, r)
        }
    }

    normalize() {
        this.p1.compareTo(this.p0) < 0 && this.reverse()
    }

    angle() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
    }

    getCoordinate(t) {
        return t === 0 ? this.p0 : this.p1
    }

    distancePerpendicular(t) {
        return vn.pointToLinePerpendicular(t, this.p0, this.p1)
    }

    minY() {
        return Math.min(this.p0.y, this.p1.y)
    }

    midPoint() {
        return Re.midPoint(this.p0, this.p1)
    }

    projectionFactor(t) {
        if (t.equals(this.p0)) return 0;
        if (t.equals(this.p1)) return 1;
        const e = this.p1.x - this.p0.x, n = this.p1.y - this.p0.y, s = e * e + n * n;
        return s <= 0 ? St.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / s
    }

    closestPoints(t) {
        const e = this.intersection(t);
        if (e !== null) return [e, e];
        const n = new Array(2).fill(null);
        let s = St.MAX_VALUE, r = null;
        const o = this.closestPoint(t.p0);
        s = o.distance(t.p0), n[0] = o, n[1] = t.p0;
        const a = this.closestPoint(t.p1);
        r = a.distance(t.p1), r < s && (s = r, n[0] = a, n[1] = t.p1);
        const l = t.closestPoint(this.p0);
        r = l.distance(this.p0), r < s && (s = r, n[0] = this.p0, n[1] = l);
        const c = t.closestPoint(this.p1);
        return r = c.distance(this.p1), r < s && (s = r, n[0] = this.p1, n[1] = c), n
    }

    closestPoint(t) {
        const e = this.projectionFactor(t);
        if (e > 0 && e < 1) return this.project(t);
        const n = this.p0.distance(t), s = this.p1.distance(t);
        return n < s ? this.p0 : this.p1
    }

    maxX() {
        return Math.max(this.p0.x, this.p1.x)
    }

    getLength() {
        return this.p0.distance(this.p1)
    }

    compareTo(t) {
        const e = t, n = this.p0.compareTo(e.p0);
        return n !== 0 ? n : this.p1.compareTo(e.p1)
    }

    reverse() {
        const t = this.p0;
        this.p0 = this.p1, this.p1 = t
    }

    equalsTopo(t) {
        return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0)
    }

    lineIntersection(t) {
        return Q0.intersection(this.p0, this.p1, t.p0, t.p1)
    }

    maxY() {
        return Math.max(this.p0.y, this.p1.y)
    }

    pointAlongOffset(t, e) {
        const n = this.p0.x + t * (this.p1.x - this.p0.x), s = this.p0.y + t * (this.p1.y - this.p0.y),
            r = this.p1.x - this.p0.x, o = this.p1.y - this.p0.y, a = Math.sqrt(r * r + o * o);
        let l = 0, c = 0;
        if (e !== 0) {
            if (a <= 0) throw new qr("Cannot compute offset from zero-length line segment");
            l = e * r / a, c = e * o / a
        }
        const h = n - c, u = s + l;
        return new F(h, u)
    }

    setCoordinates() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.setCoordinates(t.p0, t.p1)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.p0.x = t.x, this.p0.y = t.y, this.p1.x = e.x, this.p1.y = e.y
        }
    }

    segmentFraction(t) {
        let e = this.projectionFactor(t);
        return e < 0 ? e = 0 : (e > 1 || St.isNaN(e)) && (e = 1), e
    }

    toString() {
        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
    }

    isHorizontal() {
        return this.p0.y === this.p1.y
    }

    reflect(t) {
        const e = this.p1.getY() - this.p0.getY(), n = this.p0.getX() - this.p1.getX(),
            s = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()),
            r = e * e + n * n, o = e * e - n * n, a = t.getX(), l = t.getY(),
            c = (-o * a - 2 * e * n * l - 2 * e * s) / r, h = (o * l - 2 * e * n * a - 2 * n * s) / r;
        return new F(c, h)
    }

    distance() {
        if (arguments[0] instanceof Re) {
            const t = arguments[0];
            return vn.segmentToSegment(this.p0, this.p1, t.p0, t.p1)
        } else if (arguments[0] instanceof F) {
            const t = arguments[0];
            return vn.pointToSegment(t, this.p0, this.p1)
        }
    }

    pointAlong(t) {
        const e = new F;
        return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e
    }

    hashCode() {
        let t = St.doubleToLongBits(this.p0.x);
        t ^= St.doubleToLongBits(this.p0.y) * 31;
        const e = Math.trunc(t) ^ Math.trunc(t >> 32);
        let n = St.doubleToLongBits(this.p1.x);
        n ^= St.doubleToLongBits(this.p1.y) * 31;
        const s = Math.trunc(n) ^ Math.trunc(n >> 32);
        return e ^ s
    }

    get interfaces_() {
        return [Es, Ss]
    }
}

class T {
    static toLocationSymbol(t) {
        switch (t) {
            case T.EXTERIOR:
                return "e";
            case T.BOUNDARY:
                return "b";
            case T.INTERIOR:
                return "i";
            case T.NONE:
                return "-"
        }
        throw new jt("Unknown location value: " + t)
    }
}

T.INTERIOR = 0;
T.BOUNDARY = 1;
T.EXTERIOR = 2;
T.NONE = -1;

class be {
    constructor() {
        be.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._matrix = null, arguments.length === 0) this._matrix = Array(3).fill().map(() => Array(3)), this.setAll(rt.FALSE); else if (arguments.length === 1) {
            if (typeof arguments[0] == "string") {
                const t = arguments[0];
                be.constructor_.call(this), this.set(t)
            } else if (arguments[0] instanceof be) {
                const t = arguments[0];
                be.constructor_.call(this), this._matrix[T.INTERIOR][T.INTERIOR] = t._matrix[T.INTERIOR][T.INTERIOR], this._matrix[T.INTERIOR][T.BOUNDARY] = t._matrix[T.INTERIOR][T.BOUNDARY], this._matrix[T.INTERIOR][T.EXTERIOR] = t._matrix[T.INTERIOR][T.EXTERIOR], this._matrix[T.BOUNDARY][T.INTERIOR] = t._matrix[T.BOUNDARY][T.INTERIOR], this._matrix[T.BOUNDARY][T.BOUNDARY] = t._matrix[T.BOUNDARY][T.BOUNDARY], this._matrix[T.BOUNDARY][T.EXTERIOR] = t._matrix[T.BOUNDARY][T.EXTERIOR], this._matrix[T.EXTERIOR][T.INTERIOR] = t._matrix[T.EXTERIOR][T.INTERIOR], this._matrix[T.EXTERIOR][T.BOUNDARY] = t._matrix[T.EXTERIOR][T.BOUNDARY], this._matrix[T.EXTERIOR][T.EXTERIOR] = t._matrix[T.EXTERIOR][T.EXTERIOR]
            }
        }
    }

    static matches() {
        if (Number.isInteger(arguments[0]) && typeof arguments[1] == "string") {
            const t = arguments[0], e = arguments[1];
            return e === rt.SYM_DONTCARE || e === rt.SYM_TRUE && (t >= 0 || t === rt.TRUE) || e === rt.SYM_FALSE && t === rt.FALSE || e === rt.SYM_P && t === rt.P || e === rt.SYM_L && t === rt.L || e === rt.SYM_A && t === rt.A
        } else if (typeof arguments[0] == "string" && typeof arguments[1] == "string") {
            const t = arguments[0], e = arguments[1];
            return new be(t).matches(e)
        }
    }

    static isTrue(t) {
        return t >= 0 || t === rt.TRUE
    }

    isIntersects() {
        return !this.isDisjoint()
    }

    isCovers() {
        return (be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) || be.isTrue(this._matrix[T.INTERIOR][T.BOUNDARY]) || be.isTrue(this._matrix[T.BOUNDARY][T.INTERIOR]) || be.isTrue(this._matrix[T.BOUNDARY][T.BOUNDARY])) && this._matrix[T.EXTERIOR][T.INTERIOR] === rt.FALSE && this._matrix[T.EXTERIOR][T.BOUNDARY] === rt.FALSE
    }

    isCoveredBy() {
        return (be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) || be.isTrue(this._matrix[T.INTERIOR][T.BOUNDARY]) || be.isTrue(this._matrix[T.BOUNDARY][T.INTERIOR]) || be.isTrue(this._matrix[T.BOUNDARY][T.BOUNDARY])) && this._matrix[T.INTERIOR][T.EXTERIOR] === rt.FALSE && this._matrix[T.BOUNDARY][T.EXTERIOR] === rt.FALSE
    }

    set() {
        if (arguments.length === 1) {
            const t = arguments[0];
            for (let e = 0; e < t.length; e++) {
                const n = Math.trunc(e / 3), s = e % 3;
                this._matrix[n][s] = rt.toDimensionValue(t.charAt(e))
            }
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._matrix[t][e] = n
        }
    }

    isContains() {
        return be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && this._matrix[T.EXTERIOR][T.INTERIOR] === rt.FALSE && this._matrix[T.EXTERIOR][T.BOUNDARY] === rt.FALSE
    }

    setAtLeast() {
        if (arguments.length === 1) {
            const t = arguments[0];
            for (let e = 0; e < t.length; e++) {
                const n = Math.trunc(e / 3), s = e % 3;
                this.setAtLeast(n, s, rt.toDimensionValue(t.charAt(e)))
            }
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._matrix[t][e] < n && (this._matrix[t][e] = n)
        }
    }

    setAtLeastIfValid(t, e, n) {
        t >= 0 && e >= 0 && this.setAtLeast(t, e, n)
    }

    isWithin() {
        return be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && this._matrix[T.INTERIOR][T.EXTERIOR] === rt.FALSE && this._matrix[T.BOUNDARY][T.EXTERIOR] === rt.FALSE
    }

    isTouches(t, e) {
        return t > e ? this.isTouches(e, t) : t === rt.A && e === rt.A || t === rt.L && e === rt.L || t === rt.L && e === rt.A || t === rt.P && e === rt.A || t === rt.P && e === rt.L ? this._matrix[T.INTERIOR][T.INTERIOR] === rt.FALSE && (be.isTrue(this._matrix[T.INTERIOR][T.BOUNDARY]) || be.isTrue(this._matrix[T.BOUNDARY][T.INTERIOR]) || be.isTrue(this._matrix[T.BOUNDARY][T.BOUNDARY])) : !1
    }

    isOverlaps(t, e) {
        return t === rt.P && e === rt.P || t === rt.A && e === rt.A ? be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && be.isTrue(this._matrix[T.INTERIOR][T.EXTERIOR]) && be.isTrue(this._matrix[T.EXTERIOR][T.INTERIOR]) : t === rt.L && e === rt.L ? this._matrix[T.INTERIOR][T.INTERIOR] === 1 && be.isTrue(this._matrix[T.INTERIOR][T.EXTERIOR]) && be.isTrue(this._matrix[T.EXTERIOR][T.INTERIOR]) : !1
    }

    isEquals(t, e) {
        return t !== e ? !1 : be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && this._matrix[T.INTERIOR][T.EXTERIOR] === rt.FALSE && this._matrix[T.BOUNDARY][T.EXTERIOR] === rt.FALSE && this._matrix[T.EXTERIOR][T.INTERIOR] === rt.FALSE && this._matrix[T.EXTERIOR][T.BOUNDARY] === rt.FALSE
    }

    toString() {
        const t = new If("123456789");
        for (let e = 0; e < 3; e++) for (let n = 0; n < 3; n++) t.setCharAt(3 * e + n, rt.toDimensionSymbol(this._matrix[e][n]));
        return t.toString()
    }

    setAll(t) {
        for (let e = 0; e < 3; e++) for (let n = 0; n < 3; n++) this._matrix[e][n] = t
    }

    get(t, e) {
        return this._matrix[t][e]
    }

    transpose() {
        let t = this._matrix[1][0];
        return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t, t = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t, t = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t, this
    }

    matches(t) {
        if (t.length !== 9) throw new jt("Should be length 9: " + t);
        for (let e = 0; e < 3; e++) for (let n = 0; n < 3; n++) if (!be.matches(this._matrix[e][n], t.charAt(3 * e + n))) return !1;
        return !0
    }

    add(t) {
        for (let e = 0; e < 3; e++) for (let n = 0; n < 3; n++) this.setAtLeast(e, n, t.get(e, n))
    }

    isDisjoint() {
        return this._matrix[T.INTERIOR][T.INTERIOR] === rt.FALSE && this._matrix[T.INTERIOR][T.BOUNDARY] === rt.FALSE && this._matrix[T.BOUNDARY][T.INTERIOR] === rt.FALSE && this._matrix[T.BOUNDARY][T.BOUNDARY] === rt.FALSE
    }

    isCrosses(t, e) {
        return t === rt.P && e === rt.L || t === rt.P && e === rt.A || t === rt.L && e === rt.A ? be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && be.isTrue(this._matrix[T.INTERIOR][T.EXTERIOR]) : t === rt.L && e === rt.P || t === rt.A && e === rt.P || t === rt.A && e === rt.L ? be.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && be.isTrue(this._matrix[T.EXTERIOR][T.INTERIOR]) : t === rt.L && e === rt.L ? this._matrix[T.INTERIOR][T.INTERIOR] === 0 : !1
    }

    get interfaces_() {
        return [Ph]
    }
}

class Se {
    static toDegrees(t) {
        return t * 180 / Math.PI
    }

    static normalize(t) {
        for (; t > Math.PI;) t -= Se.PI_TIMES_2;
        for (; t <= -Math.PI;) t += Se.PI_TIMES_2;
        return t
    }

    static angle() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return Math.atan2(t.y, t.x)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = e.x - t.x, s = e.y - t.y;
            return Math.atan2(s, n)
        }
    }

    static isAcute(t, e, n) {
        const s = t.x - e.x, r = t.y - e.y, o = n.x - e.x, a = n.y - e.y;
        return s * o + r * a > 0
    }

    static isObtuse(t, e, n) {
        const s = t.x - e.x, r = t.y - e.y, o = n.x - e.x, a = n.y - e.y;
        return s * o + r * a < 0
    }

    static interiorAngle(t, e, n) {
        const s = Se.angle(e, t), r = Se.angle(e, n);
        return Math.abs(r - s)
    }

    static normalizePositive(t) {
        if (t < 0) {
            for (; t < 0;) t += Se.PI_TIMES_2;
            t >= Se.PI_TIMES_2 && (t = 0)
        } else {
            for (; t >= Se.PI_TIMES_2;) t -= Se.PI_TIMES_2;
            t < 0 && (t = 0)
        }
        return t
    }

    static angleBetween(t, e, n) {
        const s = Se.angle(e, t), r = Se.angle(e, n);
        return Se.diff(s, r)
    }

    static diff(t, e) {
        let n = null;
        return t < e ? n = e - t : n = t - e, n > Math.PI && (n = 2 * Math.PI - n), n
    }

    static toRadians(t) {
        return t * Math.PI / 180
    }

    static getTurn(t, e) {
        const n = Math.sin(e - t);
        return n > 0 ? Se.COUNTERCLOCKWISE : n < 0 ? Se.CLOCKWISE : Se.NONE
    }

    static angleBetweenOriented(t, e, n) {
        const s = Se.angle(e, t), o = Se.angle(e, n) - s;
        return o <= -Math.PI ? o + Se.PI_TIMES_2 : o > Math.PI ? o - Se.PI_TIMES_2 : o
    }
}

Se.PI_TIMES_2 = 2 * Math.PI;
Se.PI_OVER_2 = Math.PI / 2;
Se.PI_OVER_4 = Math.PI / 4;
Se.COUNTERCLOCKWISE = Dt.COUNTERCLOCKWISE;
Se.CLOCKWISE = Dt.CLOCKWISE;
Se.NONE = Dt.COLLINEAR;

class md extends js {
    constructor() {
        super(), md.constructor_.apply(this, arguments)
    }

    static constructor_() {
        js.constructor_.call(this, "Projective point not representable on the Cartesian plane.")
    }
}

class zo {
    constructor() {
        zo.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1; else if (arguments.length === 1) {
            const t = arguments[0];
            this.x = t.x, this.y = t.y, this.w = 1
        } else if (arguments.length === 2) {
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
                const t = arguments[0], e = arguments[1];
                this.x = t, this.y = e, this.w = 1
            } else if (arguments[0] instanceof zo && arguments[1] instanceof zo) {
                const t = arguments[0], e = arguments[1];
                this.x = t.y * e.w - e.y * t.w, this.y = e.x * t.w - t.x * e.w, this.w = t.x * e.y - e.x * t.y
            } else if (arguments[0] instanceof F && arguments[1] instanceof F) {
                const t = arguments[0], e = arguments[1];
                this.x = t.y - e.y, this.y = e.x - t.x, this.w = t.x * e.y - e.x * t.y
            }
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this.x = t, this.y = e, this.w = n
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = t.y - e.y, o = e.x - t.x,
                a = t.x * e.y - e.x * t.y, l = n.y - s.y, c = s.x - n.x, h = n.x * s.y - s.x * n.y;
            this.x = o * h - c * a, this.y = l * a - r * h, this.w = r * c - l * o
        }
    }

    getY() {
        const t = this.y / this.w;
        if (St.isNaN(t) || St.isInfinite(t)) throw new md;
        return t
    }

    getX() {
        const t = this.x / this.w;
        if (St.isNaN(t) || St.isInfinite(t)) throw new md;
        return t
    }

    getCoordinate() {
        const t = new F;
        return t.x = this.getX(), t.y = this.getY(), t
    }
}

class is {
    constructor() {
        is.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.p0 = null, this.p1 = null, this.p2 = null;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this.p0 = t, this.p1 = e, this.p2 = n
    }

    static area(t, e, n) {
        return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
    }

    static signedArea(t, e, n) {
        return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
    }

    static det(t, e, n, s) {
        return t * s - e * n
    }

    static interpolateZ(t, e, n, s) {
        const r = e.x, o = e.y, a = n.x - r, l = s.x - r, c = n.y - o, h = s.y - o, u = a * h - l * c, d = t.x - r,
            f = t.y - o, g = (h * d - l * f) / u, m = (-c * d + a * f) / u;
        return e.getZ() + g * (n.getZ() - e.getZ()) + m * (s.getZ() - e.getZ())
    }

    static longestSideLength(t, e, n) {
        const s = t.distance(e), r = e.distance(n), o = n.distance(t);
        let a = s;
        return r > a && (a = r), o > a && (a = o), a
    }

    static circumcentreDD(t, e, n) {
        const s = Z.valueOf(t.x).subtract(n.x), r = Z.valueOf(t.y).subtract(n.y), o = Z.valueOf(e.x).subtract(n.x),
            a = Z.valueOf(e.y).subtract(n.y), l = Z.determinant(s, r, o, a).multiply(2), c = s.sqr().add(r.sqr()),
            h = o.sqr().add(a.sqr()), u = Z.determinant(r, c, a, h), d = Z.determinant(s, c, o, h),
            f = Z.valueOf(n.x).subtract(u.divide(l)).doubleValue(), g = Z.valueOf(n.y).add(d.divide(l)).doubleValue();
        return new F(f, g)
    }

    static isAcute(t, e, n) {
        return !(!Se.isAcute(t, e, n) || !Se.isAcute(e, n, t) || !Se.isAcute(n, t, e))
    }

    static circumcentre(t, e, n) {
        const s = n.x, r = n.y, o = t.x - s, a = t.y - r, l = e.x - s, c = e.y - r, h = 2 * is.det(o, a, l, c),
            u = is.det(a, o * o + a * a, c, l * l + c * c), d = is.det(o, o * o + a * a, l, l * l + c * c),
            f = s - u / h, g = r + d / h;
        return new F(f, g)
    }

    static perpendicularBisector(t, e) {
        const n = e.x - t.x, s = e.y - t.y, r = new zo(t.x + n / 2, t.y + s / 2, 1),
            o = new zo(t.x - s + n / 2, t.y + n + s / 2, 1);
        return new zo(r, o)
    }

    static angleBisector(t, e, n) {
        const s = e.distance(t), r = e.distance(n), o = s / (s + r), a = n.x - t.x, l = n.y - t.y;
        return new F(t.x + o * a, t.y + o * l)
    }

    static area3D(t, e, n) {
        const s = e.x - t.x, r = e.y - t.y, o = e.getZ() - t.getZ(), a = n.x - t.x, l = n.y - t.y,
            c = n.getZ() - t.getZ(), h = r * c - o * l, u = o * a - s * c, d = s * l - r * a, f = h * h + u * u + d * d;
        return Math.sqrt(f) / 2
    }

    static centroid(t, e, n) {
        const s = (t.x + e.x + n.x) / 3, r = (t.y + e.y + n.y) / 3;
        return new F(s, r)
    }

    static inCentre(t, e, n) {
        const s = e.distance(n), r = t.distance(n), o = t.distance(e), a = s + r + o,
            l = (s * t.x + r * e.x + o * n.x) / a, c = (s * t.y + r * e.y + o * n.y) / a;
        return new F(l, c)
    }

    area() {
        return is.area(this.p0, this.p1, this.p2)
    }

    signedArea() {
        return is.signedArea(this.p0, this.p1, this.p2)
    }

    interpolateZ(t) {
        if (t === null) throw new jt("Supplied point is null.");
        return is.interpolateZ(t, this.p0, this.p1, this.p2)
    }

    longestSideLength() {
        return is.longestSideLength(this.p0, this.p1, this.p2)
    }

    isAcute() {
        return is.isAcute(this.p0, this.p1, this.p2)
    }

    circumcentre() {
        return is.circumcentre(this.p0, this.p1, this.p2)
    }

    area3D() {
        return is.area3D(this.p0, this.p1, this.p2)
    }

    centroid() {
        return is.centroid(this.p0, this.p1, this.p2)
    }

    inCentre() {
        return is.inCentre(this.p0, this.p1, this.p2)
    }
}

class _d {
    constructor() {
        _d.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._mapOp = null;
        const t = arguments[0];
        this._mapOp = t
    }

    static map(t, e) {
        return new _d(e).map(t)
    }

    map(t) {
        const e = new ct;
        for (let n = 0; n < t.getNumGeometries(); n++) {
            const s = this._mapOp.map(t.getGeometryN(n));
            s.isEmpty() || e.add(s)
        }
        return t.getFactory().createGeometryCollection(hn.toGeometryArray(e))
    }
}

class ri {
    constructor() {
        ri.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null;
        const t = arguments[0];
        this._geomFactory = ri.extractFactory(t), this._inputGeoms = t
    }

    static combine() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return new ri(t).combine()
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return new ri(ri.createList(t, e)).combine()
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            return new ri(ri.createList(t, e, n)).combine()
        }
    }

    static extractFactory(t) {
        return t.isEmpty() ? null : t.iterator().next().getFactory()
    }

    static createList() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = new ct;
            return n.add(t), n.add(e), n
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = new ct;
            return s.add(t), s.add(e), s.add(n), s
        }
    }

    extractElements(t, e) {
        if (t === null) return null;
        for (let n = 0; n < t.getNumGeometries(); n++) {
            const s = t.getGeometryN(n);
            this._skipEmpty && s.isEmpty() || e.add(s)
        }
    }

    combine() {
        const t = new ct;
        for (let e = this._inputGeoms.iterator(); e.hasNext();) {
            const n = e.next();
            this.extractElements(n, t)
        }
        return t.size() === 0 ? this._geomFactory !== null ? this._geomFactory.createGeometryCollection() : null : this._geomFactory.buildGeometry(t)
    }
}

class t_ {
    constructor() {
        t_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1
    }

    transformPoint(t, e) {
        return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
    }

    transformPolygon(t, e) {
        let n = !0;
        const s = this.transformLinearRing(t.getExteriorRing(), t);
        (s === null || !(s instanceof Un) || s.isEmpty()) && (n = !1);
        const r = new ct;
        for (let o = 0; o < t.getNumInteriorRing(); o++) {
            const a = this.transformLinearRing(t.getInteriorRingN(o), t);
            a === null || a.isEmpty() || (a instanceof Un || (n = !1), r.add(a))
        }
        if (n) return this._factory.createPolygon(s, r.toArray([]));
        {
            const o = new ct;
            return s !== null && o.add(s), o.addAll(r), this._factory.buildGeometry(o)
        }
    }

    createCoordinateSequence(t) {
        return this._factory.getCoordinateSequenceFactory().create(t)
    }

    getInputGeometry() {
        return this._inputGeom
    }

    transformMultiLineString(t, e) {
        const n = new ct;
        for (let s = 0; s < t.getNumGeometries(); s++) {
            const r = this.transformLineString(t.getGeometryN(s), t);
            r !== null && (r.isEmpty() || n.add(r))
        }
        return this._factory.buildGeometry(n)
    }

    transformCoordinates(t, e) {
        return this.copy(t)
    }

    transformLineString(t, e) {
        return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
    }

    transformMultiPoint(t, e) {
        const n = new ct;
        for (let s = 0; s < t.getNumGeometries(); s++) {
            const r = this.transformPoint(t.getGeometryN(s), t);
            r !== null && (r.isEmpty() || n.add(r))
        }
        return this._factory.buildGeometry(n)
    }

    transformMultiPolygon(t, e) {
        const n = new ct;
        for (let s = 0; s < t.getNumGeometries(); s++) {
            const r = this.transformPolygon(t.getGeometryN(s), t);
            r !== null && (r.isEmpty() || n.add(r))
        }
        return this._factory.buildGeometry(n)
    }

    copy(t) {
        return t.copy()
    }

    transformGeometryCollection(t, e) {
        const n = new ct;
        for (let s = 0; s < t.getNumGeometries(); s++) {
            const r = this.transform(t.getGeometryN(s));
            r !== null && (this._pruneEmptyGeometry && r.isEmpty() || n.add(r))
        }
        return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(hn.toGeometryArray(n)) : this._factory.buildGeometry(n)
    }

    transform(t) {
        if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof on) return this.transformPoint(t, null);
        if (t instanceof di) return this.transformMultiPoint(t, null);
        if (t instanceof Un) return this.transformLinearRing(t, null);
        if (t instanceof Te) return this.transformLineString(t, null);
        if (t instanceof Ks) return this.transformMultiLineString(t, null);
        if (t instanceof $e) return this.transformPolygon(t, null);
        if (t instanceof bs) return this.transformMultiPolygon(t, null);
        if (t instanceof Ie) return this.transformGeometryCollection(t, null);
        throw new jt("Unknown Geometry subtype: " + t.getGeometryType())
    }

    transformLinearRing(t, e) {
        const n = this.transformCoordinates(t.getCoordinateSequence(), t);
        if (n === null) return this._factory.createLinearRing(null);
        const s = n.size();
        return s > 0 && s < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n)
    }
}

class ls {
    constructor() {
        ls.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._lines = null, this._isForcedToLineString = !1, arguments.length === 1) {
            const t = arguments[0];
            this._lines = t
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._lines = t, this._isForcedToLineString = e
        }
    }

    static getGeometry() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return t.getFactory().buildGeometry(ls.getLines(t))
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return t.getFactory().buildGeometry(ls.getLines(t, e))
        }
    }

    static getLines() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return ls.getLines(t, !1)
        } else if (arguments.length === 2) {
            if (At(arguments[0], fn) && At(arguments[1], fn)) {
                const t = arguments[0], e = arguments[1];
                for (let n = t.iterator(); n.hasNext();) {
                    const s = n.next();
                    ls.getLines(s, e)
                }
                return e
            } else if (arguments[0] instanceof it && typeof arguments[1] == "boolean") {
                const t = arguments[0], e = arguments[1], n = new ct;
                return t.apply(new ls(n, e)), n
            } else if (arguments[0] instanceof it && At(arguments[1], fn)) {
                const t = arguments[0], e = arguments[1];
                return t instanceof Te ? e.add(t) : t.apply(new ls(e)), e
            }
        } else if (arguments.length === 3) {
            if (typeof arguments[2] == "boolean" && At(arguments[0], fn) && At(arguments[1], fn)) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                for (let s = t.iterator(); s.hasNext();) {
                    const r = s.next();
                    ls.getLines(r, e, n)
                }
                return e
            } else if (typeof arguments[2] == "boolean" && arguments[0] instanceof it && At(arguments[1], fn)) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                return t.apply(new ls(e, n)), e
            }
        }
    }

    filter(t) {
        if (this._isForcedToLineString && t instanceof Un) {
            const e = t.getFactory().createLineString(t.getCoordinateSequence());
            return this._lines.add(e), null
        }
        t instanceof Te && this._lines.add(t)
    }

    setForceToLineString(t) {
        this._isForcedToLineString = t
    }

    get interfaces_() {
        return [Ol]
    }
}

const cr = {
    reverseOrder: function () {
        return {
            compare(i, t) {
                return t.compareTo(i)
            }
        }
    }, min: function (i) {
        return cr.sort(i), i.get(0)
    }, sort: function (i, t) {
        const e = i.toArray();
        t ? Fr.sort(e, t) : Fr.sort(e);
        const n = i.iterator();
        for (let s = 0, r = e.length; s < r; s++) n.next(), n.set(e[s])
    }, singletonList: function (i) {
        const t = new ct;
        return t.add(i), t
    }
};

class Ha {
    constructor() {
        Ha.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._pts = null;
        const t = arguments[0];
        this._pts = t
    }

    static getPoints() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return t instanceof on ? cr.singletonList(t) : Ha.getPoints(t, new ct)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return t instanceof on ? e.add(t) : t instanceof Ie && t.apply(new Ha(e)), e
        }
    }

    filter(t) {
        t instanceof on && this._pts.add(t)
    }

    get interfaces_() {
        return [Jr]
    }
}

class $a {
    constructor() {
        $a.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._comps = null;
        const t = arguments[0];
        this._comps = t
    }

    static getPolygons() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return $a.getPolygons(t, new ct)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return t instanceof $e ? e.add(t) : t instanceof Ie && t.apply(new $a(e)), e
        }
    }

    filter(t) {
        t instanceof $e && this._comps.add(t)
    }

    get interfaces_() {
        return [Jr]
    }
}

class Lh {
    constructor() {
        Lh.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._isDone = !1
    }

    applyTo(t) {
        for (let e = 0; e < t.getNumGeometries() && !this._isDone; e++) {
            const n = t.getGeometryN(e);
            if (n instanceof Ie) this.applyTo(n); else if (this.visit(n), this.isDone()) return this._isDone = !0, null
        }
    }
}

class Af {
    visitItem(t) {
    }
}

class $S {
    locate(t) {
    }
}

class Fl {
    constructor() {
        Fl.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._min = St.POSITIVE_INFINITY, this._max = St.NEGATIVE_INFINITY
    }

    getMin() {
        return this._min
    }

    intersects(t, e) {
        return !(this._min > e || this._max < t)
    }

    getMax() {
        return this._max
    }

    toString() {
        return Bi.toLineString(new F(this._min, 0), new F(this._max, 0))
    }
}

class _z {
    compare(t, e) {
        const n = t, s = e, r = (n._min + n._max) / 2, o = (s._min + s._max) / 2;
        return r < o ? -1 : r > o ? 1 : 0
    }

    get interfaces_() {
        return [Kr]
    }
}

Fl.NodeComparator = _z;

class e_ extends Fl {
    constructor() {
        super(), e_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._item = null;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this._min = t, this._max = e, this._item = n
    }

    query(t, e, n) {
        if (!this.intersects(t, e)) return null;
        n.visitItem(this._item)
    }
}

class n_ extends Fl {
    constructor() {
        super(), n_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._node1 = null, this._node2 = null;
        const t = arguments[0], e = arguments[1];
        this._node1 = t, this._node2 = e, this.buildExtent(this._node1, this._node2)
    }

    buildExtent(t, e) {
        this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max)
    }

    query(t, e, n) {
        if (!this.intersects(t, e)) return null;
        this._node1 !== null && this._node1.query(t, e, n), this._node2 !== null && this._node2.query(t, e, n)
    }
}

class s_ {
    constructor() {
        s_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._leaves = new ct, this._root = null, this._level = 0
    }

    buildTree() {
        cr.sort(this._leaves, new Fl.NodeComparator);
        let t = this._leaves, e = null, n = new ct;
        for (; ;) {
            if (this.buildLevel(t, n), n.size() === 1) return n.get(0);
            e = t, t = n, n = e
        }
    }

    insert(t, e, n) {
        if (this._root !== null) throw new qr("Index cannot be added to once it has been queried");
        this._leaves.add(new e_(t, e, n))
    }

    query(t, e, n) {
        if (this.init(), this._root === null) return null;
        this._root.query(t, e, n)
    }

    buildRoot() {
        if (this._root !== null) return null;
        this._root = this.buildTree()
    }

    printNode(t) {
        ws.out.println(Bi.toLineString(new F(t._min, this._level), new F(t._max, this._level)))
    }

    init() {
        if (this._root !== null || this._leaves.size() === 0) return null;
        this.buildRoot()
    }

    buildLevel(t, e) {
        this._level++, e.clear();
        for (let n = 0; n < t.size(); n += 2) {
            const s = t.get(n);
            if ((n + 1 < t.size() ? t.get(n) : null) === null) e.add(s); else {
                const o = new n_(t.get(n), t.get(n + 1));
                e.add(o)
            }
        }
    }
}

class i_ {
    constructor() {
        i_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._items = new ct
    }

    visitItem(t) {
        this._items.add(t)
    }

    getItems() {
        return this._items
    }

    get interfaces_() {
        return [Af]
    }
}

class Wa {
    constructor() {
        Wa.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
        const t = arguments[0];
        this._p = t
    }

    static locatePointInRing() {
        if (arguments[0] instanceof F && At(arguments[1], pe)) {
            const t = arguments[0], e = arguments[1], n = new Wa(t), s = new F, r = new F;
            for (let o = 1; o < e.size(); o++) if (e.getCoordinate(o, s), e.getCoordinate(o - 1, r), n.countSegment(s, r), n.isOnSegment()) return n.getLocation();
            return n.getLocation()
        } else if (arguments[0] instanceof F && arguments[1] instanceof Array) {
            const t = arguments[0], e = arguments[1], n = new Wa(t);
            for (let s = 1; s < e.length; s++) {
                const r = e[s], o = e[s - 1];
                if (n.countSegment(r, o), n.isOnSegment()) return n.getLocation()
            }
            return n.getLocation()
        }
    }

    countSegment(t, e) {
        if (t.x < this._p.x && e.x < this._p.x) return null;
        if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;
        if (t.y === this._p.y && e.y === this._p.y) {
            let n = t.x, s = e.x;
            return n > s && (n = e.x, s = t.x), this._p.x >= n && this._p.x <= s && (this._isPointOnSegment = !0), null
        }
        if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
            let n = Dt.index(t, e, this._p);
            if (n === Dt.COLLINEAR) return this._isPointOnSegment = !0, null;
            e.y < t.y && (n = -n), n === Dt.LEFT && this._crossingCount++
        }
    }

    isPointInPolygon() {
        return this.getLocation() !== T.EXTERIOR
    }

    getLocation() {
        return this._isPointOnSegment ? T.BOUNDARY : this._crossingCount % 2 === 1 ? T.INTERIOR : T.EXTERIOR
    }

    isOnSegment() {
        return this._isPointOnSegment
    }
}

class zl {
    constructor() {
        zl.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geom = null, this._index = null;
        const t = arguments[0];
        if (!(At(t, Ko) || t instanceof Un)) throw new jt("Argument must be Polygonal or LinearRing");
        this._geom = t
    }

    locate(t) {
        this._index === null && (this._index = new Pf(this._geom), this._geom = null);
        const e = new Wa(t), n = new Cf(e);
        return this._index.query(t.y, t.y, n), e.getLocation()
    }

    get interfaces_() {
        return [$S]
    }
}

class Cf {
    constructor() {
        Cf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._counter = null;
        const t = arguments[0];
        this._counter = t
    }

    visitItem(t) {
        const e = t;
        this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
    }

    get interfaces_() {
        return [Af]
    }
}

class Pf {
    constructor() {
        Pf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._isEmpty = !1, this._index = new s_;
        const t = arguments[0];
        t.isEmpty() ? this._isEmpty = !0 : this.init(t)
    }

    init(t) {
        const e = ls.getLines(t);
        for (let n = e.iterator(); n.hasNext();) {
            const r = n.next().getCoordinates();
            this.addLine(r)
        }
    }

    addLine(t) {
        for (let e = 1; e < t.length; e++) {
            const n = new Re(t[e - 1], t[e]), s = Math.min(n.p0.y, n.p1.y), r = Math.max(n.p0.y, n.p1.y);
            this._index.insert(s, r, n)
        }
    }

    query() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            if (this._isEmpty) return new ct;
            const n = new i_;
            return this._index.query(t, e, n), n.getItems()
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            if (this._isEmpty) return null;
            this._index.query(t, e, n)
        }
    }
}

zl.SegmentVisitor = Cf;
zl.IntervalIndexedGeometry = Pf;

class Zs {
    static isOnLine() {
        if (arguments[0] instanceof F && At(arguments[1], pe)) {
            const t = arguments[0], e = arguments[1], n = new Gn, s = new F, r = new F, o = e.size();
            for (let a = 1; a < o; a++) if (e.getCoordinate(a - 1, s), e.getCoordinate(a, r), n.computeIntersection(t, s, r), n.hasIntersection()) return !0;
            return !1
        } else if (arguments[0] instanceof F && arguments[1] instanceof Array) {
            const t = arguments[0], e = arguments[1], n = new Gn;
            for (let s = 1; s < e.length; s++) {
                const r = e[s - 1], o = e[s];
                if (n.computeIntersection(t, r, o), n.hasIntersection()) return !0
            }
            return !1
        }
    }

    static locateInRing(t, e) {
        return Wa.locatePointInRing(t, e)
    }

    static isInRing(t, e) {
        return Zs.locateInRing(t, e) !== T.EXTERIOR
    }
}

class yz {
    hasNext() {
    }

    next() {
    }

    remove() {
    }
}

class qa {
    constructor() {
        qa.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
        const t = arguments[0];
        this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries()
    }

    static isAtomic(t) {
        return !(t instanceof Ie)
    }

    next() {
        if (this._atStart) return this._atStart = !1, qa.isAtomic(this._parent) && this._index++, this._parent;
        if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null
        }
        if (this._index >= this._max) throw new Ll;
        const t = this._parent.getGeometryN(this._index++);
        return t instanceof Ie ? (this._subcollectionIterator = new qa(t), this._subcollectionIterator.next()) : t
    }

    remove() {
        throw new Js(this.getClass().getName())
    }

    hasNext() {
        if (this._atStart) return !0;
        if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return !0;
            this._subcollectionIterator = null
        }
        return !(this._index >= this._max)
    }

    get interfaces_() {
        return [yz]
    }
}

class $s {
    constructor() {
        $s.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geom = null;
        const t = arguments[0];
        this._geom = t
    }

    static locatePointInPolygon(t, e) {
        if (e.isEmpty()) return T.EXTERIOR;
        const n = e.getExteriorRing(), s = $s.locatePointInRing(t, n);
        if (s !== T.INTERIOR) return s;
        for (let r = 0; r < e.getNumInteriorRing(); r++) {
            const o = e.getInteriorRingN(r), a = $s.locatePointInRing(t, o);
            if (a === T.BOUNDARY) return T.BOUNDARY;
            if (a === T.INTERIOR) return T.EXTERIOR
        }
        return T.INTERIOR
    }

    static locatePointInRing(t, e) {
        return e.getEnvelopeInternal().intersects(t) ? Zs.locateInRing(t, e.getCoordinates()) : T.EXTERIOR
    }

    static containsPointInPolygon(t, e) {
        return T.EXTERIOR !== $s.locatePointInPolygon(t, e)
    }

    static locateInGeometry(t, e) {
        if (e instanceof $e) return $s.locatePointInPolygon(t, e);
        if (e instanceof Ie) {
            const n = new qa(e);
            for (; n.hasNext();) {
                const s = n.next();
                if (s !== e) {
                    const r = $s.locateInGeometry(t, s);
                    if (r !== T.EXTERIOR) return r
                }
            }
        }
        return T.EXTERIOR
    }

    static isContained(t, e) {
        return T.EXTERIOR !== $s.locate(t, e)
    }

    static locate(t, e) {
        return e.isEmpty() || !e.getEnvelopeInternal().intersects(t) ? T.EXTERIOR : $s.locateInGeometry(t, e)
    }

    locate(t) {
        return $s.locate(t, this._geom)
    }

    get interfaces_() {
        return [$S]
    }
}

class Nr {
    constructor() {
        Nr.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._areaBasePt = null, this._triangleCent3 = new F, this._areasum2 = 0, this._cg3 = new F, this._lineCentSum = new F, this._totalLength = 0, this._ptCount = 0, this._ptCentSum = new F;
        const t = arguments[0];
        this._areaBasePt = null, this.add(t)
    }

    static area2(t, e, n) {
        return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y)
    }

    static centroid3(t, e, n, s) {
        return s.x = t.x + e.x + n.x, s.y = t.y + e.y + n.y, null
    }

    static getCentroid(t) {
        return new Nr(t).getCentroid()
    }

    setAreaBasePoint(t) {
        this._areaBasePt = t
    }

    addPoint(t) {
        this._ptCount += 1, this._ptCentSum.x += t.x, this._ptCentSum.y += t.y
    }

    addLineSegments(t) {
        let e = 0;
        for (let n = 0; n < t.length - 1; n++) {
            const s = t[n].distance(t[n + 1]);
            if (s === 0) continue;
            e += s;
            const r = (t[n].x + t[n + 1].x) / 2;
            this._lineCentSum.x += s * r;
            const o = (t[n].y + t[n + 1].y) / 2;
            this._lineCentSum.y += s * o
        }
        this._totalLength += e, e === 0 && t.length > 0 && this.addPoint(t[0])
    }

    addHole(t) {
        const e = Dt.isCCW(t);
        for (let n = 0; n < t.length - 1; n++) this.addTriangle(this._areaBasePt, t[n], t[n + 1], e);
        this.addLineSegments(t)
    }

    getCentroid() {
        const t = new F;
        if (Math.abs(this._areasum2) > 0) t.x = this._cg3.x / 3 / this._areasum2, t.y = this._cg3.y / 3 / this._areasum2; else if (this._totalLength > 0) t.x = this._lineCentSum.x / this._totalLength, t.y = this._lineCentSum.y / this._totalLength; else if (this._ptCount > 0) t.x = this._ptCentSum.x / this._ptCount, t.y = this._ptCentSum.y / this._ptCount; else return null;
        return t
    }

    addShell(t) {
        t.length > 0 && this.setAreaBasePoint(t[0]);
        const e = !Dt.isCCW(t);
        for (let n = 0; n < t.length - 1; n++) this.addTriangle(this._areaBasePt, t[n], t[n + 1], e);
        this.addLineSegments(t)
    }

    addTriangle(t, e, n, s) {
        const r = s ? 1 : -1;
        Nr.centroid3(t, e, n, this._triangleCent3);
        const o = Nr.area2(t, e, n);
        this._cg3.x += r * o * this._triangleCent3.x, this._cg3.y += r * o * this._triangleCent3.y, this._areasum2 += r * o
    }

    add() {
        if (arguments[0] instanceof $e) {
            const t = arguments[0];
            this.addShell(t.getExteriorRing().getCoordinates());
            for (let e = 0; e < t.getNumInteriorRing(); e++) this.addHole(t.getInteriorRingN(e).getCoordinates())
        } else if (arguments[0] instanceof it) {
            const t = arguments[0];
            if (t.isEmpty()) return null;
            if (t instanceof on) this.addPoint(t.getCoordinate()); else if (t instanceof Te) this.addLineSegments(t.getCoordinates()); else if (t instanceof $e) {
                const e = t;
                this.add(e)
            } else if (t instanceof Ie) {
                const e = t;
                for (let n = 0; n < e.getNumGeometries(); n++) this.add(e.getGeometryN(n))
            }
        }
    }
}

class yd extends js {
    constructor(t) {
        super(t), this.name = Object.keys({EmptyStackException: yd})[0]
    }
}

class WS extends Bs {
    constructor() {
        super(), this.array = []
    }

    add(t) {
        return this.array.push(t), !0
    }

    get(t) {
        if (t < 0 || t >= this.size()) throw new Tf;
        return this.array[t]
    }

    push(t) {
        return this.array.push(t), t
    }

    pop() {
        if (this.array.length === 0) throw new yd;
        return this.array.pop()
    }

    peek() {
        if (this.array.length === 0) throw new yd;
        return this.array[this.array.length - 1]
    }

    empty() {
        return this.array.length === 0
    }

    isEmpty() {
        return this.empty()
    }

    search(t) {
        return this.array.indexOf(t)
    }

    size() {
        return this.array.length
    }

    toArray() {
        return this.array.slice()
    }
}

class Kc {
    constructor() {
        Kc.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._coordSet = new Rh, this._list = new ct
    }

    static filterCoordinates(t) {
        const e = new Kc;
        for (let n = 0; n < t.length; n++) e.filter(t[n]);
        return e.getCoordinates()
    }

    filter(t) {
        this._coordSet.add(t) && this._list.add(t)
    }

    getCoordinates() {
        const t = new Array(this._list.size()).fill(null);
        return this._list.toArray(t)
    }

    get interfaces_() {
        return [Dl]
    }
}

class Ya {
    constructor() {
        Ya.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._geomFactory = null, this._inputPts = null, arguments.length === 1) {
            const t = arguments[0];
            Ya.constructor_.call(this, Ya.extractCoordinates(t), t.getFactory())
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._inputPts = Kc.filterCoordinates(t), this._geomFactory = e
        }
    }

    static extractCoordinates(t) {
        const e = new Kc;
        return t.apply(e), e.getCoordinates()
    }

    preSort(t) {
        let e = null;
        for (let n = 1; n < t.length; n++) (t[n].y < t[0].y || t[n].y === t[0].y && t[n].x < t[0].x) && (e = t[0], t[0] = t[n], t[n] = e);
        return Fr.sort(t, 1, t.length, new Jc(t[0])), t
    }

    computeOctRing(t) {
        const e = this.computeOctPts(t), n = new ui;
        return n.add(e, !1), n.size() < 3 ? null : (n.closeRing(), n.toCoordinateArray())
    }

    lineOrPolygon(t) {
        if (t = this.cleanRing(t), t.length === 3) return this._geomFactory.createLineString([t[0], t[1]]);
        const e = this._geomFactory.createLinearRing(t);
        return this._geomFactory.createPolygon(e)
    }

    cleanRing(t) {
        $t.equals(t[0], t[t.length - 1]);
        const e = new ct;
        let n = null;
        for (let r = 0; r <= t.length - 2; r++) {
            const o = t[r], a = t[r + 1];
            o.equals(a) || n !== null && this.isBetween(n, o, a) || (e.add(o), n = o)
        }
        e.add(t[t.length - 1]);
        const s = new Array(e.size()).fill(null);
        return e.toArray(s)
    }

    isBetween(t, e, n) {
        return Dt.index(t, e, n) !== 0 ? !1 : t.x !== n.x && (t.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= t.x) || t.y !== n.y && (t.y <= e.y && e.y <= n.y || n.y <= e.y && e.y <= t.y)
    }

    reduce(t) {
        const e = this.computeOctRing(t);
        if (e === null) return t;
        const n = new Ho;
        for (let r = 0; r < e.length; r++) n.add(e[r]);
        for (let r = 0; r < t.length; r++) Zs.isInRing(t[r], e) || n.add(t[r]);
        const s = ze.toCoordinateArray(n);
        return s.length < 3 ? this.padArray3(s) : s
    }

    getConvexHull() {
        if (this._inputPts.length === 0) return this._geomFactory.createGeometryCollection();
        if (this._inputPts.length === 1) return this._geomFactory.createPoint(this._inputPts[0]);
        if (this._inputPts.length === 2) return this._geomFactory.createLineString(this._inputPts);
        let t = this._inputPts;
        this._inputPts.length > 50 && (t = this.reduce(this._inputPts));
        const e = this.preSort(t), n = this.grahamScan(e), s = this.toCoordinateArray(n);
        return this.lineOrPolygon(s)
    }

    padArray3(t) {
        const e = new Array(3).fill(null);
        for (let n = 0; n < e.length; n++) n < t.length ? e[n] = t[n] : e[n] = t[0];
        return e
    }

    computeOctPts(t) {
        const e = new Array(8).fill(null);
        for (let n = 0; n < e.length; n++) e[n] = t[0];
        for (let n = 1; n < t.length; n++) t[n].x < e[0].x && (e[0] = t[n]), t[n].x - t[n].y < e[1].x - e[1].y && (e[1] = t[n]), t[n].y > e[2].y && (e[2] = t[n]), t[n].x + t[n].y > e[3].x + e[3].y && (e[3] = t[n]), t[n].x > e[4].x && (e[4] = t[n]), t[n].x - t[n].y > e[5].x - e[5].y && (e[5] = t[n]), t[n].y < e[6].y && (e[6] = t[n]), t[n].x + t[n].y < e[7].x + e[7].y && (e[7] = t[n]);
        return e
    }

    toCoordinateArray(t) {
        const e = new Array(t.size()).fill(null);
        for (let n = 0; n < t.size(); n++) {
            const s = t.get(n);
            e[n] = s
        }
        return e
    }

    grahamScan(t) {
        let e = null;
        const n = new WS;
        n.push(t[0]), n.push(t[1]), n.push(t[2]);
        for (let s = 3; s < t.length; s++) {
            for (e = n.pop(); !n.empty() && Dt.index(n.peek(), e, t[s]) > 0;) e = n.pop();
            n.push(e), n.push(t[s])
        }
        return n.push(t[0]), n
    }
}

class Jc {
    constructor() {
        Jc.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._origin = null;
        const t = arguments[0];
        this._origin = t
    }

    static polarCompare(t, e, n) {
        const s = e.x - t.x, r = e.y - t.y, o = n.x - t.x, a = n.y - t.y, l = Dt.index(t, e, n);
        if (l === Dt.COUNTERCLOCKWISE) return 1;
        if (l === Dt.CLOCKWISE) return -1;
        const c = s * s + r * r, h = o * o + a * a;
        return c < h ? -1 : c > h ? 1 : 0
    }

    compare(t, e) {
        const n = t, s = e;
        return Jc.polarCompare(this._origin, n, s)
    }

    get interfaces_() {
        return [Kr]
    }
}

Ya.RadialComparator = Jc;

class ki {
    constructor() {
        ki.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._interiorPoint = null, this._maxWidth = -1;
        const t = arguments[0];
        this.process(t)
    }

    static getInteriorPoint(t) {
        return new ki(t).getInteriorPoint()
    }

    static avg(t, e) {
        return (t + e) / 2
    }

    getInteriorPoint() {
        return this._interiorPoint
    }

    process(t) {
        if (t.isEmpty()) return null;
        if (t instanceof $e) this.processPolygon(t); else if (t instanceof Ie) {
            const e = t;
            for (let n = 0; n < e.getNumGeometries(); n++) this.process(e.getGeometryN(n))
        }
    }

    processPolygon(t) {
        const e = new sr(t);
        e.process();
        const n = e.getWidth();
        n > this._maxWidth && (this._maxWidth = n, this._interiorPoint = e.getInteriorPoint())
    }
}

class sr {
    constructor() {
        sr.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._polygon = null, this._interiorPointY = null, this._interiorSectionWidth = 0, this._interiorPoint = null;
        const t = arguments[0];
        this._polygon = t, this._interiorPointY = Qc.getScanLineY(t)
    }

    static isEdgeCrossingCounted(t, e, n) {
        const s = t.getY(), r = e.getY();
        return !(s === r || s === n && r < n || r === n && s < n)
    }

    static intersectsHorizontalLine() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return !(e < t.getMinY() || e > t.getMaxY())
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            return !(t.getY() > n && e.getY() > n || t.getY() < n && e.getY() < n)
        }
    }

    static intersection(t, e, n) {
        const s = t.getX(), r = e.getX();
        if (s === r) return s;
        const o = r - s, l = (e.getY() - t.getY()) / o;
        return s + (n - t.getY()) / l
    }

    findBestMidpoint(t) {
        if (t.size() === 0) return null;
        $t.isTrue(t.size() % 2 === 0, "Interior Point robustness failure: odd number of scanline crossings"), t.sort(new qS);
        for (let e = 0; e < t.size(); e += 2) {
            const n = t.get(e), s = t.get(e + 1), r = s - n;
            if (r > this._interiorSectionWidth) {
                this._interiorSectionWidth = r;
                const o = ki.avg(n, s);
                this._interiorPoint = new F(o, this._interiorPointY)
            }
        }
    }

    process() {
        if (this._polygon.isEmpty()) return null;
        this._interiorPoint = new F(this._polygon.getCoordinate());
        const t = new ct;
        this.scanRing(this._polygon.getExteriorRing(), t);
        for (let e = 0; e < this._polygon.getNumInteriorRing(); e++) this.scanRing(this._polygon.getInteriorRingN(e), t);
        this.findBestMidpoint(t)
    }

    scanRing(t, e) {
        if (!sr.intersectsHorizontalLine(t.getEnvelopeInternal(), this._interiorPointY)) return null;
        const n = t.getCoordinateSequence();
        for (let s = 1; s < n.size(); s++) {
            const r = n.getCoordinate(s - 1), o = n.getCoordinate(s);
            this.addEdgeCrossing(r, o, this._interiorPointY, e)
        }
    }

    getWidth() {
        return this._interiorSectionWidth
    }

    getInteriorPoint() {
        return this._interiorPoint
    }

    addEdgeCrossing(t, e, n, s) {
        if (!sr.intersectsHorizontalLine(t, e, n) || !sr.isEdgeCrossingCounted(t, e, n)) return null;
        const r = sr.intersection(t, e, n);
        s.add(r)
    }
}

class qS {
    compare(t, e) {
        return t < e ? -1 : t > e ? 1 : 0
    }

    get interfaces_() {
        return [Kr]
    }
}

sr.DoubleComparator = qS;

class Qc {
    constructor() {
        Qc.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._poly = null, this._centreY = null, this._hiY = St.MAX_VALUE, this._loY = -St.MAX_VALUE;
        const t = arguments[0];
        this._poly = t, this._hiY = t.getEnvelopeInternal().getMaxY(), this._loY = t.getEnvelopeInternal().getMinY(), this._centreY = ki.avg(this._loY, this._hiY)
    }

    static getScanLineY(t) {
        return new Qc(t).getScanLineY()
    }

    updateInterval(t) {
        t <= this._centreY ? t > this._loY && (this._loY = t) : t > this._centreY && t < this._hiY && (this._hiY = t)
    }

    getScanLineY() {
        this.process(this._poly.getExteriorRing());
        for (let e = 0; e < this._poly.getNumInteriorRing(); e++) this.process(this._poly.getInteriorRingN(e));
        return ki.avg(this._hiY, this._loY)
    }

    process(t) {
        const e = t.getCoordinateSequence();
        for (let n = 0; n < e.size(); n++) {
            const s = e.getY(n);
            this.updateInterval(s)
        }
    }
}

ki.InteriorPointPolygon = sr;
ki.ScanLineYOrdinateFinder = Qc;

class xd {
    constructor() {
        xd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._centroid = null, this._minDistance = St.MAX_VALUE, this._interiorPoint = null;
        const t = arguments[0];
        t.isEmpty() ? this._centroid = null : (this._centroid = Nr.getCentroid(t), t.getPrecisionModel().makePrecise(this._centroid)), this.addInterior(t), this._interiorPoint === null && this.addEndpoints(t)
    }

    static getInteriorPoint(t) {
        return new xd(t).getInteriorPoint()
    }

    addEndpoints() {
        if (arguments[0] instanceof it) {
            const t = arguments[0];
            if (t instanceof Te) this.addEndpoints(t.getCoordinates()); else if (t instanceof Ie) {
                const e = t;
                for (let n = 0; n < e.getNumGeometries(); n++) this.addEndpoints(e.getGeometryN(n))
            }
        } else if (arguments[0] instanceof Array) {
            const t = arguments[0];
            this.add(t[0]), this.add(t[t.length - 1])
        }
    }

    getInteriorPoint() {
        return this._interiorPoint
    }

    addInterior() {
        if (arguments[0] instanceof it) {
            const t = arguments[0];
            if (t instanceof Te) this.addInterior(t.getCoordinates()); else if (t instanceof Ie) {
                const e = t;
                for (let n = 0; n < e.getNumGeometries(); n++) this.addInterior(e.getGeometryN(n))
            }
        } else if (arguments[0] instanceof Array) {
            const t = arguments[0];
            for (let e = 1; e < t.length - 1; e++) this.add(t[e])
        }
    }

    add(t) {
        const e = t.distance(this._centroid);
        e < this._minDistance && (this._interiorPoint = new F(t), this._minDistance = e)
    }
}

class vd {
    constructor() {
        vd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._centroid = null, this._minDistance = St.MAX_VALUE, this._interiorPoint = null;
        const t = arguments[0];
        this._centroid = Nr.getCentroid(t), this.add(t)
    }

    static getInteriorPoint(t) {
        return new vd(t).getInteriorPoint()
    }

    getInteriorPoint() {
        return this._interiorPoint
    }

    add() {
        if (arguments[0] instanceof it) {
            const t = arguments[0];
            if (t instanceof on) this.add(t.getCoordinate()); else if (t instanceof Ie) {
                const e = t;
                for (let n = 0; n < e.getNumGeometries(); n++) this.add(e.getGeometryN(n))
            }
        } else if (arguments[0] instanceof F) {
            const t = arguments[0], e = t.distance(this._centroid);
            e < this._minDistance && (this._interiorPoint = new F(t), this._minDistance = e)
        }
    }
}

class Dn {
    isInBoundary(t) {
    }
}

class YS {
    isInBoundary(t) {
        return t % 2 === 1
    }

    get interfaces_() {
        return [Dn]
    }
}

class XS {
    isInBoundary(t) {
        return t > 0
    }

    get interfaces_() {
        return [Dn]
    }
}

class ZS {
    isInBoundary(t) {
        return t > 1
    }

    get interfaces_() {
        return [Dn]
    }
}

class jS {
    isInBoundary(t) {
        return t === 1
    }

    get interfaces_() {
        return [Dn]
    }
}

Dn.Mod2BoundaryNodeRule = YS;
Dn.EndPointBoundaryNodeRule = XS;
Dn.MultiValentEndPointBoundaryNodeRule = ZS;
Dn.MonoValentEndPointBoundaryNodeRule = jS;
Dn.MOD2_BOUNDARY_RULE = new YS;
Dn.ENDPOINT_BOUNDARY_RULE = new XS;
Dn.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new ZS;
Dn.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new jS;
Dn.OGC_SFS_BOUNDARY_RULE = Dn.MOD2_BOUNDARY_RULE;

class Jo {
    constructor() {
        Jo.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._boundaryRule = Dn.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, arguments.length !== 0) {
            if (arguments.length === 1) {
                const t = arguments[0];
                if (t === null) throw new jt("Rule must be non-null");
                this._boundaryRule = t
            }
        }
    }

    locateInPolygonRing(t, e) {
        return e.getEnvelopeInternal().intersects(t) ? Zs.locateInRing(t, e.getCoordinates()) : T.EXTERIOR
    }

    intersects(t, e) {
        return this.locate(t, e) !== T.EXTERIOR
    }

    updateLocationInfo(t) {
        t === T.INTERIOR && (this._isIn = !0), t === T.BOUNDARY && this._numBoundaries++
    }

    computeLocation(t, e) {
        if (e instanceof on && this.updateLocationInfo(this.locateOnPoint(t, e)), e instanceof Te) this.updateLocationInfo(this.locateOnLineString(t, e)); else if (e instanceof $e) this.updateLocationInfo(this.locateInPolygon(t, e)); else if (e instanceof Ks) {
            const n = e;
            for (let s = 0; s < n.getNumGeometries(); s++) {
                const r = n.getGeometryN(s);
                this.updateLocationInfo(this.locateOnLineString(t, r))
            }
        } else if (e instanceof bs) {
            const n = e;
            for (let s = 0; s < n.getNumGeometries(); s++) {
                const r = n.getGeometryN(s);
                this.updateLocationInfo(this.locateInPolygon(t, r))
            }
        } else if (e instanceof Ie) {
            const n = new qa(e);
            for (; n.hasNext();) {
                const s = n.next();
                s !== e && this.computeLocation(t, s)
            }
        }
    }

    locateOnPoint(t, e) {
        return e.getCoordinate().equals2D(t) ? T.INTERIOR : T.EXTERIOR
    }

    locateOnLineString(t, e) {
        if (!e.getEnvelopeInternal().intersects(t)) return T.EXTERIOR;
        const n = e.getCoordinateSequence();
        return !e.isClosed() && (t.equals(n.getCoordinate(0)) || t.equals(n.getCoordinate(n.size() - 1))) ? T.BOUNDARY : Zs.isOnLine(t, n) ? T.INTERIOR : T.EXTERIOR
    }

    locateInPolygon(t, e) {
        if (e.isEmpty()) return T.EXTERIOR;
        const n = e.getExteriorRing(), s = this.locateInPolygonRing(t, n);
        if (s === T.EXTERIOR) return T.EXTERIOR;
        if (s === T.BOUNDARY) return T.BOUNDARY;
        for (let r = 0; r < e.getNumInteriorRing(); r++) {
            const o = e.getInteriorRingN(r), a = this.locateInPolygonRing(t, o);
            if (a === T.INTERIOR) return T.EXTERIOR;
            if (a === T.BOUNDARY) return T.BOUNDARY
        }
        return T.INTERIOR
    }

    locate(t, e) {
        return e.isEmpty() ? T.EXTERIOR : e instanceof Te ? this.locateOnLineString(t, e) : e instanceof $e ? this.locateInPolygon(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? T.BOUNDARY : this._numBoundaries > 0 || this._isIn ? T.INTERIOR : T.EXTERIOR)
    }
}

class De {
    static isNorthern(t) {
        return t === De.NE || t === De.NW
    }

    static isOpposite(t, e) {
        return t === e ? !1 : (t - e + 4) % 4 === 2
    }

    static commonHalfPlane(t, e) {
        if (t === e) return t;
        if ((t - e + 4) % 4 === 2) return -1;
        const s = t < e ? t : e, r = t > e ? t : e;
        return s === 0 && r === 3 ? 3 : s
    }

    static isInHalfPlane(t, e) {
        return e === De.SE ? t === De.SE || t === De.SW : t === e || t === e + 1
    }

    static quadrant() {
        if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            const t = arguments[0], e = arguments[1];
            if (t === 0 && e === 0) throw new jt("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
            return t >= 0 ? e >= 0 ? De.NE : De.SE : e >= 0 ? De.NW : De.SW
        } else if (arguments[0] instanceof F && arguments[1] instanceof F) {
            const t = arguments[0], e = arguments[1];
            if (e.x === t.x && e.y === t.y) throw new jt("Cannot compute the quadrant for two identical points " + t);
            return e.x >= t.x ? e.y >= t.y ? De.NE : De.SE : e.y >= t.y ? De.NW : De.SW
        }
    }
}

De.NE = 0;
De.NW = 1;
De.SW = 2;
De.SE = 3;

class ot {
    static opposite(t) {
        return t === ot.LEFT ? ot.RIGHT : t === ot.RIGHT ? ot.LEFT : t
    }
}

ot.ON = 0;
ot.LEFT = 1;
ot.RIGHT = 2;

class r_ {
    constructor() {
        r_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.mce = null, this.chainIndex = null;
        const t = arguments[0], e = arguments[1];
        this.mce = t, this.chainIndex = e
    }

    computeIntersections(t, e) {
        this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
    }
}

class Ti {
    constructor() {
        Ti.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._eventType = Ti.DELETE, this._xValue = t, this._insertEvent = e
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._eventType = Ti.INSERT, this._label = t, this._xValue = e, this._obj = n
        }
    }

    isDelete() {
        return this._eventType === Ti.DELETE
    }

    setDeleteEventIndex(t) {
        this._deleteEventIndex = t
    }

    getObject() {
        return this._obj
    }

    compareTo(t) {
        const e = t;
        return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0
    }

    getInsertEvent() {
        return this._insertEvent
    }

    isInsert() {
        return this._eventType === Ti.INSERT
    }

    isSameLabel(t) {
        return this._label === null ? !1 : this._label === t._label
    }

    getDeleteEventIndex() {
        return this._deleteEventIndex
    }

    get interfaces_() {
        return [Es]
    }
}

Ti.INSERT = 1;
Ti.DELETE = 2;

class xz {
}

class $o {
    constructor() {
        $o.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this._li = t, this._includeProper = e, this._recordIsolated = n
    }

    static isAdjacentSegments(t, e) {
        return Math.abs(t - e) === 1
    }

    isTrivialIntersection(t, e, n, s) {
        if (t === n && this._li.getIntersectionNum() === 1) {
            if ($o.isAdjacentSegments(e, s)) return !0;
            if (t.isClosed()) {
                const r = t.getNumPoints() - 1;
                if (e === 0 && s === r || s === 0 && e === r) return !0
            }
        }
        return !1
    }

    getProperIntersectionPoint() {
        return this._properIntersectionPoint
    }

    setIsDoneIfProperInt(t) {
        this._isDoneWhenProperInt = t
    }

    hasProperInteriorIntersection() {
        return this._hasProperInterior
    }

    isBoundaryPointInternal(t, e) {
        for (let n = e.iterator(); n.hasNext();) {
            const r = n.next().getCoordinate();
            if (t.isIntersection(r)) return !0
        }
        return !1
    }

    hasProperIntersection() {
        return this._hasProper
    }

    hasIntersection() {
        return this._hasIntersection
    }

    isDone() {
        return this._isDone
    }

    isBoundaryPoint(t, e) {
        return e === null ? !1 : !!(this.isBoundaryPointInternal(t, e[0]) || this.isBoundaryPointInternal(t, e[1]))
    }

    setBoundaryNodes(t, e) {
        this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e
    }

    addIntersections(t, e, n, s) {
        if (t === n && e === s) return null;
        this.numTests++;
        const r = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[s],
            l = n.getCoordinates()[s + 1];
        this._li.computeIntersection(r, o, a, l), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, s) || (this._hasIntersection = !0, (this._includeProper || !this._li.isProper()) && (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, s, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))))
    }
}

class o_ extends xz {
    constructor() {
        super(), o_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.events = new ct, this.nOverlaps = null
    }

    prepareEvents() {
        cr.sort(this.events);
        for (let t = 0; t < this.events.size(); t++) {
            const e = this.events.get(t);
            e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
        }
    }

    computeIntersections() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.nOverlaps = 0, this.prepareEvents();
            for (let e = 0; e < this.events.size(); e++) {
                const n = this.events.get(e);
                if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break
            }
        } else if (arguments.length === 3) {
            if (arguments[2] instanceof $o && At(arguments[0], Bs) && At(arguments[1], Bs)) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                this.addEdges(t, t), this.addEdges(e, e), this.computeIntersections(n)
            } else if (typeof arguments[2] == "boolean" && At(arguments[0], Bs) && arguments[1] instanceof $o) {
                const t = arguments[0], e = arguments[1];
                arguments[2] ? this.addEdges(t, null) : this.addEdges(t), this.computeIntersections(e)
            }
        }
    }

    addEdge(t, e) {
        const n = t.getMonotoneChainEdge(), s = n.getStartIndexes();
        for (let r = 0; r < s.length - 1; r++) {
            const o = new r_(n, r), a = new Ti(e, n.getMinX(r), o);
            this.events.add(a), this.events.add(new Ti(n.getMaxX(r), a))
        }
    }

    processOverlaps(t, e, n, s) {
        const r = n.getObject();
        for (let o = t; o < e; o++) {
            const a = this.events.get(o);
            if (a.isInsert()) {
                const l = a.getObject();
                n.isSameLabel(a) || (r.computeIntersections(l, s), this.nOverlaps++)
            }
        }
    }

    addEdges() {
        if (arguments.length === 1) {
            const t = arguments[0];
            for (let e = t.iterator(); e.hasNext();) {
                const n = e.next();
                this.addEdge(n, n)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            for (let n = t.iterator(); n.hasNext();) {
                const s = n.next();
                this.addEdge(s, e)
            }
        }
    }
}

class os {
    constructor() {
        os.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this.location = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const t = arguments[0];
                this.init(t.length)
            } else if (Number.isInteger(arguments[0])) {
                const t = arguments[0];
                this.init(1), this.location[ot.ON] = t
            } else if (arguments[0] instanceof os) {
                const t = arguments[0];
                if (this.init(t.location.length), t !== null) for (let e = 0; e < this.location.length; e++) this.location[e] = t.location[e]
            }
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this.init(3), this.location[ot.ON] = t, this.location[ot.LEFT] = e, this.location[ot.RIGHT] = n
        }
    }

    setAllLocations(t) {
        for (let e = 0; e < this.location.length; e++) this.location[e] = t
    }

    isNull() {
        for (let t = 0; t < this.location.length; t++) if (this.location[t] !== T.NONE) return !1;
        return !0
    }

    setAllLocationsIfNull(t) {
        for (let e = 0; e < this.location.length; e++) this.location[e] === T.NONE && (this.location[e] = t)
    }

    isLine() {
        return this.location.length === 1
    }

    merge(t) {
        if (t.location.length > this.location.length) {
            const e = new Array(3).fill(null);
            e[ot.ON] = this.location[ot.ON], e[ot.LEFT] = T.NONE, e[ot.RIGHT] = T.NONE, this.location = e
        }
        for (let e = 0; e < this.location.length; e++) this.location[e] === T.NONE && e < t.location.length && (this.location[e] = t.location[e])
    }

    getLocations() {
        return this.location
    }

    flip() {
        if (this.location.length <= 1) return null;
        const t = this.location[ot.LEFT];
        this.location[ot.LEFT] = this.location[ot.RIGHT], this.location[ot.RIGHT] = t
    }

    toString() {
        const t = new Xc;
        return this.location.length > 1 && t.append(T.toLocationSymbol(this.location[ot.LEFT])), t.append(T.toLocationSymbol(this.location[ot.ON])), this.location.length > 1 && t.append(T.toLocationSymbol(this.location[ot.RIGHT])), t.toString()
    }

    setLocations(t, e, n) {
        this.location[ot.ON] = t, this.location[ot.LEFT] = e, this.location[ot.RIGHT] = n
    }

    get(t) {
        return t < this.location.length ? this.location[t] : T.NONE
    }

    isArea() {
        return this.location.length > 1
    }

    isAnyNull() {
        for (let t = 0; t < this.location.length; t++) if (this.location[t] === T.NONE) return !0;
        return !1
    }

    setLocation() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.setLocation(ot.ON, t)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.location[t] = e
        }
    }

    init(t) {
        this.location = new Array(t).fill(null), this.setAllLocations(T.NONE)
    }

    isEqualOnSide(t, e) {
        return this.location[e] === t.location[e]
    }

    allPositionsEqual(t) {
        for (let e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;
        return !0
    }
}

class Ye {
    constructor() {
        Ye.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this.elt = new Array(2).fill(null), arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
                const t = arguments[0];
                this.elt[0] = new os(t), this.elt[1] = new os(t)
            } else if (arguments[0] instanceof Ye) {
                const t = arguments[0];
                this.elt[0] = new os(t.elt[0]), this.elt[1] = new os(t.elt[1])
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.elt[0] = new os(T.NONE), this.elt[1] = new os(T.NONE), this.elt[t].setLocation(e)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this.elt[0] = new os(t, e, n), this.elt[1] = new os(t, e, n)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            this.elt[0] = new os(T.NONE, T.NONE, T.NONE), this.elt[1] = new os(T.NONE, T.NONE, T.NONE), this.elt[t].setLocations(e, n, s)
        }
    }

    static toLineLabel(t) {
        const e = new Ye(T.NONE);
        for (let n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n));
        return e
    }

    getGeometryCount() {
        let t = 0;
        return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
    }

    setAllLocations(t, e) {
        this.elt[t].setAllLocations(e)
    }

    isNull(t) {
        return this.elt[t].isNull()
    }

    setAllLocationsIfNull() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.elt[t].setAllLocationsIfNull(e)
        }
    }

    isLine(t) {
        return this.elt[t].isLine()
    }

    merge(t) {
        for (let e = 0; e < 2; e++) this.elt[e] === null && t.elt[e] !== null ? this.elt[e] = new os(t.elt[e]) : this.elt[e].merge(t.elt[e])
    }

    flip() {
        this.elt[0].flip(), this.elt[1].flip()
    }

    getLocation() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return this.elt[t].get(ot.ON)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return this.elt[t].get(e)
        }
    }

    toString() {
        const t = new Xc;
        return this.elt[0] !== null && (t.append("A:"), t.append(this.elt[0].toString())), this.elt[1] !== null && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString()
    }

    isArea() {
        if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
        if (arguments.length === 1) {
            const t = arguments[0];
            return this.elt[t].isArea()
        }
    }

    isAnyNull(t) {
        return this.elt[t].isAnyNull()
    }

    setLocation() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.elt[t].setLocation(ot.ON, e)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this.elt[t].setLocation(e, n)
        }
    }

    isEqualOnSide(t, e) {
        return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
    }

    allPositionsEqual(t, e) {
        return this.elt[t].allPositionsEqual(e)
    }

    toLine(t) {
        this.elt[t].isArea() && (this.elt[t] = new os(this.elt[t].location[0]))
    }
}

class a_ {
    constructor() {
        a_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.coord = null, this.segmentIndex = null, this.dist = null;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this.coord = new F(t), this.segmentIndex = e, this.dist = n
    }

    getSegmentIndex() {
        return this.segmentIndex
    }

    getCoordinate() {
        return this.coord
    }

    print(t) {
        t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist)
    }

    compareTo(t) {
        const e = t;
        return this.compare(e.segmentIndex, e.dist)
    }

    isEndPoint(t) {
        return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === t
    }

    toString() {
        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
    }

    getDistance() {
        return this.dist
    }

    compare(t, e) {
        return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
    }

    get interfaces_() {
        return [Es]
    }
}

class vz extends FS {
}

const wi = 0, vr = 1;

function A1(i) {
    return i == null ? wi : i.color
}

function Me(i) {
    return i == null ? null : i.parent
}

function xi(i, t) {
    i !== null && (i.color = t)
}

function tg(i) {
    return i == null ? null : i.left
}

function C1(i) {
    return i == null ? null : i.right
}

class Ui extends vz {
    constructor() {
        super(), this.root_ = null, this.size_ = 0
    }

    get(t) {
        let e = this.root_;
        for (; e !== null;) {
            const n = t.compareTo(e.key);
            if (n < 0) e = e.left; else if (n > 0) e = e.right; else return e.value
        }
        return null
    }

    put(t, e) {
        if (this.root_ === null) return this.root_ = {
            key: t,
            value: e,
            left: null,
            right: null,
            parent: null,
            color: wi,
            getValue() {
                return this.value
            },
            getKey() {
                return this.key
            }
        }, this.size_ = 1, null;
        let n = this.root_, s, r;
        do if (s = n, r = t.compareTo(n.key), r < 0) n = n.left; else if (r > 0) n = n.right; else {
            const a = n.value;
            return n.value = e, a
        } while (n !== null);
        const o = {
            key: t, left: null, right: null, value: e, parent: s, color: wi, getValue() {
                return this.value
            }, getKey() {
                return this.key
            }
        };
        return r < 0 ? s.left = o : s.right = o, this.fixAfterInsertion(o), this.size_++, null
    }

    fixAfterInsertion(t) {
        let e;
        for (t.color = vr; t != null && t !== this.root_ && t.parent.color === vr;) Me(t) === tg(Me(Me(t))) ? (e = C1(Me(Me(t))), A1(e) === vr ? (xi(Me(t), wi), xi(e, wi), xi(Me(Me(t)), vr), t = Me(Me(t))) : (t === C1(Me(t)) && (t = Me(t), this.rotateLeft(t)), xi(Me(t), wi), xi(Me(Me(t)), vr), this.rotateRight(Me(Me(t))))) : (e = tg(Me(Me(t))), A1(e) === vr ? (xi(Me(t), wi), xi(e, wi), xi(Me(Me(t)), vr), t = Me(Me(t))) : (t === tg(Me(t)) && (t = Me(t), this.rotateRight(t)), xi(Me(t), wi), xi(Me(Me(t)), vr), this.rotateLeft(Me(Me(t)))));
        this.root_.color = wi
    }

    values() {
        const t = new ct;
        let e = this.getFirstEntry();
        if (e !== null) for (t.add(e.value); (e = Ui.successor(e)) !== null;) t.add(e.value);
        return t
    }

    entrySet() {
        const t = new Rh;
        let e = this.getFirstEntry();
        if (e !== null) for (t.add(e); (e = Ui.successor(e)) !== null;) t.add(e);
        return t
    }

    rotateLeft(t) {
        if (t != null) {
            const e = t.right;
            t.right = e.left, e.left != null && (e.left.parent = t), e.parent = t.parent, t.parent == null ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e
        }
    }

    rotateRight(t) {
        if (t != null) {
            const e = t.left;
            t.left = e.right, e.right != null && (e.right.parent = t), e.parent = t.parent, t.parent == null ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e
        }
    }

    getFirstEntry() {
        let t = this.root_;
        if (t != null) for (; t.left != null;) t = t.left;
        return t
    }

    static successor(t) {
        let e;
        if (t === null) return null;
        if (t.right !== null) {
            for (e = t.right; e.left !== null;) e = e.left;
            return e
        } else {
            e = t.parent;
            let n = t;
            for (; e !== null && n === e.right;) n = e, e = e.parent;
            return e
        }
    }

    size() {
        return this.size_
    }

    containsKey(t) {
        let e = this.root_;
        for (; e !== null;) {
            const n = t.compareTo(e.key);
            if (n < 0) e = e.left; else if (n > 0) e = e.right; else return !0
        }
        return !1
    }
}

class l_ {
    constructor() {
        l_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._nodeMap = new Ui, this.edge = null;
        const t = arguments[0];
        this.edge = t
    }

    print(t) {
        t.println("Intersections:");
        for (let e = this.iterator(); e.hasNext();) e.next().print(t)
    }

    iterator() {
        return this._nodeMap.values().iterator()
    }

    addSplitEdges(t) {
        this.addEndpoints();
        const e = this.iterator();
        let n = e.next();
        for (; e.hasNext();) {
            const s = e.next(), r = this.createSplitEdge(n, s);
            t.add(r), n = s
        }
    }

    addEndpoints() {
        const t = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
    }

    createSplitEdge(t, e) {
        let n = e.segmentIndex - t.segmentIndex + 2;
        const s = this.edge.pts[e.segmentIndex], r = e.dist > 0 || !e.coord.equals2D(s);
        r || n--;
        const o = new Array(n).fill(null);
        let a = 0;
        o[a++] = new F(t.coord);
        for (let l = t.segmentIndex + 1; l <= e.segmentIndex; l++) o[a++] = this.edge.pts[l];
        return r && (o[a] = e.coord), new li(o, new Ye(this.edge._label))
    }

    add(t, e, n) {
        const s = new a_(t, e, n), r = this._nodeMap.get(s);
        return r !== null ? r : (this._nodeMap.put(s, s), s)
    }

    isIntersection(t) {
        for (let e = this.iterator(); e.hasNext();) if (e.next().coord.equals(t)) return !0;
        return !1
    }
}

class wd {
    constructor() {
        wd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._data = null, this._size = 0, arguments.length === 0) wd.constructor_.call(this, 10); else if (arguments.length === 1) {
            const t = arguments[0];
            this._data = new Array(t).fill(null)
        }
    }

    size() {
        return this._size
    }

    addAll(t) {
        if (t === null || t.length === 0) return null;
        this.ensureCapacity(this._size + t.length), ws.arraycopy(t, 0, this._data, this._size, t.length), this._size += t.length
    }

    ensureCapacity(t) {
        if (t <= this._data.length) return null;
        const e = Math.max(t, this._data.length * 2);
        this._data = Fr.copyOf(this._data, e)
    }

    toArray() {
        const t = new Array(this._size).fill(null);
        return ws.arraycopy(this._data, 0, t, 0, this._size), t
    }

    add(t) {
        this.ensureCapacity(this._size + 1), this._data[this._size] = t, ++this._size
    }
}

class c_ {
    static toIntArray(t) {
        const e = new Array(t.size()).fill(null);
        for (let n = 0; n < e.length; n++) e[n] = t.get(n).intValue();
        return e
    }

    getChainStartIndices(t) {
        let e = 0;
        const n = new wd(Math.trunc(t.length / 2));
        n.add(e);
        do {
            const s = this.findChainEnd(t, e);
            n.add(s), e = s
        } while (e < t.length - 1);
        return n.toArray()
    }

    findChainEnd(t, e) {
        const n = De.quadrant(t[e], t[e + 1]);
        let s = e + 1;
        for (; s < t.length && De.quadrant(t[s - 1], t[s]) === n;) s++;
        return s - 1
    }

    OLDgetChainStartIndices(t) {
        let e = 0;
        const n = new ct;
        n.add(e);
        do {
            const r = this.findChainEnd(t, e);
            n.add(r), e = r
        } while (e < t.length - 1);
        return c_.toIntArray(n)
    }
}

class h_ {
    constructor() {
        h_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.e = null, this.pts = null, this.startIndex = null;
        const t = arguments[0];
        this.e = t, this.pts = t.getCoordinates();
        const e = new c_;
        this.startIndex = e.getChainStartIndices(this.pts)
    }

    getCoordinates() {
        return this.pts
    }

    getMaxX(t) {
        const e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
        return e > n ? e : n
    }

    getMinX(t) {
        const e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
        return e < n ? e : n
    }

    computeIntersectsForChain() {
        if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], s)
        } else if (arguments.length === 6) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = arguments[4],
                o = arguments[5];
            if (e - t === 1 && r - s === 1) return o.addIntersections(this.e, t, n.e, s), null;
            if (!this.overlaps(t, e, n, s, r)) return null;
            const a = Math.trunc((t + e) / 2), l = Math.trunc((s + r) / 2);
            t < a && (s < l && this.computeIntersectsForChain(t, a, n, s, l, o), l < r && this.computeIntersectsForChain(t, a, n, l, r, o)), a < e && (s < l && this.computeIntersectsForChain(a, e, n, s, l, o), l < r && this.computeIntersectsForChain(a, e, n, l, r, o))
        }
    }

    overlaps(t, e, n, s, r) {
        return Kt.intersects(this.pts[t], this.pts[e], n.pts[s], n.pts[r])
    }

    getStartIndexes() {
        return this.startIndex
    }

    computeIntersects(t, e) {
        for (let n = 0; n < this.startIndex.length - 1; n++) for (let s = 0; s < t.startIndex.length - 1; s++) this.computeIntersectsForChain(n, t, s, e)
    }
}

class si {
    constructor() {
        si.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._depth = Array(2).fill().map(() => Array(3));
        for (let t = 0; t < 2; t++) for (let e = 0; e < 3; e++) this._depth[t][e] = si.NULL_VALUE
    }

    static depthAtLocation(t) {
        return t === T.EXTERIOR ? 0 : t === T.INTERIOR ? 1 : si.NULL_VALUE
    }

    getDepth(t, e) {
        return this._depth[t][e]
    }

    setDepth(t, e, n) {
        this._depth[t][e] = n
    }

    isNull() {
        if (arguments.length === 0) {
            for (let t = 0; t < 2; t++) for (let e = 0; e < 3; e++) if (this._depth[t][e] !== si.NULL_VALUE) return !1;
            return !0
        } else if (arguments.length === 1) {
            const t = arguments[0];
            return this._depth[t][1] === si.NULL_VALUE
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return this._depth[t][e] === si.NULL_VALUE
        }
    }

    normalize() {
        for (let t = 0; t < 2; t++) if (!this.isNull(t)) {
            let e = this._depth[t][1];
            this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);
            for (let n = 1; n < 3; n++) {
                let s = 0;
                this._depth[t][n] > e && (s = 1), this._depth[t][n] = s
            }
        }
    }

    getDelta(t) {
        return this._depth[t][ot.RIGHT] - this._depth[t][ot.LEFT]
    }

    getLocation(t, e) {
        return this._depth[t][e] <= 0 ? T.EXTERIOR : T.INTERIOR
    }

    toString() {
        return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2]
    }

    add() {
        if (arguments.length === 1) {
            const t = arguments[0];
            for (let e = 0; e < 2; e++) for (let n = 1; n < 3; n++) {
                const s = t.getLocation(e, n);
                (s === T.EXTERIOR || s === T.INTERIOR) && (this.isNull(e, n) ? this._depth[e][n] = si.depthAtLocation(s) : this._depth[e][n] += si.depthAtLocation(s))
            }
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1];
            arguments[2] === T.INTERIOR && this._depth[t][e]++
        }
    }
}

si.NULL_VALUE = -1;

class Rf {
    constructor() {
        Rf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0) {
            if (arguments.length === 1) {
                const t = arguments[0];
                this._label = t
            }
        }
    }

    setVisited(t) {
        this._isVisited = t
    }

    setInResult(t) {
        this._isInResult = t
    }

    isCovered() {
        return this._isCovered
    }

    isCoveredSet() {
        return this._isCoveredSet
    }

    setLabel(t) {
        this._label = t
    }

    getLabel() {
        return this._label
    }

    setCovered(t) {
        this._isCovered = t, this._isCoveredSet = !0
    }

    updateIM(t) {
        $t.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t)
    }

    isInResult() {
        return this._isInResult
    }

    isVisited() {
        return this._isVisited
    }
}

class li extends Rf {
    constructor() {
        super(), li.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this.pts = null, this._env = null, this.eiList = new l_(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new si, this._depthDelta = 0, arguments.length === 1) {
            const t = arguments[0];
            li.constructor_.call(this, t, null)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.pts = t, this._label = e
        }
    }

    static updateIM() {
        if (arguments.length === 2 && arguments[1] instanceof be && arguments[0] instanceof Ye) {
            const t = arguments[0], e = arguments[1];
            e.setAtLeastIfValid(t.getLocation(0, ot.ON), t.getLocation(1, ot.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, ot.LEFT), t.getLocation(1, ot.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, ot.RIGHT), t.getLocation(1, ot.RIGHT), 2))
        } else return super.updateIM.apply(this, arguments)
    }

    getDepth() {
        return this._depth
    }

    getCollapsedEdge() {
        const t = new Array(2).fill(null);
        return t[0] = this.pts[0], t[1] = this.pts[1], new li(t, Ye.toLineLabel(this._label))
    }

    isIsolated() {
        return this._isIsolated
    }

    getCoordinates() {
        return this.pts
    }

    setIsolated(t) {
        this._isIsolated = t
    }

    setName(t) {
        this._name = t
    }

    equals(t) {
        if (!(t instanceof li)) return !1;
        const e = t;
        if (this.pts.length !== e.pts.length) return !1;
        let n = !0, s = !0, r = this.pts.length;
        for (let o = 0; o < this.pts.length; o++) if (this.pts[o].equals2D(e.pts[o]) || (n = !1), this.pts[o].equals2D(e.pts[--r]) || (s = !1), !n && !s) return !1;
        return !0
    }

    getCoordinate() {
        if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
        if (arguments.length === 1) {
            const t = arguments[0];
            return this.pts[t]
        }
    }

    print(t) {
        t.print("edge " + this._name + ": "), t.print("LINESTRING (");
        for (let e = 0; e < this.pts.length; e++) e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
        t.print(")  " + this._label + " " + this._depthDelta)
    }

    computeIM(t) {
        li.updateIM(this._label, t)
    }

    isCollapsed() {
        return !this._label.isArea() || this.pts.length !== 3 ? !1 : !!this.pts[0].equals(this.pts[2])
    }

    isClosed() {
        return this.pts[0].equals(this.pts[this.pts.length - 1])
    }

    getMaximumSegmentIndex() {
        return this.pts.length - 1
    }

    getDepthDelta() {
        return this._depthDelta
    }

    getNumPoints() {
        return this.pts.length
    }

    printReverse(t) {
        t.print("edge " + this._name + ": ");
        for (let e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + " ");
        t.println("")
    }

    getMonotoneChainEdge() {
        return this._mce === null && (this._mce = new h_(this)), this._mce
    }

    getEnvelope() {
        if (this._env === null) {
            this._env = new Kt;
            for (let t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t])
        }
        return this._env
    }

    addIntersection(t, e, n, s) {
        const r = new F(t.getIntersection(s));
        let o = e, a = t.getEdgeDistance(n, s);
        const l = o + 1;
        if (l < this.pts.length) {
            const c = this.pts[l];
            r.equals2D(c) && (o = l, a = 0)
        }
        this.eiList.add(r, o, a)
    }

    toString() {
        const t = new If;
        t.append("edge " + this._name + ": "), t.append("LINESTRING (");
        for (let e = 0; e < this.pts.length; e++) e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
        return t.append(")  " + this._label + " " + this._depthDelta), t.toString()
    }

    isPointwiseEqual(t) {
        if (this.pts.length !== t.pts.length) return !1;
        for (let e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;
        return !0
    }

    setDepthDelta(t) {
        this._depthDelta = t
    }

    getEdgeIntersectionList() {
        return this.eiList
    }

    addIntersections(t, e, n) {
        for (let s = 0; s < t.getIntersectionNum(); s++) this.addIntersection(t, e, n, s)
    }
}

class hr extends Rf {
    constructor() {
        super(), hr.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._coord = null, this._edges = null;
        const t = arguments[0], e = arguments[1];
        this._coord = t, this._edges = e, this._label = new Ye(0, T.NONE)
    }

    isIncidentEdgeInResult() {
        for (let t = this.getEdges().getEdges().iterator(); t.hasNext();) if (t.next().getEdge().isInResult()) return !0;
        return !1
    }

    isIsolated() {
        return this._label.getGeometryCount() === 1
    }

    getCoordinate() {
        return this._coord
    }

    print(t) {
        t.println("node " + this._coord + " lbl: " + this._label)
    }

    computeIM(t) {
    }

    computeMergedLocation(t, e) {
        let n = T.NONE;
        if (n = this._label.getLocation(e), !t.isNull(e)) {
            const s = t.getLocation(e);
            n !== T.BOUNDARY && (n = s)
        }
        return n
    }

    setLabel() {
        if (arguments.length === 2 && Number.isInteger(arguments[1]) && Number.isInteger(arguments[0])) {
            const t = arguments[0], e = arguments[1];
            this._label === null ? this._label = new Ye(t, e) : this._label.setLocation(t, e)
        } else return super.setLabel.apply(this, arguments)
    }

    getEdges() {
        return this._edges
    }

    mergeLabel() {
        if (arguments[0] instanceof hr) {
            const t = arguments[0];
            this.mergeLabel(t._label)
        } else if (arguments[0] instanceof Ye) {
            const t = arguments[0];
            for (let e = 0; e < 2; e++) {
                const n = this.computeMergedLocation(t, e);
                this._label.getLocation(e) === T.NONE && this._label.setLocation(e, n)
            }
        }
    }

    add(t) {
        this._edges.insert(t), t.setNode(this)
    }

    setLabelBoundary(t) {
        if (this._label === null) return null;
        let e = T.NONE;
        this._label !== null && (e = this._label.getLocation(t));
        let n = null;
        switch (e) {
            case T.BOUNDARY:
                n = T.INTERIOR;
                break;
            case T.INTERIOR:
                n = T.BOUNDARY;
                break;
            default:
                n = T.BOUNDARY;
                break
        }
        this._label.setLocation(t, n)
    }
}

class gl {
    constructor() {
        gl.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.nodeMap = new Ui, this.nodeFact = null;
        const t = arguments[0];
        this.nodeFact = t
    }

    find(t) {
        return this.nodeMap.get(t)
    }

    addNode() {
        if (arguments[0] instanceof F) {
            const t = arguments[0];
            let e = this.nodeMap.get(t);
            return e === null && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e
        } else if (arguments[0] instanceof hr) {
            const t = arguments[0], e = this.nodeMap.get(t.getCoordinate());
            return e === null ? (this.nodeMap.put(t.getCoordinate(), t), t) : (e.mergeLabel(t), e)
        }
    }

    print(t) {
        for (let e = this.iterator(); e.hasNext();) e.next().print(t)
    }

    iterator() {
        return this.nodeMap.values().iterator()
    }

    values() {
        return this.nodeMap.values()
    }

    getBoundaryNodes(t) {
        const e = new ct;
        for (let n = this.iterator(); n.hasNext();) {
            const s = n.next();
            s.getLabel().getLocation(t) === T.BOUNDARY && e.add(s)
        }
        return e
    }

    add(t) {
        const e = t.getCoordinate();
        this.addNode(e).add(t)
    }
}

class Ni {
    constructor() {
        Ni.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
            const t = arguments[0];
            this._edge = t
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            Ni.constructor_.call(this, t, e, n, null)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            Ni.constructor_.call(this, t), this.init(e, n), this._label = s
        }
    }

    compareDirection(t) {
        return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : Dt.index(t._p0, t._p1, this._p1)
    }

    getDy() {
        return this._dy
    }

    getCoordinate() {
        return this._p0
    }

    setNode(t) {
        this._node = t
    }

    print(t) {
        const e = Math.atan2(this._dy, this._dx), n = this.getClass().getName(), s = n.lastIndexOf("."),
            r = n.substring(s + 1);
        t.print("  " + r + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label)
    }

    compareTo(t) {
        const e = t;
        return this.compareDirection(e)
    }

    getDirectedCoordinate() {
        return this._p1
    }

    getDx() {
        return this._dx
    }

    getLabel() {
        return this._label
    }

    getEdge() {
        return this._edge
    }

    getQuadrant() {
        return this._quadrant
    }

    getNode() {
        return this._node
    }

    toString() {
        const t = Math.atan2(this._dy, this._dx), e = this.getClass().getName(), n = e.lastIndexOf(".");
        return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label
    }

    computeLabel(t) {
    }

    init(t, e) {
        this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = De.quadrant(this._dx, this._dy), $t.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found")
    }

    get interfaces_() {
        return [Es]
    }
}

class Us extends vs {
    constructor(t, e) {
        super(e ? t + " [ " + e + " ]" : t), this.pt = e ? new F(e) : void 0, this.name = Object.keys({TopologyException: Us})[0]
    }

    getCoordinate() {
        return this.pt
    }
}

class th extends Ni {
    constructor() {
        super(), th.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
        const t = arguments[0], e = arguments[1];
        if (Ni.constructor_.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1)); else {
            const n = t.getNumPoints() - 1;
            this.init(t.getCoordinate(n), t.getCoordinate(n - 1))
        }
        this.computeDirectedLabel()
    }

    static depthFactor(t, e) {
        return t === T.EXTERIOR && e === T.INTERIOR ? 1 : t === T.INTERIOR && e === T.EXTERIOR ? -1 : 0
    }

    getNextMin() {
        return this._nextMin
    }

    getDepth(t) {
        return this._depth[t]
    }

    setVisited(t) {
        this._isVisited = t
    }

    computeDirectedLabel() {
        this._label = new Ye(this._edge.getLabel()), this._isForward || this._label.flip()
    }

    getNext() {
        return this._next
    }

    setDepth(t, e) {
        if (this._depth[t] !== -999 && this._depth[t] !== e) throw new Us("assigned depths do not match", this.getCoordinate());
        this._depth[t] = e
    }

    isInteriorAreaEdge() {
        let t = !0;
        for (let e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, ot.LEFT) === T.INTERIOR && this._label.getLocation(e, ot.RIGHT) === T.INTERIOR || (t = !1);
        return t
    }

    setNextMin(t) {
        this._nextMin = t
    }

    print(t) {
        super.print.call(this, t), t.print(" " + this._depth[ot.LEFT] + "/" + this._depth[ot.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult")
    }

    setMinEdgeRing(t) {
        this._minEdgeRing = t
    }

    isLineEdge() {
        const t = this._label.isLine(0) || this._label.isLine(1),
            e = !this._label.isArea(0) || this._label.allPositionsEqual(0, T.EXTERIOR),
            n = !this._label.isArea(1) || this._label.allPositionsEqual(1, T.EXTERIOR);
        return t && e && n
    }

    setEdgeRing(t) {
        this._edgeRing = t
    }

    getMinEdgeRing() {
        return this._minEdgeRing
    }

    getDepthDelta() {
        let t = this._edge.getDepthDelta();
        return this._isForward || (t = -t), t
    }

    setInResult(t) {
        this._isInResult = t
    }

    getSym() {
        return this._sym
    }

    isForward() {
        return this._isForward
    }

    getEdge() {
        return this._edge
    }

    printEdge(t) {
        this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t)
    }

    setSym(t) {
        this._sym = t
    }

    setVisitedEdge(t) {
        this.setVisited(t), this._sym.setVisited(t)
    }

    setEdgeDepths(t, e) {
        let n = this.getEdge().getDepthDelta();
        this._isForward || (n = -n);
        let s = 1;
        t === ot.LEFT && (s = -1);
        const r = ot.opposite(t), o = n * s, a = e + o;
        this.setDepth(t, e), this.setDepth(r, a)
    }

    getEdgeRing() {
        return this._edgeRing
    }

    isInResult() {
        return this._isInResult
    }

    setNext(t) {
        this._next = t
    }

    isVisited() {
        return this._isVisited
    }
}

class u_ {
    createNode(t) {
        return new hr(t, null)
    }
}

class Qo {
    constructor() {
        Qo.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._edges = new ct, this._nodes = null, this._edgeEndList = new ct, arguments.length === 0) this._nodes = new gl(new u_); else if (arguments.length === 1) {
            const t = arguments[0];
            this._nodes = new gl(t)
        }
    }

    static linkResultDirectedEdges(t) {
        for (let e = t.iterator(); e.hasNext();) e.next().getEdges().linkResultDirectedEdges()
    }

    printEdges(t) {
        t.println("Edges:");
        for (let e = 0; e < this._edges.size(); e++) {
            t.println("edge " + e + ":");
            const n = this._edges.get(e);
            n.print(t), n.eiList.print(t)
        }
    }

    find(t) {
        return this._nodes.find(t)
    }

    addNode() {
        if (arguments[0] instanceof hr) {
            const t = arguments[0];
            return this._nodes.addNode(t)
        } else if (arguments[0] instanceof F) {
            const t = arguments[0];
            return this._nodes.addNode(t)
        }
    }

    getNodeIterator() {
        return this._nodes.iterator()
    }

    linkResultDirectedEdges() {
        for (let t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkResultDirectedEdges()
    }

    debugPrintln(t) {
        ws.out.println(t)
    }

    isBoundaryNode(t, e) {
        const n = this._nodes.find(e);
        if (n === null) return !1;
        const s = n.getLabel();
        return s !== null && s.getLocation(t) === T.BOUNDARY
    }

    linkAllDirectedEdges() {
        for (let t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkAllDirectedEdges()
    }

    matchInSameDirection(t, e, n, s) {
        return t.equals(n) ? Dt.index(t, e, s) === Dt.COLLINEAR && De.quadrant(t, e) === De.quadrant(n, s) : !1
    }

    getEdgeEnds() {
        return this._edgeEndList
    }

    debugPrint(t) {
        ws.out.print(t)
    }

    getEdgeIterator() {
        return this._edges.iterator()
    }

    findEdgeInSameDirection(t, e) {
        for (let n = 0; n < this._edges.size(); n++) {
            const s = this._edges.get(n), r = s.getCoordinates();
            if (this.matchInSameDirection(t, e, r[0], r[1]) || this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return s
        }
        return null
    }

    insertEdge(t) {
        this._edges.add(t)
    }

    findEdgeEnd(t) {
        for (let e = this.getEdgeEnds().iterator(); e.hasNext();) {
            const n = e.next();
            if (n.getEdge() === t) return n
        }
        return null
    }

    addEdges(t) {
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next();
            this._edges.add(n);
            const s = new th(n, !0), r = new th(n, !1);
            s.setSym(r), r.setSym(s), this.add(s), this.add(r)
        }
    }

    add(t) {
        this._nodes.add(t), this._edgeEndList.add(t)
    }

    getNodes() {
        return this._nodes.values()
    }

    findEdge(t, e) {
        for (let n = 0; n < this._edges.size(); n++) {
            const s = this._edges.get(n), r = s.getCoordinates();
            if (t.equals(r[0]) && e.equals(r[1])) return s
        }
        return null
    }
}

class Fs extends Qo {
    constructor() {
        super(), Fs.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._parentGeom = null, this._lineEdgeMap = new zS, this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Jo, arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            Fs.constructor_.call(this, t, e, Dn.OGC_SFS_BOUNDARY_RULE)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._argIndex = t, this._parentGeom = e, this._boundaryNodeRule = n, e !== null && this.add(e)
        }
    }

    static determineBoundary(t, e) {
        return t.isInBoundary(e) ? T.BOUNDARY : T.INTERIOR
    }

    insertBoundaryPoint(t, e) {
        const s = this._nodes.addNode(e).getLabel();
        let r = 1, o = T.NONE;
        o = s.getLocation(t, ot.ON), o === T.BOUNDARY && r++;
        const a = Fs.determineBoundary(this._boundaryNodeRule, r);
        s.setLocation(t, a)
    }

    computeSelfNodes() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return this.computeSelfNodes(t, e, !1)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = new $o(t, !0, !1);
            s.setIsDoneIfProperInt(n);
            const r = this.createEdgeSetIntersector(),
                o = this._parentGeom instanceof Un || this._parentGeom instanceof $e || this._parentGeom instanceof bs,
                a = e || !o;
            return r.computeIntersections(this._edges, s, a), this.addSelfIntersectionNodes(this._argIndex), s
        }
    }

    computeSplitEdges(t) {
        for (let e = this._edges.iterator(); e.hasNext();) e.next().eiList.addSplitEdges(t)
    }

    computeEdgeIntersections(t, e, n) {
        const s = new $o(e, n, !0);
        return s.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, s), s
    }

    getGeometry() {
        return this._parentGeom
    }

    getBoundaryNodeRule() {
        return this._boundaryNodeRule
    }

    hasTooFewPoints() {
        return this._hasTooFewPoints
    }

    addPoint() {
        if (arguments[0] instanceof on) {
            const e = arguments[0].getCoordinate();
            this.insertPoint(this._argIndex, e, T.INTERIOR)
        } else if (arguments[0] instanceof F) {
            const t = arguments[0];
            this.insertPoint(this._argIndex, t, T.INTERIOR)
        }
    }

    addPolygon(t) {
        this.addPolygonRing(t.getExteriorRing(), T.EXTERIOR, T.INTERIOR);
        for (let e = 0; e < t.getNumInteriorRing(); e++) {
            const n = t.getInteriorRingN(e);
            this.addPolygonRing(n, T.INTERIOR, T.EXTERIOR)
        }
    }

    addEdge(t) {
        this.insertEdge(t);
        const e = t.getCoordinates();
        this.insertPoint(this._argIndex, e[0], T.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], T.BOUNDARY)
    }

    addLineString(t) {
        const e = ze.removeRepeatedPoints(t.getCoordinates());
        if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;
        const n = new li(e, new Ye(this._argIndex, T.INTERIOR));
        this._lineEdgeMap.put(t, n), this.insertEdge(n), $t.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1])
    }

    getInvalidPoint() {
        return this._invalidPoint
    }

    getBoundaryPoints() {
        const t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null);
        let n = 0;
        for (let s = t.iterator(); s.hasNext();) {
            const r = s.next();
            e[n++] = r.getCoordinate().copy()
        }
        return e
    }

    getBoundaryNodes() {
        return this._boundaryNodes === null && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes
    }

    addSelfIntersectionNode(t, e, n) {
        if (this.isBoundaryNode(t, e)) return null;
        n === T.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n)
    }

    addPolygonRing(t, e, n) {
        if (t.isEmpty()) return null;
        const s = ze.removeRepeatedPoints(t.getCoordinates());
        if (s.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = s[0], null;
        let r = e, o = n;
        Dt.isCCW(s) && (r = n, o = e);
        const a = new li(s, new Ye(this._argIndex, T.BOUNDARY, r, o));
        this._lineEdgeMap.put(t, a), this.insertEdge(a), this.insertPoint(this._argIndex, s[0], T.BOUNDARY)
    }

    insertPoint(t, e, n) {
        const s = this._nodes.addNode(e), r = s.getLabel();
        r === null ? s._label = new Ye(t, n) : r.setLocation(t, n)
    }

    createEdgeSetIntersector() {
        return new o_
    }

    addSelfIntersectionNodes(t) {
        for (let e = this._edges.iterator(); e.hasNext();) {
            const n = e.next(), s = n.getLabel().getLocation(t);
            for (let r = n.eiList.iterator(); r.hasNext();) {
                const o = r.next();
                this.addSelfIntersectionNode(t, o.coord, s)
            }
        }
    }

    add() {
        if (arguments.length === 1 && arguments[0] instanceof it) {
            const t = arguments[0];
            if (t.isEmpty()) return null;
            if (t instanceof bs && (this._useBoundaryDeterminationRule = !1), t instanceof $e) this.addPolygon(t); else if (t instanceof Te) this.addLineString(t); else if (t instanceof on) this.addPoint(t); else if (t instanceof di) this.addCollection(t); else if (t instanceof Ks) this.addCollection(t); else if (t instanceof bs) this.addCollection(t); else if (t instanceof Ie) this.addCollection(t); else throw new Js(t.getGeometryType())
        } else return super.add.apply(this, arguments)
    }

    addCollection(t) {
        for (let e = 0; e < t.getNumGeometries(); e++) {
            const n = t.getGeometryN(e);
            this.add(n)
        }
    }

    locate(t) {
        return At(this._parentGeom, Ko) && this._parentGeom.getNumGeometries() > 50 ? (this._areaPtLocator === null && (this._areaPtLocator = new zl(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom)
    }

    findEdge() {
        if (arguments.length === 1 && arguments[0] instanceof Te) {
            const t = arguments[0];
            return this._lineEdgeMap.get(t)
        } else return super.findEdge.apply(this, arguments)
    }
}

new F(0, 0);

class wz {
    insert(t, e) {
    }

    remove(t, e) {
    }

    query() {
    }
}

class KS {
    getBounds() {
    }
}

class oi {
    constructor() {
        oi.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._bounds = null, this._item = null;
        const t = arguments[0], e = arguments[1];
        this._bounds = t, this._item = e
    }

    getItem() {
        return this._item
    }

    getBounds() {
        return this._bounds
    }

    get interfaces_() {
        return [KS, Ss]
    }
}

class Fa {
    constructor() {
        Fa.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._size = null, this._items = null, this._size = 0, this._items = new ct, this._items.add(null)
    }

    poll() {
        if (this.isEmpty()) return null;
        const t = this._items.get(1);
        return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t
    }

    size() {
        return this._size
    }

    reorder(t) {
        let e = null;
        const n = this._items.get(t);
        for (; t * 2 <= this._size && (e = t * 2, e !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));
        this._items.set(t, n)
    }

    clear() {
        this._size = 0, this._items.clear()
    }

    peek() {
        return this.isEmpty() ? null : this._items.get(1)
    }

    isEmpty() {
        return this._size === 0
    }

    add(t) {
        this._items.add(null), this._size += 1;
        let e = this._size;
        for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));
        this._items.set(e, t)
    }
}

class ms {
    constructor() {
        ms.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._childBoundables = new ct, this._bounds = null, this._level = null, arguments.length !== 0) {
            if (arguments.length === 1) {
                const t = arguments[0];
                this._level = t
            }
        }
    }

    getLevel() {
        return this._level
    }

    size() {
        return this._childBoundables.size()
    }

    getChildBoundables() {
        return this._childBoundables
    }

    addChildBoundable(t) {
        $t.isTrue(this._bounds === null), this._childBoundables.add(t)
    }

    isEmpty() {
        return this._childBoundables.isEmpty()
    }

    getBounds() {
        return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds
    }

    get interfaces_() {
        return [KS, Ss]
    }
}

class Ke {
    static maxDistance(t, e, n, s, r, o, a, l) {
        let c = Ke.distance(t, e, r, o);
        return c = Math.max(c, Ke.distance(t, e, a, l)), c = Math.max(c, Ke.distance(n, s, r, o)), c = Math.max(c, Ke.distance(n, s, a, l)), c
    }

    static distance(t, e, n, s) {
        const r = n - t, o = s - e;
        return Math.sqrt(r * r + o * o)
    }

    static maximumDistance(t, e) {
        const n = Math.min(t.getMinX(), e.getMinX()), s = Math.min(t.getMinY(), e.getMinY()),
            r = Math.max(t.getMaxX(), e.getMaxX()), o = Math.max(t.getMaxY(), e.getMaxY());
        return Ke.distance(n, s, r, o)
    }

    static minMaxDistance(t, e) {
        const n = t.getMinX(), s = t.getMinY(), r = t.getMaxX(), o = t.getMaxY(), a = e.getMinX(), l = e.getMinY(),
            c = e.getMaxX(), h = e.getMaxY();
        let u = Ke.maxDistance(n, s, n, o, a, l, a, h);
        return u = Math.min(u, Ke.maxDistance(n, s, n, o, a, l, c, l)), u = Math.min(u, Ke.maxDistance(n, s, n, o, c, h, a, h)), u = Math.min(u, Ke.maxDistance(n, s, n, o, c, h, c, l)), u = Math.min(u, Ke.maxDistance(n, s, r, s, a, l, a, h)), u = Math.min(u, Ke.maxDistance(n, s, r, s, a, l, c, l)), u = Math.min(u, Ke.maxDistance(n, s, r, s, c, h, a, h)), u = Math.min(u, Ke.maxDistance(n, s, r, s, c, h, c, l)), u = Math.min(u, Ke.maxDistance(r, o, n, o, a, l, a, h)), u = Math.min(u, Ke.maxDistance(r, o, n, o, a, l, c, l)), u = Math.min(u, Ke.maxDistance(r, o, n, o, c, h, a, h)), u = Math.min(u, Ke.maxDistance(r, o, n, o, c, h, c, l)), u = Math.min(u, Ke.maxDistance(r, o, r, s, a, l, a, h)), u = Math.min(u, Ke.maxDistance(r, o, r, s, a, l, c, l)), u = Math.min(u, Ke.maxDistance(r, o, r, s, c, h, a, h)), u = Math.min(u, Ke.maxDistance(r, o, r, s, c, h, c, l)), u
    }
}

class qn {
    constructor() {
        qn.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance()
    }

    static area(t) {
        return t.getBounds().getArea()
    }

    static isComposite(t) {
        return t instanceof ms
    }

    maximumDistance() {
        return Ke.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds())
    }

    expandToQueue(t, e) {
        const n = qn.isComposite(this._boundable1), s = qn.isComposite(this._boundable2);
        if (n && s) return qn.area(this._boundable1) > qn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, t, e), null) : (this.expand(this._boundable2, this._boundable1, !0, t, e), null);
        if (n) return this.expand(this._boundable1, this._boundable2, !1, t, e), null;
        if (s) return this.expand(this._boundable2, this._boundable1, !0, t, e), null;
        throw new jt("neither boundable is composite")
    }

    isLeaves() {
        return !(qn.isComposite(this._boundable1) || qn.isComposite(this._boundable2))
    }

    compareTo(t) {
        const e = t;
        return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
    }

    expand(t, e, n, s, r) {
        const o = t.getChildBoundables();
        for (let a = o.iterator(); a.hasNext();) {
            const l = a.next();
            let c = null;
            n ? c = new qn(e, l, this._itemDistance) : c = new qn(l, e, this._itemDistance), c.getDistance() < r && s.add(c)
        }
    }

    getBoundable(t) {
        return t === 0 ? this._boundable1 : this._boundable2
    }

    getDistance() {
        return this._distance
    }

    distance() {
        return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds())
    }

    get interfaces_() {
        return [Es]
    }
}

class Oi {
    constructor() {
        Oi.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._root = null, this._built = !1, this._itemBoundables = new ct, this._nodeCapacity = null, arguments.length === 0) Oi.constructor_.call(this, Oi.DEFAULT_NODE_CAPACITY); else if (arguments.length === 1) {
            const t = arguments[0];
            $t.isTrue(t > 1, "Node capacity must be greater than 1"), this._nodeCapacity = t
        }
    }

    static compareDoubles(t, e) {
        return t > e ? 1 : t < e ? -1 : 0
    }

    queryInternal() {
        if (At(arguments[2], Af) && arguments[0] instanceof Object && arguments[1] instanceof ms) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = e.getChildBoundables();
            for (let r = 0; r < s.size(); r++) {
                const o = s.get(r);
                this.getIntersectsOp().intersects(o.getBounds(), t) && (o instanceof ms ? this.queryInternal(t, o, n) : o instanceof oi ? n.visitItem(o.getItem()) : $t.shouldNeverReachHere())
            }
        } else if (At(arguments[2], Bs) && arguments[0] instanceof Object && arguments[1] instanceof ms) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = e.getChildBoundables();
            for (let r = 0; r < s.size(); r++) {
                const o = s.get(r);
                this.getIntersectsOp().intersects(o.getBounds(), t) && (o instanceof ms ? this.queryInternal(t, o, n) : o instanceof oi ? n.add(o.getItem()) : $t.shouldNeverReachHere())
            }
        }
    }

    getNodeCapacity() {
        return this._nodeCapacity
    }

    lastNode(t) {
        return t.get(t.size() - 1)
    }

    size() {
        if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
        if (arguments.length === 1) {
            const t = arguments[0];
            let e = 0;
            for (let n = t.getChildBoundables().iterator(); n.hasNext();) {
                const s = n.next();
                s instanceof ms ? e += this.size(s) : s instanceof oi && (e += 1)
            }
            return e
        }
    }

    removeItem(t, e) {
        let n = null;
        for (let s = t.getChildBoundables().iterator(); s.hasNext();) {
            const r = s.next();
            r instanceof oi && r.getItem() === e && (n = r)
        }
        return n !== null ? (t.getChildBoundables().remove(n), !0) : !1
    }

    itemsTree() {
        if (arguments.length === 0) {
            this.build();
            const t = this.itemsTree(this._root);
            return t === null ? new ct : t
        } else if (arguments.length === 1) {
            const t = arguments[0], e = new ct;
            for (let n = t.getChildBoundables().iterator(); n.hasNext();) {
                const s = n.next();
                if (s instanceof ms) {
                    const r = this.itemsTree(s);
                    r !== null && e.add(r)
                } else s instanceof oi ? e.add(s.getItem()) : $t.shouldNeverReachHere()
            }
            return e.size() <= 0 ? null : e
        }
    }

    insert(t, e) {
        $t.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new oi(t, e))
    }

    boundablesAtLevel() {
        if (arguments.length === 1) {
            const t = arguments[0], e = new ct;
            return this.boundablesAtLevel(t, this._root, e), e
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            if ($t.isTrue(t > -2), e.getLevel() === t) return n.add(e), null;
            for (let s = e.getChildBoundables().iterator(); s.hasNext();) {
                const r = s.next();
                r instanceof ms ? this.boundablesAtLevel(t, r, n) : ($t.isTrue(r instanceof oi), t === -1 && n.add(r))
            }
            return null
        }
    }

    query() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.build();
            const e = new ct;
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e), e
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e)
        }
    }

    build() {
        if (this._built) return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0
    }

    getRoot() {
        return this.build(), this._root
    }

    remove() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return this.build(), this.getIntersectsOp().intersects(this._root.getBounds(), t) ? this.remove(t, this._root, e) : !1
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            let s = this.removeItem(e, n);
            if (s) return !0;
            let r = null;
            for (let o = e.getChildBoundables().iterator(); o.hasNext();) {
                const a = o.next();
                if (this.getIntersectsOp().intersects(a.getBounds(), t) && a instanceof ms && (s = this.remove(t, a, n), s)) {
                    r = a;
                    break
                }
            }
            return r !== null && r.getChildBoundables().isEmpty() && e.getChildBoundables().remove(r), s
        }
    }

    createHigherLevels(t, e) {
        $t.isTrue(!t.isEmpty());
        const n = this.createParentBoundables(t, e + 1);
        return n.size() === 1 ? n.get(0) : this.createHigherLevels(n, e + 1)
    }

    depth() {
        if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
        if (arguments.length === 1) {
            const t = arguments[0];
            let e = 0;
            for (let n = t.getChildBoundables().iterator(); n.hasNext();) {
                const s = n.next();
                if (s instanceof ms) {
                    const r = this.depth(s);
                    r > e && (e = r)
                }
            }
            return e + 1
        }
    }

    createParentBoundables(t, e) {
        $t.isTrue(!t.isEmpty());
        const n = new ct;
        n.add(this.createNode(e));
        const s = new ct(t);
        cr.sort(s, this.getComparator());
        for (let r = s.iterator(); r.hasNext();) {
            const o = r.next();
            this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(o)
        }
        return n
    }

    isEmpty() {
        return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty()
    }

    get interfaces_() {
        return [Ss]
    }
}

function bz() {
}

Oi.IntersectsOp = bz;
Oi.DEFAULT_NODE_CAPACITY = 10;

class Ez {
    distance(t, e) {
    }
}

class nn extends Oi {
    constructor() {
        super(), nn.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (arguments.length === 0) nn.constructor_.call(this, nn.DEFAULT_NODE_CAPACITY); else if (arguments.length === 1) {
            const t = arguments[0];
            Oi.constructor_.call(this, t)
        }
    }

    static centreX(t) {
        return nn.avg(t.getMinX(), t.getMaxX())
    }

    static avg(t, e) {
        return (t + e) / 2
    }

    static getItems(t) {
        const e = new Array(t.size()).fill(null);
        let n = 0;
        for (; !t.isEmpty();) {
            const s = t.poll();
            e[n] = s.getBoundable(0).getItem(), n++
        }
        return e
    }

    static centreY(t) {
        return nn.avg(t.getMinY(), t.getMaxY())
    }

    createParentBoundablesFromVerticalSlices(t, e) {
        $t.isTrue(t.length > 0);
        const n = new ct;
        for (let s = 0; s < t.length; s++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[s], e));
        return n
    }

    nearestNeighbourK() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return this.nearestNeighbourK(t, St.POSITIVE_INFINITY, e)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            let s = e;
            const r = new Fa;
            r.add(t);
            const o = new Fa;
            for (; !r.isEmpty() && s >= 0;) {
                const a = r.poll(), l = a.getDistance();
                if (l >= s) break;
                a.isLeaves() ? o.size() < n ? o.add(a) : (o.peek().getDistance() > l && (o.poll(), o.add(a)), s = o.peek().getDistance()) : a.expandToQueue(r, s)
            }
            return nn.getItems(o)
        }
    }

    createNode(t) {
        return new Lf(t)
    }

    size() {
        return arguments.length === 0 ? super.size.call(this) : super.size.apply(this, arguments)
    }

    insert() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Kt) {
            const t = arguments[0], e = arguments[1];
            if (t.isNull()) return null;
            super.insert.call(this, t, e)
        } else return super.insert.apply(this, arguments)
    }

    getIntersectsOp() {
        return nn.intersectsOp
    }

    verticalSlices(t, e) {
        const n = Math.trunc(Math.ceil(t.size() / e)), s = new Array(e).fill(null), r = t.iterator();
        for (let o = 0; o < e; o++) {
            s[o] = new ct;
            let a = 0;
            for (; r.hasNext() && a < n;) {
                const l = r.next();
                s[o].add(l), a++
            }
        }
        return s
    }

    query() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return super.query.call(this, t)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            super.query.call(this, t, e)
        }
    }

    getComparator() {
        return nn.yComparator
    }

    createParentBoundablesFromVerticalSlice(t, e) {
        return super.createParentBoundables.call(this, t, e)
    }

    remove() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Kt) {
            const t = arguments[0], e = arguments[1];
            return super.remove.call(this, t, e)
        } else return super.remove.apply(this, arguments)
    }

    depth() {
        return arguments.length === 0 ? super.depth.call(this) : super.depth.apply(this, arguments)
    }

    createParentBoundables(t, e) {
        $t.isTrue(!t.isEmpty());
        const n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())), s = new ct(t);
        cr.sort(s, nn.xComparator);
        const r = this.verticalSlices(s, Math.trunc(Math.ceil(Math.sqrt(n))));
        return this.createParentBoundablesFromVerticalSlices(r, e)
    }

    nearestNeighbour() {
        if (arguments.length === 1) {
            if (At(arguments[0], Ez)) {
                const t = arguments[0];
                if (this.isEmpty()) return null;
                const e = new qn(this.getRoot(), this.getRoot(), t);
                return this.nearestNeighbour(e)
            } else if (arguments[0] instanceof qn) {
                const t = arguments[0];
                let e = St.POSITIVE_INFINITY, n = null;
                const s = new Fa;
                for (s.add(t); !s.isEmpty() && e > 0;) {
                    const r = s.poll(), o = r.getDistance();
                    if (o >= e) break;
                    r.isLeaves() ? (e = o, n = r) : r.expandToQueue(s, e)
                }
                return n === null ? null : [n.getBoundable(0).getItem(), n.getBoundable(1).getItem()]
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            if (this.isEmpty() || t.isEmpty()) return null;
            const n = new qn(this.getRoot(), t.getRoot(), e);
            return this.nearestNeighbour(n)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = new oi(t, e),
                r = new qn(this.getRoot(), s, n);
            return this.nearestNeighbour(r)[0]
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = new oi(t, e),
                o = new qn(this.getRoot(), r, n);
            return this.nearestNeighbourK(o, s)
        }
    }

    isWithinDistance() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            let n = St.POSITIVE_INFINITY;
            const s = new Fa;
            for (s.add(t); !s.isEmpty();) {
                const r = s.poll(), o = r.getDistance();
                if (o > e) return !1;
                if (r.maximumDistance() <= e) return !0;
                if (r.isLeaves()) {
                    if (n = o, n <= e) return !0
                } else r.expandToQueue(s, n)
            }
            return !1
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = new qn(this.getRoot(), t.getRoot(), e);
            return this.isWithinDistance(s, n)
        }
    }

    get interfaces_() {
        return [wz, Ss]
    }
}

class Lf extends ms {
    constructor() {
        super(), Lf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0];
        ms.constructor_.call(this, t)
    }

    computeBounds() {
        let t = null;
        for (let e = this.getChildBoundables().iterator(); e.hasNext();) {
            const n = e.next();
            t === null ? t = new Kt(n.getBounds()) : t.expandToInclude(n.getBounds())
        }
        return t
    }
}

nn.STRtreeNode = Lf;
nn.xComparator = new class {
    get interfaces_() {
        return [Kr]
    }

    compare(i, t) {
        return Oi.compareDoubles(nn.centreX(i.getBounds()), nn.centreX(t.getBounds()))
    }
};
nn.yComparator = new class {
    get interfaces_() {
        return [Kr]
    }

    compare(i, t) {
        return Oi.compareDoubles(nn.centreY(i.getBounds()), nn.centreY(t.getBounds()))
    }
};
nn.intersectsOp = new class {
    get interfaces_() {
        return [IntersectsOp]
    }

    intersects(i, t) {
        return i.intersects(t)
    }
};
nn.DEFAULT_NODE_CAPACITY = 10;

class Hs {
    static relativeSign(t, e) {
        return t < e ? -1 : t > e ? 1 : 0
    }

    static compare(t, e, n) {
        if (e.equals2D(n)) return 0;
        const s = Hs.relativeSign(e.x, n.x), r = Hs.relativeSign(e.y, n.y);
        switch (t) {
            case 0:
                return Hs.compareValue(s, r);
            case 1:
                return Hs.compareValue(r, s);
            case 2:
                return Hs.compareValue(r, -s);
            case 3:
                return Hs.compareValue(-s, r);
            case 4:
                return Hs.compareValue(-s, -r);
            case 5:
                return Hs.compareValue(-r, -s);
            case 6:
                return Hs.compareValue(-r, s);
            case 7:
                return Hs.compareValue(s, -r)
        }
        return $t.shouldNeverReachHere("invalid octant value"), 0
    }

    static compareValue(t, e) {
        return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0
    }
}

class d_ {
    constructor() {
        d_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
        const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
        this._segString = t, this.coord = new F(e), this.segmentIndex = n, this._segmentOctant = s, this._isInterior = !e.equals2D(t.getCoordinate(n))
    }

    getCoordinate() {
        return this.coord
    }

    print(t) {
        t.print(this.coord), t.print(" seg # = " + this.segmentIndex)
    }

    compareTo(t) {
        const e = t;
        return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : this._isInterior ? e._isInterior ? Hs.compare(this._segmentOctant, this.coord, e.coord) : 1 : -1
    }

    isEndPoint(t) {
        return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === t
    }

    toString() {
        return this.segmentIndex + ":" + this.coord.toString()
    }

    isInterior() {
        return this._isInterior
    }

    get interfaces_() {
        return [Es]
    }
}

class f_ {
    constructor() {
        f_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._nodeMap = new Ui, this._edge = null;
        const t = arguments[0];
        this._edge = t
    }

    getSplitCoordinates() {
        const t = new ui;
        this.addEndpoints();
        const e = this.iterator();
        let n = e.next();
        for (; e.hasNext();) {
            const s = e.next();
            this.addEdgeCoordinates(n, s, t), n = s
        }
        return t.toCoordinateArray()
    }

    addCollapsedNodes() {
        const t = new ct;
        this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next().intValue();
            this.add(this._edge.getCoordinate(n), n)
        }
    }

    createSplitEdgePts(t, e) {
        let n = e.segmentIndex - t.segmentIndex + 2;
        if (n === 2) return [new F(t.coord), new F(e.coord)];
        const s = this._edge.getCoordinate(e.segmentIndex), r = e.isInterior() || !e.coord.equals2D(s);
        r || n--;
        const o = new Array(n).fill(null);
        let a = 0;
        o[a++] = new F(t.coord);
        for (let l = t.segmentIndex + 1; l <= e.segmentIndex; l++) o[a++] = this._edge.getCoordinate(l);
        return r && (o[a] = new F(e.coord)), o
    }

    print(t) {
        t.println("Intersections:");
        for (let e = this.iterator(); e.hasNext();) e.next().print(t)
    }

    findCollapsesFromExistingVertices(t) {
        for (let e = 0; e < this._edge.size() - 2; e++) {
            const n = this._edge.getCoordinate(e);
            this._edge.getCoordinate(e + 1);
            const s = this._edge.getCoordinate(e + 2);
            n.equals2D(s) && t.add(dl.valueOf(e + 1))
        }
    }

    addEdgeCoordinates(t, e, n) {
        const s = this.createSplitEdgePts(t, e);
        n.add(s, !1)
    }

    iterator() {
        return this._nodeMap.values().iterator()
    }

    addSplitEdges(t) {
        this.addEndpoints(), this.addCollapsedNodes();
        const e = this.iterator();
        let n = e.next();
        for (; e.hasNext();) {
            const s = e.next(), r = this.createSplitEdge(n, s);
            t.add(r), n = s
        }
    }

    findCollapseIndex(t, e, n) {
        if (!t.coord.equals2D(e.coord)) return !1;
        let s = e.segmentIndex - t.segmentIndex;
        return e.isInterior() || s--, s === 1 ? (n[0] = t.segmentIndex + 1, !0) : !1
    }

    findCollapsesFromInsertedNodes(t) {
        const e = new Array(1).fill(null), n = this.iterator();
        let s = n.next();
        for (; n.hasNext();) {
            const r = n.next();
            this.findCollapseIndex(s, r, e) && t.add(dl.valueOf(e[0])), s = r
        }
    }

    getEdge() {
        return this._edge
    }

    addEndpoints() {
        const t = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t)
    }

    createSplitEdge(t, e) {
        const n = this.createSplitEdgePts(t, e);
        return new Di(n, this._edge.getData())
    }

    add(t, e) {
        const n = new d_(this._edge, t, e, this._edge.getSegmentOctant(e)), s = this._nodeMap.get(n);
        return s !== null ? ($t.isTrue(s.coord.equals2D(t), "Found equal nodes with different coordinates"), s) : (this._nodeMap.put(n, n), n)
    }

    checkSplitEdgesCorrectness(t) {
        const e = this._edge.getCoordinates(), s = t.get(0).getCoordinate(0);
        if (!s.equals2D(e[0])) throw new vs("bad split edge start point at " + s);
        const o = t.get(t.size() - 1).getCoordinates(), a = o[o.length - 1];
        if (!a.equals2D(e[e.length - 1])) throw new vs("bad split edge end point at " + a)
    }
}

class Nf {
    static octant() {
        if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            const t = arguments[0], e = arguments[1];
            if (t === 0 && e === 0) throw new jt("Cannot compute the octant for point ( " + t + ", " + e + " )");
            const n = Math.abs(t), s = Math.abs(e);
            return t >= 0 ? e >= 0 ? n >= s ? 0 : 1 : n >= s ? 7 : 6 : e >= 0 ? n >= s ? 3 : 2 : n >= s ? 4 : 5
        } else if (arguments[0] instanceof F && arguments[1] instanceof F) {
            const t = arguments[0], e = arguments[1], n = e.x - t.x, s = e.y - t.y;
            if (n === 0 && s === 0) throw new jt("Cannot compute the octant for two identical points " + t);
            return Nf.octant(n, s)
        }
    }
}

class JS {
    getCoordinates() {
    }

    size() {
    }

    getCoordinate(t) {
    }

    isClosed() {
    }

    setData(t) {
    }

    getData() {
    }
}

class Sz {
    addIntersection(t, e) {
    }

    get interfaces_() {
        return [JS]
    }
}

class Di {
    constructor() {
        Di.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._nodeList = new f_(this), this._pts = null, this._data = null;
        const t = arguments[0], e = arguments[1];
        this._pts = t, this._data = e
    }

    static getNodedSubstrings() {
        if (arguments.length === 1) {
            const t = arguments[0], e = new ct;
            return Di.getNodedSubstrings(t, e), e
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            for (let n = t.iterator(); n.hasNext();) n.next().getNodeList().addSplitEdges(e)
        }
    }

    getCoordinates() {
        return this._pts
    }

    size() {
        return this._pts.length
    }

    getCoordinate(t) {
        return this._pts[t]
    }

    isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1])
    }

    getSegmentOctant(t) {
        return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
    }

    setData(t) {
        this._data = t
    }

    safeOctant(t, e) {
        return t.equals2D(e) ? 0 : Nf.octant(t, e)
    }

    getData() {
        return this._data
    }

    addIntersection() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.addIntersectionNode(t, e)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[3], s = new F(t.getIntersection(n));
            this.addIntersection(s, e)
        }
    }

    toString() {
        return Bi.toLineString(new hi(this._pts))
    }

    getNodeList() {
        return this._nodeList
    }

    addIntersectionNode(t, e) {
        let n = e;
        const s = n + 1;
        if (s < this._pts.length) {
            const o = this._pts[s];
            t.equals2D(o) && (n = s)
        }
        return this._nodeList.add(t, n)
    }

    addIntersections(t, e, n) {
        for (let s = 0; s < t.getIntersectionNum(); s++) this.addIntersection(t, e, n, s)
    }

    get interfaces_() {
        return [Sz]
    }
}

class p_ {
    constructor() {
        p_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._overlapSeg1 = new Re, this._overlapSeg2 = new Re
    }

    overlap() {
        if (arguments.length !== 2) {
            if (arguments.length === 4) {
                const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
                t.getLineSegment(e, this._overlapSeg1), n.getLineSegment(s, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2)
            }
        }
    }
}

class Of {
    constructor() {
        Of.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
        const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
        this._pts = t, this._start = e, this._end = n, this._context = s
    }

    getLineSegment(t, e) {
        e.p0 = this._pts[t], e.p1 = this._pts[t + 1]
    }

    computeSelect(t, e, n, s) {
        const r = this._pts[e], o = this._pts[n];
        if (n - e === 1) return s.select(this, e), null;
        if (!t.intersects(r, o)) return null;
        const a = Math.trunc((e + n) / 2);
        e < a && this.computeSelect(t, e, a, s), a < n && this.computeSelect(t, a, n, s)
    }

    getCoordinates() {
        const t = new Array(this._end - this._start + 1).fill(null);
        let e = 0;
        for (let n = this._start; n <= this._end; n++) t[e++] = this._pts[n];
        return t
    }

    computeOverlaps() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this.computeOverlaps(this._start, this._end, t, t._start, t._end, e)
        } else if (arguments.length === 6) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = arguments[4],
                o = arguments[5];
            if (e - t === 1 && r - s === 1) return o.overlap(this, t, n, s), null;
            if (!this.overlaps(t, e, n, s, r)) return null;
            const a = Math.trunc((t + e) / 2), l = Math.trunc((s + r) / 2);
            t < a && (s < l && this.computeOverlaps(t, a, n, s, l, o), l < r && this.computeOverlaps(t, a, n, l, r, o)), a < e && (s < l && this.computeOverlaps(a, e, n, s, l, o), l < r && this.computeOverlaps(a, e, n, l, r, o))
        }
    }

    setId(t) {
        this._id = t
    }

    select(t, e) {
        this.computeSelect(t, this._start, this._end, e)
    }

    getEnvelope() {
        if (this._env === null) {
            const t = this._pts[this._start], e = this._pts[this._end];
            this._env = new Kt(t, e)
        }
        return this._env
    }

    overlaps(t, e, n, s, r) {
        return Kt.intersects(this._pts[t], this._pts[e], n._pts[s], n._pts[r])
    }

    getEndIndex() {
        return this._end
    }

    getStartIndex() {
        return this._start
    }

    getContext() {
        return this._context
    }

    getId() {
        return this._id
    }
}

class bd {
    static findChainEnd(t, e) {
        let n = e;
        for (; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;
        if (n >= t.length - 1) return t.length - 1;
        const s = De.quadrant(t[n], t[n + 1]);
        let r = e + 1;
        for (; r < t.length && !(!t[r - 1].equals2D(t[r]) && De.quadrant(t[r - 1], t[r]) !== s);) r++;
        return r - 1
    }

    static getChains() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return bd.getChains(t, null)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = new ct;
            let s = 0;
            do {
                const r = bd.findChainEnd(t, s), o = new Of(t, s, r, e);
                n.add(o), s = r
            } while (s < t.length - 1);
            return n
        }
    }
}

class g_ {
    computeNodes(t) {
    }

    getNodedSubstrings() {
    }
}

class Ed {
    constructor() {
        Ed.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._segInt = null, arguments.length !== 0) {
            if (arguments.length === 1) {
                const t = arguments[0];
                this.setSegmentIntersector(t)
            }
        }
    }

    setSegmentIntersector(t) {
        this._segInt = t
    }

    get interfaces_() {
        return [g_]
    }
}

class Bl extends Ed {
    constructor() {
        super(), Bl.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._monoChains = new ct, this._index = new nn, this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, arguments.length !== 0) {
            if (arguments.length === 1) {
                const t = arguments[0];
                Ed.constructor_.call(this, t)
            }
        }
    }

    getMonotoneChains() {
        return this._monoChains
    }

    getNodedSubstrings() {
        return Di.getNodedSubstrings(this._nodedSegStrings)
    }

    getIndex() {
        return this._index
    }

    add(t) {
        const e = bd.getChains(t.getCoordinates(), t);
        for (let n = e.iterator(); n.hasNext();) {
            const s = n.next();
            s.setId(this._idCounter++), this._index.insert(s.getEnvelope(), s), this._monoChains.add(s)
        }
    }

    computeNodes(t) {
        this._nodedSegStrings = t;
        for (let e = t.iterator(); e.hasNext();) this.add(e.next());
        this.intersectChains()
    }

    intersectChains() {
        const t = new Df(this._segInt);
        for (let e = this._monoChains.iterator(); e.hasNext();) {
            const n = e.next(), s = this._index.query(n.getEnvelope());
            for (let r = s.iterator(); r.hasNext();) {
                const o = r.next();
                if (o.getId() > n.getId() && (n.computeOverlaps(o, t), this._nOverlaps++), this._segInt.isDone()) return null
            }
        }
    }
}

class Df extends p_ {
    constructor() {
        super(), Df.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._si = null;
        const t = arguments[0];
        this._si = t
    }

    overlap() {
        if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = t.getContext(),
                o = n.getContext();
            this._si.processIntersections(r, e, o, s)
        } else return super.overlap.apply(this, arguments)
    }
}

Bl.SegmentOverlapAction = Df;

class Sd {
    constructor() {
        Sd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            Sd.constructor_.call(this, t, e, 0, 0)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1];
            this._noder = t, this._scaleFactor = e, this._isScaled = !this.isIntegerPrecision()
        }
    }

    rescale() {
        if (At(arguments[0], fn)) {
            const t = arguments[0];
            for (let e = t.iterator(); e.hasNext();) {
                const n = e.next();
                this.rescale(n.getCoordinates())
            }
        } else if (arguments[0] instanceof Array) {
            const t = arguments[0];
            for (let e = 0; e < t.length; e++) t[e].x = t[e].x / this._scaleFactor + this._offsetX, t[e].y = t[e].y / this._scaleFactor + this._offsetY;
            t.length === 2 && t[0].equals2D(t[1]) && ws.out.println(t)
        }
    }

    scale() {
        if (At(arguments[0], fn)) {
            const t = arguments[0], e = new ct(t.size());
            for (let n = t.iterator(); n.hasNext();) {
                const s = n.next();
                e.add(new Di(this.scale(s.getCoordinates()), s.getData()))
            }
            return e
        } else if (arguments[0] instanceof Array) {
            const t = arguments[0], e = new Array(t.length).fill(null);
            for (let s = 0; s < t.length; s++) e[s] = new F(Math.round((t[s].x - this._offsetX) * this._scaleFactor), Math.round((t[s].y - this._offsetY) * this._scaleFactor), t[s].getZ());
            return ze.removeRepeatedPoints(e)
        }
    }

    isIntegerPrecision() {
        return this._scaleFactor === 1
    }

    getNodedSubstrings() {
        const t = this._noder.getNodedSubstrings();
        return this._isScaled && this.rescale(t), t
    }

    computeNodes(t) {
        let e = t;
        this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e)
    }

    get interfaces_() {
        return [g_]
    }
}

class Co {
    constructor() {
        Co.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, arguments.length === 1) {
            const t = arguments[0];
            Co.constructor_.call(this, t, Dn.MOD2_BOUNDARY_RULE)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e
        }
    }

    static getBoundary() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return new Co(t).getBoundary()
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return new Co(t, e).getBoundary()
        }
    }

    boundaryMultiLineString(t) {
        if (this._geom.isEmpty()) return this.getEmptyMultiPoint();
        const e = this.computeBoundaryCoordinates(t);
        return e.length === 1 ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e)
    }

    getBoundary() {
        return this._geom instanceof Te ? this.boundaryLineString(this._geom) : this._geom instanceof Ks ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary()
    }

    boundaryLineString(t) {
        return this._geom.isEmpty() ? this.getEmptyMultiPoint() : t.isClosed() ? this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint() : this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
    }

    getEmptyMultiPoint() {
        return this._geomFact.createMultiPoint()
    }

    computeBoundaryCoordinates(t) {
        const e = new ct;
        this._endpointMap = new Ui;
        for (let n = 0; n < t.getNumGeometries(); n++) {
            const s = t.getGeometryN(n);
            s.getNumPoints() !== 0 && (this.addEndpoint(s.getCoordinateN(0)), this.addEndpoint(s.getCoordinateN(s.getNumPoints() - 1)))
        }
        for (let n = this._endpointMap.entrySet().iterator(); n.hasNext();) {
            const s = n.next(), o = s.getValue().count;
            this._bnRule.isInBoundary(o) && e.add(s.getKey())
        }
        return ze.toCoordinateArray(e)
    }

    addEndpoint(t) {
        let e = this._endpointMap.get(t);
        e === null && (e = new m_, this._endpointMap.put(t, e)), e.count++
    }
}

class m_ {
    constructor() {
        m_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.count = null
    }
}

class Xa {
    constructor() {
        Xa.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._inputGeom = null, this._isClosedEndpointsInInterior = !0, this._nonSimpleLocation = null, arguments.length === 1) {
            const t = arguments[0];
            this._inputGeom = t
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._inputGeom = t, this._isClosedEndpointsInInterior = !e.isInBoundary(2)
        }
    }

    static isSimple() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return new Xa(t).isSimple()
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return new Xa(t, e).isSimple()
        }
    }

    isSimpleMultiPoint(t) {
        if (t.isEmpty()) return !0;
        const e = new Ho;
        for (let n = 0; n < t.getNumGeometries(); n++) {
            const r = t.getGeometryN(n).getCoordinate();
            if (e.contains(r)) return this._nonSimpleLocation = r, !1;
            e.add(r)
        }
        return !0
    }

    isSimplePolygonal(t) {
        const e = ls.getLines(t);
        for (let n = e.iterator(); n.hasNext();) {
            const s = n.next();
            if (!this.isSimpleLinearGeometry(s)) return !1
        }
        return !0
    }

    hasClosedEndpointIntersection(t) {
        const e = new Ui;
        for (let n = t.getEdgeIterator(); n.hasNext();) {
            const s = n.next(), r = s.isClosed(), o = s.getCoordinate(0);
            this.addEndpoint(e, o, r);
            const a = s.getCoordinate(s.getNumPoints() - 1);
            this.addEndpoint(e, a, r)
        }
        for (let n = e.values().iterator(); n.hasNext();) {
            const s = n.next();
            if (s.isClosed && s.degree !== 2) return this._nonSimpleLocation = s.getCoordinate(), !0
        }
        return !1
    }

    getNonSimpleLocation() {
        return this._nonSimpleLocation
    }

    isSimpleLinearGeometry(t) {
        if (t.isEmpty()) return !0;
        const e = new Fs(0, t), n = new Gn, s = e.computeSelfNodes(n, !0);
        return s.hasIntersection() ? s.hasProperIntersection() ? (this._nonSimpleLocation = s.getProperIntersectionPoint(), !1) : !(this.hasNonEndpointIntersection(e) || this._isClosedEndpointsInInterior && this.hasClosedEndpointIntersection(e)) : !0
    }

    hasNonEndpointIntersection(t) {
        for (let e = t.getEdgeIterator(); e.hasNext();) {
            const n = e.next(), s = n.getMaximumSegmentIndex();
            for (let r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
                const o = r.next();
                if (!o.isEndPoint(s)) return this._nonSimpleLocation = o.getCoordinate(), !0
            }
        }
        return !1
    }

    addEndpoint(t, e, n) {
        let s = t.get(e);
        s === null && (s = new Ff(e), t.put(e, s)), s.addEndpoint(n)
    }

    computeSimple(t) {
        return this._nonSimpleLocation = null, t.isEmpty() ? !0 : t instanceof Te ? this.isSimpleLinearGeometry(t) : t instanceof Ks ? this.isSimpleLinearGeometry(t) : t instanceof di ? this.isSimpleMultiPoint(t) : At(t, Ko) ? this.isSimplePolygonal(t) : t instanceof Ie ? this.isSimpleGeometryCollection(t) : !0
    }

    isSimple() {
        return this._nonSimpleLocation = null, this.computeSimple(this._inputGeom)
    }

    isSimpleGeometryCollection(t) {
        for (let e = 0; e < t.getNumGeometries(); e++) {
            const n = t.getGeometryN(e);
            if (!this.computeSimple(n)) return !1
        }
        return !0
    }
}

class Ff {
    constructor() {
        Ff.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.pt = null, this.isClosed = null, this.degree = null;
        const t = arguments[0];
        this.pt = t, this.isClosed = !1, this.degree = 0
    }

    addEndpoint(t) {
        this.degree++, this.isClosed |= t
    }

    getCoordinate() {
        return this.pt
    }
}

Xa.EndpointInfo = Ff;

class Jt {
    constructor() {
        Jt.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._quadrantSegments = Jt.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = Jt.CAP_ROUND, this._joinStyle = Jt.JOIN_ROUND, this._mitreLimit = Jt.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = Jt.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
            if (arguments.length === 1) {
                const t = arguments[0];
                this.setQuadrantSegments(t)
            } else if (arguments.length === 2) {
                const t = arguments[0], e = arguments[1];
                this.setQuadrantSegments(t), this.setEndCapStyle(e)
            } else if (arguments.length === 4) {
                const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
                this.setQuadrantSegments(t), this.setEndCapStyle(e), this.setJoinStyle(n), this.setMitreLimit(s)
            }
        }
    }

    static bufferDistanceError(t) {
        const e = Math.PI / 2 / t;
        return 1 - Math.cos(e / 2)
    }

    getEndCapStyle() {
        return this._endCapStyle
    }

    isSingleSided() {
        return this._isSingleSided
    }

    setQuadrantSegments(t) {
        this._quadrantSegments = t, this._quadrantSegments === 0 && (this._joinStyle = Jt.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Jt.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Jt.JOIN_ROUND && (this._quadrantSegments = Jt.DEFAULT_QUADRANT_SEGMENTS)
    }

    getJoinStyle() {
        return this._joinStyle
    }

    setJoinStyle(t) {
        this._joinStyle = t
    }

    setSimplifyFactor(t) {
        this._simplifyFactor = t < 0 ? 0 : t
    }

    getSimplifyFactor() {
        return this._simplifyFactor
    }

    getQuadrantSegments() {
        return this._quadrantSegments
    }

    setEndCapStyle(t) {
        this._endCapStyle = t
    }

    getMitreLimit() {
        return this._mitreLimit
    }

    setMitreLimit(t) {
        this._mitreLimit = t
    }

    setSingleSided(t) {
        this._isSingleSided = t
    }
}

Jt.CAP_ROUND = 1;
Jt.CAP_FLAT = 2;
Jt.CAP_SQUARE = 3;
Jt.JOIN_ROUND = 1;
Jt.JOIN_MITRE = 2;
Jt.JOIN_BEVEL = 3;
Jt.DEFAULT_QUADRANT_SEGMENTS = 8;
Jt.DEFAULT_MITRE_LIMIT = 5;
Jt.DEFAULT_SIMPLIFY_FACTOR = .01;

class __ {
    constructor() {
        __.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null
    }

    getCoordinate() {
        return this._minCoord
    }

    getRightmostSide(t, e) {
        let n = this.getRightmostSideOfSegment(t, e);
        return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n
    }

    findRightmostEdgeAtVertex() {
        const t = this._minDe.getEdge().getCoordinates();
        $t.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
        const e = t[this._minIndex - 1], n = t[this._minIndex + 1], s = Dt.index(this._minCoord, n, e);
        let r = !1;
        (e.y < this._minCoord.y && n.y < this._minCoord.y && s === Dt.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && s === Dt.CLOCKWISE) && (r = !0), r && (this._minIndex = this._minIndex - 1)
    }

    getRightmostSideOfSegment(t, e) {
        const s = t.getEdge().getCoordinates();
        if (e < 0 || e + 1 >= s.length || s[e].y === s[e + 1].y) return -1;
        let r = ot.LEFT;
        return s[e].y < s[e + 1].y && (r = ot.RIGHT), r
    }

    getEdge() {
        return this._orientedDe
    }

    checkForRightmostCoordinate(t) {
        const e = t.getEdge().getCoordinates();
        for (let n = 0; n < e.length - 1; n++) (this._minCoord === null || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n])
    }

    findRightmostEdgeAtNode() {
        const e = this._minDe.getNode().getEdges();
        this._minDe = e.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1)
    }

    findEdge(t) {
        for (let n = t.iterator(); n.hasNext();) {
            const s = n.next();
            s.isForward() && this.checkForRightmostCoordinate(s)
        }
        $t.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === ot.LEFT && (this._orientedDe = this._minDe.getSym())
    }
}

class Mz {
    constructor() {
        this.array = []
    }

    addLast(t) {
        this.array.push(t)
    }

    removeFirst() {
        return this.array.shift()
    }

    isEmpty() {
        return this.array.length === 0
    }
}

class y_ {
    constructor() {
        y_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._finder = null, this._dirEdgeList = new ct, this._nodes = new ct, this._rightMostCoord = null, this._env = null, this._finder = new __
    }

    clearVisitedEdges() {
        for (let t = this._dirEdgeList.iterator(); t.hasNext();) t.next().setVisited(!1)
    }

    getRightmostCoordinate() {
        return this._rightMostCoord
    }

    computeNodeDepth(t) {
        let e = null;
        for (let n = t.getEdges().iterator(); n.hasNext();) {
            const s = n.next();
            if (s.isVisited() || s.getSym().isVisited()) {
                e = s;
                break
            }
        }
        if (e === null) throw new Us("unable to find edge to compute depths at " + t.getCoordinate());
        t.getEdges().computeDepths(e);
        for (let n = t.getEdges().iterator(); n.hasNext();) {
            const s = n.next();
            s.setVisited(!0), this.copySymDepths(s)
        }
    }

    computeDepth(t) {
        this.clearVisitedEdges();
        const e = this._finder.getEdge();
        e.getNode(), e.getLabel(), e.setEdgeDepths(ot.RIGHT, t), this.copySymDepths(e), this.computeDepths(e)
    }

    create(t) {
        this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate()
    }

    findResultEdges() {
        for (let t = this._dirEdgeList.iterator(); t.hasNext();) {
            const e = t.next();
            e.getDepth(ot.RIGHT) >= 1 && e.getDepth(ot.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
        }
    }

    computeDepths(t) {
        const e = new Rh, n = new Mz, s = t.getNode();
        for (n.addLast(s), e.add(s), t.setVisited(!0); !n.isEmpty();) {
            const r = n.removeFirst();
            e.add(r), this.computeNodeDepth(r);
            for (let o = r.getEdges().iterator(); o.hasNext();) {
                const l = o.next().getSym();
                if (l.isVisited()) continue;
                const c = l.getNode();
                e.contains(c) || (n.addLast(c), e.add(c))
            }
        }
    }

    compareTo(t) {
        const e = t;
        return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0
    }

    getEnvelope() {
        if (this._env === null) {
            const t = new Kt;
            for (let e = this._dirEdgeList.iterator(); e.hasNext();) {
                const s = e.next().getEdge().getCoordinates();
                for (let r = 0; r < s.length - 1; r++) t.expandToInclude(s[r])
            }
            this._env = t
        }
        return this._env
    }

    addReachable(t) {
        const e = new WS;
        for (e.add(t); !e.empty();) {
            const n = e.pop();
            this.add(n, e)
        }
    }

    copySymDepths(t) {
        const e = t.getSym();
        e.setDepth(ot.LEFT, t.getDepth(ot.RIGHT)), e.setDepth(ot.RIGHT, t.getDepth(ot.LEFT))
    }

    add(t, e) {
        t.setVisited(!0), this._nodes.add(t);
        for (let n = t.getEdges().iterator(); n.hasNext();) {
            const s = n.next();
            this._dirEdgeList.add(s);
            const o = s.getSym().getNode();
            o.isVisited() || e.push(o)
        }
    }

    getNodes() {
        return this._nodes
    }

    getDirectedEdges() {
        return this._dirEdgeList
    }

    get interfaces_() {
        return [Es]
    }
}

class ml {
    constructor() {
        ml.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new ct, this._pts = new ct, this._label = new Ye(T.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new ct, this._geometryFactory = null, arguments.length !== 0) {
            if (arguments.length === 2) {
                const t = arguments[0], e = arguments[1];
                this._geometryFactory = e, this.computePoints(t), this.computeRing()
            }
        }
    }

    computeRing() {
        if (this._ring !== null) return null;
        const t = new Array(this._pts.size()).fill(null);
        for (let e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);
        this._ring = this._geometryFactory.createLinearRing(t), this._isHole = Dt.isCCW(this._ring.getCoordinates())
    }

    isIsolated() {
        return this._label.getGeometryCount() === 1
    }

    computePoints(t) {
        this._startDe = t;
        let e = t, n = !0;
        do {
            if (e === null) throw new Us("Found null DirectedEdge");
            if (e.getEdgeRing() === this) throw new Us("Directed Edge visited twice during ring-building at " + e.getCoordinate());
            this._edges.add(e);
            const s = e.getLabel();
            $t.isTrue(s.isArea()), this.mergeLabel(s), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e)
        } while (e !== this._startDe)
    }

    getLinearRing() {
        return this._ring
    }

    getCoordinate(t) {
        return this._pts.get(t)
    }

    computeMaxNodeDegree() {
        this._maxNodeDegree = 0;
        let t = this._startDe;
        do {
            const n = t.getNode().getEdges().getOutgoingDegree(this);
            n > this._maxNodeDegree && (this._maxNodeDegree = n), t = this.getNext(t)
        } while (t !== this._startDe);
        this._maxNodeDegree *= 2
    }

    addPoints(t, e, n) {
        const s = t.getCoordinates();
        if (e) {
            let r = 1;
            n && (r = 0);
            for (let o = r; o < s.length; o++) this._pts.add(s[o])
        } else {
            let r = s.length - 2;
            n && (r = s.length - 1);
            for (let o = r; o >= 0; o--) this._pts.add(s[o])
        }
    }

    isHole() {
        return this._isHole
    }

    setInResult() {
        let t = this._startDe;
        do t.getEdge().setInResult(!0), t = t.getNext(); while (t !== this._startDe)
    }

    containsPoint(t) {
        const e = this.getLinearRing();
        if (!e.getEnvelopeInternal().contains(t) || !Zs.isInRing(t, e.getCoordinates())) return !1;
        for (let s = this._holes.iterator(); s.hasNext();) if (s.next().containsPoint(t)) return !1;
        return !0
    }

    addHole(t) {
        this._holes.add(t)
    }

    isShell() {
        return this._shell === null
    }

    getLabel() {
        return this._label
    }

    getEdges() {
        return this._edges
    }

    getMaxNodeDegree() {
        return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree
    }

    getShell() {
        return this._shell
    }

    mergeLabel() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.mergeLabel(t, 0), this.mergeLabel(t, 1)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t.getLocation(e, ot.RIGHT);
            if (n === T.NONE) return null;
            if (this._label.getLocation(e) === T.NONE) return this._label.setLocation(e, n), null
        }
    }

    setShell(t) {
        this._shell = t, t !== null && t.addHole(this)
    }

    toPolygon(t) {
        const e = new Array(this._holes.size()).fill(null);
        for (let s = 0; s < this._holes.size(); s++) e[s] = this._holes.get(s).getLinearRing();
        return t.createPolygon(this.getLinearRing(), e)
    }
}

class x_ extends ml {
    constructor() {
        super(), x_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0], e = arguments[1];
        ml.constructor_.call(this, t, e)
    }

    setEdgeRing(t, e) {
        t.setMinEdgeRing(e)
    }

    getNext(t) {
        return t.getNextMin()
    }
}

class zf extends ml {
    constructor() {
        super(), zf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0], e = arguments[1];
        ml.constructor_.call(this, t, e)
    }

    buildMinimalRings() {
        const t = new ct;
        let e = this._startDe;
        do {
            if (e.getMinEdgeRing() === null) {
                const n = new x_(e, this._geometryFactory);
                t.add(n)
            }
            e = e.getNext()
        } while (e !== this._startDe);
        return t
    }

    setEdgeRing(t, e) {
        t.setEdgeRing(e)
    }

    linkDirectedEdgesForMinimalEdgeRings() {
        let t = this._startDe;
        do t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext(); while (t !== this._startDe)
    }

    getNext(t) {
        return t.getNext()
    }
}

class eh {
    constructor() {
        eh.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geometryFactory = null, this._shellList = new ct;
        const t = arguments[0];
        this._geometryFactory = t
    }

    static findEdgeRingContaining(t, e) {
        const n = t.getLinearRing(), s = n.getEnvelopeInternal();
        let r = n.getCoordinateN(0), o = null, a = null;
        for (let l = e.iterator(); l.hasNext();) {
            const c = l.next(), h = c.getLinearRing(), u = h.getEnvelopeInternal();
            if (u.equals(s) || !u.contains(s)) continue;
            r = ze.ptNotInList(n.getCoordinates(), h.getCoordinates());
            let d = !1;
            Zs.isInRing(r, h.getCoordinates()) && (d = !0), d && (o === null || a.contains(u)) && (o = c, a = o.getLinearRing().getEnvelopeInternal())
        }
        return o
    }

    sortShellsAndHoles(t, e, n) {
        for (let s = t.iterator(); s.hasNext();) {
            const r = s.next();
            r.isHole() ? n.add(r) : e.add(r)
        }
    }

    computePolygons(t) {
        const e = new ct;
        for (let n = t.iterator(); n.hasNext();) {
            const r = n.next().toPolygon(this._geometryFactory);
            e.add(r)
        }
        return e
    }

    placeFreeHoles(t, e) {
        for (let n = e.iterator(); n.hasNext();) {
            const s = n.next();
            if (s.getShell() === null) {
                const r = eh.findEdgeRingContaining(s, t);
                if (r === null) throw new Us("unable to assign hole to a shell", s.getCoordinate(0));
                s.setShell(r)
            }
        }
    }

    buildMinimalEdgeRings(t, e, n) {
        const s = new ct;
        for (let r = t.iterator(); r.hasNext();) {
            const o = r.next();
            if (o.getMaxNodeDegree() > 2) {
                o.linkDirectedEdgesForMinimalEdgeRings();
                const a = o.buildMinimalRings(), l = this.findShell(a);
                l !== null ? (this.placePolygonHoles(l, a), e.add(l)) : n.addAll(a)
            } else s.add(o)
        }
        return s
    }

    buildMaximalEdgeRings(t) {
        const e = new ct;
        for (let n = t.iterator(); n.hasNext();) {
            const s = n.next();
            if (s.isInResult() && s.getLabel().isArea() && s.getEdgeRing() === null) {
                const r = new zf(s, this._geometryFactory);
                e.add(r), r.setInResult()
            }
        }
        return e
    }

    placePolygonHoles(t, e) {
        for (let n = e.iterator(); n.hasNext();) {
            const s = n.next();
            s.isHole() && s.setShell(t)
        }
    }

    getPolygons() {
        return this.computePolygons(this._shellList)
    }

    findShell(t) {
        let e = 0, n = null;
        for (let s = t.iterator(); s.hasNext();) {
            const r = s.next();
            r.isHole() || (n = r, e++)
        }
        return $t.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n
    }

    add() {
        if (arguments.length === 1) {
            const t = arguments[0];
            this.add(t.getEdgeEnds(), t.getNodes())
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            Qo.linkResultDirectedEdges(e);
            const n = this.buildMaximalEdgeRings(t), s = new ct, r = this.buildMinimalEdgeRings(n, this._shellList, s);
            this.sortShellsAndHoles(r, this._shellList, s), this.placeFreeHoles(this._shellList, s)
        }
    }
}

class Ln {
    constructor() {
        Ln.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = Dt.COUNTERCLOCKWISE;
        const t = arguments[0];
        this._inputLine = t
    }

    static simplify(t, e) {
        return new Ln(t).simplify(e)
    }

    isDeletable(t, e, n, s) {
        const r = this._inputLine[t], o = this._inputLine[e], a = this._inputLine[n];
        return !this.isConcave(r, o, a) || !this.isShallow(r, o, a, s) ? !1 : this.isShallowSampled(r, o, t, n, s)
    }

    deleteShallowConcavities() {
        let t = 1, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e), s = !1;
        for (; n < this._inputLine.length;) {
            let r = !1;
            this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = Ln.DELETE, r = !0, s = !0), r ? t = n : t = e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e)
        }
        return s
    }

    isShallowConcavity(t, e, n, s) {
        return Dt.index(t, e, n) === this._angleOrientation ? vn.pointToSegment(e, t, n) < s : !1
    }

    isShallowSampled(t, e, n, s, r) {
        let o = Math.trunc((s - n) / Ln.NUM_PTS_TO_CHECK);
        o <= 0 && (o = 1);
        for (let a = n; a < s; a += o) if (!this.isShallow(t, e, this._inputLine[a], r)) return !1;
        return !0
    }

    isConcave(t, e, n) {
        return Dt.index(t, e, n) === this._angleOrientation
    }

    simplify(t) {
        this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = Dt.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
        let e = !1;
        do e = this.deleteShallowConcavities(); while (e);
        return this.collapseLine()
    }

    findNextNonDeletedIndex(t) {
        let e = t + 1;
        for (; e < this._inputLine.length && this._isDeleted[e] === Ln.DELETE;) e++;
        return e
    }

    isShallow(t, e, n, s) {
        return vn.pointToSegment(e, t, n) < s
    }

    collapseLine() {
        const t = new ui;
        for (let e = 0; e < this._inputLine.length; e++) this._isDeleted[e] !== Ln.DELETE && t.add(this._inputLine[e]);
        return t.toCoordinateArray()
    }
}

Ln.INIT = 0;
Ln.DELETE = 1;
Ln.KEEP = 1;
Ln.NUM_PTS_TO_CHECK = 10;

class nh {
    constructor() {
        nh.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new ct
    }

    getCoordinates() {
        return this._ptList.toArray(nh.COORDINATE_ARRAY_TYPE)
    }

    setPrecisionModel(t) {
        this._precisionModel = t
    }

    addPt(t) {
        const e = new F(t);
        if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;
        this._ptList.add(e)
    }

    reverse() {
    }

    addPts(t, e) {
        if (e) for (let n = 0; n < t.length; n++) this.addPt(t[n]); else for (let n = t.length - 1; n >= 0; n--) this.addPt(t[n])
    }

    isRedundant(t) {
        if (this._ptList.size() < 1) return !1;
        const e = this._ptList.get(this._ptList.size() - 1);
        return t.distance(e) < this._minimimVertexDistance
    }

    toString() {
        return new hn().createLineString(this.getCoordinates()).toString()
    }

    closeRing() {
        if (this._ptList.size() < 1) return null;
        const t = new F(this._ptList.get(0)), e = this._ptList.get(this._ptList.size() - 1);
        if (t.equals(e)) return null;
        this._ptList.add(t)
    }

    setMinimumVertexDistance(t) {
        this._minimimVertexDistance = t
    }
}

nh.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);

class ci {
    constructor() {
        ci.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new Re, this._seg1 = new Re, this._offset0 = new Re, this._offset1 = new Re, this._side = 0, this._hasNarrowConcaveAngle = !1;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this._precisionModel = t, this._bufParams = e, this._li = new Gn, this._filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === Jt.JOIN_ROUND && (this._closingSegLengthFactor = ci.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n)
    }

    addNextSegment(t, e) {
        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
        const n = Dt.index(this._s0, this._s1, this._s2),
            s = n === Dt.CLOCKWISE && this._side === ot.LEFT || n === Dt.COUNTERCLOCKWISE && this._side === ot.RIGHT;
        n === 0 ? this.addCollinear(e) : s ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
    }

    addLineEndCap(t, e) {
        const n = new Re(t, e), s = new Re;
        this.computeOffsetSegment(n, ot.LEFT, this._distance, s);
        const r = new Re;
        this.computeOffsetSegment(n, ot.RIGHT, this._distance, r);
        const o = e.x - t.x, a = e.y - t.y, l = Math.atan2(a, o);
        switch (this._bufParams.getEndCapStyle()) {
            case Jt.CAP_ROUND:
                this._segList.addPt(s.p1), this.addDirectedFillet(e, l + Math.PI / 2, l - Math.PI / 2, Dt.CLOCKWISE, this._distance), this._segList.addPt(r.p1);
                break;
            case Jt.CAP_FLAT:
                this._segList.addPt(s.p1), this._segList.addPt(r.p1);
                break;
            case Jt.CAP_SQUARE:
                const c = new F;
                c.x = Math.abs(this._distance) * Math.cos(l), c.y = Math.abs(this._distance) * Math.sin(l);
                const h = new F(s.p1.x + c.x, s.p1.y + c.y), u = new F(r.p1.x + c.x, r.p1.y + c.y);
                this._segList.addPt(h), this._segList.addPt(u);
                break
        }
    }

    getCoordinates() {
        return this._segList.getCoordinates()
    }

    addMitreJoin(t, e, n, s) {
        const r = Q0.intersection(e.p0, e.p1, n.p0, n.p1);
        if (r !== null && (s <= 0 ? 1 : r.distance(t) / Math.abs(s)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(r), null;
        this.addLimitedMitreJoin(e, n, s, this._bufParams.getMitreLimit())
    }

    addOutsideTurn(t, e) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * ci.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
        this._bufParams.getJoinStyle() === Jt.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Jt.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0))
    }

    createSquare(t) {
        this._segList.addPt(new F(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new F(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new F(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new F(t.x - this._distance, t.y + this._distance)), this._segList.closeRing()
    }

    addSegments(t, e) {
        this._segList.addPts(t, e)
    }

    addFirstSegment() {
        this._segList.addPt(this._offset1.p0)
    }

    addCornerFillet(t, e, n, s, r) {
        const o = e.x - t.x, a = e.y - t.y;
        let l = Math.atan2(a, o);
        const c = n.x - t.x, h = n.y - t.y, u = Math.atan2(h, c);
        s === Dt.CLOCKWISE ? l <= u && (l += 2 * Math.PI) : l >= u && (l -= 2 * Math.PI), this._segList.addPt(e), this.addDirectedFillet(t, l, u, s, r), this._segList.addPt(n)
    }

    addLastSegment() {
        this._segList.addPt(this._offset1.p1)
    }

    initSideSegments(t, e, n) {
        this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1)
    }

    addLimitedMitreJoin(t, e, n, s) {
        const r = this._seg0.p1, o = Se.angle(r, this._seg0.p0),
            l = Se.angleBetweenOriented(this._seg0.p0, r, this._seg1.p1) / 2, c = Se.normalize(o + l),
            h = Se.normalize(c + Math.PI), u = s * n, d = u * Math.abs(Math.sin(l)), f = n - d,
            g = r.x + u * Math.cos(h), m = r.y + u * Math.sin(h), p = new F(g, m), _ = new Re(r, p),
            x = _.pointAlongOffset(1, f), y = _.pointAlongOffset(1, -f);
        this._side === ot.LEFT ? (this._segList.addPt(x), this._segList.addPt(y)) : (this._segList.addPt(y), this._segList.addPt(x))
    }

    addDirectedFillet(t, e, n, s, r) {
        const o = s === Dt.CLOCKWISE ? -1 : 1, a = Math.abs(e - n), l = Math.trunc(a / this._filletAngleQuantum + .5);
        if (l < 1) return null;
        const c = a / l, h = new F;
        for (let u = 0; u < l; u++) {
            const d = e + o * u * c;
            h.x = t.x + r * Math.cos(d), h.y = t.y + r * Math.sin(d), this._segList.addPt(h)
        }
    }

    computeOffsetSegment(t, e, n, s) {
        const r = e === ot.LEFT ? 1 : -1, o = t.p1.x - t.p0.x, a = t.p1.y - t.p0.y, l = Math.sqrt(o * o + a * a),
            c = r * n * o / l, h = r * n * a / l;
        s.p0.x = t.p0.x - h, s.p0.y = t.p0.y + c, s.p1.x = t.p1.x - h, s.p1.y = t.p1.y + c
    }

    addInsideTurn(t, e) {
        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0)); else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * ci.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1); else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
                const n = new F((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                this._segList.addPt(n);
                const s = new F((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                this._segList.addPt(s)
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0)
        }
    }

    createCircle(t) {
        const e = new F(t.x + this._distance, t.y);
        this._segList.addPt(e), this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing()
    }

    addBevelJoin(t, e) {
        this._segList.addPt(t.p1), this._segList.addPt(e.p0)
    }

    init(t) {
        this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new nh, this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * ci.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
    }

    addCollinear(t) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Jt.JOIN_BEVEL || this._bufParams.getJoinStyle() === Jt.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Dt.CLOCKWISE, this._distance))
    }

    closeRing() {
        this._segList.closeRing()
    }

    hasNarrowConcaveAngle() {
        return this._hasNarrowConcaveAngle
    }
}

ci.OFFSET_SEGMENT_SEPARATION_FACTOR = .001;
ci.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001;
ci.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6;
ci.MAX_CLOSING_SEG_LEN_FACTOR = 80;

class Md {
    constructor() {
        Md.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._distance = 0, this._precisionModel = null, this._bufParams = null;
        const t = arguments[0], e = arguments[1];
        this._precisionModel = t, this._bufParams = e
    }

    static copyCoordinates(t) {
        const e = new Array(t.length).fill(null);
        for (let n = 0; n < e.length; n++) e[n] = new F(t[n]);
        return e
    }

    getOffsetCurve(t, e) {
        if (this._distance = e, e === 0) return null;
        const n = e < 0, s = Math.abs(e), r = this.getSegGen(s);
        t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);
        const o = r.getCoordinates();
        return n && ze.reverse(o), o
    }

    computeSingleSidedBufferCurve(t, e, n) {
        const s = this.simplifyTolerance(this._distance);
        if (e) {
            n.addSegments(t, !0);
            const r = Ln.simplify(t, -s), o = r.length - 1;
            n.initSideSegments(r[o], r[o - 1], ot.LEFT), n.addFirstSegment();
            for (let a = o - 2; a >= 0; a--) n.addNextSegment(r[a], !0)
        } else {
            n.addSegments(t, !1);
            const r = Ln.simplify(t, s), o = r.length - 1;
            n.initSideSegments(r[0], r[1], ot.LEFT), n.addFirstSegment();
            for (let a = 2; a <= o; a++) n.addNextSegment(r[a], !0)
        }
        n.addLastSegment(), n.closeRing()
    }

    computeRingBufferCurve(t, e, n) {
        let s = this.simplifyTolerance(this._distance);
        e === ot.RIGHT && (s = -s);
        const r = Ln.simplify(t, s), o = r.length - 1;
        n.initSideSegments(r[o - 1], r[0], e);
        for (let a = 1; a <= o; a++) {
            const l = a !== 1;
            n.addNextSegment(r[a], l)
        }
        n.closeRing()
    }

    computeLineBufferCurve(t, e) {
        const n = this.simplifyTolerance(this._distance), s = Ln.simplify(t, n), r = s.length - 1;
        e.initSideSegments(s[0], s[1], ot.LEFT);
        for (let l = 2; l <= r; l++) e.addNextSegment(s[l], !0);
        e.addLastSegment(), e.addLineEndCap(s[r - 1], s[r]);
        const o = Ln.simplify(t, -n), a = o.length - 1;
        e.initSideSegments(o[a], o[a - 1], ot.LEFT);
        for (let l = a - 2; l >= 0; l--) e.addNextSegment(o[l], !0);
        e.addLastSegment(), e.addLineEndCap(o[1], o[0]), e.closeRing()
    }

    computePointCurve(t, e) {
        switch (this._bufParams.getEndCapStyle()) {
            case Jt.CAP_ROUND:
                e.createCircle(t);
                break;
            case Jt.CAP_SQUARE:
                e.createSquare(t);
                break
        }
    }

    getLineCurve(t, e) {
        if (this._distance = e, this.isLineOffsetEmpty(e)) return null;
        const n = Math.abs(e), s = this.getSegGen(n);
        if (t.length <= 1) this.computePointCurve(t[0], s); else if (this._bufParams.isSingleSided()) {
            const o = e < 0;
            this.computeSingleSidedBufferCurve(t, o, s)
        } else this.computeLineBufferCurve(t, s);
        return s.getCoordinates()
    }

    getBufferParameters() {
        return this._bufParams
    }

    simplifyTolerance(t) {
        return t * this._bufParams.getSimplifyFactor()
    }

    getRingCurve(t, e, n) {
        if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n);
        if (n === 0) return Md.copyCoordinates(t);
        const s = this.getSegGen(n);
        return this.computeRingBufferCurve(t, e, s), s.getCoordinates()
    }

    computeOffsetCurve(t, e, n) {
        const s = this.simplifyTolerance(this._distance);
        if (e) {
            const r = Ln.simplify(t, -s), o = r.length - 1;
            n.initSideSegments(r[o], r[o - 1], ot.LEFT), n.addFirstSegment();
            for (let a = o - 2; a >= 0; a--) n.addNextSegment(r[a], !0)
        } else {
            const r = Ln.simplify(t, s), o = r.length - 1;
            n.initSideSegments(r[0], r[1], ot.LEFT), n.addFirstSegment();
            for (let a = 2; a <= o; a++) n.addNextSegment(r[a], !0)
        }
        n.addLastSegment()
    }

    isLineOffsetEmpty(t) {
        return t === 0 || t < 0 && !this._bufParams.isSingleSided()
    }

    getSegGen(t) {
        return new ci(this._precisionModel, this._bufParams, t)
    }
}

class Bf {
    constructor() {
        Bf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._subgraphs = null, this._seg = new Re;
        const t = arguments[0];
        this._subgraphs = t
    }

    findStabbedSegments() {
        if (arguments.length === 1) {
            const t = arguments[0], e = new ct;
            for (let n = this._subgraphs.iterator(); n.hasNext();) {
                const s = n.next(), r = s.getEnvelope();
                t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, s.getDirectedEdges(), e)
            }
            return e
        } else if (arguments.length === 3) {
            if (At(arguments[2], Bs) && arguments[0] instanceof F && arguments[1] instanceof th) {
                const t = arguments[0], e = arguments[1], n = arguments[2], s = e.getEdge().getCoordinates();
                for (let r = 0; r < s.length - 1; r++) {
                    if (this._seg.p0 = s[r], this._seg.p1 = s[r + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), Math.max(this._seg.p0.x, this._seg.p1.x) < t.x || this._seg.isHorizontal() || t.y < this._seg.p0.y || t.y > this._seg.p1.y || Dt.index(this._seg.p0, this._seg.p1, t) === Dt.RIGHT) continue;
                    let a = e.getDepth(ot.LEFT);
                    this._seg.p0.equals(s[r]) || (a = e.getDepth(ot.RIGHT));
                    const l = new kf(this._seg, a);
                    n.add(l)
                }
            } else if (At(arguments[2], Bs) && arguments[0] instanceof F && At(arguments[1], Bs)) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                for (let s = e.iterator(); s.hasNext();) {
                    const r = s.next();
                    r.isForward() && this.findStabbedSegments(t, r, n)
                }
            }
        }
    }

    getDepth(t) {
        const e = this.findStabbedSegments(t);
        return e.size() === 0 ? 0 : cr.min(e)._leftDepth
    }
}

class kf {
    constructor() {
        kf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._upwardSeg = null, this._leftDepth = null;
        const t = arguments[0], e = arguments[1];
        this._upwardSeg = new Re(t), this._leftDepth = e
    }

    compareTo(t) {
        const e = t;
        if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
        if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;
        let n = this._upwardSeg.orientationIndex(e._upwardSeg);
        return n !== 0 || (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg), n !== 0) ? n : this._upwardSeg.compareTo(e._upwardSeg)
    }

    compareX(t, e) {
        const n = t.p0.compareTo(e.p0);
        return n !== 0 ? n : t.p1.compareTo(e.p1)
    }

    toString() {
        return this._upwardSeg.toString()
    }

    get interfaces_() {
        return [Es]
    }
}

Bf.DepthSegment = kf;

class v_ {
    constructor() {
        v_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new ct;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this._inputGeom = t, this._distance = e, this._curveBuilder = n
    }

    addRingSide(t, e, n, s, r) {
        if (e === 0 && t.length < Un.MINIMUM_VALID_SIZE) return null;
        let o = s, a = r;
        t.length >= Un.MINIMUM_VALID_SIZE && Dt.isCCW(t) && (o = r, a = s, n = ot.opposite(n));
        const l = this._curveBuilder.getRingCurve(t, n, e);
        this.addCurve(l, o, a)
    }

    addRingBothSides(t, e) {
        this.addRingSide(t, e, ot.LEFT, T.EXTERIOR, T.INTERIOR), this.addRingSide(t, e, ot.RIGHT, T.INTERIOR, T.EXTERIOR)
    }

    addPoint(t) {
        if (this._distance <= 0) return null;
        const e = t.getCoordinates(), n = this._curveBuilder.getLineCurve(e, this._distance);
        this.addCurve(n, T.EXTERIOR, T.INTERIOR)
    }

    addPolygon(t) {
        let e = this._distance, n = ot.LEFT;
        this._distance < 0 && (e = -this._distance, n = ot.RIGHT);
        const s = t.getExteriorRing(), r = ze.removeRepeatedPoints(s.getCoordinates());
        if (this._distance < 0 && this.isErodedCompletely(s, this._distance) || this._distance <= 0 && r.length < 3) return null;
        this.addRingSide(r, e, n, T.EXTERIOR, T.INTERIOR);
        for (let o = 0; o < t.getNumInteriorRing(); o++) {
            const a = t.getInteriorRingN(o), l = ze.removeRepeatedPoints(a.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(a, -this._distance) || this.addRingSide(l, e, ot.opposite(n), T.INTERIOR, T.EXTERIOR)
        }
    }

    isTriangleErodedCompletely(t, e) {
        const n = new is(t[0], t[1], t[2]), s = n.inCentre();
        return vn.pointToSegment(s, n.p0, n.p1) < Math.abs(e)
    }

    addLineString(t) {
        if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
        const e = ze.removeRepeatedPoints(t.getCoordinates());
        if (ze.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e, this._distance); else {
            const n = this._curveBuilder.getLineCurve(e, this._distance);
            this.addCurve(n, T.EXTERIOR, T.INTERIOR)
        }
    }

    addCurve(t, e, n) {
        if (t === null || t.length < 2) return null;
        const s = new Di(t, new Ye(0, T.BOUNDARY, e, n));
        this._curveList.add(s)
    }

    getCurves() {
        return this.add(this._inputGeom), this._curveList
    }

    add(t) {
        if (t.isEmpty()) return null;
        if (t instanceof $e) this.addPolygon(t); else if (t instanceof Te) this.addLineString(t); else if (t instanceof on) this.addPoint(t); else if (t instanceof di) this.addCollection(t); else if (t instanceof Ks) this.addCollection(t); else if (t instanceof bs) this.addCollection(t); else if (t instanceof Ie) this.addCollection(t); else throw new Js(t.getGeometryType())
    }

    isErodedCompletely(t, e) {
        const n = t.getCoordinates();
        if (n.length < 4) return e < 0;
        if (n.length === 4) return this.isTriangleErodedCompletely(n, e);
        const s = t.getEnvelopeInternal(), r = Math.min(s.getHeight(), s.getWidth());
        return e < 0 && 2 * Math.abs(e) > r
    }

    addCollection(t) {
        for (let e = 0; e < t.getNumGeometries(); e++) {
            const n = t.getGeometryN(e);
            this.add(n)
        }
    }
}

class Uf {
    constructor() {
        Uf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._edgeMap = new Ui, this._edgeList = null, this._ptInAreaLocation = [T.NONE, T.NONE]
    }

    getNextCW(t) {
        this.getEdges();
        const e = this._edgeList.indexOf(t);
        let n = e - 1;
        return e === 0 && (n = this._edgeList.size() - 1), this._edgeList.get(n)
    }

    propagateSideLabels(t) {
        let e = T.NONE;
        for (let s = this.iterator(); s.hasNext();) {
            const o = s.next().getLabel();
            o.isArea(t) && o.getLocation(t, ot.LEFT) !== T.NONE && (e = o.getLocation(t, ot.LEFT))
        }
        if (e === T.NONE) return null;
        let n = e;
        for (let s = this.iterator(); s.hasNext();) {
            const r = s.next(), o = r.getLabel();
            if (o.getLocation(t, ot.ON) === T.NONE && o.setLocation(t, ot.ON, n), o.isArea(t)) {
                const a = o.getLocation(t, ot.LEFT), l = o.getLocation(t, ot.RIGHT);
                if (l !== T.NONE) {
                    if (l !== n) throw new Us("side location conflict", r.getCoordinate());
                    a === T.NONE && $t.shouldNeverReachHere("found single null side (at " + r.getCoordinate() + ")"), n = a
                } else $t.isTrue(o.getLocation(t, ot.LEFT) === T.NONE, "found single null side"), o.setLocation(t, ot.RIGHT, n), o.setLocation(t, ot.LEFT, n)
            }
        }
    }

    getCoordinate() {
        const t = this.iterator();
        return t.hasNext() ? t.next().getCoordinate() : null
    }

    print(t) {
        ws.out.println("EdgeEndStar:   " + this.getCoordinate());
        for (let e = this.iterator(); e.hasNext();) e.next().print(t)
    }

    isAreaLabelsConsistent(t) {
        return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
    }

    checkAreaLabelsConsistent(t) {
        const e = this.getEdges();
        if (e.size() <= 0) return !0;
        const n = e.size() - 1, r = e.get(n).getLabel().getLocation(t, ot.LEFT);
        $t.isTrue(r !== T.NONE, "Found unlabelled area edge");
        let o = r;
        for (let a = this.iterator(); a.hasNext();) {
            const c = a.next().getLabel();
            $t.isTrue(c.isArea(t), "Found non-area edge");
            const h = c.getLocation(t, ot.LEFT), u = c.getLocation(t, ot.RIGHT);
            if (h === u || u !== o) return !1;
            o = h
        }
        return !0
    }

    findIndex(t) {
        this.iterator();
        for (let e = 0; e < this._edgeList.size(); e++) if (this._edgeList.get(e) === t) return e;
        return -1
    }

    iterator() {
        return this.getEdges().iterator()
    }

    getEdges() {
        return this._edgeList === null && (this._edgeList = new ct(this._edgeMap.values())), this._edgeList
    }

    getLocation(t, e, n) {
        return this._ptInAreaLocation[t] === T.NONE && (this._ptInAreaLocation[t] = $s.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t]
    }

    toString() {
        const t = new Xc;
        t.append("EdgeEndStar:   " + this.getCoordinate()), t.append(`
`);
        for (let e = this.iterator(); e.hasNext();) {
            const n = e.next();
            t.append(n), t.append(`
`)
        }
        return t.toString()
    }

    computeEdgeEndLabels(t) {
        for (let e = this.iterator(); e.hasNext();) e.next().computeLabel(t)
    }

    computeLabelling(t) {
        this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
        const e = [!1, !1];
        for (let n = this.iterator(); n.hasNext();) {
            const r = n.next().getLabel();
            for (let o = 0; o < 2; o++) r.isLine(o) && r.getLocation(o) === T.BOUNDARY && (e[o] = !0)
        }
        for (let n = this.iterator(); n.hasNext();) {
            const s = n.next(), r = s.getLabel();
            for (let o = 0; o < 2; o++) if (r.isAnyNull(o)) {
                let a = T.NONE;
                if (e[o]) a = T.EXTERIOR; else {
                    const l = s.getCoordinate();
                    a = this.getLocation(o, l, t)
                }
                r.setAllLocationsIfNull(o, a)
            }
        }
    }

    getDegree() {
        return this._edgeMap.size()
    }

    insertEdgeEnd(t, e) {
        this._edgeMap.put(t, e), this._edgeList = null
    }
}

class w_ extends Uf {
    constructor() {
        super(), w_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2
    }

    linkResultDirectedEdges() {
        this.getResultAreaEdges();
        let t = null, e = null, n = this._SCANNING_FOR_INCOMING;
        for (let s = 0; s < this._resultAreaEdgeList.size(); s++) {
            const r = this._resultAreaEdgeList.get(s), o = r.getSym();
            if (r.getLabel().isArea()) switch (t === null && r.isInResult() && (t = r), n) {
                case this._SCANNING_FOR_INCOMING:
                    if (!o.isInResult()) continue;
                    e = o, n = this._LINKING_TO_OUTGOING;
                    break;
                case this._LINKING_TO_OUTGOING:
                    if (!r.isInResult()) continue;
                    e.setNext(r), n = this._SCANNING_FOR_INCOMING;
                    break
            }
        }
        if (n === this._LINKING_TO_OUTGOING) {
            if (t === null) throw new Us("no outgoing dirEdge found", this.getCoordinate());
            $t.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t)
        }
    }

    insert(t) {
        const e = t;
        this.insertEdgeEnd(e, e)
    }

    getRightmostEdge() {
        const t = this.getEdges(), e = t.size();
        if (e < 1) return null;
        const n = t.get(0);
        if (e === 1) return n;
        const s = t.get(e - 1), r = n.getQuadrant(), o = s.getQuadrant();
        return De.isNorthern(r) && De.isNorthern(o) ? n : !De.isNorthern(r) && !De.isNorthern(o) ? s : n.getDy() !== 0 ? n : s.getDy() !== 0 ? s : ($t.shouldNeverReachHere("found two horizontal edges incident on node"), null)
    }

    print(t) {
        ws.out.println("DirectedEdgeStar: " + this.getCoordinate());
        for (let e = this.iterator(); e.hasNext();) {
            const n = e.next();
            t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println()
        }
    }

    getResultAreaEdges() {
        if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new ct;
        for (let t = this.iterator(); t.hasNext();) {
            const e = t.next();
            (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e)
        }
        return this._resultAreaEdgeList
    }

    updateLabelling(t) {
        for (let e = this.iterator(); e.hasNext();) {
            const s = e.next().getLabel();
            s.setAllLocationsIfNull(0, t.getLocation(0)), s.setAllLocationsIfNull(1, t.getLocation(1))
        }
    }

    linkAllDirectedEdges() {
        this.getEdges();
        let t = null, e = null;
        for (let n = this._edgeList.size() - 1; n >= 0; n--) {
            const s = this._edgeList.get(n), r = s.getSym();
            e === null && (e = r), t !== null && r.setNext(t), t = s
        }
        e.setNext(t)
    }

    computeDepths() {
        if (arguments.length === 1) {
            const t = arguments[0], e = this.findIndex(t), n = t.getDepth(ot.LEFT), s = t.getDepth(ot.RIGHT),
                r = this.computeDepths(e + 1, this._edgeList.size(), n);
            if (this.computeDepths(0, e, r) !== s) throw new Us("depth mismatch at " + t.getCoordinate())
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1];
            let s = arguments[2];
            for (let r = t; r < e; r++) {
                const o = this._edgeList.get(r);
                o.setEdgeDepths(ot.RIGHT, s), s = o.getDepth(ot.LEFT)
            }
            return s
        }
    }

    mergeSymLabels() {
        for (let t = this.iterator(); t.hasNext();) {
            const e = t.next();
            e.getLabel().merge(e.getSym().getLabel())
        }
    }

    linkMinimalDirectedEdges(t) {
        let e = null, n = null, s = this._SCANNING_FOR_INCOMING;
        for (let r = this._resultAreaEdgeList.size() - 1; r >= 0; r--) {
            const o = this._resultAreaEdgeList.get(r), a = o.getSym();
            switch (e === null && o.getEdgeRing() === t && (e = o), s) {
                case this._SCANNING_FOR_INCOMING:
                    if (a.getEdgeRing() !== t) continue;
                    n = a, s = this._LINKING_TO_OUTGOING;
                    break;
                case this._LINKING_TO_OUTGOING:
                    if (o.getEdgeRing() !== t) continue;
                    n.setNextMin(o), s = this._SCANNING_FOR_INCOMING;
                    break
            }
        }
        s === this._LINKING_TO_OUTGOING && ($t.isTrue(e !== null, "found null for first outgoing dirEdge"), $t.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e))
    }

    getOutgoingDegree() {
        if (arguments.length === 0) {
            let t = 0;
            for (let e = this.iterator(); e.hasNext();) e.next().isInResult() && t++;
            return t
        } else if (arguments.length === 1) {
            const t = arguments[0];
            let e = 0;
            for (let n = this.iterator(); n.hasNext();) n.next().getEdgeRing() === t && e++;
            return e
        }
    }

    getLabel() {
        return this._label
    }

    findCoveredLineEdges() {
        let t = T.NONE;
        for (let n = this.iterator(); n.hasNext();) {
            const s = n.next(), r = s.getSym();
            if (!s.isLineEdge()) {
                if (s.isInResult()) {
                    t = T.INTERIOR;
                    break
                }
                if (r.isInResult()) {
                    t = T.EXTERIOR;
                    break
                }
            }
        }
        if (t === T.NONE) return null;
        let e = t;
        for (let n = this.iterator(); n.hasNext();) {
            const s = n.next(), r = s.getSym();
            s.isLineEdge() ? s.getEdge().setCovered(e === T.INTERIOR) : (s.isInResult() && (e = T.EXTERIOR), r.isInResult() && (e = T.INTERIOR))
        }
    }

    computeLabelling(t) {
        super.computeLabelling.call(this, t), this._label = new Ye(T.NONE);
        for (let e = this.iterator(); e.hasNext();) {
            const r = e.next().getEdge().getLabel();
            for (let o = 0; o < 2; o++) {
                const a = r.getLocation(o);
                (a === T.INTERIOR || a === T.BOUNDARY) && this._label.setLocation(o, T.INTERIOR)
            }
        }
    }
}

class b_ extends u_ {
    constructor() {
        super()
    }

    createNode(t) {
        return new hr(t, new w_)
    }
}

class Za {
    constructor() {
        Za.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._pts = null, this._orientation = null;
        const t = arguments[0];
        this._pts = t, this._orientation = Za.orientation(t)
    }

    static orientation(t) {
        return ze.increasingDirection(t) === 1
    }

    static compareOriented(t, e, n, s) {
        const r = e ? 1 : -1, o = s ? 1 : -1, a = e ? t.length : -1, l = s ? n.length : -1;
        let c = e ? 0 : t.length - 1, h = s ? 0 : n.length - 1;
        for (; ;) {
            const u = t[c].compareTo(n[h]);
            if (u !== 0) return u;
            c += r, h += o;
            const d = c === a, f = h === l;
            if (d && !f) return -1;
            if (!d && f) return 1;
            if (d && f) return 0
        }
    }

    compareTo(t) {
        const e = t;
        return Za.compareOriented(this._pts, this._orientation, e._pts, e._orientation)
    }

    get interfaces_() {
        return [Es]
    }
}

class Gf {
    constructor() {
        Gf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._edges = new ct, this._ocaMap = new Ui
    }

    print(t) {
        t.print("MULTILINESTRING ( ");
        for (let e = 0; e < this._edges.size(); e++) {
            const n = this._edges.get(e);
            e > 0 && t.print(","), t.print("(");
            const s = n.getCoordinates();
            for (let r = 0; r < s.length; r++) r > 0 && t.print(","), t.print(s[r].x + " " + s[r].y);
            t.println(")")
        }
        t.print(")  ")
    }

    addAll(t) {
        for (let e = t.iterator(); e.hasNext();) this.add(e.next())
    }

    findEdgeIndex(t) {
        for (let e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;
        return -1
    }

    iterator() {
        return this._edges.iterator()
    }

    getEdges() {
        return this._edges
    }

    get(t) {
        return this._edges.get(t)
    }

    findEqualEdge(t) {
        const e = new Za(t.getCoordinates());
        return this._ocaMap.get(e)
    }

    add(t) {
        this._edges.add(t);
        const e = new Za(t.getCoordinates());
        this._ocaMap.put(e, t)
    }
}

class E_ {
    processIntersections(t, e, n, s) {
    }

    isDone() {
    }
}

class Td {
    constructor() {
        Td.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
        const t = arguments[0];
        this._li = t
    }

    static isAdjacentSegments(t, e) {
        return Math.abs(t - e) === 1
    }

    isTrivialIntersection(t, e, n, s) {
        if (t === n && this._li.getIntersectionNum() === 1) {
            if (Td.isAdjacentSegments(e, s)) return !0;
            if (t.isClosed()) {
                const r = t.size() - 1;
                if (e === 0 && s === r || s === 0 && e === r) return !0
            }
        }
        return !1
    }

    getProperIntersectionPoint() {
        return this._properIntersectionPoint
    }

    hasProperInteriorIntersection() {
        return this._hasProperInterior
    }

    getLineIntersector() {
        return this._li
    }

    hasProperIntersection() {
        return this._hasProper
    }

    processIntersections(t, e, n, s) {
        if (t === n && e === s) return null;
        this.numTests++;
        const r = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[s],
            l = n.getCoordinates()[s + 1];
        this._li.computeIntersection(r, o, a, l), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, s) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, s, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)))
    }

    hasIntersection() {
        return this._hasIntersection
    }

    isDone() {
        return !1
    }

    hasInteriorIntersection() {
        return this._hasInterior
    }

    get interfaces_() {
        return [E_]
    }
}

class ja {
    constructor() {
        ja.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Gf;
        const t = arguments[0];
        this._bufParams = t
    }

    static depthDelta(t) {
        const e = t.getLocation(0, ot.LEFT), n = t.getLocation(0, ot.RIGHT);
        return e === T.INTERIOR && n === T.EXTERIOR ? 1 : e === T.EXTERIOR && n === T.INTERIOR ? -1 : 0
    }

    static convertSegStrings(t) {
        const e = new hn, n = new ct;
        for (; t.hasNext();) {
            const s = t.next(), r = e.createLineString(s.getCoordinates());
            n.add(r)
        }
        return e.buildGeometry(n)
    }

    setWorkingPrecisionModel(t) {
        this._workingPrecisionModel = t
    }

    insertUniqueEdge(t) {
        const e = this._edgeList.findEqualEdge(t);
        if (e !== null) {
            const n = e.getLabel();
            let s = t.getLabel();
            e.isPointwiseEqual(t) || (s = new Ye(t.getLabel()), s.flip()), n.merge(s);
            const r = ja.depthDelta(s), a = e.getDepthDelta() + r;
            e.setDepthDelta(a)
        } else this._edgeList.add(t), t.setDepthDelta(ja.depthDelta(t.getLabel()))
    }

    buildSubgraphs(t, e) {
        const n = new ct;
        for (let s = t.iterator(); s.hasNext();) {
            const r = s.next(), o = r.getRightmostCoordinate(), l = new Bf(n).getDepth(o);
            r.computeDepth(l), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes())
        }
    }

    createSubgraphs(t) {
        const e = new ct;
        for (let n = t.getNodes().iterator(); n.hasNext();) {
            const s = n.next();
            if (!s.isVisited()) {
                const r = new y_;
                r.create(s), e.add(r)
            }
        }
        return cr.sort(e, cr.reverseOrder()), e
    }

    createEmptyResultGeometry() {
        return this._geomFact.createPolygon()
    }

    getNoder(t) {
        if (this._workingNoder !== null) return this._workingNoder;
        const e = new Bl, n = new Gn;
        return n.setPrecisionModel(t), e.setSegmentIntersector(new Td(n)), e
    }

    buffer(t, e) {
        let n = this._workingPrecisionModel;
        n === null && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();
        const s = new Md(n, this._bufParams), o = new v_(t, e, s).getCurves();
        if (o.size() <= 0) return this.createEmptyResultGeometry();
        this.computeNodedEdges(o, n), this._graph = new Qo(new b_), this._graph.addEdges(this._edgeList.getEdges());
        const a = this.createSubgraphs(this._graph), l = new eh(this._geomFact);
        this.buildSubgraphs(a, l);
        const c = l.getPolygons();
        return c.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(c)
    }

    computeNodedEdges(t, e) {
        const n = this.getNoder(e);
        n.computeNodes(t);
        const s = n.getNodedSubstrings();
        for (let r = s.iterator(); r.hasNext();) {
            const o = r.next(), a = o.getCoordinates();
            if (a.length === 2 && a[0].equals2D(a[1])) continue;
            const l = o.getData(), c = new li(o.getCoordinates(), new Ye(l));
            this.insertUniqueEdge(c)
        }
    }

    setNoder(t) {
        this._workingNoder = t
    }
}

class sh {
    constructor() {
        sh.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._li = new Gn, this._segStrings = null;
        const t = arguments[0];
        this._segStrings = t
    }

    checkEndPtVertexIntersections() {
        if (arguments.length === 0) for (let t = this._segStrings.iterator(); t.hasNext();) {
            const n = t.next().getCoordinates();
            this.checkEndPtVertexIntersections(n[0], this._segStrings), this.checkEndPtVertexIntersections(n[n.length - 1], this._segStrings)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            for (let n = e.iterator(); n.hasNext();) {
                const r = n.next().getCoordinates();
                for (let o = 1; o < r.length - 1; o++) if (r[o].equals(t)) throw new vs("found endpt/interior pt intersection at index " + o + " :pt " + t)
            }
        }
    }

    checkInteriorIntersections() {
        if (arguments.length === 0) for (let t = this._segStrings.iterator(); t.hasNext();) {
            const e = t.next();
            for (let n = this._segStrings.iterator(); n.hasNext();) {
                const s = n.next();
                this.checkInteriorIntersections(e, s)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t.getCoordinates(), s = e.getCoordinates();
            for (let r = 0; r < n.length - 1; r++) for (let o = 0; o < s.length - 1; o++) this.checkInteriorIntersections(t, r, e, o)
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            if (t === n && e === s) return null;
            const r = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[s],
                l = n.getCoordinates()[s + 1];
            if (this._li.computeIntersection(r, o, a, l), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, r, o) || this.hasInteriorIntersection(this._li, a, l))) throw new vs("found non-noded intersection at " + r + "-" + o + " and " + a + "-" + l)
        }
    }

    checkValid() {
        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses()
    }

    checkCollapses() {
        if (arguments.length === 0) for (let t = this._segStrings.iterator(); t.hasNext();) {
            const e = t.next();
            this.checkCollapses(e)
        } else if (arguments.length === 1) {
            const e = arguments[0].getCoordinates();
            for (let n = 0; n < e.length - 2; n++) this.checkCollapse(e[n], e[n + 1], e[n + 2])
        }
    }

    hasInteriorIntersection(t, e, n) {
        for (let s = 0; s < t.getIntersectionNum(); s++) {
            const r = t.getIntersection(s);
            if (!(r.equals(e) || r.equals(n))) return !0
        }
        return !1
    }

    checkCollapse(t, e, n) {
        if (t.equals(n)) throw new vs("found non-noded collapse at " + sh.fact.createLineString([t, e, n]))
    }
}

sh.fact = new hn;

class _l {
    constructor() {
        _l.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new jt("Scale factor must be non-zero");
        e !== 1 && (this._pt = new F(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new F, this._p1Scaled = new F), this.initCorners(this._pt)
    }

    intersectsScaled(t, e) {
        const n = Math.min(t.x, e.x), s = Math.max(t.x, e.x), r = Math.min(t.y, e.y), o = Math.max(t.y, e.y),
            a = this._maxx < n || this._minx > s || this._maxy < r || this._miny > o;
        if (a) return !1;
        const l = this.intersectsToleranceSquare(t, e);
        return $t.isTrue(!(a && l), "Found bad envelope test"), l
    }

    initCorners(t) {
        this._minx = t.x - .5, this._maxx = t.x + .5, this._miny = t.y - .5, this._maxy = t.y + .5, this._corner[0] = new F(this._maxx, this._maxy), this._corner[1] = new F(this._minx, this._maxy), this._corner[2] = new F(this._minx, this._miny), this._corner[3] = new F(this._maxx, this._miny)
    }

    intersects(t, e) {
        return this._scaleFactor === 1 ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled))
    }

    scale(t) {
        return Math.round(t * this._scaleFactor)
    }

    getCoordinate() {
        return this._originalPt
    }

    copyScaled(t, e) {
        e.x = this.scale(t.x), e.y = this.scale(t.y)
    }

    getSafeEnvelope() {
        if (this._safeEnv === null) {
            const t = _l.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new Kt(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t)
        }
        return this._safeEnv
    }

    intersectsPixelClosure(t, e) {
        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection()) || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection()) || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection()))
    }

    intersectsToleranceSquare(t, e) {
        let n = !1, s = !1;
        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper()) || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper()) || (this._li.hasIntersection() && (s = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper()) || n && s || t.equals(this._pt) || e.equals(this._pt))
    }

    addSnappedNode(t, e) {
        const n = t.getCoordinate(e), s = t.getCoordinate(e + 1);
        return this.intersects(n, s) ? (t.addIntersection(this.getCoordinate(), e), !0) : !1
    }
}

_l.SAFE_ENV_EXPANSION_FACTOR = .75;

class S_ {
    constructor() {
        S_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.selectedSegment = new Re
    }

    select() {
        if (arguments.length !== 1) {
            if (arguments.length === 2) {
                const t = arguments[0], e = arguments[1];
                t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment)
            }
        }
    }
}

class Vf {
    constructor() {
        Vf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._index = null;
        const t = arguments[0];
        this._index = t
    }

    snap() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return this.snap(t, null, -1)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = t.getSafeEnvelope(), r = new Hf(t, e, n);
            return this._index.query(s, new class {
                get interfaces_() {
                    return [Af]
                }

                visitItem(o) {
                    o.select(s, r)
                }
            }), r.isNodeAdded()
        }
    }
}

class Hf extends S_ {
    constructor() {
        super(), Hf.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n
    }

    isNodeAdded() {
        return this._isNodeAdded
    }

    select() {
        if (arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof Of) {
            const t = arguments[0], e = arguments[1], n = t.getContext();
            if (this._parentEdge === n && (e === this._hotPixelVertexIndex || e + 1 === this._hotPixelVertexIndex)) return null;
            this._isNodeAdded |= this._hotPixel.addSnappedNode(n, e)
        } else return super.select.apply(this, arguments)
    }
}

Vf.HotPixelSnapAction = Hf;

class M_ {
    constructor() {
        M_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._li = null, this._interiorIntersections = null;
        const t = arguments[0];
        this._li = t, this._interiorIntersections = new ct
    }

    processIntersections(t, e, n, s) {
        if (t === n && e === s) return null;
        const r = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[s],
            l = n.getCoordinates()[s + 1];
        if (this._li.computeIntersection(r, o, a, l), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (let c = 0; c < this._li.getIntersectionNum(); c++) this._interiorIntersections.add(this._li.getIntersection(c));
            t.addIntersections(this._li, e, 0), n.addIntersections(this._li, s, 1)
        }
    }

    isDone() {
        return !1
    }

    getInteriorIntersections() {
        return this._interiorIntersections
    }

    get interfaces_() {
        return [E_]
    }
}

class T_ {
    constructor() {
        T_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
        const t = arguments[0];
        this._pm = t, this._li = new Gn, this._li.setPrecisionModel(t), this._scaleFactor = t.getScale()
    }

    checkCorrectness(t) {
        const e = Di.getNodedSubstrings(t), n = new sh(e);
        try {
            n.checkValid()
        } catch (s) {
            if (s instanceof js) s.printStackTrace(); else throw s
        } finally {
        }
    }

    getNodedSubstrings() {
        return Di.getNodedSubstrings(this._nodedSegStrings)
    }

    snapRound(t, e) {
        const n = this.findInteriorIntersections(t, e);
        this.computeIntersectionSnaps(n), this.computeVertexSnaps(t)
    }

    findInteriorIntersections(t, e) {
        const n = new M_(e);
        return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections()
    }

    computeVertexSnaps() {
        if (At(arguments[0], fn)) {
            const t = arguments[0];
            for (let e = t.iterator(); e.hasNext();) {
                const n = e.next();
                this.computeVertexSnaps(n)
            }
        } else if (arguments[0] instanceof Di) {
            const t = arguments[0], e = t.getCoordinates();
            for (let n = 0; n < e.length; n++) {
                const s = new _l(e[n], this._scaleFactor, this._li);
                this._pointSnapper.snap(s, t, n) && t.addIntersection(e[n], n)
            }
        }
    }

    computeNodes(t) {
        this._nodedSegStrings = t, this._noder = new Bl, this._pointSnapper = new Vf(this._noder.getIndex()), this.snapRound(t, this._li)
    }

    computeIntersectionSnaps(t) {
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next(), s = new _l(n, this._scaleFactor, this._li);
            this._pointSnapper.snap(s)
        }
    }

    get interfaces_() {
        return [g_]
    }
}

class Nn {
    constructor() {
        Nn.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._argGeom = null, this._distance = null, this._bufParams = new Jt, this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
            const t = arguments[0];
            this._argGeom = t
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._argGeom = t, this._bufParams = e
        }
    }

    static bufferOp() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return new Nn(t).getResultGeometry(e)
        } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof it && typeof arguments[1] == "number") {
                const t = arguments[0], e = arguments[1], n = arguments[2], s = new Nn(t);
                return s.setQuadrantSegments(n), s.getResultGeometry(e)
            } else if (arguments[2] instanceof Jt && arguments[0] instanceof it && typeof arguments[1] == "number") {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                return new Nn(t, n).getResultGeometry(e)
            }
        } else if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = new Nn(t);
            return r.setQuadrantSegments(n), r.setEndCapStyle(s), r.getResultGeometry(e)
        }
    }

    static precisionScaleFactor(t, e, n) {
        const s = t.getEnvelopeInternal(),
            r = Vo.max(Math.abs(s.getMaxX()), Math.abs(s.getMaxY()), Math.abs(s.getMinX()), Math.abs(s.getMinY())),
            o = e > 0 ? e : 0, a = r + 2 * o, l = Math.trunc(Math.log(a) / Math.log(10) + 1), c = n - l;
        return Math.pow(10, c)
    }

    bufferFixedPrecision(t) {
        const e = new Sd(new T_(new Pe(1)), t.getScale()), n = new ja(this._bufParams);
        n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance)
    }

    bufferReducedPrecision() {
        if (arguments.length === 0) {
            for (let t = Nn.MAX_PRECISION_DIGITS; t >= 0; t--) {
                try {
                    this.bufferReducedPrecision(t)
                } catch (e) {
                    if (e instanceof Us) this._saveException = e; else throw e
                } finally {
                }
                if (this._resultGeometry !== null) return null
            }
            throw this._saveException
        } else if (arguments.length === 1) {
            const t = arguments[0], e = Nn.precisionScaleFactor(this._argGeom, this._distance, t), n = new Pe(e);
            this.bufferFixedPrecision(n)
        }
    }

    computeGeometry() {
        if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
        const t = this._argGeom.getFactory().getPrecisionModel();
        t.getType() === Pe.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
    }

    setQuadrantSegments(t) {
        this._bufParams.setQuadrantSegments(t)
    }

    bufferOriginalPrecision() {
        try {
            const t = new ja(this._bufParams);
            this._resultGeometry = t.buffer(this._argGeom, this._distance)
        } catch (t) {
            if (t instanceof vs) this._saveException = t; else throw t
        } finally {
        }
    }

    getResultGeometry(t) {
        return this._distance = t, this.computeGeometry(), this._resultGeometry
    }

    setEndCapStyle(t) {
        this._bufParams.setEndCapStyle(t)
    }
}

Nn.CAP_ROUND = Jt.CAP_ROUND;
Nn.CAP_BUTT = Jt.CAP_FLAT;
Nn.CAP_FLAT = Jt.CAP_FLAT;
Nn.CAP_SQUARE = Jt.CAP_SQUARE;
Nn.MAX_PRECISION_DIGITS = 12;

class cs {
    constructor() {
        cs.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._component = null, this._segIndex = null, this._pt = null, arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            cs.constructor_.call(this, t, cs.INSIDE_AREA, e)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._component = t, this._segIndex = e, this._pt = n
        }
    }

    getSegmentIndex() {
        return this._segIndex
    }

    getCoordinate() {
        return this._pt
    }

    isInsideArea() {
        return this._segIndex === cs.INSIDE_AREA
    }

    toString() {
        return this._component.getGeometryType() + "[" + this._segIndex + "]-" + Bi.toPoint(this._pt)
    }

    getGeometryComponent() {
        return this._component
    }
}

cs.INSIDE_AREA = -1;

class Id {
    constructor() {
        Id.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._locations = null;
        const t = arguments[0];
        this._locations = t
    }

    static getLocations(t) {
        const e = new ct;
        return t.apply(new Id(e)), e
    }

    filter(t) {
        if (t.isEmpty()) return null;
        (t instanceof on || t instanceof Te || t instanceof $e) && this._locations.add(new cs(t, 0, t.getCoordinate()))
    }

    get interfaces_() {
        return [Jr]
    }
}

class Ii {
    constructor() {
        Ii.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Jo, this._minDistanceLocation = null, this._minDistance = St.MAX_VALUE, arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            Ii.constructor_.call(this, t, e, 0)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e, this._terminateDistance = n
        }
    }

    static distance(t, e) {
        return new Ii(t, e).distance()
    }

    static isWithinDistance(t, e, n) {
        return t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > n ? !1 : new Ii(t, e, n).distance() <= n
    }

    static nearestPoints(t, e) {
        return new Ii(t, e).nearestPoints()
    }

    computeContainmentDistance() {
        if (arguments.length === 0) {
            const t = new Array(2).fill(null);
            if (this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance) return null;
            this.computeContainmentDistance(1, t)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = this._geom[t];
            if (n.getDimension() < 2) return null;
            const s = 1 - t, r = $a.getPolygons(n);
            if (r.size() > 0) {
                const o = Id.getLocations(this._geom[s]);
                if (this.computeContainmentDistance(o, r, e), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[s] = e[0], this._minDistanceLocation[t] = e[1], null
            }
        } else if (arguments.length === 3) {
            if (arguments[2] instanceof Array && At(arguments[0], Bs) && At(arguments[1], Bs)) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                for (let s = 0; s < t.size(); s++) {
                    const r = t.get(s);
                    for (let o = 0; o < e.size(); o++) if (this.computeContainmentDistance(r, e.get(o), n), this._minDistance <= this._terminateDistance) return null
                }
            } else if (arguments[2] instanceof Array && arguments[0] instanceof cs && arguments[1] instanceof $e) {
                const t = arguments[0], e = arguments[1], n = arguments[2], s = t.getCoordinate();
                if (T.EXTERIOR !== this._ptLocator.locate(s, e)) return this._minDistance = 0, n[0] = t, n[1] = new cs(e, s), null
            }
        }
    }

    computeMinDistanceLinesPoints(t, e, n) {
        for (let s = 0; s < t.size(); s++) {
            const r = t.get(s);
            for (let o = 0; o < e.size(); o++) {
                const a = e.get(o);
                if (this.computeMinDistance(r, a, n), this._minDistance <= this._terminateDistance) return null
            }
        }
    }

    computeFacetDistance() {
        const t = new Array(2).fill(null), e = ls.getLines(this._geom[0]), n = ls.getLines(this._geom[1]),
            s = Ha.getPoints(this._geom[0]), r = Ha.getPoints(this._geom[1]);
        if (this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance || (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance) || (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, s, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance)) return null;
        t[0] = null, t[1] = null, this.computeMinDistancePoints(s, r, t), this.updateMinDistance(t, !1)
    }

    nearestLocations() {
        return this.computeMinDistance(), this._minDistanceLocation
    }

    updateMinDistance(t, e) {
        if (t[0] === null) return null;
        e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1])
    }

    nearestPoints() {
        return this.computeMinDistance(), [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()]
    }

    computeMinDistance() {
        if (arguments.length === 0) {
            if (this._minDistanceLocation !== null || (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)) return null;
            this.computeFacetDistance()
        } else if (arguments.length === 3) {
            if (arguments[2] instanceof Array && arguments[0] instanceof Te && arguments[1] instanceof on) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance) return null;
                const s = t.getCoordinates(), r = e.getCoordinate();
                for (let o = 0; o < s.length - 1; o++) {
                    const a = vn.pointToSegment(r, s[o], s[o + 1]);
                    if (a < this._minDistance) {
                        this._minDistance = a;
                        const c = new Re(s[o], s[o + 1]).closestPoint(r);
                        n[0] = new cs(t, o, c), n[1] = new cs(e, 0, r)
                    }
                    if (this._minDistance <= this._terminateDistance) return null
                }
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Te && arguments[1] instanceof Te) {
                const t = arguments[0], e = arguments[1], n = arguments[2];
                if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance) return null;
                const s = t.getCoordinates(), r = e.getCoordinates();
                for (let o = 0; o < s.length - 1; o++) {
                    const a = new Kt(s[o], s[o + 1]);
                    if (!(a.distance(e.getEnvelopeInternal()) > this._minDistance)) for (let l = 0; l < r.length - 1; l++) {
                        const c = new Kt(r[l], r[l + 1]);
                        if (a.distance(c) > this._minDistance) continue;
                        const h = vn.segmentToSegment(s[o], s[o + 1], r[l], r[l + 1]);
                        if (h < this._minDistance) {
                            this._minDistance = h;
                            const u = new Re(s[o], s[o + 1]), d = new Re(r[l], r[l + 1]), f = u.closestPoints(d);
                            n[0] = new cs(t, o, f[0]), n[1] = new cs(e, l, f[1])
                        }
                        if (this._minDistance <= this._terminateDistance) return null
                    }
                }
            }
        }
    }

    computeMinDistancePoints(t, e, n) {
        for (let s = 0; s < t.size(); s++) {
            const r = t.get(s);
            for (let o = 0; o < e.size(); o++) {
                const a = e.get(o), l = r.getCoordinate().distance(a.getCoordinate());
                if (l < this._minDistance && (this._minDistance = l, n[0] = new cs(r, 0, r.getCoordinate()), n[1] = new cs(a, 0, a.getCoordinate())), this._minDistance <= this._terminateDistance) return null
            }
        }
    }

    distance() {
        if (this._geom[0] === null || this._geom[1] === null) throw new jt("null geometries are not supported");
        return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance)
    }

    computeMinDistanceLines(t, e, n) {
        for (let s = 0; s < t.size(); s++) {
            const r = t.get(s);
            for (let o = 0; o < e.size(); o++) {
                const a = e.get(o);
                if (this.computeMinDistance(r, a, n), this._minDistance <= this._terminateDistance) return null
            }
        }
    }
}

class Ac {
    constructor() {
        Ac.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._snapTolerance = 0, this._srcPts = null, this._seg = new Re, this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Te && typeof arguments[1] == "number") {
            const t = arguments[0], e = arguments[1];
            Ac.constructor_.call(this, t.getCoordinates(), e)
        } else if (arguments[0] instanceof Array && typeof arguments[1] == "number") {
            const t = arguments[0], e = arguments[1];
            this._srcPts = t, this._isClosed = Ac.isClosed(t), this._snapTolerance = e
        }
    }

    static isClosed(t) {
        return t.length <= 1 ? !1 : t[0].equals2D(t[t.length - 1])
    }

    snapVertices(t, e) {
        const n = this._isClosed ? t.size() - 1 : t.size();
        for (let s = 0; s < n; s++) {
            const r = t.get(s), o = this.findSnapForVertex(r, e);
            o !== null && (t.set(s, new F(o)), s === 0 && this._isClosed && t.set(t.size() - 1, new F(o)))
        }
    }

    findSnapForVertex(t, e) {
        for (let n = 0; n < e.length; n++) {
            if (t.equals2D(e[n])) return null;
            if (t.distance(e[n]) < this._snapTolerance) return e[n]
        }
        return null
    }

    snapTo(t) {
        const e = new ui(this._srcPts);
        return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray()
    }

    snapSegments(t, e) {
        if (e.length === 0) return null;
        let n = e.length;
        e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);
        for (let s = 0; s < n; s++) {
            const r = e[s], o = this.findSegmentIndexToSnap(r, t);
            o >= 0 && t.add(o + 1, new F(r), !1)
        }
    }

    findSegmentIndexToSnap(t, e) {
        let n = St.MAX_VALUE, s = -1;
        for (let r = 0; r < e.size() - 1; r++) {
            if (this._seg.p0 = e.get(r), this._seg.p1 = e.get(r + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) {
                if (this._allowSnappingToSourceVertices) continue;
                return -1
            }
            const o = this._seg.distance(t);
            o < this._snapTolerance && o < n && (n = o, s = r)
        }
        return s
    }

    setAllowSnappingToSourceVertices(t) {
        this._allowSnappingToSourceVertices = t
    }
}

class Ls {
    constructor() {
        Ls.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._srcGeom = null;
        const t = arguments[0];
        this._srcGeom = t
    }

    static snap(t, e, n) {
        const s = new Array(2).fill(null), r = new Ls(t);
        s[0] = r.snapTo(e, n);
        const o = new Ls(e);
        return s[1] = o.snapTo(s[0], n), s
    }

    static computeOverlaySnapTolerance() {
        if (arguments.length === 1) {
            const t = arguments[0];
            let e = Ls.computeSizeBasedSnapTolerance(t);
            const n = t.getPrecisionModel();
            if (n.getType() === Pe.FIXED) {
                const s = 1 / n.getScale() * 2 / 1.415;
                s > e && (e = s)
            }
            return e
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return Math.min(Ls.computeOverlaySnapTolerance(t), Ls.computeOverlaySnapTolerance(e))
        }
    }

    static computeSizeBasedSnapTolerance(t) {
        const e = t.getEnvelopeInternal();
        return Math.min(e.getHeight(), e.getWidth()) * Ls.SNAP_PRECISION_FACTOR
    }

    static snapToSelf(t, e, n) {
        return new Ls(t).snapToSelf(e, n)
    }

    snapTo(t, e) {
        const n = this.extractTargetCoordinates(t);
        return new Ad(e, n).transform(this._srcGeom)
    }

    snapToSelf(t, e) {
        const n = this.extractTargetCoordinates(this._srcGeom), r = new Ad(t, n, !0).transform(this._srcGeom);
        let o = r;
        return e && At(o, Ko) && (o = r.buffer(0)), o
    }

    computeSnapTolerance(t) {
        return this.computeMinimumSegmentLength(t) / 10
    }

    extractTargetCoordinates(t) {
        const e = new Ho, n = t.getCoordinates();
        for (let s = 0; s < n.length; s++) e.add(n[s]);
        return e.toArray(new Array(0).fill(null))
    }

    computeMinimumSegmentLength(t) {
        let e = St.MAX_VALUE;
        for (let n = 0; n < t.length - 1; n++) {
            const s = t[n].distance(t[n + 1]);
            s < e && (e = s)
        }
        return e
    }
}

Ls.SNAP_PRECISION_FACTOR = 1e-9;

class Ad extends t_ {
    constructor() {
        super(), Ad.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._snapTolerance = null, this._snapPts = null, this._isSelfSnap = !1, arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._snapTolerance = t, this._snapPts = e
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            this._snapTolerance = t, this._snapPts = e, this._isSelfSnap = n
        }
    }

    snapLine(t, e) {
        const n = new Ac(t, this._snapTolerance);
        return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e)
    }

    transformCoordinates(t, e) {
        const n = t.toCoordinateArray(), s = this.snapLine(n, this._snapPts);
        return this._factory.getCoordinateSequenceFactory().create(s)
    }
}

class I_ {
    constructor() {
        I_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._pts = null, this._data = null;
        const t = arguments[0], e = arguments[1];
        this._pts = t, this._data = e
    }

    getCoordinates() {
        return this._pts
    }

    size() {
        return this._pts.length
    }

    getCoordinate(t) {
        return this._pts[t]
    }

    isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1])
    }

    getSegmentOctant(t) {
        return t === this._pts.length - 1 ? -1 : Nf.octant(this.getCoordinate(t), this.getCoordinate(t + 1))
    }

    setData(t) {
        this._data = t
    }

    getData() {
        return this._data
    }

    toString() {
        return Bi.toLineString(new hi(this._pts))
    }

    get interfaces_() {
        return [JS]
    }
}

class rs {
    constructor() {
        rs.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._keepIntersections = !0, this._isInteriorIntersectionsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new ct, this._intersectionCount = 0;
        const t = arguments[0];
        this._li = t, this._interiorIntersection = null
    }

    static createAllIntersectionsFinder(t) {
        const e = new rs(t);
        return e.setFindAllIntersections(!0), e
    }

    static isInteriorVertexIntersection() {
        if (arguments.length === 4) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3];
            return n && s ? !1 : !!t.equals2D(e)
        } else if (arguments.length === 8) {
            const t = arguments[0], e = arguments[1], n = arguments[2], s = arguments[3], r = arguments[4],
                o = arguments[5], a = arguments[6], l = arguments[7];
            return !!(rs.isInteriorVertexIntersection(t, n, r, a) || rs.isInteriorVertexIntersection(t, s, r, l) || rs.isInteriorVertexIntersection(e, n, o, a) || rs.isInteriorVertexIntersection(e, s, o, l))
        }
    }

    static createInteriorIntersectionCounter(t) {
        const e = new rs(t);
        return e.setInteriorIntersectionsOnly(!0), e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e
    }

    static createIntersectionCounter(t) {
        const e = new rs(t);
        return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e
    }

    static isEndSegment(t, e) {
        return e === 0 || e >= t.size() - 2
    }

    static createAnyIntersectionFinder(t) {
        return new rs(t)
    }

    static createInteriorIntersectionsFinder(t) {
        const e = new rs(t);
        return e.setFindAllIntersections(!0), e.setInteriorIntersectionsOnly(!0), e
    }

    setCheckEndSegmentsOnly(t) {
        this._isCheckEndSegmentsOnly = t
    }

    getIntersectionSegments() {
        return this._intSegments
    }

    count() {
        return this._intersectionCount
    }

    getIntersections() {
        return this._intersections
    }

    setFindAllIntersections(t) {
        this._findAllIntersections = t
    }

    setKeepIntersections(t) {
        this._keepIntersections = t
    }

    getIntersection() {
        return this._interiorIntersection
    }

    processIntersections(t, e, n, s) {
        if (!this._findAllIntersections && this.hasIntersection()) return null;
        const r = t === n;
        if (r && e === s || this._isCheckEndSegmentsOnly && !(rs.isEndSegment(t, e) || rs.isEndSegment(n, s))) return null;
        const a = t.getCoordinate(e), l = t.getCoordinate(e + 1), c = n.getCoordinate(s), h = n.getCoordinate(s + 1),
            u = e === 0, d = e + 2 === t.size(), f = s === 0, g = s + 2 === n.size();
        this._li.computeIntersection(a, l, c, h);
        const m = this._li.hasIntersection() && this._li.isInteriorIntersection();
        let p = !1;
        this._isInteriorIntersectionsOnly || (p = !(r && Math.abs(s - e) <= 1) && rs.isInteriorVertexIntersection(a, l, c, h, u, d, f, g)), (m || p) && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = a, this._intSegments[1] = l, this._intSegments[2] = c, this._intSegments[3] = h, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++)
    }

    hasIntersection() {
        return this._interiorIntersection !== null
    }

    isDone() {
        return this._findAllIntersections ? !1 : this._interiorIntersection !== null
    }

    setInteriorIntersectionsOnly(t) {
        this._isInteriorIntersectionsOnly = t
    }

    get interfaces_() {
        return [E_]
    }
}

class Cd {
    constructor() {
        Cd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._li = new Gn, this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;
        const t = arguments[0];
        this._segStrings = t
    }

    static computeIntersections(t) {
        const e = new Cd(t);
        return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections()
    }

    execute() {
        if (this._segInt !== null) return null;
        this.checkInteriorIntersections()
    }

    getIntersections() {
        return this._segInt.getIntersections()
    }

    isValid() {
        return this.execute(), this._isValid
    }

    setFindAllIntersections(t) {
        this._findAllIntersections = t
    }

    checkInteriorIntersections() {
        this._isValid = !0, this._segInt = new rs(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
        const t = new Bl;
        if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null
    }

    checkValid() {
        if (this.execute(), !this._isValid) throw new Us(this.getErrorMessage(), this._segInt.getIntersection())
    }

    getErrorMessage() {
        if (this._isValid) return "no intersections found";
        const t = this._segInt.getIntersectionSegments();
        return "found non-noded intersection between " + Bi.toLineString(t[0], t[1]) + " and " + Bi.toLineString(t[2], t[3])
    }
}

class Cc {
    constructor() {
        Cc.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._nv = null;
        const t = arguments[0];
        this._nv = new Cd(Cc.toSegmentStrings(t))
    }

    static toSegmentStrings(t) {
        const e = new ct;
        for (let n = t.iterator(); n.hasNext();) {
            const s = n.next();
            e.add(new I_(s.getCoordinates(), s))
        }
        return e
    }

    static checkValid(t) {
        new Cc(t).checkValid()
    }

    checkValid() {
        this._nv.checkValid()
    }
}

class A_ {
    constructor() {
        A_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new ct, this._resultLineList = new ct;
        const t = arguments[0], e = arguments[1], n = arguments[2];
        this._op = t, this._geometryFactory = e, this._ptLocator = n
    }

    collectLines(t) {
        for (let e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
            const n = e.next();
            this.collectLineEdge(n, t, this._lineEdgesList), this.collectBoundaryTouchEdge(n, t, this._lineEdgesList)
        }
    }

    labelIsolatedLine(t, e) {
        const n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));
        t.getLabel().setLocation(e, n)
    }

    build(t) {
        return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList
    }

    collectLineEdge(t, e, n) {
        const s = t.getLabel(), r = t.getEdge();
        t.isLineEdge() && !t.isVisited() && Bt.isResultOfOp(s, e) && !r.isCovered() && (n.add(r), t.setVisitedEdge(!0))
    }

    findCoveredLineEdges() {
        for (let t = this._op.getGraph().getNodes().iterator(); t.hasNext();) t.next().getEdges().findCoveredLineEdges();
        for (let t = this._op.getGraph().getEdgeEnds().iterator(); t.hasNext();) {
            const e = t.next(), n = e.getEdge();
            if (e.isLineEdge() && !n.isCoveredSet()) {
                const s = this._op.isCoveredByA(e.getCoordinate());
                n.setCovered(s)
            }
        }
    }

    labelIsolatedLines(t) {
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next(), s = n.getLabel();
            n.isIsolated() && (s.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1))
        }
    }

    buildLines(t) {
        for (let e = this._lineEdgesList.iterator(); e.hasNext();) {
            const n = e.next(), s = this._geometryFactory.createLineString(n.getCoordinates());
            this._resultLineList.add(s), n.setInResult(!0)
        }
    }

    collectBoundaryTouchEdge(t, e, n) {
        const s = t.getLabel();
        if (t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult()) return null;
        $t.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), Bt.isResultOfOp(s, e) && e === Bt.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))
    }
}

class C_ {
    constructor() {
        C_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._op = null, this._geometryFactory = null, this._resultPointList = new ct;
        const t = arguments[0], e = arguments[1];
        this._op = t, this._geometryFactory = e
    }

    filterCoveredNodeToPoint(t) {
        const e = t.getCoordinate();
        if (!this._op.isCoveredByLA(e)) {
            const n = this._geometryFactory.createPoint(e);
            this._resultPointList.add(n)
        }
    }

    extractNonCoveredResultNodes(t) {
        for (let e = this._op.getGraph().getNodes().iterator(); e.hasNext();) {
            const n = e.next();
            if (!n.isInResult() && !n.isIncidentEdgeInResult() && (n.getEdges().getDegree() === 0 || t === Bt.INTERSECTION)) {
                const s = n.getLabel();
                Bt.isResultOfOp(s, t) && this.filterCoveredNodeToPoint(n)
            }
        }
    }

    build(t) {
        return this.extractNonCoveredResultNodes(t), this._resultPointList
    }
}

class bi {
    constructor() {
        this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = new bo, this._commonSignExp = null
    }

    getCommon() {
        return St.longBitsToDouble(this._commonBits)
    }

    add(t) {
        const e = St.doubleToLongBits(t);
        if (this._isFirst) return this._commonBits = e, this._commonSignExp = bi.signExpBits(this._commonBits), this._isFirst = !1, null;
        if (bi.signExpBits(e) !== this._commonSignExp) return this._commonBits.high = 0, this._commonBits.low = 0, null;
        this._commonMantissaBitsCount = bi.numCommonMostSigMantissaBits(this._commonBits, e), this._commonBits = bi.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount))
    }

    toString() {
        if (arguments.length === 1) {
            const t = arguments[0], e = St.longBitsToDouble(t),
                s = "0000000000000000000000000000000000000000000000000000000000000000" + bo.toBinaryString(t),
                r = s.substring(s.length - 64);
            return r.substring(0, 1) + "  " + r.substring(1, 12) + "(exp) " + r.substring(12) + " [ " + e + " ]"
        }
    }

    getClass() {
        return bi
    }

    get interfaces_() {
        return []
    }

    static getBit(t, e) {
        const n = 1 << e % 32;
        return e < 32 ? t.low & n ? 1 : 0 : t.high & n ? 1 : 0
    }

    static signExpBits(t) {
        return t.high >>> 20
    }

    static zeroLowerBits(t, e) {
        let n = "low";
        if (e > 32 && (t.low = 0, e %= 32, n = "high"), e > 0) {
            const s = e < 32 ? ~((1 << e) - 1) : 0;
            t[n] &= s
        }
        return t
    }

    static numCommonMostSigMantissaBits(t, e) {
        let n = 0;
        for (let s = 52; s >= 0; s--) {
            if (bi.getBit(t, s) !== bi.getBit(e, s)) return n;
            n++
        }
        return 52
    }
}

class Nh {
    constructor() {
        Nh.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._commonCoord = null, this._ccFilter = new $f
    }

    addCommonBits(t) {
        const e = new ih(this._commonCoord);
        t.apply(e), t.geometryChanged()
    }

    removeCommonBits(t) {
        if (this._commonCoord.x === 0 && this._commonCoord.y === 0) return t;
        const e = new F(this._commonCoord);
        e.x = -e.x, e.y = -e.y;
        const n = new ih(e);
        return t.apply(n), t.geometryChanged(), t
    }

    getCommonCoordinate() {
        return this._commonCoord
    }

    add(t) {
        t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate()
    }
}

class $f {
    constructor() {
        $f.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._commonBitsX = new bi, this._commonBitsY = new bi
    }

    filter(t) {
        this._commonBitsX.add(t.x), this._commonBitsY.add(t.y)
    }

    getCommonCoordinate() {
        return new F(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
    }

    get interfaces_() {
        return [Dl]
    }
}

class ih {
    constructor() {
        ih.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this.trans = null;
        const t = arguments[0];
        this.trans = t
    }

    filter(t, e) {
        const n = t.getOrdinate(e, 0) + this.trans.x, s = t.getOrdinate(e, 1) + this.trans.y;
        t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, s)
    }

    isDone() {
        return !1
    }

    isGeometryChanged() {
        return !0
    }

    get interfaces_() {
        return [Nl]
    }
}

Nh.CommonCoordinateFilter = $f;
Nh.Translater = ih;

class Ar {
    constructor() {
        Ar.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null;
        const t = arguments[0], e = arguments[1];
        this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance()
    }

    static overlayOp(t, e, n) {
        return new Ar(t, e).getResultGeometry(n)
    }

    static union(t, e) {
        return Ar.overlayOp(t, e, Bt.UNION)
    }

    static intersection(t, e) {
        return Ar.overlayOp(t, e, Bt.INTERSECTION)
    }

    static symDifference(t, e) {
        return Ar.overlayOp(t, e, Bt.SYMDIFFERENCE)
    }

    static difference(t, e) {
        return Ar.overlayOp(t, e, Bt.DIFFERENCE)
    }

    selfSnap(t) {
        return new Ls(t).snapTo(t, this._snapTolerance)
    }

    removeCommonBits(t) {
        this._cbr = new Nh, this._cbr.add(t[0]), this._cbr.add(t[1]);
        const e = new Array(2).fill(null);
        return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e
    }

    prepareResult(t) {
        return this._cbr.addCommonBits(t), t
    }

    getResultGeometry(t) {
        const e = this.snap(this._geom), n = Bt.overlayOp(e[0], e[1], t);
        return this.prepareResult(n)
    }

    checkValid(t) {
        t.isValid() || ws.out.println("Snapped geometry is invalid")
    }

    computeSnapTolerance() {
        this._snapTolerance = Ls.computeOverlaySnapTolerance(this._geom[0], this._geom[1])
    }

    snap(t) {
        const e = this.removeCommonBits(t);
        return Ls.snap(e[0], e[1], this._snapTolerance)
    }
}

class Ns {
    constructor() {
        Ns.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geom = new Array(2).fill(null);
        const t = arguments[0], e = arguments[1];
        this._geom[0] = t, this._geom[1] = e
    }

    static overlayOp(t, e, n) {
        return new Ns(t, e).getResultGeometry(n)
    }

    static union(t, e) {
        return Ns.overlayOp(t, e, Bt.UNION)
    }

    static intersection(t, e) {
        return Ns.overlayOp(t, e, Bt.INTERSECTION)
    }

    static symDifference(t, e) {
        return Ns.overlayOp(t, e, Bt.SYMDIFFERENCE)
    }

    static difference(t, e) {
        return Ns.overlayOp(t, e, Bt.DIFFERENCE)
    }

    getResultGeometry(t) {
        let e = null, n = !1, s = null;
        try {
            e = Bt.overlayOp(this._geom[0], this._geom[1], t), !0 && (n = !0)
        } catch (r) {
            if (r instanceof vs) s = r; else throw r
        } finally {
        }
        if (!n) try {
            e = Ar.overlayOp(this._geom[0], this._geom[1], t)
        } catch (r) {
            throw r instanceof vs ? s : r
        } finally {
        }
        return e
    }
}

class zr {
    constructor() {
        zr.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._li = new Gn, this._resultPrecisionModel = null, this._arg = null, arguments.length === 1) {
            const t = arguments[0];
            this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Fs(0, t)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            zr.constructor_.call(this, t, e, Dn.OGC_SFS_BOUNDARY_RULE)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            t.getPrecisionModel().compareTo(e.getPrecisionModel()) >= 0 ? this.setComputationPrecision(t.getPrecisionModel()) : this.setComputationPrecision(e.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Fs(0, t, n), this._arg[1] = new Fs(1, e, n)
        }
    }

    getArgGeometry(t) {
        return this._arg[t].getGeometry()
    }

    setComputationPrecision(t) {
        this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel)
    }
}

class Bt extends zr {
    constructor() {
        super(), Bt.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._ptLocator = new Jo, this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Gf, this._resultPolyList = new ct, this._resultLineList = new ct, this._resultPointList = new ct;
        const t = arguments[0], e = arguments[1];
        zr.constructor_.call(this, t, e), this._graph = new Qo(new b_), this._geomFact = t.getFactory()
    }

    static overlayOp(t, e, n) {
        return new Bt(t, e).getResultGeometry(n)
    }

    static union(t, e) {
        if (t.isEmpty() || e.isEmpty()) {
            if (t.isEmpty() && e.isEmpty()) return Bt.createEmptyResult(Bt.UNION, t, e, t.getFactory());
            if (t.isEmpty()) return e.copy();
            if (e.isEmpty()) return t.copy()
        }
        if (t.isGeometryCollection() || e.isGeometryCollection()) throw new jt("This method does not support GeometryCollection arguments");
        return Ns.overlayOp(t, e, Bt.UNION)
    }

    static intersection(t, e) {
        if (t.isEmpty() || e.isEmpty()) return Bt.createEmptyResult(Bt.INTERSECTION, t, e, t.getFactory());
        if (t.isGeometryCollection()) {
            const n = e;
            return _d.map(t, new class {
                get interfaces_() {
                    return [MapOp]
                }

                map(s) {
                    return Bt.intersection(s, n)
                }
            })
        }
        return Ns.overlayOp(t, e, Bt.INTERSECTION)
    }

    static symDifference(t, e) {
        if (t.isEmpty() || e.isEmpty()) {
            if (t.isEmpty() && e.isEmpty()) return Bt.createEmptyResult(Bt.SYMDIFFERENCE, t, e, t.getFactory());
            if (t.isEmpty()) return e.copy();
            if (e.isEmpty()) return t.copy()
        }
        if (t.isGeometryCollection() || e.isGeometryCollection()) throw new jt("This method does not support GeometryCollection arguments");
        return Ns.overlayOp(t, e, Bt.SYMDIFFERENCE)
    }

    static resultDimension(t, e, n) {
        const s = e.getDimension(), r = n.getDimension();
        let o = -1;
        switch (t) {
            case Bt.INTERSECTION:
                o = Math.min(s, r);
                break;
            case Bt.UNION:
                o = Math.max(s, r);
                break;
            case Bt.DIFFERENCE:
                o = s;
                break;
            case Bt.SYMDIFFERENCE:
                o = Math.max(s, r);
                break
        }
        return o
    }

    static createEmptyResult(t, e, n, s) {
        const r = Bt.resultDimension(t, e, n);
        return s.createEmpty(r)
    }

    static difference(t, e) {
        if (t.isEmpty()) return Bt.createEmptyResult(Bt.DIFFERENCE, t, e, t.getFactory());
        if (e.isEmpty()) return t.copy();
        if (t.isGeometryCollection() || e.isGeometryCollection()) throw new jt("This method does not support GeometryCollection arguments");
        return Ns.overlayOp(t, e, Bt.DIFFERENCE)
    }

    static isResultOfOp() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t.getLocation(0), s = t.getLocation(1);
            return Bt.isResultOfOp(n, s, e)
        } else if (arguments.length === 3) {
            let t = arguments[0], e = arguments[1], n = arguments[2];
            switch (t === T.BOUNDARY && (t = T.INTERIOR), e === T.BOUNDARY && (e = T.INTERIOR), n) {
                case Bt.INTERSECTION:
                    return t === T.INTERIOR && e === T.INTERIOR;
                case Bt.UNION:
                    return t === T.INTERIOR || e === T.INTERIOR;
                case Bt.DIFFERENCE:
                    return t === T.INTERIOR && e !== T.INTERIOR;
                case Bt.SYMDIFFERENCE:
                    return t === T.INTERIOR && e !== T.INTERIOR || t !== T.INTERIOR && e === T.INTERIOR
            }
            return !1
        }
    }

    insertUniqueEdge(t) {
        const e = this._edgeList.findEqualEdge(t);
        if (e !== null) {
            const n = e.getLabel();
            let s = t.getLabel();
            e.isPointwiseEqual(t) || (s = new Ye(t.getLabel()), s.flip());
            const r = e.getDepth();
            r.isNull() && r.add(n), r.add(s), n.merge(s)
        } else this._edgeList.add(t)
    }

    getGraph() {
        return this._graph
    }

    cancelDuplicateResultEdges() {
        for (let t = this._graph.getEdgeEnds().iterator(); t.hasNext();) {
            const e = t.next(), n = e.getSym();
            e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1))
        }
    }

    isCoveredByLA(t) {
        return !!(this.isCovered(t, this._resultLineList) || this.isCovered(t, this._resultPolyList))
    }

    computeGeometry(t, e, n, s) {
        const r = new ct;
        return r.addAll(t), r.addAll(e), r.addAll(n), r.isEmpty() ? Bt.createEmptyResult(s, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(r)
    }

    mergeSymLabels() {
        for (let t = this._graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().mergeSymLabels()
    }

    isCovered(t, e) {
        for (let n = e.iterator(); n.hasNext();) {
            const s = n.next();
            if (this._ptLocator.locate(t, s) !== T.EXTERIOR) return !0
        }
        return !1
    }

    replaceCollapsedEdges() {
        const t = new ct;
        for (let e = this._edgeList.iterator(); e.hasNext();) {
            const n = e.next();
            n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()))
        }
        this._edgeList.addAll(t)
    }

    updateNodeLabelling() {
        for (let t = this._graph.getNodes().iterator(); t.hasNext();) {
            const e = t.next(), n = e.getEdges().getLabel();
            e.getLabel().merge(n)
        }
    }

    getResultGeometry(t) {
        return this.computeOverlay(t), this._resultGeom
    }

    insertUniqueEdges(t) {
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next();
            this.insertUniqueEdge(n)
        }
    }

    computeOverlay(t) {
        this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
        const e = new ct;
        this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Cc.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
        const n = new eh(this._geomFact);
        n.add(this._graph), this._resultPolyList = n.getPolygons();
        const s = new A_(this, this._geomFact, this._ptLocator);
        this._resultLineList = s.build(t);
        const r = new C_(this, this._geomFact, this._ptLocator);
        this._resultPointList = r.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t)
    }

    labelIncompleteNode(t, e) {
        const n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());
        t.getLabel().setLocation(e, n)
    }

    copyPoints(t) {
        for (let e = this._arg[t].getNodeIterator(); e.hasNext();) {
            const n = e.next();
            this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
        }
    }

    findResultAreaEdges(t) {
        for (let e = this._graph.getEdgeEnds().iterator(); e.hasNext();) {
            const n = e.next(), s = n.getLabel();
            s.isArea() && !n.isInteriorAreaEdge() && Bt.isResultOfOp(s.getLocation(0, ot.RIGHT), s.getLocation(1, ot.RIGHT), t) && n.setInResult(!0)
        }
    }

    computeLabelsFromDepths() {
        for (let t = this._edgeList.iterator(); t.hasNext();) {
            const e = t.next(), n = e.getLabel(), s = e.getDepth();
            if (!s.isNull()) {
                s.normalize();
                for (let r = 0; r < 2; r++) !n.isNull(r) && n.isArea() && !s.isNull(r) && (s.getDelta(r) === 0 ? n.toLine(r) : ($t.isTrue(!s.isNull(r, ot.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(r, ot.LEFT, s.getLocation(r, ot.LEFT)), $t.isTrue(!s.isNull(r, ot.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(r, ot.RIGHT, s.getLocation(r, ot.RIGHT))))
            }
        }
    }

    computeLabelling() {
        for (let t = this._graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().computeLabelling(this._arg);
        this.mergeSymLabels(), this.updateNodeLabelling()
    }

    labelIncompleteNodes() {
        for (let t = this._graph.getNodes().iterator(); t.hasNext();) {
            const e = t.next(), n = e.getLabel();
            e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n)
        }
    }

    isCoveredByA(t) {
        return !!this.isCovered(t, this._resultPolyList)
    }
}

Bt.INTERSECTION = 1;
Bt.UNION = 2;
Bt.DIFFERENCE = 3;
Bt.SYMDIFFERENCE = 4;

class Pd {
    constructor() {
        Pd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geometryFactory = new hn, this._geomGraph = null, this._disconnectedRingcoord = null;
        const t = arguments[0];
        this._geomGraph = t
    }

    static findDifferentPoint(t, e) {
        for (let n = 0; n < t.length; n++) if (!t[n].equals(e)) return t[n];
        return null
    }

    visitInteriorRing(t, e) {
        if (t.isEmpty()) return null;
        const n = t.getCoordinates(), s = n[0], r = Pd.findDifferentPoint(n, s), o = e.findEdgeInSameDirection(s, r),
            a = e.findEdgeEnd(o);
        let l = null;
        a.getLabel().getLocation(0, ot.RIGHT) === T.INTERIOR ? l = a : a.getSym().getLabel().getLocation(0, ot.RIGHT) === T.INTERIOR && (l = a.getSym()), $t.isTrue(l !== null, "unable to find dirEdge with Interior on RHS"), this.visitLinkedDirectedEdges(l)
    }

    visitShellInteriors(t, e) {
        if (t instanceof $e) {
            const n = t;
            this.visitInteriorRing(n.getExteriorRing(), e)
        }
        if (t instanceof bs) {
            const n = t;
            for (let s = 0; s < n.getNumGeometries(); s++) {
                const r = n.getGeometryN(s);
                this.visitInteriorRing(r.getExteriorRing(), e)
            }
        }
    }

    getCoordinate() {
        return this._disconnectedRingcoord
    }

    setInteriorEdgesInResult(t) {
        for (let e = t.getEdgeEnds().iterator(); e.hasNext();) {
            const n = e.next();
            n.getLabel().getLocation(0, ot.RIGHT) === T.INTERIOR && n.setInResult(!0)
        }
    }

    visitLinkedDirectedEdges(t) {
        const e = t;
        let n = t;
        do $t.isTrue(n !== null, "found null Directed Edge"), n.setVisited(!0), n = n.getNext(); while (n !== e)
    }

    buildEdgeRings(t) {
        const e = new ct;
        for (let n = t.iterator(); n.hasNext();) {
            const s = n.next();
            if (s.isInResult() && s.getEdgeRing() === null) {
                const r = new zf(s, this._geometryFactory);
                r.linkDirectedEdgesForMinimalEdgeRings();
                const o = r.buildMinimalRings();
                e.addAll(o)
            }
        }
        return e
    }

    hasUnvisitedShellEdge(t) {
        for (let e = 0; e < t.size(); e++) {
            const n = t.get(e);
            if (n.isHole()) continue;
            const s = n.getEdges();
            let r = s.get(0);
            if (r.getLabel().getLocation(0, ot.RIGHT) === T.INTERIOR) {
                for (let o = 0; o < s.size(); o++) if (r = s.get(o), !r.isVisited()) return this._disconnectedRingcoord = r.getCoordinate(), !0
            }
        }
        return !1
    }

    isInteriorsConnected() {
        const t = new ct;
        this._geomGraph.computeSplitEdges(t);
        const e = new Qo(new b_);
        e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();
        const n = this.buildEdgeRings(e.getEdgeEnds());
        return this.visitShellInteriors(this._geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(n)
    }
}

class QS {
    createEdgeEndForNext(t, e, n, s) {
        const r = n.segmentIndex + 1;
        if (r >= t.getNumPoints() && s === null) return null;
        let o = t.getCoordinate(r);
        s !== null && s.segmentIndex === n.segmentIndex && (o = s.coord);
        const a = new Ni(t, n.coord, o, new Ye(t.getLabel()));
        e.add(a)
    }

    createEdgeEndForPrev(t, e, n, s) {
        let r = n.segmentIndex;
        if (n.dist === 0) {
            if (r === 0) return null;
            r--
        }
        let o = t.getCoordinate(r);
        s !== null && s.segmentIndex >= r && (o = s.coord);
        const a = new Ye(t.getLabel());
        a.flip();
        const l = new Ni(t, n.coord, o, a);
        e.add(l)
    }

    computeEdgeEnds() {
        if (arguments.length === 1) {
            const t = arguments[0], e = new ct;
            for (let n = t; n.hasNext();) {
                const s = n.next();
                this.computeEdgeEnds(s, e)
            }
            return e
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1], n = t.getEdgeIntersectionList();
            n.addEndpoints();
            const s = n.iterator();
            let r = null, o = null;
            if (!s.hasNext()) return null;
            let a = s.next();
            do r = o, o = a, a = null, s.hasNext() && (a = s.next()), o !== null && (this.createEdgeEndForPrev(t, e, o, r), this.createEdgeEndForNext(t, e, o, a)); while (o !== null)
        }
    }
}

class Rd extends Ni {
    constructor() {
        super(), Rd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._edgeEnds = new ct, arguments.length === 1) {
            const t = arguments[0];
            Rd.constructor_.call(this, null, t)
        } else if (arguments.length === 2) {
            const t = arguments[1];
            Ni.constructor_.call(this, t.getEdge(), t.getCoordinate(), t.getDirectedCoordinate(), new Ye(t.getLabel())), this.insert(t)
        }
    }

    insert(t) {
        this._edgeEnds.add(t)
    }

    print(t) {
        t.println("EdgeEndBundle--> Label: " + this._label);
        for (let e = this.iterator(); e.hasNext();) e.next().print(t), t.println()
    }

    iterator() {
        return this._edgeEnds.iterator()
    }

    getEdgeEnds() {
        return this._edgeEnds
    }

    computeLabelOn(t, e) {
        let n = 0, s = !1;
        for (let o = this.iterator(); o.hasNext();) {
            const l = o.next().getLabel().getLocation(t);
            l === T.BOUNDARY && n++, l === T.INTERIOR && (s = !0)
        }
        let r = T.NONE;
        s && (r = T.INTERIOR), n > 0 && (r = Fs.determineBoundary(e, n)), this._label.setLocation(t, r)
    }

    computeLabelSide(t, e) {
        for (let n = this.iterator(); n.hasNext();) {
            const s = n.next();
            if (s.getLabel().isArea()) {
                const r = s.getLabel().getLocation(t, e);
                if (r === T.INTERIOR) return this._label.setLocation(t, e, T.INTERIOR), null;
                r === T.EXTERIOR && this._label.setLocation(t, e, T.EXTERIOR)
            }
        }
    }

    getLabel() {
        return this._label
    }

    computeLabelSides(t) {
        this.computeLabelSide(t, ot.LEFT), this.computeLabelSide(t, ot.RIGHT)
    }

    updateIM(t) {
        li.updateIM(this._label, t)
    }

    computeLabel(t) {
        let e = !1;
        for (let n = this.iterator(); n.hasNext();) n.next().getLabel().isArea() && (e = !0);
        e ? this._label = new Ye(T.NONE, T.NONE, T.NONE) : this._label = new Ye(T.NONE);
        for (let n = 0; n < 2; n++) this.computeLabelOn(n, t), e && this.computeLabelSides(n)
    }
}

class Tz extends Uf {
    constructor() {
        super()
    }

    updateIM(t) {
        for (let e = this.iterator(); e.hasNext();) e.next().updateIM(t)
    }

    insert(t) {
        let e = this._edgeMap.get(t);
        e === null ? (e = new Rd(t), this.insertEdgeEnd(t, e)) : e.insert(t)
    }
}

class P_ extends hr {
    constructor() {
        super(), P_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        const t = arguments[0], e = arguments[1];
        hr.constructor_.call(this, t, e)
    }

    updateIMFromEdges(t) {
        this._edges.updateIM(t)
    }

    computeIM(t) {
        t.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0)
    }
}

class tM extends u_ {
    constructor() {
        super()
    }

    createNode(t) {
        return new P_(t, new Tz)
    }
}

class R_ {
    constructor() {
        R_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._nodes = new gl(new tM)
    }

    insertEdgeEnds(t) {
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next();
            this._nodes.add(n)
        }
    }

    getNodeIterator() {
        return this._nodes.iterator()
    }

    copyNodesAndLabels(t, e) {
        for (let n = t.getNodeIterator(); n.hasNext();) {
            const s = n.next();
            this._nodes.addNode(s.getCoordinate()).setLabel(e, s.getLabel().getLocation(e))
        }
    }

    build(t) {
        this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);
        const n = new QS().computeEdgeEnds(t.getEdgeIterator());
        this.insertEdgeEnds(n)
    }

    computeIntersectionNodes(t, e) {
        for (let n = t.getEdgeIterator(); n.hasNext();) {
            const s = n.next(), r = s.getLabel().getLocation(e);
            for (let o = s.getEdgeIntersectionList().iterator(); o.hasNext();) {
                const a = o.next(), l = this._nodes.addNode(a.coord);
                r === T.BOUNDARY ? l.setLabelBoundary(e) : l.getLabel().isNull(e) && l.setLabel(e, T.INTERIOR)
            }
        }
    }
}

class L_ {
    constructor() {
        L_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._li = new Gn, this._geomGraph = null, this._nodeGraph = new R_, this._invalidPoint = null;
        const t = arguments[0];
        this._geomGraph = t
    }

    isNodeEdgeAreaLabelsConsistent() {
        for (let t = this._nodeGraph.getNodeIterator(); t.hasNext();) {
            const e = t.next();
            if (!e.getEdges().isAreaLabelsConsistent(this._geomGraph)) return this._invalidPoint = e.getCoordinate().copy(), !1
        }
        return !0
    }

    getInvalidPoint() {
        return this._invalidPoint
    }

    hasDuplicateRings() {
        for (let t = this._nodeGraph.getNodeIterator(); t.hasNext();) {
            const e = t.next();
            for (let n = e.getEdges().iterator(); n.hasNext();) {
                const s = n.next();
                if (s.getEdgeEnds().size() > 1) return this._invalidPoint = s.getEdge().getCoordinate(0), !0
            }
        }
        return !1
    }

    isNodeConsistentArea() {
        const t = this._geomGraph.computeSelfNodes(this._li, !0, !0);
        return t.hasProperIntersection() ? (this._invalidPoint = t.getProperIntersectionPoint(), !1) : (this._nodeGraph.build(this._geomGraph), this.isNodeEdgeAreaLabelsConsistent())
    }
}

class N_ {
    constructor() {
        N_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._graph = null, this._rings = new ct, this._totalEnv = new Kt, this._index = null, this._nestedPt = null;
        const t = arguments[0];
        this._graph = t
    }

    buildIndex() {
        this._index = new nn;
        for (let t = 0; t < this._rings.size(); t++) {
            const e = this._rings.get(t), n = e.getEnvelopeInternal();
            this._index.insert(n, e)
        }
    }

    getNestedPoint() {
        return this._nestedPt
    }

    isNonNested() {
        this.buildIndex();
        for (let t = 0; t < this._rings.size(); t++) {
            const e = this._rings.get(t), n = e.getCoordinates(), s = this._index.query(e.getEnvelopeInternal());
            for (let r = 0; r < s.size(); r++) {
                const o = s.get(r), a = o.getCoordinates();
                if (e === o || !e.getEnvelopeInternal().intersects(o.getEnvelopeInternal())) continue;
                const l = Ei.findPtNotNode(n, o, this._graph);
                if (l === null) continue;
                if (Zs.isInRing(l, a)) return this._nestedPt = l, !1
            }
        }
        return !0
    }

    add(t) {
        this._rings.add(t), this._totalEnv.expandToInclude(t.getEnvelopeInternal())
    }
}

class ne {
    constructor() {
        ne.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._errorType = null, this._pt = null, arguments.length === 1) {
            const t = arguments[0];
            ne.constructor_.call(this, t, null)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._errorType = t, e !== null && (this._pt = e.copy())
        }
    }

    getErrorType() {
        return this._errorType
    }

    getMessage() {
        return ne.errMsg[this._errorType]
    }

    getCoordinate() {
        return this._pt
    }

    toString() {
        let t = "";
        return this._pt !== null && (t = " at or near point " + this._pt), this.getMessage() + t
    }
}

ne.ERROR = 0;
ne.REPEATED_POINT = 1;
ne.HOLE_OUTSIDE_SHELL = 2;
ne.NESTED_HOLES = 3;
ne.DISCONNECTED_INTERIOR = 4;
ne.SELF_INTERSECTION = 5;
ne.RING_SELF_INTERSECTION = 6;
ne.NESTED_SHELLS = 7;
ne.DUPLICATE_RINGS = 8;
ne.TOO_FEW_POINTS = 9;
ne.INVALID_COORDINATE = 10;
ne.RING_NOT_CLOSED = 11;
ne.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"];

class Ei {
    constructor() {
        Ei.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._parentGeometry = null, this._isSelfTouchingRingFormingHoleValid = !1, this._validErr = null;
        const t = arguments[0];
        this._parentGeometry = t
    }

    static findPtNotNode(t, e, n) {
        const r = n.findEdge(e).getEdgeIntersectionList();
        for (let o = 0; o < t.length; o++) {
            const a = t[o];
            if (!r.isIntersection(a)) return a
        }
        return null
    }

    static isValid() {
        if (arguments[0] instanceof it) {
            const t = arguments[0];
            return new Ei(t).isValid()
        } else if (arguments[0] instanceof F) {
            const t = arguments[0];
            return !(St.isNaN(t.x) || St.isInfinite(t.x) || St.isNaN(t.y) || St.isInfinite(t.y))
        }
    }

    checkInvalidCoordinates() {
        if (arguments[0] instanceof Array) {
            const t = arguments[0];
            for (let e = 0; e < t.length; e++) if (!Ei.isValid(t[e])) return this._validErr = new ne(ne.INVALID_COORDINATE, t[e]), null
        } else if (arguments[0] instanceof $e) {
            const t = arguments[0];
            if (this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()), this._validErr !== null) return null;
            for (let e = 0; e < t.getNumInteriorRing(); e++) if (this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()), this._validErr !== null) return null
        }
    }

    checkHolesNotNested(t, e) {
        if (t.getNumInteriorRing() <= 0) return null;
        const n = new N_(e);
        for (let r = 0; r < t.getNumInteriorRing(); r++) {
            const o = t.getInteriorRingN(r);
            o.isEmpty() || n.add(o)
        }
        n.isNonNested() || (this._validErr = new ne(ne.NESTED_HOLES, n.getNestedPoint()))
    }

    checkConsistentArea(t) {
        const e = new L_(t);
        if (!e.isNodeConsistentArea()) return this._validErr = new ne(ne.SELF_INTERSECTION, e.getInvalidPoint()), null;
        e.hasDuplicateRings() && (this._validErr = new ne(ne.DUPLICATE_RINGS, e.getInvalidPoint()))
    }

    isValid() {
        return this.checkValid(this._parentGeometry), this._validErr === null
    }

    checkShellInsideHole(t, e, n) {
        const s = t.getCoordinates(), r = e.getCoordinates(), o = Ei.findPtNotNode(s, e, n);
        if (o !== null && !Zs.isInRing(o, r)) return o;
        const a = Ei.findPtNotNode(r, t, n);
        return a !== null ? Zs.isInRing(a, s) ? a : null : ($t.shouldNeverReachHere("points in shell and hole appear to be equal"), null)
    }

    checkNoSelfIntersectingRings(t) {
        for (let e = t.getEdgeIterator(); e.hasNext();) {
            const n = e.next();
            if (this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()), this._validErr !== null) return null
        }
    }

    checkConnectedInteriors(t) {
        const e = new Pd(t);
        e.isInteriorsConnected() || (this._validErr = new ne(ne.DISCONNECTED_INTERIOR, e.getCoordinate()))
    }

    checkNoSelfIntersectingRing(t) {
        const e = new Ho;
        let n = !0;
        for (let s = t.iterator(); s.hasNext();) {
            const r = s.next();
            if (n) {
                n = !1;
                continue
            }
            if (e.contains(r.coord)) return this._validErr = new ne(ne.RING_SELF_INTERSECTION, r.coord), null;
            e.add(r.coord)
        }
    }

    checkHolesInShell(t, e) {
        if (t.getNumInteriorRing() <= 0) return null;
        const n = t.getExteriorRing(), s = n.isEmpty(), r = new zl(n);
        for (let o = 0; o < t.getNumInteriorRing(); o++) {
            const a = t.getInteriorRingN(o);
            let l = null;
            if (a.isEmpty()) continue;
            if (l = Ei.findPtNotNode(a.getCoordinates(), n, e), l === null) return null;
            if (s || T.EXTERIOR === r.locate(l)) return this._validErr = new ne(ne.HOLE_OUTSIDE_SHELL, l), null
        }
    }

    checkTooFewPoints(t) {
        if (t.hasTooFewPoints()) return this._validErr = new ne(ne.TOO_FEW_POINTS, t.getInvalidPoint()), null
    }

    getValidationError() {
        return this.checkValid(this._parentGeometry), this._validErr
    }

    checkValid() {
        if (arguments[0] instanceof on) {
            const t = arguments[0];
            this.checkInvalidCoordinates(t.getCoordinates())
        } else if (arguments[0] instanceof di) {
            const t = arguments[0];
            this.checkInvalidCoordinates(t.getCoordinates())
        } else if (arguments[0] instanceof Un) {
            const t = arguments[0];
            if (this.checkInvalidCoordinates(t.getCoordinates()), this._validErr !== null || (this.checkClosedRing(t), this._validErr !== null)) return null;
            const e = new Fs(0, t);
            if (this.checkTooFewPoints(e), this._validErr !== null) return null;
            const n = new Gn;
            e.computeSelfNodes(n, !0, !0), this.checkNoSelfIntersectingRings(e)
        } else if (arguments[0] instanceof Te) {
            const t = arguments[0];
            if (this.checkInvalidCoordinates(t.getCoordinates()), this._validErr !== null) return null;
            const e = new Fs(0, t);
            this.checkTooFewPoints(e)
        } else if (arguments[0] instanceof $e) {
            const t = arguments[0];
            if (this.checkInvalidCoordinates(t), this._validErr !== null || (this.checkClosedRings(t), this._validErr !== null)) return null;
            const e = new Fs(0, t);
            if (this.checkTooFewPoints(e), this._validErr !== null || (this.checkConsistentArea(e), this._validErr !== null) || !this._isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(e), this._validErr !== null) || (this.checkHolesInShell(t, e), this._validErr !== null) || (this.checkHolesNotNested(t, e), this._validErr !== null)) return null;
            this.checkConnectedInteriors(e)
        } else if (arguments[0] instanceof bs) {
            const t = arguments[0];
            for (let n = 0; n < t.getNumGeometries(); n++) {
                const s = t.getGeometryN(n);
                if (this.checkInvalidCoordinates(s), this._validErr !== null || (this.checkClosedRings(s), this._validErr !== null)) return null
            }
            const e = new Fs(0, t);
            if (this.checkTooFewPoints(e), this._validErr !== null || (this.checkConsistentArea(e), this._validErr !== null) || !this._isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(e), this._validErr !== null)) return null;
            for (let n = 0; n < t.getNumGeometries(); n++) {
                const s = t.getGeometryN(n);
                if (this.checkHolesInShell(s, e), this._validErr !== null) return null
            }
            for (let n = 0; n < t.getNumGeometries(); n++) {
                const s = t.getGeometryN(n);
                if (this.checkHolesNotNested(s, e), this._validErr !== null) return null
            }
            if (this.checkShellsNotNested(t, e), this._validErr !== null) return null;
            this.checkConnectedInteriors(e)
        } else if (arguments[0] instanceof Ie) {
            const t = arguments[0];
            for (let e = 0; e < t.getNumGeometries(); e++) {
                const n = t.getGeometryN(e);
                if (this.checkValid(n), this._validErr !== null) return null
            }
        } else if (arguments[0] instanceof it) {
            const t = arguments[0];
            if (this._validErr = null, t.isEmpty()) return null;
            if (t instanceof on) this.checkValid(t); else if (t instanceof di) this.checkValid(t); else if (t instanceof Un) this.checkValid(t); else if (t instanceof Te) this.checkValid(t); else if (t instanceof $e) this.checkValid(t); else if (t instanceof bs) this.checkValid(t); else if (t instanceof Ie) this.checkValid(t); else throw new Js(t.getGeometryType())
        }
    }

    setSelfTouchingRingFormingHoleValid(t) {
        this._isSelfTouchingRingFormingHoleValid = t
    }

    checkShellNotNested(t, e, n) {
        const s = t.getCoordinates(), r = e.getExteriorRing();
        if (r.isEmpty()) return null;
        const o = r.getCoordinates(), a = Ei.findPtNotNode(s, r, n);
        if (a === null || !Zs.isInRing(a, o)) return null;
        if (e.getNumInteriorRing() <= 0) return this._validErr = new ne(ne.NESTED_SHELLS, a), null;
        let c = null;
        for (let h = 0; h < e.getNumInteriorRing(); h++) {
            const u = e.getInteriorRingN(h);
            if (c = this.checkShellInsideHole(t, u, n), c === null) return null
        }
        this._validErr = new ne(ne.NESTED_SHELLS, c)
    }

    checkClosedRings(t) {
        if (this.checkClosedRing(t.getExteriorRing()), this._validErr !== null) return null;
        for (let e = 0; e < t.getNumInteriorRing(); e++) if (this.checkClosedRing(t.getInteriorRingN(e)), this._validErr !== null) return null
    }

    checkClosedRing(t) {
        if (t.isEmpty()) return null;
        if (!t.isClosed()) {
            let e = null;
            t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)), this._validErr = new ne(ne.RING_NOT_CLOSED, e)
        }
    }

    checkShellsNotNested(t, e) {
        for (let n = 0; n < t.getNumGeometries(); n++) {
            const r = t.getGeometryN(n).getExteriorRing();
            for (let o = 0; o < t.getNumGeometries(); o++) {
                if (n === o) continue;
                const a = t.getGeometryN(o);
                if (this.checkShellNotNested(r, a, e), this._validErr !== null) return null
            }
        }
    }
}

class Ld {
    constructor() {
        Ld.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._li = new Gn, this._ptLocator = new Jo, this._arg = null, this._nodes = new gl(new tM), this._im = null, this._isolatedEdges = new ct, this._invalidPoint = null;
        const t = arguments[0];
        this._arg = t
    }

    insertEdgeEnds(t) {
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next();
            this._nodes.add(n)
        }
    }

    computeProperIntersectionIM(t, e) {
        const n = this._arg[0].getGeometry().getDimension(), s = this._arg[1].getGeometry().getDimension(),
            r = t.hasProperIntersection(), o = t.hasProperInteriorIntersection();
        n === 2 && s === 2 ? r && e.setAtLeast("212101212") : n === 2 && s === 1 ? (r && e.setAtLeast("FFF0FFFF2"), o && e.setAtLeast("1FFFFF1FF")) : n === 1 && s === 2 ? (r && e.setAtLeast("F0FFFFFF2"), o && e.setAtLeast("1F1FFFFFF")) : n === 1 && s === 1 && o && e.setAtLeast("0FFFFFFFF")
    }

    labelIsolatedEdges(t, e) {
        for (let n = this._arg[t].getEdgeIterator(); n.hasNext();) {
            const s = n.next();
            s.isIsolated() && (this.labelIsolatedEdge(s, e, this._arg[e].getGeometry()), this._isolatedEdges.add(s))
        }
    }

    labelIsolatedEdge(t, e, n) {
        if (n.getDimension() > 0) {
            const s = this._ptLocator.locate(t.getCoordinate(), n);
            t.getLabel().setAllLocations(e, s)
        } else t.getLabel().setAllLocations(e, T.EXTERIOR)
    }

    computeIM() {
        const t = new be;
        if (t.set(T.EXTERIOR, T.EXTERIOR, 2), !this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(t), t;
        this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1);
        const e = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !1);
        this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e, t);
        const n = new QS, s = n.computeEdgeEnds(this._arg[0].getEdgeIterator());
        this.insertEdgeEnds(s);
        const r = n.computeEdgeEnds(this._arg[1].getEdgeIterator());
        return this.insertEdgeEnds(r), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t), t
    }

    labelNodeEdges() {
        for (let t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().computeLabelling(this._arg)
    }

    copyNodesAndLabels(t) {
        for (let e = this._arg[t].getNodeIterator(); e.hasNext();) {
            const n = e.next();
            this._nodes.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
        }
    }

    labelIntersectionNodes(t) {
        for (let e = this._arg[t].getEdgeIterator(); e.hasNext();) {
            const n = e.next(), s = n.getLabel().getLocation(t);
            for (let r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
                const o = r.next(), a = this._nodes.find(o.coord);
                a.getLabel().isNull(t) && (s === T.BOUNDARY ? a.setLabelBoundary(t) : a.setLabel(t, T.INTERIOR))
            }
        }
    }

    labelIsolatedNode(t, e) {
        const n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());
        t.getLabel().setAllLocations(e, n)
    }

    computeIntersectionNodes(t) {
        for (let e = this._arg[t].getEdgeIterator(); e.hasNext();) {
            const n = e.next(), s = n.getLabel().getLocation(t);
            for (let r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
                const o = r.next(), a = this._nodes.addNode(o.coord);
                s === T.BOUNDARY ? a.setLabelBoundary(t) : a.getLabel().isNull(t) && a.setLabel(t, T.INTERIOR)
            }
        }
    }

    labelIsolatedNodes() {
        for (let t = this._nodes.iterator(); t.hasNext();) {
            const e = t.next(), n = e.getLabel();
            $t.isTrue(n.getGeometryCount() > 0, "node with empty label found"), e.isIsolated() && (n.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1))
        }
    }

    updateIM(t) {
        for (let e = this._isolatedEdges.iterator(); e.hasNext();) e.next().updateIM(t);
        for (let e = this._nodes.iterator(); e.hasNext();) {
            const n = e.next();
            n.updateIM(t), n.updateIMFromEdges(t)
        }
    }

    computeDisjointIM(t) {
        const e = this._arg[0].getGeometry();
        e.isEmpty() || (t.set(T.INTERIOR, T.EXTERIOR, e.getDimension()), t.set(T.BOUNDARY, T.EXTERIOR, e.getBoundaryDimension()));
        const n = this._arg[1].getGeometry();
        n.isEmpty() || (t.set(T.EXTERIOR, T.INTERIOR, n.getDimension()), t.set(T.EXTERIOR, T.BOUNDARY, n.getBoundaryDimension()))
    }
}

class Nd {
    constructor() {
        Nd.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._rectEnv = null;
        const t = arguments[0];
        this._rectEnv = t.getEnvelopeInternal()
    }

    static contains(t, e) {
        return new Nd(t).contains(e)
    }

    isContainedInBoundary(t) {
        if (t instanceof $e) return !1;
        if (t instanceof on) return this.isPointContainedInBoundary(t);
        if (t instanceof Te) return this.isLineStringContainedInBoundary(t);
        for (let e = 0; e < t.getNumGeometries(); e++) {
            const n = t.getGeometryN(e);
            if (!this.isContainedInBoundary(n)) return !1
        }
        return !0
    }

    isLineSegmentContainedInBoundary(t, e) {
        if (t.equals(e)) return this.isPointContainedInBoundary(t);
        if (t.x === e.x) {
            if (t.x === this._rectEnv.getMinX() || t.x === this._rectEnv.getMaxX()) return !0
        } else if (t.y === e.y && (t.y === this._rectEnv.getMinY() || t.y === this._rectEnv.getMaxY())) return !0;
        return !1
    }

    isLineStringContainedInBoundary(t) {
        const e = t.getCoordinateSequence(), n = new F, s = new F;
        for (let r = 0; r < e.size() - 1; r++) if (e.getCoordinate(r, n), e.getCoordinate(r + 1, s), !this.isLineSegmentContainedInBoundary(n, s)) return !1;
        return !0
    }

    isPointContainedInBoundary() {
        if (arguments[0] instanceof on) {
            const t = arguments[0];
            return this.isPointContainedInBoundary(t.getCoordinate())
        } else if (arguments[0] instanceof F) {
            const t = arguments[0];
            return t.x === this._rectEnv.getMinX() || t.x === this._rectEnv.getMaxX() || t.y === this._rectEnv.getMinY() || t.y === this._rectEnv.getMaxY()
        }
    }

    contains(t) {
        return !(!this._rectEnv.contains(t.getEnvelopeInternal()) || this.isContainedInBoundary(t))
    }
}

class O_ {
    constructor() {
        O_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._li = new Gn, this._rectEnv = null, this._diagUp0 = null, this._diagUp1 = null, this._diagDown0 = null, this._diagDown1 = null;
        const t = arguments[0];
        this._rectEnv = t, this._diagUp0 = new F(t.getMinX(), t.getMinY()), this._diagUp1 = new F(t.getMaxX(), t.getMaxY()), this._diagDown0 = new F(t.getMinX(), t.getMaxY()), this._diagDown1 = new F(t.getMaxX(), t.getMinY())
    }

    intersects(t, e) {
        const n = new Kt(t, e);
        if (!this._rectEnv.intersects(n)) return !1;
        if (this._rectEnv.intersects(t) || this._rectEnv.intersects(e)) return !0;
        if (t.compareTo(e) > 0) {
            const r = t;
            t = e, e = r
        }
        let s = !1;
        return e.y > t.y && (s = !0), s ? this._li.computeIntersection(t, e, this._diagDown0, this._diagDown1) : this._li.computeIntersection(t, e, this._diagUp0, this._diagUp1), !!this._li.hasIntersection()
    }
}

class rh {
    constructor() {
        rh.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._rectangle = null, this._rectEnv = null;
        const t = arguments[0];
        this._rectangle = t, this._rectEnv = t.getEnvelopeInternal()
    }

    static intersects(t, e) {
        return new rh(t).intersects(e)
    }

    intersects(t) {
        if (!this._rectEnv.intersects(t.getEnvelopeInternal())) return !1;
        const e = new D_(this._rectEnv);
        if (e.applyTo(t), e.intersects()) return !0;
        const n = new F_(this._rectangle);
        if (n.applyTo(t), n.containsPoint()) return !0;
        const s = new z_(this._rectangle);
        return s.applyTo(t), !!s.intersects()
    }
}

class D_ extends Lh {
    constructor() {
        super(), D_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._rectEnv = null, this._intersects = !1;
        const t = arguments[0];
        this._rectEnv = t
    }

    isDone() {
        return this._intersects === !0
    }

    visit(t) {
        const e = t.getEnvelopeInternal();
        if (!this._rectEnv.intersects(e)) return null;
        if (this._rectEnv.contains(e)) return this._intersects = !0, null;
        if (e.getMinX() >= this._rectEnv.getMinX() && e.getMaxX() <= this._rectEnv.getMaxX()) return this._intersects = !0, null;
        if (e.getMinY() >= this._rectEnv.getMinY() && e.getMaxY() <= this._rectEnv.getMaxY()) return this._intersects = !0, null
    }

    intersects() {
        return this._intersects
    }
}

class F_ extends Lh {
    constructor() {
        super(), F_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._rectSeq = null, this._rectEnv = null, this._containsPoint = !1;
        const t = arguments[0];
        this._rectSeq = t.getExteriorRing().getCoordinateSequence(), this._rectEnv = t.getEnvelopeInternal()
    }

    isDone() {
        return this._containsPoint === !0
    }

    visit(t) {
        if (!(t instanceof $e)) return null;
        const e = t.getEnvelopeInternal();
        if (!this._rectEnv.intersects(e)) return null;
        const n = new F;
        for (let s = 0; s < 4; s++) if (this._rectSeq.getCoordinate(s, n), !!e.contains(n) && $s.containsPointInPolygon(n, t)) return this._containsPoint = !0, null
    }

    containsPoint() {
        return this._containsPoint
    }
}

class z_ extends Lh {
    constructor() {
        super(), z_.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._rectEnv = null, this._rectIntersector = null, this._hasIntersection = !1, this._p0 = new F, this._p1 = new F;
        const t = arguments[0];
        this._rectEnv = t.getEnvelopeInternal(), this._rectIntersector = new O_(this._rectEnv)
    }

    intersects() {
        return this._hasIntersection
    }

    isDone() {
        return this._hasIntersection === !0
    }

    visit(t) {
        const e = t.getEnvelopeInternal();
        if (!this._rectEnv.intersects(e)) return null;
        const n = ls.getLines(t);
        this.checkIntersectionWithLineStrings(n)
    }

    checkIntersectionWithLineStrings(t) {
        for (let e = t.iterator(); e.hasNext();) {
            const n = e.next();
            if (this.checkIntersectionWithSegments(n), this._hasIntersection) return null
        }
    }

    checkIntersectionWithSegments(t) {
        const e = t.getCoordinateSequence();
        for (let n = 1; n < e.size(); n++) if (e.getCoordinate(n - 1, this._p0), e.getCoordinate(n, this._p1), this._rectIntersector.intersects(this._p0, this._p1)) return this._hasIntersection = !0, null
    }
}

class Le extends zr {
    constructor() {
        super(), Le.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._relate = null, arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            zr.constructor_.call(this, t, e), this._relate = new Ld(this._arg)
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            zr.constructor_.call(this, t, e, n), this._relate = new Ld(this._arg)
        }
    }

    static covers(t, e) {
        return e.getDimension() === 2 && t.getDimension() < 2 || e.getDimension() === 1 && t.getDimension() < 1 && e.getLength() > 0 || !t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) ? !1 : t.isRectangle() ? !0 : new Le(t, e).getIntersectionMatrix().isCovers()
    }

    static intersects(t, e) {
        if (!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())) return !1;
        if (t.isRectangle()) return rh.intersects(t, e);
        if (e.isRectangle()) return rh.intersects(e, t);
        if (t.isGeometryCollection() || e.isGeometryCollection()) {
            for (let n = 0; n < t.getNumGeometries(); n++) for (let s = 0; s < e.getNumGeometries(); s++) if (t.getGeometryN(n).intersects(e.getGeometryN(s))) return !0;
            return !1
        }
        return new Le(t, e).getIntersectionMatrix().isIntersects()
    }

    static touches(t, e) {
        return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) ? new Le(t, e).getIntersectionMatrix().isTouches(t.getDimension(), e.getDimension()) : !1
    }

    static equalsTopo(t, e) {
        return t.getEnvelopeInternal().equals(e.getEnvelopeInternal()) ? Le.relate(t, e).isEquals(t.getDimension(), e.getDimension()) : !1
    }

    static relate() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return new Le(t, e).getIntersectionMatrix()
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            return new Le(t, e, n).getIntersectionMatrix()
        }
    }

    static overlaps(t, e) {
        return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) ? new Le(t, e).getIntersectionMatrix().isOverlaps(t.getDimension(), e.getDimension()) : !1
    }

    static crosses(t, e) {
        return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) ? new Le(t, e).getIntersectionMatrix().isCrosses(t.getDimension(), e.getDimension()) : !1
    }

    static contains(t, e) {
        return e.getDimension() === 2 && t.getDimension() < 2 || e.getDimension() === 1 && t.getDimension() < 1 && e.getLength() > 0 || !t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) ? !1 : t.isRectangle() ? Nd.contains(t, e) : new Le(t, e).getIntersectionMatrix().isContains()
    }

    getIntersectionMatrix() {
        return this._relate.computeIM()
    }
}

class Od {
    constructor() {
        Od.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._pointGeom = null, this._otherGeom = null, this._geomFact = null;
        const t = arguments[0], e = arguments[1];
        this._pointGeom = t, this._otherGeom = e, this._geomFact = e.getFactory()
    }

    static union(t, e) {
        return new Od(t, e).union()
    }

    union() {
        const t = new Jo, e = new Ho;
        for (let r = 0; r < this._pointGeom.getNumGeometries(); r++) {
            const a = this._pointGeom.getGeometryN(r).getCoordinate();
            t.locate(a, this._otherGeom) === T.EXTERIOR && e.add(a)
        }
        if (e.size() === 0) return this._otherGeom;
        let n = null;
        const s = ze.toCoordinateArray(e);
        return s.length === 1 ? n = this._geomFact.createPoint(s[0]) : n = this._geomFact.createMultiPointFromCoords(s), ri.combine(n, this._otherGeom)
    }
}

class Ka {
    constructor() {
        Ka.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geomFactory = null, this._polygons = new ct, this._lines = new ct, this._points = new ct, this._dimension = rt.FALSE
    }

    static extract() {
        if (At(arguments[0], fn)) {
            const t = arguments[0], e = new Ka;
            return e.add(t), e
        } else if (arguments[0] instanceof it) {
            const t = arguments[0], e = new Ka;
            return e.add(t), e
        }
    }

    getFactory() {
        return this._geomFactory
    }

    recordDimension(t) {
        t > this._dimension && (this._dimension = t)
    }

    getDimension() {
        return this._dimension
    }

    filter(t) {
        if (this.recordDimension(t.getDimension()), t instanceof Ie || t.isEmpty()) return null;
        if (t instanceof $e) return this._polygons.add(t), null;
        if (t instanceof Te) return this._lines.add(t), null;
        if (t instanceof on) return this._points.add(t), null;
        $t.shouldNeverReachHere("Unhandled geometry type: " + t.getGeometryType())
    }

    getExtract(t) {
        switch (t) {
            case 0:
                return this._points;
            case 1:
                return this._lines;
            case 2:
                return this._polygons
        }
        return $t.shouldNeverReachHere("Invalid dimension: " + t), null
    }

    isEmpty() {
        return this._polygons.isEmpty() && this._lines.isEmpty() && this._points.isEmpty()
    }

    add() {
        if (At(arguments[0], fn)) {
            const t = arguments[0];
            for (const e of t) this.add(e)
        } else if (arguments[0] instanceof it) {
            const t = arguments[0];
            this._geomFactory === null && (this._geomFactory = t.getFactory()), t.apply(this)
        }
    }

    get interfaces_() {
        return [Jr]
    }
}

class eM {
    static union(t, e) {
        if (t.isEmpty() || e.isEmpty()) {
            if (t.isEmpty() && e.isEmpty()) return Bt.createEmptyResult(Bt.UNION, t, e, t.getFactory());
            if (t.isEmpty()) return e.copy();
            if (e.isEmpty()) return t.copy()
        }
        return it.checkNotGeometryCollection(t), it.checkNotGeometryCollection(e), Ns.overlayOp(t, e, Bt.UNION)
    }
}

class Rs {
    constructor() {
        Rs.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._geomFactory = null, this._g0 = null, this._g1 = null, this._isUnionSafe = null;
        const t = arguments[0], e = arguments[1];
        this._g0 = t, this._g1 = e, this._geomFactory = t.getFactory()
    }

    static containsProperly() {
        if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return t.isNull() ? !1 : e.getX() > t.getMinX() && e.getX() < t.getMaxX() && e.getY() > t.getMinY() && e.getY() < t.getMaxY()
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            return Rs.containsProperly(t, e) && Rs.containsProperly(t, n)
        }
    }

    static union(t, e) {
        return new Rs(t, e).union()
    }

    static intersects(t, e, n) {
        return t.intersects(e) || t.intersects(n)
    }

    static overlapEnvelope(t, e) {
        const n = t.getEnvelopeInternal(), s = e.getEnvelopeInternal();
        return n.intersection(s)
    }

    static extractBorderSegments(t, e, n) {
        t.apply(new class {
            get interfaces_() {
                return [Nl]
            }

            filter(s, r) {
                if (r <= 0) return null;
                const o = s.getCoordinate(r - 1), a = s.getCoordinate(r);
                if (Rs.intersects(e, o, a) && !Rs.containsProperly(e, o, a)) {
                    const c = new Re(o, a);
                    n.add(c)
                }
            }

            isDone() {
                return !1
            }

            isGeometryChanged() {
                return !1
            }
        })
    }

    static unionBuffer(t, e) {
        return t.getFactory().createGeometryCollection([t, e]).buffer(0)
    }

    isBorderSegmentsSame(t, e) {
        const n = this.extractBorderSegments(this._g0, this._g1, e), s = new ct;
        return Rs.extractBorderSegments(t, e, s), this.isEqual(n, s)
    }

    extractByEnvelope(t, e, n) {
        const s = new ct;
        for (let r = 0; r < e.getNumGeometries(); r++) {
            const o = e.getGeometryN(r);
            if (o.getEnvelopeInternal().intersects(t)) s.add(o); else {
                const a = o.copy();
                n.add(a)
            }
        }
        return this._geomFactory.buildGeometry(s)
    }

    isEqual(t, e) {
        if (t.size() !== e.size()) return !1;
        const n = new Rh(t);
        for (const s of e) if (!n.contains(s)) return !1;
        return !0
    }

    union() {
        const t = Rs.overlapEnvelope(this._g0, this._g1);
        if (t.isNull()) {
            const a = this._g0.copy(), l = this._g1.copy();
            return ri.combine(a, l)
        }
        const e = new ct, n = this.extractByEnvelope(t, this._g0, e), s = this.extractByEnvelope(t, this._g1, e),
            r = this.unionFull(n, s);
        let o = null;
        return this._isUnionSafe = this.isBorderSegmentsSame(r, t), this._isUnionSafe ? o = this.combine(r, e) : o = this.unionFull(this._g0, this._g1), o
    }

    combine(t, e) {
        return e.size() <= 0 ? t : (e.add(t), ri.combine(e))
    }

    unionFull(t, e) {
        try {
            return eM.union(t, e)
        } catch (n) {
            if (n instanceof Us) return Rs.unionBuffer(t, e);
            throw n
        } finally {
        }
    }

    extractBorderSegments(t, e, n) {
        const s = new ct;
        return Rs.extractBorderSegments(t, n, s), e !== null && Rs.extractBorderSegments(e, n, s), s
    }

    isUnionOptimized() {
        return this._isUnionSafe
    }
}

class Si {
    constructor() {
        Si.constructor_.apply(this, arguments)
    }

    static constructor_() {
        this._inputPolys = null, this._geomFactory = null;
        const t = arguments[0];
        this._inputPolys = t, this._inputPolys === null && (this._inputPolys = new ct)
    }

    static restrictToPolygons(t) {
        if (At(t, Ko)) return t;
        const e = $a.getPolygons(t);
        return e.size() === 1 ? e.get(0) : t.getFactory().createMultiPolygon(hn.toPolygonArray(e))
    }

    static getGeometry(t, e) {
        return e >= t.size() ? null : t.get(e)
    }

    static union(t) {
        return new Si(t).union()
    }

    reduceToGeometries(t) {
        const e = new ct;
        for (let n = t.iterator(); n.hasNext();) {
            const s = n.next();
            let r = null;
            At(s, Bs) ? r = this.unionTree(s) : s instanceof it && (r = s), e.add(r)
        }
        return e
    }

    union() {
        if (this._inputPolys === null) throw new qr("union() method cannot be called twice");
        if (this._inputPolys.isEmpty()) return null;
        this._geomFactory = this._inputPolys.iterator().next().getFactory();
        const t = new nn(Si.STRTREE_NODE_CAPACITY);
        for (let s = this._inputPolys.iterator(); s.hasNext();) {
            const r = s.next();
            t.insert(r.getEnvelopeInternal(), r)
        }
        this._inputPolys = null;
        const e = t.itemsTree();
        return this.unionTree(e)
    }

    binaryUnion() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return this.binaryUnion(t, 0, t.size())
        } else if (arguments.length === 3) {
            const t = arguments[0], e = arguments[1], n = arguments[2];
            if (n - e <= 1) {
                const s = Si.getGeometry(t, e);
                return this.unionSafe(s, null)
            } else {
                if (n - e === 2) return this.unionSafe(Si.getGeometry(t, e), Si.getGeometry(t, e + 1));
                {
                    const s = Math.trunc((n + e) / 2), r = this.binaryUnion(t, e, s), o = this.binaryUnion(t, s, n);
                    return this.unionSafe(r, o)
                }
            }
        }
    }

    repeatedUnion(t) {
        let e = null;
        for (let n = t.iterator(); n.hasNext();) {
            const s = n.next();
            e === null ? e = s.copy() : e = e.union(s)
        }
        return e
    }

    unionSafe(t, e) {
        return t === null && e === null ? null : t === null ? e.copy() : e === null ? t.copy() : this.unionActual(t, e)
    }

    unionActual(t, e) {
        const n = Rs.union(t, e);
        return Si.restrictToPolygons(n)
    }

    unionTree(t) {
        const e = this.reduceToGeometries(t);
        return this.binaryUnion(e)
    }

    bufferUnion() {
        if (arguments.length === 1) {
            const t = arguments[0];
            return t.get(0).getFactory().buildGeometry(t).buffer(0)
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return t.getFactory().createGeometryCollection([t, e]).buffer(0)
        }
    }
}

Si.STRTREE_NODE_CAPACITY = 4;

class za {
    constructor() {
        za.constructor_.apply(this, arguments)
    }

    static constructor_() {
        if (this._geomFact = null, this._extracter = null, arguments.length === 1) {
            if (At(arguments[0], fn)) {
                const t = arguments[0];
                this.extract(t)
            } else if (arguments[0] instanceof it) {
                const t = arguments[0];
                this.extract(t)
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            this._geomFact = e, this.extract(t)
        }
    }

    static union() {
        if (arguments.length === 1) {
            if (At(arguments[0], fn)) {
                const t = arguments[0];
                return new za(t).union()
            } else if (arguments[0] instanceof it) {
                const t = arguments[0];
                return new za(t).union()
            }
        } else if (arguments.length === 2) {
            const t = arguments[0], e = arguments[1];
            return new za(t, e).union()
        }
    }

    unionNoOpt(t) {
        const e = this._geomFact.createPoint();
        return Ns.overlayOp(t, e, Bt.UNION)
    }

    unionWithNull(t, e) {
        return t === null && e === null ? null : e === null ? t : t === null ? e : Bt.union(t, e)
    }

    extract() {
        if (At(arguments[0], fn)) {
            const t = arguments[0];
            this._extracter = Ka.extract(t)
        } else if (arguments[0] instanceof it) {
            const t = arguments[0];
            this._extracter = Ka.extract(t)
        }
    }

    union() {
        if (this._geomFact === null && (this._geomFact = this._extracter.getFactory()), this._geomFact === null) return null;
        if (this._extracter.isEmpty()) return this._geomFact.createEmpty(this._extracter.getDimension());
        const t = this._extracter.getExtract(0), e = this._extracter.getExtract(1), n = this._extracter.getExtract(2);
        let s = null;
        if (t.size() > 0) {
            const c = this._geomFact.buildGeometry(t);
            s = this.unionNoOpt(c)
        }
        let r = null;
        if (e.size() > 0) {
            const c = this._geomFact.buildGeometry(e);
            r = this.unionNoOpt(c)
        }
        let o = null;
        n.size() > 0 && (o = Si.union(n));
        const a = this.unionWithNull(r, o);
        let l = null;
        return s === null ? l = a : a === null ? l = s : l = Od.union(s, a), l === null ? this._geomFact.createGeometryCollection() : l
    }
}

Te.prototype.getBoundary = function () {
    return Co.getBoundary(this)
};
Ks.prototype.getBoundary = function () {
    return Co.getBoundary(this)
};
it.prototype.equalsTopo = function (i) {
    return Le.equalsTopo(this, i)
};
it.prototype.equals = function (i) {
    return i === null ? !1 : Le.equalsTopo(this, i)
};
it.prototype.union = function () {
    if (arguments.length === 0) return za.union(this);
    if (arguments.length === 1) {
        const i = arguments[0];
        return eM.union(this, i)
    }
};
it.prototype.isValid = function () {
    return Ei.isValid(this)
};
it.prototype.intersection = function (i) {
    return Bt.intersection(this, i)
};
it.prototype.covers = function (i) {
    return Le.covers(this, i)
};
it.prototype.coveredBy = function (i) {
    return Le.covers(i, this)
};
it.prototype.touches = function (i) {
    return Le.touches(this, i)
};
it.prototype.intersects = function (i) {
    return Le.intersects(this, i)
};
it.prototype.within = function (i) {
    return Le.contains(i, this)
};
it.prototype.overlaps = function (i) {
    return Le.overlaps(this, i)
};
it.prototype.disjoint = function (i) {
    return Le.disjoint(this, i)
};
it.prototype.crosses = function (i) {
    return Le.crosses(this, i)
};
it.prototype.buffer = function () {
    if (arguments.length === 1) {
        const i = arguments[0];
        return Nn.bufferOp(this, i)
    } else if (arguments.length === 2) {
        const i = arguments[0], t = arguments[1];
        return Nn.bufferOp(this, i, t)
    } else if (arguments.length === 3) {
        const i = arguments[0], t = arguments[1], e = arguments[2];
        return Nn.bufferOp(this, i, t, e)
    }
};
it.prototype.convexHull = function () {
    return new Ya(this).getConvexHull()
};
it.prototype.relate = function () {
    if (arguments.length === 1) {
        const i = arguments[0];
        return Le.relate(this, i)
    } else if (arguments.length === 2) {
        const i = arguments[0], t = arguments[1];
        return Le.relate(this, i).matches(t)
    }
};
it.prototype.getCentroid = function () {
    if (this.isEmpty()) return this._factory.createPoint();
    const i = Nr.getCentroid(this);
    return this.createPointFromInternalCoord(i, this)
};
it.prototype.getInteriorPoint = function () {
    if (this.isEmpty()) return this._factory.createPoint();
    let i = null;
    const t = this.getDimension();
    t === 0 ? i = new vd(this) : t === 1 ? i = new xd(this) : i = new ki(this);
    const e = i.getInteriorPoint();
    return this.createPointFromInternalCoord(e, this)
};
it.prototype.symDifference = function (i) {
    return Bt.symDifference(this, i)
};
it.prototype.createPointFromInternalCoord = function (i, t) {
    return t.getPrecisionModel().makePrecise(i), t.getFactory().createPoint(i)
};
it.prototype.toText = function () {
    return new Bi().write(this)
};
it.prototype.toString = function () {
    this.toText()
};
it.prototype.contains = function (i) {
    return Le.contains(this, i)
};
it.prototype.difference = function (i) {
    return Bt.difference(this, i)
};
it.prototype.isSimple = function () {
    return new Xa(this).isSimple()
};
it.prototype.isWithinDistance = function (i, t) {
    return this.getEnvelopeInternal().distance(i.getEnvelopeInternal()) > t ? !1 : Ii.isWithinDistance(this, i, t)
};
it.prototype.distance = function (i) {
    return Ii.distance(this, i)
};

class as {
    constructor(t, e) {
        z(this, "scaleToMeter", 1);
        z(this, "name");
        z(this, "unit");
        z(this, "sourceUri", null);
        z(this, "gisProperties", null);
        z(this, "grids");
        z(this, "walls");
        z(this, "spaces");
        z(this, "openings");
        z(this, "pois");
        z(this, "columns");
        z(this, "topologyNodes");
        z(this, "libraryModels");
        z(this, "floors");
        z(this, "topologyLinks");
        z(this, "groups");
        z(this, "materials");
        z(this, "useWallOutline", !1);
        switch (this.name = t, this.unit = e, this.unit) {
            case"mm":
                this.scaleToMeter = .001;
                break;
            case"cm":
                this.scaleToMeter = .01;
                break;
            case"m":
                this.scaleToMeter = 1;
                break
        }
        this.grids = new Map, this.walls = new Map, this.spaces = new Map, this.openings = new Map, this.pois = new Map, this.columns = new Map, this.topologyNodes = new Map, this.libraryModels = new Map, this.floors = new Map, this.topologyLinks = new Map, this.groups = new Map, this.materials = new Map
    }

    * getFloors(t = () => !0, e = !1) {
        for (const [, n] of this.floors) if (t(n) === !0 && (yield n, e === !0)) break
    }

    * getSpaces(t = () => !0, e = !1) {
        for (const [, n] of this.spaces) if (t(n) === !0 && (yield n, e === !0)) break
    }

    * getPois(t = () => !0, e = !1) {
        for (const [, n] of this.pois) if (t(n) === !0 && (yield n, e === !0)) break
    }

    * getTopologyNodes(t = () => !0, e = !1) {
        for (let [, n] of this.topologyNodes) if (t(n) === !0 && (yield n, e === !0)) break
    }

    * getTopologyLinks(t = () => !0, e = !1) {
        for (let [, n] of this.topologyLinks) if (t(n) === !0 && (yield n, e === !0)) break
    }

    cutOutSpacePolygons() {
    }

    dispose() {
        this.grids.clear(), this.walls.clear(), this.spaces.clear(), this.openings.clear(), this.pois.clear(), this.columns.clear(), this.topologyNodes.clear(), this.libraryModels.clear(), this.groups.clear(), this.topologyLinks.clear(), this.floors.forEach(t => t.dispose()), this.floors.clear()
    }
}

z(as, "GeomFactory", new hn);
const Iz = 1e5, Az = 1e-5, Cz = 1e-13, Pz = Math.PI * 2;
var me = {EPS: Az, NEPS: Cz, TAU: Pz, spatialResolution: Iz};
const Rz = () => [0, 1, 0];
var B_ = Rz;
const Lz = B_, Nz = i => {
    const t = Lz();
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t
};
var Oz = Nz;
const Dz = (i, t) => (i[0] = Math.abs(t[0]), i[1] = Math.abs(t[1]), i);
var Fz = Dz;
const zz = (i, t, e) => (i[0] = t[0] + e[0], i[1] = t[1] + e[1], i);
var Bz = zz;
const kz = i => Math.atan2(i[1], i[0]);
var k_ = kz, Uz = k_;
const Gz = k_, Vz = i => Gz(i) * 57.29577951308232;
var Hz = Vz;
const $z = () => [0, 0];
var Wf = $z;
const Wz = Wf, qz = i => {
    const t = Wz();
    return t[0] = i[0], t[1] = i[1], t
};
var Yz = qz;
const Xz = (i, t) => (i[0] = t[0], i[1] = t[1], i);
var Zz = Xz;
const jz = (i, t, e) => (i[0] = 0, i[1] = 0, i[2] = t[0] * e[1] - t[1] * e[0], i);
var Kz = jz;
const Jz = (i, t) => {
    const e = t[0] - i[0], n = t[1] - i[1];
    return Math.sqrt(e * e + n * n)
};
var Qz = Jz;
const tB = (i, t, e) => (i[0] = t[0] / e[0], i[1] = t[1] / e[1], i);
var eB = tB;
const nB = (i, t) => i[0] * t[0] + i[1] * t[1];
var sB = nB;
const iB = (i, t) => i[0] === t[0] && i[1] === t[1];
var rB = iB;
const {NEPS: oB} = me, nM = i => Math.abs(i) < oB ? 0 : i, aB = i => nM(Math.sin(i)), lB = i => nM(Math.cos(i));
var Vn = {sin: aB, cos: lB};
const {sin: cB, cos: hB} = Vn, uB = (i, t) => (i[0] = hB(t), i[1] = cB(t), i);
var sM = uB;
const dB = sM, fB = (i, t) => dB(i, t * .017453292519943295);
var pB = fB;
const gB = (i, t) => (i[0] = t, i[1] = t, i);
var mB = gB;
const _B = Wf, yB = (i, t) => {
    const e = _B();
    return e[0] = i, e[1] = t, e
};
var xB = yB;
const vB = i => Math.sqrt(i[0] * i[0] + i[1] * i[1]);
var wB = vB;
const bB = (i, t, e, n) => {
    const s = t[0], r = t[1];
    return i[0] = s + n * (e[0] - s), i[1] = r + n * (e[1] - r), i
};
var EB = bB;
const SB = (i, t, e) => (i[0] = Math.max(t[0], e[0]), i[1] = Math.max(t[1], e[1]), i);
var MB = SB;
const TB = (i, t, e) => (i[0] = Math.min(t[0], e[0]), i[1] = Math.min(t[1], e[1]), i);
var IB = TB;
const AB = (i, t, e) => (i[0] = t[0] * e[0], i[1] = t[1] * e[1], i);
var CB = AB;
const PB = (i, t) => (i[0] = -t[0], i[1] = -t[1], i);
var RB = PB;
const LB = (i, t, e, n) => {
    const s = t[0] - e[0], r = t[1] - e[1], o = Math.cos(n), a = Math.sin(n);
    return i[0] = s * o - r * a + e[0], i[1] = s * a + r * o + e[1], i
};
var iM = LB;
const {TAU: NB} = me, OB = Wf, DB = iM, FB = (i, t) => DB(i, t, OB(), NB / 4);
var zB = FB;
const BB = (i, t) => {
    const e = t[0], n = t[1];
    let s = e * e + n * n;
    return s > 0 && (s = 1 / Math.sqrt(s)), i[0] = e * s, i[1] = n * s, i
};
var kB = BB;
const UB = (i, t, e) => (i[0] = t[0] * e, i[1] = t[1] * e, i);
var GB = UB;
const VB = (i, t, e) => (i[0] = Math.round(t[0] / e) * e + 0, i[1] = Math.round(t[1] / e) * e + 0, i);
var HB = VB;
const $B = (i, t) => {
    const e = t[0] - i[0], n = t[1] - i[1];
    return e * e + n * n
};
var WB = $B;
const qB = i => {
    const t = i[0], e = i[1];
    return t * t + e * e
};
var YB = qB;
const XB = (i, t, e) => (i[0] = t[0] - e[0], i[1] = t[1] - e[1], i);
var ZB = XB;
const jB = i => `[${i[0].toFixed(7)}, ${i[1].toFixed(7)}]`;
var KB = jB;
const JB = (i, t, e) => {
    const n = t[0], s = t[1];
    return i[0] = e[0] * n + e[4] * s + e[12], i[1] = e[1] * n + e[5] * s + e[13], i
};
var QB = JB, te = {
    abs: Fz,
    add: Bz,
    angle: Uz,
    angleDegrees: Hz,
    angleRadians: k_,
    clone: Yz,
    copy: Zz,
    create: Wf,
    cross: Kz,
    distance: Qz,
    divide: eB,
    dot: sB,
    equals: rB,
    fromAngleDegrees: pB,
    fromAngleRadians: sM,
    fromScalar: mB,
    fromValues: xB,
    length: wB,
    lerp: EB,
    max: MB,
    min: IB,
    multiply: CB,
    negate: RB,
    normal: zB,
    normalize: kB,
    rotate: iM,
    scale: GB,
    snap: HB,
    squaredDistance: WB,
    squaredLength: YB,
    subtract: ZB,
    toString: KB,
    transform: QB
};
const eg = te, tk = i => {
    const t = eg.normal(eg.create(), i);
    return eg.negate(t, t), t
};
var U_ = tk;
const P1 = te, ek = i => P1.scale(P1.create(), i, i[2]);
var qf = ek;
const nk = te, sk = U_, ik = qf, rk = (i, t) => {
    const e = ik(i), n = sk(i), s = (n[1] - e[1]) / (n[0] - e[0]), r = e[1] - s * e[0], o = -1 / s,
        l = (t[1] - o * t[0] - r) / (s - o), c = s * l + r;
    return nk.fromValues(l, c)
};
var ok = rk;
const ak = (i, t) => (i[0] = t[0], i[1] = t[1], i[2] = t[2], i);
var rM = ak;
const lk = te, ck = (i, t) => {
    let e = lk.dot(t, i);
    return e = Math.abs(e - i[2]), e
};
var hk = ck;
const uk = (i, t) => i[0] === t[0] && i[1] === t[1] && i[2] === t[2];
var dk = uk;
const nc = te, fk = (i, t, e) => {
    const n = nc.subtract(nc.create(), e, t);
    nc.normal(n, n), nc.normalize(n, n);
    const s = nc.dot(t, n);
    return i[0] = n[0], i[1] = n[1], i[2] = s, i
};
var oM = fk;
const pk = B_, gk = (i, t, e) => {
    const n = pk();
    return n[0] = i, n[1] = t, n[2] = e, n
};
var aM = gk;
const {NEPS: ng} = me,
    mk = (i, t) => Math.abs(i[0] - t[0]) <= ng && Math.abs(i[1] - t[1]) <= ng && Math.abs(i[2] - t[2]) <= ng;
var G_ = mk;
const _k = i => {
    let t = 0;
    for (let e = 0; e < i.length; e++) {
        const n = (e + 1) % i.length;
        t += i[e][0] * i[n][1], t -= i[n][0] * i[e][1]
    }
    return t / 2
};
var Yf = _k;
const yk = (i, t, e) => {
    let n = e - i[1], s = t[1] - i[1];
    s < 0 && (n = -n, s = -s);
    let r;
    return n <= 0 ? r = 0 : n >= s ? r = 1 : s < 1e-10 ? r = .5 : r = n / s, i[0] + r * (t[0] - i[0])
};
var lM = yk;
const xk = (i, t, e, n) => {
    if (i[0] === t[0] && i[1] === t[1] || e[0] === n[0] && e[1] === n[1]) return;
    const s = (n[1] - e[1]) * (t[0] - i[0]) - (n[0] - e[0]) * (t[1] - i[1]);
    if (Math.abs(s) < Number.MIN_VALUE) return;
    const r = ((n[0] - e[0]) * (i[1] - e[1]) - (n[1] - e[1]) * (i[0] - e[0])) / s,
        o = ((t[0] - i[0]) * (i[1] - e[1]) - (t[1] - i[1]) * (i[0] - e[0])) / s;
    if (r < 0 || r > 1 || o < 0 || o > 1) return;
    const a = i[0] + r * (t[0] - i[0]), l = i[1] + r * (t[1] - i[1]);
    return [a, l]
};
var cM = xk;
const vk = (i, t, e, n, s, r) => {
    const a = 1 / (i * n - t * e);
    let l = s * n - t * r, c = -s * e + i * r;
    return l *= a, c *= a, [l, c]
};
var wk = vk, Oh = {
    aboutEqualNormals: G_,
    area: Yf,
    cos: Vn.cos,
    interpolateBetween2DPointsForY: lM,
    intersect: cM,
    sin: Vn.sin,
    solve2Linear: wk
};
const bk = te, {solve2Linear: Ek} = Oh, Sk = (i, t) => {
    const e = Ek(i[0], i[1], t[0], t[1], i[2], t[2]);
    return bk.clone(e)
};
var Mk = Sk;
const R1 = te, Tk = rM, Ik = aM, Ak = (i, t) => {
    const e = R1.negate(R1.create(), t), n = -t[2];
    return Tk(i, Ik(e[0], e[1], n))
};
var Ck = Ak;
const Pk = i => `line2: (${i[0].toFixed(7)}, ${i[1].toFixed(7)}, ${i[2].toFixed(7)})`;
var Rk = Pk;
const L1 = te, Lk = oM, Nk = qf, Ok = U_, Dk = (i, t, e) => {
    const n = Nk(t), s = Ok(t);
    return L1.transform(n, n, e), L1.transform(s, s, e), Lk(i, n, s)
};
var Fk = Dk;
const zk = qf, Bk = (i, t) => {
    let e = (i[2] - i[1] * t) / i[0];
    return Number.isNaN(e) && (e = zk(i)[0]), e
};
var kk = Bk, V_ = {
    clone: Oz,
    closestPoint: ok,
    copy: rM,
    create: B_,
    direction: U_,
    distanceToPoint: hk,
    equals: dk,
    fromPoints: oM,
    fromValues: aM,
    intersectPointOfLines: Mk,
    origin: qf,
    reverse: Ck,
    toString: Rk,
    transform: Fk,
    xAtY: kk
};
const Uk = (i, t) => (i[0] = Math.abs(t[0]), i[1] = Math.abs(t[1]), i[2] = Math.abs(t[2]), i);
var hM = Uk;
const Gk = (i, t, e) => (i[0] = t[0] + e[0], i[1] = t[1] + e[1], i[2] = t[2] + e[2], i);
var Vk = Gk;
const Hk = (i, t) => i[0] * t[0] + i[1] * t[1] + i[2] * t[2];
var uM = Hk;
const $k = uM, Wk = (i, t) => {
    const e = i[0], n = i[1], s = i[2], r = t[0], o = t[1], a = t[2], l = Math.sqrt(e * e + n * n + s * s),
        c = Math.sqrt(r * r + o * o + a * a), h = l * c, u = h && $k(i, t) / h;
    return Math.acos(Math.min(Math.max(u, -1), 1))
};
var qk = Wk;
const Yk = () => [0, 0, 0];
var Xf = Yk;
const Xk = Xf, Zk = i => {
    const t = Xk();
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t
};
var jk = Zk;
const Kk = (i, t) => (i[0] = t[0], i[1] = t[1], i[2] = t[2], i);
var Jk = Kk;
const Qk = (i, t, e) => {
    const n = t[0], s = t[1], r = t[2], o = e[0], a = e[1], l = e[2];
    return i[0] = s * l - r * a, i[1] = r * o - n * l, i[2] = n * a - s * o, i
};
var dM = Qk;
const tU = (i, t) => {
    const e = t[0] - i[0], n = t[1] - i[1], s = t[2] - i[2];
    return Math.sqrt(e * e + n * n + s * s)
};
var eU = tU;
const nU = (i, t, e) => (i[0] = t[0] / e[0], i[1] = t[1] / e[1], i[2] = t[2] / e[2], i);
var sU = nU;
const iU = (i, t) => i[0] === t[0] && i[1] === t[1] && i[2] === t[2];
var rU = iU;
const oU = (i, t) => (i[0] = t, i[1] = t, i[2] = t, i);
var aU = oU;
const lU = Xf, cU = (i, t, e) => {
    const n = lU();
    return n[0] = i, n[1] = t, n[2] = e, n
};
var hU = cU;
const uU = (i, t, e = 0) => (i[0] = t[0], i[1] = t[1], i[2] = e, i);
var dU = uU;
const fU = i => {
    const t = i[0], e = i[1], n = i[2];
    return Math.sqrt(t * t + e * e + n * n)
};
var pU = fU;
const gU = (i, t, e, n) => (i[0] = t[0] + n * (e[0] - t[0]), i[1] = t[1] + n * (e[1] - t[1]), i[2] = t[2] + n * (e[2] - t[2]), i);
var mU = gU;
const _U = (i, t, e) => (i[0] = Math.max(t[0], e[0]), i[1] = Math.max(t[1], e[1]), i[2] = Math.max(t[2], e[2]), i);
var fM = _U;
const yU = (i, t, e) => (i[0] = Math.min(t[0], e[0]), i[1] = Math.min(t[1], e[1]), i[2] = Math.min(t[2], e[2]), i);
var pM = yU;
const xU = (i, t, e) => (i[0] = t[0] * e[0], i[1] = t[1] * e[1], i[2] = t[2] * e[2], i);
var vU = xU;
const wU = (i, t) => (i[0] = -t[0], i[1] = -t[1], i[2] = -t[2], i);
var bU = wU;
const EU = (i, t) => {
    const e = t[0], n = t[1], s = t[2];
    let r = e * e + n * n + s * s;
    return r > 0 && (r = 1 / Math.sqrt(r)), i[0] = e * r, i[1] = n * r, i[2] = s * r, i
};
var SU = EU;
const MU = hM, TU = Xf, IU = dM, AU = (i, t) => {
    const e = MU(TU(), t), n = 0 + (e[0] < e[1] && e[0] < e[2]), s = 0 + (e[1] <= e[0] && e[1] < e[2]),
        r = 0 + (e[2] <= e[0] && e[2] <= e[1]);
    return IU(i, t, [n, s, r])
};
var CU = AU;
const PU = (i, t, e, n) => {
    const s = [], r = [];
    return s[0] = t[0] - e[0], s[1] = t[1] - e[1], s[2] = t[2] - e[2], r[0] = s[0], r[1] = s[1] * Math.cos(n) - s[2] * Math.sin(n), r[2] = s[1] * Math.sin(n) + s[2] * Math.cos(n), i[0] = r[0] + e[0], i[1] = r[1] + e[1], i[2] = r[2] + e[2], i
};
var RU = PU;
const LU = (i, t, e, n) => {
    const s = [], r = [];
    return s[0] = t[0] - e[0], s[1] = t[1] - e[1], s[2] = t[2] - e[2], r[0] = s[2] * Math.sin(n) + s[0] * Math.cos(n), r[1] = s[1], r[2] = s[2] * Math.cos(n) - s[0] * Math.sin(n), i[0] = r[0] + e[0], i[1] = r[1] + e[1], i[2] = r[2] + e[2], i
};
var NU = LU;
const OU = (i, t, e, n) => {
    const s = [], r = [];
    return s[0] = t[0] - e[0], s[1] = t[1] - e[1], r[0] = s[0] * Math.cos(n) - s[1] * Math.sin(n), r[1] = s[0] * Math.sin(n) + s[1] * Math.cos(n), i[0] = r[0] + e[0], i[1] = r[1] + e[1], i[2] = t[2], i
};
var DU = OU;
const FU = (i, t, e) => (i[0] = t[0] * e, i[1] = t[1] * e, i[2] = t[2] * e, i);
var zU = FU;
const BU = (i, t, e) => (i[0] = Math.round(t[0] / e) * e + 0, i[1] = Math.round(t[1] / e) * e + 0, i[2] = Math.round(t[2] / e) * e + 0, i);
var kU = BU;
const UU = (i, t) => {
    const e = t[0] - i[0], n = t[1] - i[1], s = t[2] - i[2];
    return e * e + n * n + s * s
};
var GU = UU;
const VU = i => {
    const t = i[0], e = i[1], n = i[2];
    return t * t + e * e + n * n
};
var HU = VU;
const $U = (i, t, e) => (i[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], i);
var WU = $U;
const qU = i => `[${i[0].toFixed(7)}, ${i[1].toFixed(7)}, ${i[2].toFixed(7)}]`;
var YU = qU;
const XU = (i, t, e) => {
    const n = t[0], s = t[1], r = t[2];
    let o = e[3] * n + e[7] * s + e[11] * r + e[15];
    return o = o || 1, i[0] = (e[0] * n + e[4] * s + e[8] * r + e[12]) / o, i[1] = (e[1] * n + e[5] * s + e[9] * r + e[13]) / o, i[2] = (e[2] * n + e[6] * s + e[10] * r + e[14]) / o, i
};
var ZU = XU, kt = {
    abs: hM,
    add: Vk,
    angle: qk,
    clone: jk,
    copy: Jk,
    create: Xf,
    cross: dM,
    distance: eU,
    divide: sU,
    dot: uM,
    equals: rU,
    fromScalar: aU,
    fromValues: hU,
    fromVec2: dU,
    length: pU,
    lerp: mU,
    max: fM,
    min: pM,
    multiply: vU,
    negate: bU,
    normalize: SU,
    orthogonal: CU,
    rotateX: RU,
    rotateY: NU,
    rotateZ: DU,
    scale: zU,
    snap: kU,
    squaredDistance: GU,
    squaredLength: HU,
    subtract: WU,
    toString: YU,
    transform: ZU
};
const N1 = kt, jU = () => [N1.fromValues(0, 0, 0), N1.fromValues(0, 0, 1)];
var gM = jU;
const O1 = kt, KU = gM, JU = i => {
    const t = KU();
    return O1.copy(t[0], i[0]), O1.copy(t[1], i[1]), t
};
var QU = JU;
const uo = kt, tG = (i, t) => {
    const e = i[0], n = i[1], s = uo.dot(uo.subtract(uo.create(), t, e), n), r = uo.dot(n, n), o = s / r,
        a = uo.scale(uo.create(), n, o);
    return uo.add(a, a, e), a
};
var mM = tG;
const D1 = kt, eG = (i, t) => (D1.copy(i[0], t[0]), D1.copy(i[1], t[1]), i);
var nG = eG;
const sG = i => i[1];
var iG = sG;
const sg = kt, rG = mM, oG = (i, t) => {
    const e = rG(i, t), n = sg.subtract(sg.create(), t, e);
    return sg.length(n)
};
var aG = oG;
const F1 = kt, lG = (i, t) => !(!F1.equals(i[1], t[1]) || !F1.equals(i[0], t[0]));
var cG = lG;
const Cu = kt, hG = (i, t, e) => {
    const n = Cu.normalize(Cu.create(), e);
    return Cu.copy(i[0], t), Cu.copy(i[1], n), i
};
var Dh = hG;
const fo = kt, {solve2Linear: ig} = Oh, {EPS: uG} = me, dG = Dh, fG = (i, t, e) => {
    let n = fo.cross(fo.create(), t, e), s = fo.length(n);
    if (s < uG) throw new Error("parallel planes do not intersect");
    s = 1 / s, n = fo.scale(n, n, s);
    const r = Math.abs(n[0]), o = Math.abs(n[1]), a = Math.abs(n[2]);
    let l, c;
    return r >= o && r >= a ? (c = ig(t[1], t[2], e[1], e[2], t[3], e[3]), l = fo.fromValues(0, c[0], c[1])) : o >= r && o >= a ? (c = ig(t[0], t[2], e[0], e[2], t[3], e[3]), l = fo.fromValues(c[0], 0, c[1])) : (c = ig(t[0], t[1], e[0], e[1], t[3], e[3]), l = fo.fromValues(c[0], c[1], 0)), dG(i, l, n)
};
var pG = fG;
const z1 = kt, gG = Dh, mG = (i, t, e) => {
    const n = z1.subtract(z1.create(), e, t);
    return gG(i, t, n)
};
var _G = mG;
const wa = kt, yG = (i, t) => {
    const e = t, n = t[3], s = i[0], r = i[1], o = (n - wa.dot(e, s)) / wa.dot(e, r);
    return wa.add(wa.create(), s, wa.scale(wa.create(), r, o))
};
var xG = yG;
const vG = i => i[0];
var wG = vG;
const rg = kt, bG = Dh, EG = (i, t) => {
    const e = rg.clone(t[0]), n = rg.negate(rg.create(), t[1]);
    return bG(i, e, n)
};
var SG = EG;
const MG = i => {
    const t = i[0], e = i[1];
    return `line3: point: (${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)}) direction: (${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)})`
};
var TG = MG;
const ba = kt, IG = Dh, AG = (i, t, e) => {
    const n = t[0], s = t[1], r = ba.add(ba.create(), n, s), o = ba.transform(ba.create(), n, e),
        a = ba.transform(r, r, e), l = ba.subtract(a, a, o);
    return IG(i, o, l)
};
var CG = AG, PG = {
    clone: QU,
    closestPoint: mM,
    copy: nG,
    create: gM,
    direction: iG,
    distanceToPoint: aG,
    equals: cG,
    fromPlanes: pG,
    fromPointAndDirection: Dh,
    fromPoints: _G,
    intersectPointOfLineAndPlane: xG,
    origin: wG,
    reverse: SG,
    toString: TG,
    transform: CG
};
const RG = (i, t, e) => (i[0] = t[0] + e[0], i[1] = t[1] + e[1], i[2] = t[2] + e[2], i[3] = t[3] + e[3], i[4] = t[4] + e[4], i[5] = t[5] + e[5], i[6] = t[6] + e[6], i[7] = t[7] + e[7], i[8] = t[8] + e[8], i[9] = t[9] + e[9], i[10] = t[10] + e[10], i[11] = t[11] + e[11], i[12] = t[12] + e[12], i[13] = t[13] + e[13], i[14] = t[14] + e[14], i[15] = t[15] + e[15], i);
var LG = RG;
const NG = () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var H_ = NG;
const OG = H_, DG = i => {
    const t = OG();
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t
};
var FG = DG;
const zG = (i, t) => (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i);
var _M = zG;
const BG = (i, t) => {
    const e = t[0], n = t[1], s = t[2], r = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8], u = t[9], d = t[10],
        f = t[11], g = t[12], m = t[13], p = t[14], _ = t[15], x = e * a - n * o, y = e * l - s * o, v = e * c - r * o,
        w = n * l - s * a, E = n * c - r * a, S = s * c - r * l, b = h * m - u * g, M = h * p - d * g,
        I = h * _ - f * g, N = u * p - d * m, B = u * _ - f * m, D = d * _ - f * p;
    let L = x * D - y * B + v * N + w * I - E * M + S * b;
    return L ? (L = 1 / L, i[0] = (a * D - l * B + c * N) * L, i[1] = (s * B - n * D - r * N) * L, i[2] = (m * S - p * E + _ * w) * L, i[3] = (d * E - u * S - f * w) * L, i[4] = (l * I - o * D - c * M) * L, i[5] = (e * D - s * I + r * M) * L, i[6] = (p * v - g * S - _ * y) * L, i[7] = (h * S - d * v + f * y) * L, i[8] = (o * B - a * I + c * b) * L, i[9] = (n * I - e * B - r * b) * L, i[10] = (g * E - m * v + _ * x) * L, i[11] = (u * v - h * E - f * x) * L, i[12] = (a * M - o * N - l * b) * L, i[13] = (e * N - n * M + s * b) * L, i[14] = (m * y - g * w - p * x) * L, i[15] = (h * w - u * y + d * x) * L, i) : null
};
var kG = BG;
const UG = (i, t) => i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15];
var GG = UG;
const VG = i => (i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i);
var yM = VG;
const {EPS: HG} = me, {sin: $G, cos: WG} = Vn, qG = yM, YG = (i, t, e) => {
    let [n, s, r] = e;
    const o = n * n + s * s + r * r;
    if (Math.abs(o) < HG) return qG(i);
    const a = 1 / Math.sqrt(o);
    n *= a, s *= a, r *= a;
    const l = $G(t), c = WG(t), h = 1 - c;
    return i[0] = n * n * h + c, i[1] = s * n * h + r * l, i[2] = r * n * h - s * l, i[3] = 0, i[4] = n * s * h - r * l, i[5] = s * s * h + c, i[6] = r * s * h + n * l, i[7] = 0, i[8] = n * r * h + s * l, i[9] = s * r * h - n * l, i[10] = r * r * h + c, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
};
var xM = YG;
const XG = (i, t) => (i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i);
var ZG = XG;
const {sin: og, cos: ag} = Vn, jG = (i, t, e, n) => {
    const s = og(t), r = ag(t), o = og(e), a = ag(e), l = og(n), c = ag(n);
    return i[0] = a * r, i[1] = a * s, i[2] = -o, i[3] = 0, i[4] = l * o * r - c * s, i[5] = c * r + l * o * s, i[6] = l * a, i[7] = 0, i[8] = l * s + c * o * r, i[9] = c * o * s - l * r, i[10] = c * a, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
};
var KG = jG;
const JG = (i, t) => (i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = t[0], i[13] = t[1], i[14] = t[2], i[15] = 1, i);
var QG = JG;
const t4 = H_, e4 = (i, t, e, n, s, r, o, a, l, c, h, u, d, f, g, m) => {
    const p = t4();
    return p[0] = i, p[1] = t, p[2] = e, p[3] = n, p[4] = s, p[5] = r, p[6] = o, p[7] = a, p[8] = l, p[9] = c, p[10] = h, p[11] = u, p[12] = d, p[13] = f, p[14] = g, p[15] = m, p
};
var n4 = e4;
const wr = kt, s4 = xM, i4 = (i, t, e) => {
    const n = wr.normalize(wr.create(), t), s = wr.normalize(wr.create(), e), r = wr.cross(wr.create(), s, n),
        o = wr.dot(s, n);
    if (o === -1) return s4(i, Math.PI, wr.orthogonal(r, n));
    const a = 1 / (1 + o);
    return i[0] = r[0] * r[0] * a + o, i[1] = r[1] * r[0] * a - r[2], i[2] = r[2] * r[0] * a + r[1], i[3] = 0, i[4] = r[0] * r[1] * a + r[2], i[5] = r[1] * r[1] * a + o, i[6] = r[2] * r[1] * a - r[0], i[7] = 0, i[8] = r[0] * r[2] * a - r[1], i[9] = r[1] * r[2] * a + r[0], i[10] = r[2] * r[2] * a + o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
};
var r4 = i4;
const {sin: o4, cos: a4} = Vn, l4 = (i, t) => {
    const e = o4(t), n = a4(t);
    return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = n, i[6] = e, i[7] = 0, i[8] = 0, i[9] = -e, i[10] = n, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
};
var c4 = l4;
const {sin: h4, cos: u4} = Vn, d4 = (i, t) => {
    const e = h4(t), n = u4(t);
    return i[0] = n, i[1] = 0, i[2] = -e, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = e, i[9] = 0, i[10] = n, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
};
var f4 = d4;
const {sin: p4, cos: g4} = Vn, m4 = (i, t) => {
    const e = p4(t), n = g4(t);
    return i[0] = n, i[1] = e, i[2] = 0, i[3] = 0, i[4] = -e, i[5] = n, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
};
var _4 = m4;
const y4 = i => i[0] === 1 && i[1] === 0 && i[2] === 0 && i[3] === 0 && i[4] === 0 && i[5] === 1 && i[6] === 0 && i[7] === 0 && i[8] === 0 && i[9] === 0 && i[10] === 1 && i[11] === 0 && i[12] === 0 && i[13] === 0 && i[14] === 0 && i[15] === 1;
var x4 = y4;
const v4 = i => Ji(i[1]) && Ji(i[2]) && Ji(i[3]) && Ji(i[4]) && Ji(i[6]) && Ji(i[7]) && Ji(i[8]) && Ji(i[9]) && Ji(i[11]) && i[15] === 1,
    Ji = i => Math.abs(i) < Number.EPSILON;
var w4 = v4;
const b4 = i => {
    const t = i[4] * i[9] - i[8] * i[5], e = i[8] * i[1] - i[0] * i[9], n = i[0] * i[5] - i[4] * i[1];
    return t * i[2] + e * i[6] + n * i[10] < 0
};
var E4 = b4;
const S4 = (i, t) => {
    const [e, n, s, r] = t;
    return i[0] = 1 - 2 * e * e, i[1] = -2 * n * e, i[2] = -2 * s * e, i[3] = 0, i[4] = -2 * e * n, i[5] = 1 - 2 * n * n, i[6] = -2 * s * n, i[7] = 0, i[8] = -2 * e * s, i[9] = -2 * n * s, i[10] = 1 - 2 * s * s, i[11] = 0, i[12] = 2 * e * r, i[13] = 2 * n * r, i[14] = 2 * s * r, i[15] = 1, i
};
var M4 = S4;
const T4 = (i, t, e) => {
    const n = t[0], s = t[1], r = t[2], o = t[3], a = t[4], l = t[5], c = t[6], h = t[7], u = t[8], d = t[9], f = t[10],
        g = t[11], m = t[12], p = t[13], _ = t[14], x = t[15];
    let y = e[0], v = e[1], w = e[2], E = e[3];
    return i[0] = y * n + v * a + w * u + E * m, i[1] = y * s + v * l + w * d + E * p, i[2] = y * r + v * c + w * f + E * _, i[3] = y * o + v * h + w * g + E * x, y = e[4], v = e[5], w = e[6], E = e[7], i[4] = y * n + v * a + w * u + E * m, i[5] = y * s + v * l + w * d + E * p, i[6] = y * r + v * c + w * f + E * _, i[7] = y * o + v * h + w * g + E * x, y = e[8], v = e[9], w = e[10], E = e[11], i[8] = y * n + v * a + w * u + E * m, i[9] = y * s + v * l + w * d + E * p, i[10] = y * r + v * c + w * f + E * _, i[11] = y * o + v * h + w * g + E * x, y = e[12], v = e[13], w = e[14], E = e[15], i[12] = y * n + v * a + w * u + E * m, i[13] = y * s + v * l + w * d + E * p, i[14] = y * r + v * c + w * f + E * _, i[15] = y * o + v * h + w * g + E * x, i
};
var I4 = T4;
const {EPS: A4} = me, {sin: C4, cos: P4} = Vn, R4 = _M, L4 = (i, t, e, n) => {
    let [s, r, o] = n;
    const a = s * s + r * r + o * o;
    if (Math.abs(a) < A4) return R4(i, t);
    const l = 1 / Math.sqrt(a);
    s *= l, r *= l, o *= l;
    const c = C4(e), h = P4(e), u = 1 - h, d = t[0], f = t[1], g = t[2], m = t[3], p = t[4], _ = t[5], x = t[6],
        y = t[7], v = t[8], w = t[9], E = t[10], S = t[11], b = s * s * u + h, M = r * s * u + o * c,
        I = o * s * u - r * c, N = s * r * u - o * c, B = r * r * u + h, D = o * r * u + s * c, L = s * o * u + r * c,
        k = r * o * u - s * c, G = o * o * u + h;
    return i[0] = d * b + p * M + v * I, i[1] = f * b + _ * M + w * I, i[2] = g * b + x * M + E * I, i[3] = m * b + y * M + S * I, i[4] = d * N + p * B + v * D, i[5] = f * N + _ * B + w * D, i[6] = g * N + x * B + E * D, i[7] = m * N + y * B + S * D, i[8] = d * L + p * k + v * G, i[9] = f * L + _ * k + w * G, i[10] = g * L + x * k + E * G, i[11] = m * L + y * k + S * G, t !== i && (i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i
};
var N4 = L4;
const {sin: O4, cos: D4} = Vn, F4 = (i, t, e) => {
    const n = O4(e), s = D4(e), r = t[4], o = t[5], a = t[6], l = t[7], c = t[8], h = t[9], u = t[10], d = t[11];
    return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = r * s + c * n, i[5] = o * s + h * n, i[6] = a * s + u * n, i[7] = l * s + d * n, i[8] = c * s - r * n, i[9] = h * s - o * n, i[10] = u * s - a * n, i[11] = d * s - l * n, i
};
var z4 = F4;
const {sin: B4, cos: k4} = Vn, U4 = (i, t, e) => {
    const n = B4(e), s = k4(e), r = t[0], o = t[1], a = t[2], l = t[3], c = t[8], h = t[9], u = t[10], d = t[11];
    return t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = r * s - c * n, i[1] = o * s - h * n, i[2] = a * s - u * n, i[3] = l * s - d * n, i[8] = r * n + c * s, i[9] = o * n + h * s, i[10] = a * n + u * s, i[11] = l * n + d * s, i
};
var G4 = U4;
const {sin: V4, cos: H4} = Vn, $4 = (i, t, e) => {
    const n = V4(e), s = H4(e), r = t[0], o = t[1], a = t[2], l = t[3], c = t[4], h = t[5], u = t[6], d = t[7];
    return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = r * s + c * n, i[1] = o * s + h * n, i[2] = a * s + u * n, i[3] = l * s + d * n, i[4] = c * s - r * n, i[5] = h * s - o * n, i[6] = u * s - a * n, i[7] = d * s - l * n, i
};
var W4 = $4;
const q4 = (i, t, e) => {
    const n = e[0], s = e[1], r = e[2];
    return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i[3] = t[3] * n, i[4] = t[4] * s, i[5] = t[5] * s, i[6] = t[6] * s, i[7] = t[7] * s, i[8] = t[8] * r, i[9] = t[9] * r, i[10] = t[10] * r, i[11] = t[11] * r, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
};
var Y4 = q4;
const X4 = (i, t, e) => (i[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], i[3] = t[3] - e[3], i[4] = t[4] - e[4], i[5] = t[5] - e[5], i[6] = t[6] - e[6], i[7] = t[7] - e[7], i[8] = t[8] - e[8], i[9] = t[9] - e[9], i[10] = t[10] - e[10], i[11] = t[11] - e[11], i[12] = t[12] - e[12], i[13] = t[13] - e[13], i[14] = t[14] - e[14], i[15] = t[15] - e[15], i);
var Z4 = X4;
const j4 = i => i.map(t => t.toFixed(7)).toString();
var K4 = j4;
const J4 = (i, t, e) => {
    const n = e[0], s = e[1], r = e[2];
    let o, a, l, c, h, u, d, f, g, m, p, _;
    return t === i ? (i[12] = t[0] * n + t[4] * s + t[8] * r + t[12], i[13] = t[1] * n + t[5] * s + t[9] * r + t[13], i[14] = t[2] * n + t[6] * s + t[10] * r + t[14], i[15] = t[3] * n + t[7] * s + t[11] * r + t[15]) : (o = t[0], a = t[1], l = t[2], c = t[3], h = t[4], u = t[5], d = t[6], f = t[7], g = t[8], m = t[9], p = t[10], _ = t[11], i[0] = o, i[1] = a, i[2] = l, i[3] = c, i[4] = h, i[5] = u, i[6] = d, i[7] = f, i[8] = g, i[9] = m, i[10] = p, i[11] = _, i[12] = o * n + h * s + g * r + t[12], i[13] = a * n + u * s + m * r + t[13], i[14] = l * n + d * s + p * r + t[14], i[15] = c * n + f * s + _ * r + t[15]), i
};
var Q4 = J4, He = {
    add: LG,
    clone: FG,
    copy: _M,
    create: H_,
    invert: kG,
    equals: GG,
    fromRotation: xM,
    fromScaling: ZG,
    fromTaitBryanRotation: KG,
    fromTranslation: QG,
    fromValues: n4,
    fromVectorRotation: r4,
    fromXRotation: c4,
    fromYRotation: f4,
    fromZRotation: _4,
    identity: yM,
    isIdentity: x4,
    isOnlyTransformScale: w4,
    isMirroring: E4,
    mirrorByPlane: M4,
    multiply: I4,
    rotate: N4,
    rotateX: z4,
    rotateY: G4,
    rotateZ: W4,
    scale: Y4,
    subtract: Z4,
    toString: K4,
    translate: Q4
};
const tV = () => [0, 0, 0, 0];
var Zf = tV;
const eV = Zf, nV = i => {
    const t = eV();
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t
};
var vM = nV;
const sV = (i, t) => (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i);
var wM = sV;
const iV = (i, t) => i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3];
var bM = iV;
const rV = (i, t) => (i[0] = -t[0], i[1] = -t[1], i[2] = -t[2], i[3] = -t[3], i);
var EM = rV;
const lg = kt, oV = (i, t, e) => {
    const n = lg.normalize(lg.create(), t), s = lg.dot(e, n);
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = s, i
};
var aV = oV;
const lV = Zf, cV = (i, t, e, n) => {
    const s = lV();
    return s[0] = i, s[1] = t, s[2] = e, s[3] = n, s
};
var SM = cV;
const vi = kt, hV = (i, ...t) => {
    const e = t.length, n = vi.create(), s = vi.create(), r = o => {
        const a = t[o], l = t[(o + 1) % e], c = t[(o + 2) % e];
        return vi.subtract(n, l, a), vi.subtract(s, c, a), vi.cross(n, n, s), vi.normalize(n, n), n
    };
    return i[0] = 0, i[1] = 0, i[2] = 0, e === 3 ? vi.copy(i, r(0)) : (t.forEach((o, a) => {
        vi.add(i, i, r(a))
    }), vi.normalize(i, i)), i[3] = vi.dot(i, t[0]), i
};
var MM = hV;
const {EPS: cg} = me, es = kt, uV = (i, t, e, n) => {
    let s = es.subtract(es.create(), e, t), r = es.subtract(es.create(), n, t);
    es.length(s) < cg && (s = es.orthogonal(s, r)), es.length(r) < cg && (r = es.orthogonal(r, s));
    let o = es.cross(es.create(), s, r);
    es.length(o) < cg && (r = es.orthogonal(r, s), o = es.cross(o, s, r)), o = es.normalize(o, o);
    const a = es.dot(o, t);
    return i[0] = o[0], i[1] = o[1], i[2] = o[2], i[3] = a, i
};
var dV = uV;
const fV = kt, pV = (i, t) => {
    const e = t[0] * i[0] + t[1] * i[1] + t[2] * i[2] - i[3], n = t[0] - e * i[0], s = t[1] - e * i[1],
        r = t[2] - e * i[2];
    return fV.fromValues(n, s, r)
};
var gV = pV;
const mV = kt, _V = (i, t) => mV.dot(i, t) - i[3];
var TM = _V;
const yV = i => `(${i[0].toFixed(9)}, ${i[1].toFixed(9)}, ${i[2].toFixed(9)}, ${i[3].toFixed(9)})`;
var IM = yV;
const xV = He, ns = kt, vV = MM, wV = EM, bV = (i, t, e) => {
    const n = xV.isMirroring(e), s = ns.orthogonal(ns.create(), t), r = ns.cross(s, t, s),
        o = ns.cross(ns.create(), t, r);
    let a = ns.fromScalar(ns.create(), t[3]);
    ns.multiply(a, a, t);
    let l = ns.add(ns.create(), a, r), c = ns.add(ns.create(), a, o);
    return a = ns.transform(a, a, e), l = ns.transform(l, l, e), c = ns.transform(c, c, e), vV(i, a, l, c), n && wV(i, i), i
};
var EV = bV, Hi = {
    clone: vM,
    copy: wM,
    create: Zf,
    equals: bM,
    flip: EM,
    fromNormalAndPoint: aV,
    fromValues: SM,
    fromPoints: MM,
    fromPointsRandom: dV,
    projectionOfPoint: gV,
    signedDistanceToPoint: TM,
    toString: IM,
    transform: EV
};
const SV = (i, t) => i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3] * t[3];
var MV = SV;
const TV = (i, t) => (i[0] = t, i[1] = t, i[2] = t, i[3] = t, i);
var IV = TV;
const AV = (i, t, e) => {
    const [n, s, r, o] = t;
    return i[0] = e[0] * n + e[4] * s + e[8] * r + e[12] * o, i[1] = e[1] * n + e[5] * s + e[9] * r + e[13] * o, i[2] = e[2] * n + e[6] * s + e[10] * r + e[14] * o, i[3] = e[3] * n + e[7] * s + e[11] * r + e[15] * o, i
};
var CV = AV, AM = {
    clone: vM,
    copy: wM,
    create: Zf,
    dot: MV,
    equals: bM,
    fromScalar: IV,
    fromValues: SM,
    toString: IM,
    transform: CV
}, xn = {constants: me, line2: V_, line3: PG, mat4: He, plane: Hi, utils: Oh, vec2: te, vec3: kt, vec4: AM};
const PV = i => Object.assign({}, i);
var RV = PV;
const LV = He, NV = i => (i === void 0 && (i = []), {sides: i, transforms: LV.create()});
var jf = NV;
const hg = te, OV = jf, DV = i => {
    if (!Array.isArray(i)) throw new Error("the given points must be an array");
    let t = i.length;
    if (t < 3) throw new Error("the given points must define a closed geometry with three or more points");
    hg.equals(i[0], i[t - 1]) && --t;
    const e = [];
    let n = i[t - 1];
    for (let s = 0; s < t; s++) {
        const r = i[s];
        e.push([hg.clone(n), hg.clone(r)]), n = r
    }
    return OV(e)
};
var FV = DV;
const zV = He, B1 = te, BV = jf, kV = i => {
    if (i[0] !== 0) throw new Error("invalid compact binary data");
    const t = BV();
    t.transforms = zV.clone(i.slice(1, 17));
    for (let e = 21; e < i.length; e += 4) {
        const n = B1.fromValues(i[e + 0], i[e + 1]), s = B1.fromValues(i[e + 2], i[e + 3]);
        t.sides.push([n, s])
    }
    return i[17] >= 0 && (t.color = [i[17], i[18], i[19], i[20]]), t
};
var UV = kV;
const GV = i => !!(i && typeof i == "object" && "sides" in i && "transforms" in i && Array.isArray(i.sides) && "length" in i.transforms);
var CM = GV;
const k1 = He, Pu = te, VV = i => (k1.isIdentity(i.transforms) || (i.sides = i.sides.map(t => {
    const e = Pu.transform(Pu.create(), t[0], i.transforms), n = Pu.transform(Pu.create(), t[1], i.transforms);
    return [e, n]
}), i.transforms = k1.create()), i);
var HV = VV;
const $V = HV, WV = i => $V(i).sides;
var Fh = WV;
const qV = jf, YV = Fh, XV = i => {
    const e = YV(i).map(n => [n[1], n[0]]);
    return e.reverse(), qV(e)
};
var ZV = XV;
const sc = te, jV = Fh, KV = i => {
    const t = new Map, e = n => {
        const s = n.toString();
        return t.has(s) ? t.get(s) : (t.set(s, n), n)
    };
    return i.map(n => n.map(e))
}, JV = i => {
    const t = new Map;
    return KV(i).forEach(n => {
        t.has(n[0]) ? t.get(n[0]).push(n) : t.set(n[0], [n])
    }), t
}, QV = i => {
    const t = JV(jV(i)), e = [];
    for (; ;) {
        let n;
        for (const [o, a] of t) {
            if (n = a.shift(), !n) {
                t.delete(o);
                continue
            }
            break
        }
        if (n === void 0) break;
        const s = [], r = n[0];
        for (; ;) {
            s.push(n[0]);
            const o = n[1];
            if (o === r) break;
            const a = t.get(o);
            if (!a) throw new Error(`geometry is not closed at vertex ${o}`);
            const l = t5(n, a);
            a.length === 0 && t.delete(o), n = l
        }
        s.length > 0 && s.push(s.shift()), e.push(s)
    }
    return t.clear(), e
}, t5 = (i, t) => {
    if (t.length === 1) return t.pop();
    const e = sc.create(), n = sc.angleDegrees(sc.subtract(e, i[1], i[0]));
    let s, r;
    t.forEach((a, l) => {
        let h = sc.angleDegrees(sc.subtract(e, a[1], a[0])) - n;
        h < -180 && (h += 360), h >= 180 && (h -= 360), (r === void 0 || h > s) && (r = l, s = h)
    });
    const o = t[r];
    return t.splice(r, 1), o
};
var PM = QV;
const e5 = Fh, n5 = i => {
    const e = e5(i).map(n => n[0]);
    return e.length > 0 && e.push(e.shift()), e
};
var s5 = n5;
const U1 = te, i5 = Fh, r5 = i => {
    const t = i5(i);
    let e = "geom2 (" + t.length + ` sides):
[
`;
    return t.forEach(n => {
        e += "  [" + U1.toString(n[0]) + ", " + U1.toString(n[1]) + `]
`
    }), e += `]
`, e
};
var o5 = r5;
const a5 = i => {
    const t = i.sides, e = i.transforms;
    let n = [-1, -1, -1, -1];
    i.color && (n = i.color);
    const s = new Float32Array(1 + 16 + 4 + t.length * 4);
    s[0] = 0, s[1] = e[0], s[2] = e[1], s[3] = e[2], s[4] = e[3], s[5] = e[4], s[6] = e[5], s[7] = e[6], s[8] = e[7], s[9] = e[8], s[10] = e[9], s[11] = e[10], s[12] = e[11], s[13] = e[12], s[14] = e[13], s[15] = e[14], s[16] = e[15], s[17] = n[0], s[18] = n[1], s[19] = n[2], s[20] = n[3];
    for (let r = 0; r < t.length; r++) {
        const o = r * 4 + 21, a = t[r][0], l = t[r][1];
        s[o + 0] = a[0], s[o + 1] = a[1], s[o + 2] = l[0], s[o + 3] = l[1]
    }
    return s
};
var l5 = a5;
const G1 = He, c5 = (i, t) => {
    const e = G1.multiply(G1.create(), i, t.transforms);
    return Object.assign({}, t, {transforms: e})
};
var h5 = c5;
const u5 = te, d5 = CM, f5 = PM, p5 = i => {
    if (!d5(i)) throw new Error("invalid geom2 structure");
    if (f5(i), i.sides.forEach(t => {
        if (u5.equals(t[0], t[1])) throw new Error(`geom2 self-edge ${t[0]}`)
    }), !i.transforms.every(Number.isFinite)) throw new Error(`geom2 invalid transforms ${i.transforms}`)
};
var g5 = p5, xe = {
    clone: RV,
    create: jf,
    fromPoints: FV,
    fromCompactBinary: UV,
    isA: CM,
    reverse: ZV,
    toOutlines: PM,
    toPoints: s5,
    toSides: Fh,
    toString: o5,
    toCompactBinary: l5,
    transform: h5,
    validate: g5
};
const m5 = i => Object.assign({}, i);
var _5 = m5;
const y5 = He, x5 = i => (i === void 0 && (i = []), {polygons: i, transforms: y5.create()});
var Kf = x5;
const v5 = i => ((i === void 0 || i.length < 3) && (i = []), {vertices: i});
var kl = v5;
const w5 = kl, b5 = kt, E5 = (...i) => {
    let t, e;
    return i.length === 1 ? (t = w5(), e = i[0]) : (t = i[0], e = i[1]), t.vertices = e.vertices.map(n => b5.clone(n)), t
};
var S5 = E5;
const M5 = kt, T5 = kl, I5 = i => {
    const t = i.map(e => M5.clone(e));
    return T5(t)
};
var A5 = I5;
const C5 = kl, P5 = (i, t) => {
    const e = C5(i);
    return e.plane = t, e
};
var R5 = P5;
const V1 = Hi, L5 = kl, N5 = i => {
    const t = i.vertices.slice().reverse(), e = L5(t);
    return i.plane && (e.plane = V1.flip(V1.create(), i.plane)), e
};
var O5 = N5;
const D5 = i => !!(i && typeof i == "object" && "vertices" in i && Array.isArray(i.vertices));
var RM = D5;
const H1 = Hi, po = kt, F5 = i => z5(i.vertices), z5 = i => {
    const t = i.length;
    if (t > 2) {
        const e = H1.fromPoints(H1.create(), ...i);
        let n = i[t - 2], s = i[t - 1];
        for (let r = 0; r < t; r++) {
            const o = i[r];
            if (!B5(n, s, o, e)) return !1;
            n = s, s = o
        }
    }
    return !0
}, B5 = (i, t, e, n) => {
    const s = po.cross(po.create(), po.subtract(po.create(), t, i), po.subtract(po.create(), e, t));
    return po.dot(s, n) >= 0
};
var LM = F5;
const $1 = Hi, k5 = i => (i.plane || (i.plane = $1.fromPoints($1.create(), ...i.vertices)), i.plane);
var $_ = k5;
const U5 = $_, G5 = i => {
    const t = i.vertices.length;
    if (t < 3) return 0;
    const e = i.vertices, n = U5(i), s = Math.abs(n[0]), r = Math.abs(n[1]), o = Math.abs(n[2]);
    if (s + r + o === 0) return 0;
    let a = 3;
    s > r && s > o ? a = 1 : r > o && (a = 2);
    let l = 0, c = 0, h = 1, u = 2;
    switch (a) {
        case 1:
            for (h = 1; h < t; h++) c = h - 1, u = (h + 1) % t, l += e[h][1] * (e[u][2] - e[c][2]);
            l += e[0][1] * (e[1][2] - e[t - 1][2]), l /= 2 * n[0];
            break;
        case 2:
            for (h = 1; h < t; h++) c = h - 1, u = (h + 1) % t, l += e[h][2] * (e[u][0] - e[c][0]);
            l += e[0][2] * (e[1][0] - e[t - 1][0]), l /= 2 * n[1];
            break;
        case 3:
        default:
            for (h = 1; h < t; h++) c = h - 1, u = (h + 1) % t, l += e[h][0] * (e[u][1] - e[c][1]);
            l += e[0][0] * (e[1][1] - e[t - 1][1]), l /= 2 * n[2];
            break
    }
    return l
};
var NM = G5;
const ic = kt, V5 = i => {
    const t = i.vertices, e = t.length, n = e === 0 ? ic.create() : ic.clone(t[0]), s = ic.clone(n);
    for (let r = 1; r < e; r++) ic.min(n, n, t[r]), ic.max(s, s, t[r]);
    return [n, s]
};
var H5 = V5;
const $5 = AM, W1 = new WeakMap, W5 = i => {
    let t = W1.get(i);
    if (t) return t;
    const e = i.vertices, n = $5.create();
    if (e.length === 0) return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0, n;
    let s = e[0], r = s, o = s, a = s, l = s, c = s;
    e.forEach(f => {
        s[0] > f[0] && (s = f), r[1] > f[1] && (r = f), o[2] > f[2] && (o = f), a[0] < f[0] && (a = f), l[1] < f[1] && (l = f), c[2] < f[2] && (c = f)
    }), n[0] = (s[0] + a[0]) * .5, n[1] = (r[1] + l[1]) * .5, n[2] = (o[2] + c[2]) * .5;
    const h = n[0] - a[0], u = n[1] - l[1], d = n[2] - c[2];
    return n[3] = Math.sqrt(h * h + u * u + d * d), W1.set(i, n), n
};
var q5 = W5;
const ug = kt, Y5 = i => {
    let t = 0;
    const e = i.vertices, n = ug.create();
    for (let s = 0; s < e.length - 2; s++) ug.cross(n, e[s + 1], e[s + 2]), t += ug.dot(e[0], n);
    return t /= 6, t
};
var X5 = Y5;
const Z5 = i => i.vertices;
var j5 = Z5;
const K5 = kt, J5 = i => {
    let t = "poly3: vertices: [";
    return i.vertices.forEach(e => {
        t += `${K5.toString(e)}, `
    }), t += "]", t
};
var Q5 = J5;
const tH = He, q1 = kt, eH = kl, nH = (i, t) => {
    const e = t.vertices.map(n => q1.transform(q1.create(), n, i));
    return tH.isMirroring(i) && e.reverse(), eH(e)
};
var sH = nH;
const iH = TM, {NEPS: rH} = me, oH = kt, aH = RM, lH = LM, cH = NM, hH = $_, uH = i => {
    if (!aH(i)) throw new Error("invalid poly3 structure");
    if (i.vertices.length < 3) throw new Error(`poly3 not enough vertices ${i.vertices.length}`);
    if (cH(i) <= 0) throw new Error("poly3 area must be greater than zero");
    for (let t = 0; t < i.vertices.length; t++) if (oH.equals(i.vertices[t], i.vertices[(t + 1) % i.vertices.length])) throw new Error(`poly3 duplicate vertex ${i.vertices[t]}`);
    if (!lH(i)) throw new Error("poly3 must be convex");
    if (i.vertices.forEach(t => {
        if (!t.every(Number.isFinite)) throw new Error(`poly3 invalid vertex ${t}`)
    }), i.vertices.length > 3) {
        const t = hH(i);
        i.vertices.forEach(e => {
            const n = Math.abs(iH(t, e));
            if (n > rH) throw new Error(`poly3 must be coplanar: vertex ${e} distance ${n}`)
        })
    }
};
var dH = uH, Be = {
    clone: S5,
    create: kl,
    fromPoints: A5,
    fromPointsAndPlane: R5,
    invert: O5,
    isA: RM,
    isConvex: LM,
    measureArea: NM,
    measureBoundingBox: H5,
    measureBoundingSphere: q5,
    measureSignedVolume: X5,
    plane: $_,
    toPoints: j5,
    toString: Q5,
    transform: sH,
    validate: dH
};
const fH = Be, pH = Kf, gH = i => {
    if (!Array.isArray(i)) throw new Error("the given points must be an array");
    const t = i.map((n, s) => fH.create(n));
    return pH(t)
};
var mH = gH;
const _H = kt, yH = He, xH = Be, vH = Kf, wH = i => {
    if (i[0] !== 1) throw new Error("invalid compact binary data");
    const t = vH();
    t.transforms = yH.clone(i.slice(1, 17));
    const e = i[21];
    let n = 22, s = i.length - e * 3;
    for (; s < i.length;) {
        const r = i[n];
        n++;
        const o = [];
        for (let a = 0; a < r; a++) o.push(_H.fromValues(i[s], i[s + 1], i[s + 2])), s += 3;
        t.polygons.push(xH.create(o))
    }
    return i[17] >= 0 && (t.color = [i[17], i[18], i[19], i[20]]), t
};
var bH = wH;
const Y1 = He, EH = Be,
    SH = i => (Y1.isIdentity(i.transforms) || (i.polygons = i.polygons.map(t => EH.transform(i.transforms, t)), i.transforms = Y1.create()), i);
var MH = SH;
const TH = MH, IH = i => TH(i).polygons;
var Jf = IH;
const AH = Be, CH = Kf, PH = Jf, RH = i => {
    const e = PH(i).map(n => AH.invert(n));
    return CH(e)
};
var LH = RH;
const NH = i => !!(i && typeof i == "object" && "polygons" in i && "transforms" in i && Array.isArray(i.polygons) && "length" in i.transforms);
var OM = NH;
const OH = Be, DH = Jf, FH = i => DH(i).map(n => OH.toPoints(n));
var zH = FH;
const BH = Be, kH = Jf, UH = i => {
    const t = kH(i);
    let e = "geom3 (" + t.length + ` polygons):
`;
    return t.forEach(n => {
        e += "  " + BH.toString(n) + `
`
    }), e
};
var GH = UH;
const VH = Be, HH = i => {
    const t = i.polygons, e = i.transforms, n = t.length, s = t.reduce((c, h) => c + h.vertices.length, 0);
    let r = [-1, -1, -1, -1];
    i.color && (r = i.color);
    const o = new Float32Array(1 + 16 + 4 + 1 + n + s * 3);
    o[0] = 1, o[1] = e[0], o[2] = e[1], o[3] = e[2], o[4] = e[3], o[5] = e[4], o[6] = e[5], o[7] = e[6], o[8] = e[7], o[9] = e[8], o[10] = e[9], o[11] = e[10], o[12] = e[11], o[13] = e[12], o[14] = e[13], o[15] = e[14], o[16] = e[15], o[17] = r[0], o[18] = r[1], o[19] = r[2], o[20] = r[3], o[21] = s;
    let a = 22, l = a + n;
    return t.forEach(c => {
        const h = VH.toPoints(c);
        o[a] = h.length, a++;
        for (let u = 0; u < h.length; u++) {
            const d = h[u];
            o[l + 0] = d[0], o[l + 1] = d[1], o[l + 2] = d[2], l += 3
        }
    }), o
};
var $H = HH;
const X1 = He, WH = (i, t) => {
    const e = X1.multiply(X1.create(), i, t.transforms);
    return Object.assign({}, t, {transforms: e})
};
var qH = WH;
const YH = Be, XH = OM, ZH = i => {
    if (!XH(i)) throw new Error("invalid geom3 structure");
    if (i.polygons.forEach(YH.validate), jH(i), !i.transforms.every(Number.isFinite)) throw new Error(`geom3 invalid transforms ${i.transforms}`)
}, jH = i => {
    const t = new Map;
    i.polygons.forEach(({vertices: n}) => {
        n.forEach((s, r) => {
            const o = `${s}`, a = `${n[(r + 1) % n.length]}`, l = `${o}/${a}`, c = t.has(l) ? t.get(l) : 0;
            t.set(l, c + 1)
        })
    });
    const e = [];
    if (t.forEach((n, s) => {
        const r = s.split("/").reverse().join("/"), o = t.get(r);
        n !== o && e.push(s.replace("/", " -> "))
    }), e.length > 0) throw new Error(`non-manifold edges ${e.length}
${e.join(`
`)}`)
};
var KH = ZH, le = {
    clone: _5,
    create: Kf,
    fromPoints: mH,
    fromCompactBinary: bH,
    invert: LH,
    isA: OM,
    toPoints: zH,
    toPolygons: Jf,
    toString: GH,
    toCompactBinary: $H,
    transform: qH,
    validate: KH
};
const JH = i => Object.assign({}, i);
var W_ = JH;
const {EPS: Z1} = me, QH = te, t$ = W_, e$ = i => {
    if (i.isClosed) return i;
    const t = t$(i);
    if (t.isClosed = !0, t.points.length > 1) {
        const e = t.points, n = e[0];
        let s = e[e.length - 1];
        for (; QH.distance(n, s) < Z1 * Z1 && (e.pop(), e.length !== 1);) s = e[e.length - 1]
    }
    return t
};
var DM = e$;
const n$ = He, s$ = i => (i === void 0 && (i = []), {points: i, isClosed: !1, transforms: n$.create()});
var Qf = s$;
const {EPS: j1} = me, K1 = te, i$ = DM, r$ = Qf, o$ = (i, t) => {
    const e = {closed: !1};
    let {closed: n} = Object.assign({}, e, i), s = r$();
    if (s.points = t.map(r => K1.clone(r)), s.points.length > 1) {
        const r = s.points[0], o = s.points[s.points.length - 1];
        K1.distance(r, o) < j1 * j1 && (n = !0)
    }
    return n === !0 && (s = i$(s)), s
};
var q_ = o$;
const J1 = He, Q1 = te,
    a$ = i => (J1.isIdentity(i.transforms) || (i.points = i.points.map(t => Q1.transform(Q1.create(), t, i.transforms)), i.transforms = J1.create()), i);
var l$ = a$;
const c$ = l$, h$ = i => c$(i).points;
var Ul = h$;
const {TAU: Ru} = me, _n = te, u$ = q_, d$ = Ul, f$ = (i, t) => {
    const e = {radius: [0, 0], xaxisrotation: 0, clockwise: !1, large: !1, segments: 16};
    let {endpoint: n, radius: s, xaxisrotation: r, clockwise: o, large: a, segments: l} = Object.assign({}, e, i);
    if (!Array.isArray(n)) throw new Error("endpoint must be an array of X and Y values");
    if (n.length < 2) throw new Error("endpoint must contain X and Y values");
    if (n = _n.clone(n), !Array.isArray(s)) throw new Error("radius must be an array of X and Y values");
    if (s.length < 2) throw new Error("radius must contain X and Y values");
    if (l < 4) throw new Error("segments must be four or more");
    const c = 1e5;
    if (t.isClosed) throw new Error("the given path cannot be closed");
    const h = d$(t);
    if (h.length < 1) throw new Error("the given path must contain one or more points (as the starting point for the arc)");
    let u = s[0], d = s[1];
    const f = h[h.length - 1];
    u = Math.round(u * c) / c, d = Math.round(d * c) / c, n = _n.fromValues(Math.round(n[0] * c) / c, Math.round(n[1] * c) / c);
    const g = !o;
    let m = [];
    if (u === 0 || d === 0) m.push(n); else {
        u = Math.abs(u), d = Math.abs(d);
        const _ = r, x = Math.cos(_), y = Math.sin(_), v = _n.subtract(_n.create(), f, n);
        _n.scale(v, v, .5);
        const w = Math.round((x * v[0] + y * v[1]) * c) / c, E = Math.round((-y * v[0] + x * v[1]) * c) / c,
            S = _n.fromValues(w, E), b = S[0] * S[0] / (u * u) + S[1] * S[1] / (d * d);
        if (b > 1) {
            const q = Math.sqrt(b);
            u *= q, d *= q, u = Math.round(u * c) / c, d = Math.round(d * c) / c
        }
        let M = Math.sqrt((u * u * d * d - u * u * S[1] * S[1] - d * d * S[0] * S[0]) / (u * u * S[1] * S[1] + d * d * S[0] * S[0]));
        g === a && (M = -M);
        const I = _n.fromValues(u * S[1] / d, -d * S[0] / u);
        _n.scale(I, I, M);
        let N = _n.fromValues(x * I[0] - y * I[1], y * I[0] + x * I[1]);
        N = _n.add(N, N, _n.scale(_n.create(), _n.add(_n.create(), f, n), .5));
        const B = _n.fromValues((S[0] - I[0]) / u, (S[1] - I[1]) / d),
            D = _n.fromValues((-S[0] - I[0]) / u, (-S[1] - I[1]) / d), L = _n.angleRadians(B);
        let G = _n.angleRadians(D) - L;
        G = G % Ru, !g && G > 0 ? G -= Ru : g && G < 0 && (G += Ru);
        let Q = Math.ceil(Math.abs(G) / Ru * l) + 1;
        Q < 1 && (Q = 1);
        for (let q = 1; q < Q; q++) {
            const at = L + q / Q * G, lt = Math.cos(at), wt = Math.sin(at),
                W = _n.fromValues(x * u * lt - y * d * wt, y * u * lt + x * d * wt);
            _n.add(W, W, N), m.push(W)
        }
        Q && m.push(i.endpoint)
    }
    return m = h.concat(m), u$({}, m)
};
var p$ = f$;
const g$ = q_, m$ = Ul, {equals: _$} = te, y$ = (...i) => {
    let t = !1, e = [];
    return i.forEach((n, s) => {
        const r = m$(n).slice();
        if (e.length > 0 && r.length > 0 && _$(r[0], e[e.length - 1]) && r.shift(), r.length > 0 && t) throw new Error(`Cannot concatenate to a closed path; check the ${s}th path`);
        t = n.isClosed, e = e.concat(r)
    }), g$({closed: t}, e)
};
var FM = y$;
const x$ = FM, v$ = Qf, w$ = (i, t) => x$(t, v$(i));
var zM = w$;
const {TAU: b$} = me, Cs = te, E$ = te, S$ = zM, M$ = Ul, T$ = (i, t) => {
    const e = {segments: 16};
    let {controlPoints: n, segments: s} = Object.assign({}, e, i);
    if (!Array.isArray(n)) throw new Error("controlPoints must be an array of one or more points");
    if (n.length < 1) throw new Error("controlPoints must be an array of one or more points");
    if (s < 4) throw new Error("segments must be four or more");
    if (t.isClosed) throw new Error("the given geometry cannot be closed");
    const r = M$(t);
    if (r.length < 1) throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");
    if (n = n.slice(), n[0] === null) {
        if (n.length < 2) throw new Error("a null control point must be passed with one more control points");
        let E = r[r.length - 2];
        if ("lastBezierControlPoint" in t && (E = t.lastBezierControlPoint), !Array.isArray(E)) throw new Error("the given path must contain TWO or more points if given a null control point");
        const S = Cs.scale(Cs.create(), r[r.length - 1], 2);
        Cs.subtract(S, S, E), n[0] = S
    }
    n.unshift(r[r.length - 1]);
    const a = n.length - 1, l = [];
    let c = 1;
    for (let E = 0; E <= a; ++E) E > 0 && (c *= E), l.push(c);
    const h = [];
    for (let E = 0; E <= a; ++E) {
        const S = l[a] / (l[E] * l[a - E]);
        h.push(S)
    }
    const u = Cs.create(), d = Cs.create(), f = E$.create(), g = E => {
        let S = 1, b = Math.pow(1 - E, a);
        const M = E !== 1 ? 1 / (1 - E) : 1, I = Cs.create();
        for (let N = 0; N <= a; ++N) {
            N === a && (b = 1);
            const B = h[N] * S * b, D = Cs.scale(u, n[N], B);
            Cs.add(I, I, D), S *= E, b *= M
        }
        return I
    }, m = [], p = [], _ = a + 1;
    for (let E = 0; E < _; ++E) {
        const S = E / (_ - 1), b = g(S);
        m.push(b), p.push(S)
    }
    let x = 1;
    const y = b$ / s, v = Math.sin(y);
    for (; x < m.length - 1;) {
        const E = Cs.subtract(u, m[x], m[x - 1]);
        Cs.normalize(E, E);
        const S = Cs.subtract(d, m[x + 1], m[x]);
        Cs.normalize(S, S);
        const b = Cs.cross(f, E, S);
        if (Math.abs(b[2]) > v) {
            const M = p[x - 1], I = p[x + 1], N = M + (I - M) * 1 / 3, B = M + (I - M) * 2 / 3, D = g(N), L = g(B);
            m.splice(x, 1, D, L), p.splice(x, 1, N, B), x--, x < 1 && (x = 1)
        } else ++x
    }
    m.shift();
    const w = S$(m, t);
    return w.lastBezierControlPoint = n[n.length - 2], w
};
var I$ = T$;
const A$ = te, tv = Ul, C$ = (i, t) => {
    if (i.isClosed !== t.isClosed || i.points.length !== t.points.length) return !1;
    const e = tv(i), n = tv(t), s = e.length;
    let r = 0;
    do {
        let o = !1;
        for (let a = 0; a < s; a++) if (!A$.equals(e[a], n[(a + r) % s])) {
            o = !0;
            break
        }
        if (o === !1) return !0;
        if (!i.isClosed) return !1
    } while (++r < s);
    return !1
};
var P$ = C$;
const R$ = He, L$ = te, N$ = Qf, O$ = i => {
    if (i[0] !== 2) throw new Error("invalid compact binary data");
    const t = N$();
    t.transforms = R$.clone(i.slice(1, 17)), t.isClosed = !!i[17];
    for (let e = 22; e < i.length; e += 2) {
        const n = L$.fromValues(i[e], i[e + 1]);
        t.points.push(n)
    }
    return i[18] >= 0 && (t.color = [i[18], i[19], i[20], i[21]]), t
};
var D$ = O$;
const F$ = i => !!(i && typeof i == "object" && "points" in i && "transforms" in i && "isClosed" in i && Array.isArray(i.points) && "length" in i.transforms);
var BM = F$;
const z$ = W_, B$ = i => {
    const t = z$(i);
    return t.points = i.points.slice().reverse(), t
};
var k$ = B$;
const U$ = te, G$ = Ul, V$ = i => {
    const t = G$(i);
    let e = "path (" + t.length + " points, " + i.isClosed + `):
[
`;
    return t.forEach(n => {
        e += "  " + U$.toString(n) + `,
`
    }), e += `]
`, e
};
var H$ = V$;
const $$ = i => {
    const t = i.points, e = i.transforms;
    let n = [-1, -1, -1, -1];
    i.color && (n = i.color);
    const s = new Float32Array(1 + 16 + 1 + 4 + t.length * 2);
    s[0] = 2, s[1] = e[0], s[2] = e[1], s[3] = e[2], s[4] = e[3], s[5] = e[4], s[6] = e[5], s[7] = e[6], s[8] = e[7], s[9] = e[8], s[10] = e[9], s[11] = e[10], s[12] = e[11], s[13] = e[12], s[14] = e[13], s[15] = e[14], s[16] = e[15], s[17] = i.isClosed ? 1 : 0, s[18] = n[0], s[19] = n[1], s[20] = n[2], s[21] = n[3];
    for (let r = 0; r < t.length; r++) {
        const o = r * 2 + 22, a = t[r];
        s[o] = a[0], s[o + 1] = a[1]
    }
    return s
};
var W$ = $$;
const ev = He, q$ = (i, t) => {
    const e = ev.multiply(ev.create(), i, t.transforms);
    return Object.assign({}, t, {transforms: e})
};
var Y$ = q$;
const X$ = te, Z$ = BM, j$ = i => {
    if (!Z$(i)) throw new Error("invalid path2 structure");
    if (i.points.length > 1) {
        for (let t = 0; t < i.points.length; t++) if (X$.equals(i.points[t], i.points[(t + 1) % i.points.length])) throw new Error(`path2 duplicate points ${i.points[t]}`)
    }
    if (i.points.forEach(t => {
        if (!t.every(Number.isFinite)) throw new Error(`path2 invalid point ${t}`)
    }), !i.transforms.every(Number.isFinite)) throw new Error(`path2 invalid transforms ${i.transforms}`)
};
var K$ = j$, Fn = {
    appendArc: p$,
    appendBezier: I$,
    appendPoints: zM,
    clone: W_,
    close: DM,
    concat: FM,
    create: Qf,
    equals: P$,
    fromPoints: q_,
    fromCompactBinary: D$,
    isA: BM,
    reverse: k$,
    toPoints: Ul,
    toString: H$,
    toCompactBinary: W$,
    transform: Y$,
    validate: K$
};
const J$ = Yf, Q$ = i => J$(i.vertices);
var kM = Q$;
const t6 = i => ((i === void 0 || i.length < 3) && (i = []), {vertices: i});
var UM = t6;
const e6 = UM, n6 = i => {
    const t = i.vertices.slice().reverse();
    return e6(t)
};
var GM = n6;
const s6 = kM, i6 = GM, r6 = (i, t) => {
    if (i.length === 0) return 0;
    const e = t.vertices;
    return e.length < 3 ? 0 : (s6(t) < 0 && (t = i6(t)), i.reduce((s, r) => s + o6(r, e), 0) === i.length ? 1 : 0)
}, o6 = (i, t) => {
    const e = t.length, n = i[0], s = i[1];
    let r = t[e - 1], o = t[0], a = r[1] > s, l = 0, c = 0;
    for (let h = e + 1; --h;) {
        const u = o[1] > s;
        if (a !== u) {
            const d = r[0] > n, f = o[0] > n;
            (d && f || o[0] - (o[1] - s) * (r[0] - o[0]) / (r[1] - o[1]) >= n) && (l = !l)
        }
        a = u, r = o, o = t[++c]
    }
    return l
};
var a6 = r6, VM = {arePointsInside: a6, create: UM, flip: GM, measureArea: kM},
    Yr = {geom2: xe, geom3: le, path2: Fn, poly2: VM, poly3: Be};
const nv = Hi, go = kt, l6 = i => {
    const t = i.edges;
    if (t.length < 3) throw new Error("slices must have 3 or more edges to calculate a plane");
    const e = t.reduce((o, a) => go.add(go.create(), o, a[0]), go.create());
    go.scale(e, e, 1 / t.length);
    let n, s = 0;
    t.forEach(o => {
        if (!go.equals(o[0], o[1])) {
            const a = go.squaredDistance(e, o[0]);
            a > s && (n = o, s = a)
        }
    });
    const r = t.find(o => go.equals(o[1], n[0]));
    return nv.fromPoints(nv.create(), r[0], n[0], n[1])
};
var HM = l6;
const c6 = i => (i || (i = []), {edges: i});
var ta = c6;
const h6 = ta, sv = kt, u6 = (...i) => {
    let t, e;
    return i.length === 1 ? (t = h6(), e = i[0]) : (t = i[0], e = i[1]), t.edges = e.edges.map(n => [sv.clone(n[0]), sv.clone(n[1])]), t
};
var d6 = u6;
const f6 = kt, p6 = (i, t) => {
    const e = i.edges, n = t.edges;
    return e.length !== n.length ? !1 : e.reduce((r, o, a) => {
        const l = n[a], c = f6.squaredDistance(o[0], l[0]);
        return r && c < Number.EPSILON
    }, !0)
};
var g6 = p6;
const Lu = kt, m6 = ta, _6 = i => {
    if (!Array.isArray(i)) throw new Error("the given points must be an array");
    if (i.length < 3) throw new Error("the given points must contain THREE or more points");
    const t = [];
    let e = i[i.length - 1];
    return i.forEach(n => {
        n.length === 2 && t.push([Lu.fromVec2(Lu.create(), e), Lu.fromVec2(Lu.create(), n)]), n.length === 3 && t.push([e, n]), e = n
    }), m6(t)
};
var y6 = _6;
const Nu = kt, x6 = ta, v6 = i => {
    if (!Array.isArray(i)) throw new Error("the given sides must be an array");
    const t = [];
    return i.forEach(e => {
        t.push([Nu.fromVec2(Nu.create(), e[0]), Nu.fromVec2(Nu.create(), e[1])])
    }), x6(t)
};
var w6 = v6;
const b6 = i => !!(i && typeof i == "object" && "edges" in i && Array.isArray(i.edges));
var E6 = b6;
const S6 = ta, M6 = (...i) => {
    let t, e;
    return i.length === 1 ? (t = S6(), e = i[0]) : (t = i[0], e = i[1]), t.edges = e.edges.map(n => [n[1], n[0]]), t
};
var T6 = M6;
const I6 = i => i.edges;
var A6 = I6;
const C6 = (i, t) => {
    let e, n, s, r, o, a = 1;
    do {
        n = i, i = null;
        let l = null;
        for (o = 0; n;) {
            o++, s = n;
            let c = 0;
            for (e = 0; e < a && (c++, s = s.nextZ, !!s); e++) ;
            let h = a;
            for (; c > 0 || h > 0 && s;) c !== 0 && (h === 0 || !s || t(n) <= t(s)) ? (r = n, n = n.nextZ, c--) : (r = s, s = s.nextZ, h--), l ? l.nextZ = r : i = r, r.prevZ = l, l = r;
            n = s
        }
        l.nextZ = null, a *= 2
    } while (o > 1);
    return i
};
var P6 = C6;
const R6 = P6;

class $M {
    constructor(t, e, n) {
        this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
}

const L6 = (i, t, e, n) => {
    const s = new $M(i, t, e);
    return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s
}, N6 = i => {
    i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
};
var WM = {Node: $M, insertNode: L6, removeNode: N6, sortLinked: R6};
const O6 = (i, t, e, n, s, r, o, a) => (s - o) * (t - a) - (i - o) * (r - a) >= 0 && (i - o) * (n - a) - (e - o) * (t - a) >= 0 && (e - o) * (r - a) - (s - o) * (n - a) >= 0,
    D6 = (i, t, e) => (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
var Y_ = {area: D6, pointInTriangle: O6};
const {Node: iv, insertNode: rv, removeNode: Dd} = WM, {area: _s} = Y_, F6 = (i, t, e, n, s) => {
        let r;
        if (s === V6(i, t, e, n) > 0) for (let o = t; o < e; o += n) r = rv(o, i[o], i[o + 1], r); else for (let o = e - n; o >= t; o -= n) r = rv(o, i[o], i[o + 1], r);
        return r && tp(r, r.next) && (Dd(r), r = r.next), r
    }, qM = (i, t) => {
        if (!i) return i;
        t || (t = i);
        let e = i, n;
        do if (n = !1, !e.steiner && (tp(e, e.next) || _s(e.prev, e, e.next) === 0)) {
            if (Dd(e), e = t = e.prev, e === e.next) break;
            n = !0
        } else e = e.next; while (n || e !== t);
        return t
    }, z6 = (i, t, e) => {
        let n = i;
        do {
            const s = n.prev, r = n.next.next;
            !tp(s, r) && YM(s, n, n.next, r) && oh(s, r) && oh(r, s) && (t.push(s.i / e), t.push(n.i / e), t.push(r.i / e), Dd(n), Dd(n.next), n = i = r), n = n.next
        } while (n !== i);
        return qM(n)
    }, B6 = (i, t) => {
        let e = i;
        do {
            if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && YM(e, e.next, i, t)) return !0;
            e = e.next
        } while (e !== i);
        return !1
    },
    oh = (i, t) => _s(i.prev, i, i.next) < 0 ? _s(i, t, i.next) >= 0 && _s(i, i.prev, t) >= 0 : _s(i, t, i.prev) < 0 || _s(i, i.next, t) < 0,
    k6 = (i, t) => {
        let e = i, n = !1;
        const s = (i.x + t.x) / 2, r = (i.y + t.y) / 2;
        do e.y > r != e.next.y > r && e.next.y !== e.y && s < (e.next.x - e.x) * (r - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next; while (e !== i);
        return n
    }, U6 = (i, t) => {
        const e = new iv(i.i, i.x, i.y), n = new iv(t.i, t.x, t.y), s = i.next, r = t.prev;
        return i.next = t, t.prev = i, e.next = s, s.prev = e, n.next = e, e.prev = n, r.next = n, n.prev = r, n
    },
    G6 = (i, t) => i.next.i !== t.i && i.prev.i !== t.i && !B6(i, t) && (oh(i, t) && oh(t, i) && k6(i, t) && (_s(i.prev, i, t.prev) || _s(i, t.prev, t)) || tp(i, t) && _s(i.prev, i, i.next) > 0 && _s(t.prev, t, t.next) > 0),
    YM = (i, t, e, n) => {
        const s = Math.sign(_s(i, t, e)), r = Math.sign(_s(i, t, n)), o = Math.sign(_s(e, n, i)),
            a = Math.sign(_s(e, n, t));
        return !!(s !== r && o !== a || s === 0 && Ou(i, e, t) || r === 0 && Ou(i, n, t) || o === 0 && Ou(e, i, n) || a === 0 && Ou(e, t, n))
    },
    Ou = (i, t, e) => t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y),
    V6 = (i, t, e, n) => {
        let s = 0;
        for (let r = t, o = e - n; r < e; r += n) s += (i[o] - i[r]) * (i[r + 1] + i[o + 1]), o = r;
        return s
    }, tp = (i, t) => i.x === t.x && i.y === t.y;
var XM = {
    cureLocalIntersections: z6,
    filterPoints: qM,
    isValidDiagonal: G6,
    linkedPolygon: F6,
    locallyInside: oh,
    splitPolygon: U6
};
const {filterPoints: Bm, linkedPolygon: H6, locallyInside: $6, splitPolygon: W6} = XM, {
    area: ov,
    pointInTriangle: q6
} = Y_, Y6 = (i, t, e, n) => {
    const s = [];
    for (let r = 0, o = t.length; r < o; r++) {
        const a = t[r] * n, l = r < o - 1 ? t[r + 1] * n : i.length, c = H6(i, a, l, n, !1);
        c === c.next && (c.steiner = !0), s.push(K6(c))
    }
    s.sort((r, o) => r.x - o.x);
    for (let r = 0; r < s.length; r++) e = X6(s[r], e), e = Bm(e, e.next);
    return e
}, X6 = (i, t) => {
    const e = Z6(i, t);
    if (!e) return t;
    const n = W6(e, i), s = Bm(e, e.next);
    return Bm(n, n.next), t === e ? s : t
}, Z6 = (i, t) => {
    let e = t;
    const n = i.x, s = i.y;
    let r = -1 / 0, o;
    do {
        if (s <= e.y && s >= e.next.y && e.next.y !== e.y) {
            const u = e.x + (s - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
            if (u <= n && u > r) {
                if (r = u, u === n) {
                    if (s === e.y) return e;
                    if (s === e.next.y) return e.next
                }
                o = e.x < e.next.x ? e : e.next
            }
        }
        e = e.next
    } while (e !== t);
    if (!o) return null;
    if (n === r) return o;
    const a = o, l = o.x, c = o.y;
    let h = 1 / 0;
    e = o;
    do {
        if (n >= e.x && e.x >= l && n !== e.x && q6(s < c ? n : r, s, l, c, s < c ? r : n, s, e.x, e.y)) {
            const u = Math.abs(s - e.y) / (n - e.x);
            $6(e, i) && (u < h || u === h && (e.x > o.x || e.x === o.x && j6(o, e))) && (o = e, h = u)
        }
        e = e.next
    } while (e !== a);
    return o
}, j6 = (i, t) => ov(i.prev, i, t.prev) < 0 && ov(t.next, i, i.next) < 0, K6 = i => {
    let t = i, e = i;
    do (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next; while (t !== i);
    return e
};
var J6 = Y6;
const Q6 = J6, {removeNode: tW, sortLinked: eW} = WM, {
        cureLocalIntersections: nW,
        filterPoints: Fd,
        isValidDiagonal: sW,
        linkedPolygon: iW,
        splitPolygon: rW
    } = XM, {area: So, pointInTriangle: yc} = Y_, oW = (i, t, e = 2) => {
        const n = t && t.length, s = n ? t[0] * e : i.length;
        let r = iW(i, 0, s, e, !0);
        const o = [];
        if (!r || r.next === r.prev) return o;
        let a, l, c, h, u;
        if (n && (r = Q6(i, t, r, e)), i.length > 80 * e) {
            a = c = i[0], l = h = i[1];
            for (let d = e; d < s; d += e) {
                const f = i[d], g = i[d + 1];
                f < a && (a = f), g < l && (l = g), f > c && (c = f), g > h && (h = g)
            }
            u = Math.max(c - a, h - l), u = u !== 0 ? 1 / u : 0
        }
        return ah(r, o, e, a, l, u), o
    }, ah = (i, t, e, n, s, r, o) => {
        if (!i) return;
        !o && r && hW(i, n, s, r);
        let a = i, l, c;
        for (; i.prev !== i.next;) {
            if (l = i.prev, c = i.next, r ? lW(i, n, s, r) : aW(i)) {
                t.push(l.i / e), t.push(i.i / e), t.push(c.i / e), tW(i), i = c.next, a = c.next;
                continue
            }
            if (i = c, i === a) {
                o ? o === 1 ? (i = nW(Fd(i), t, e), ah(i, t, e, n, s, r, 2)) : o === 2 && cW(i, t, e, n, s, r) : ah(Fd(i), t, e, n, s, r, 1);
                break
            }
        }
    }, aW = i => {
        const t = i.prev, e = i, n = i.next;
        if (So(t, e, n) >= 0) return !1;
        let s = i.next.next;
        for (; s !== i.prev;) {
            if (yc(t.x, t.y, e.x, e.y, n.x, n.y, s.x, s.y) && So(s.prev, s, s.next) >= 0) return !1;
            s = s.next
        }
        return !0
    }, lW = (i, t, e, n) => {
        const s = i.prev, r = i, o = i.next;
        if (So(s, r, o) >= 0) return !1;
        const a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x,
            l = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y,
            c = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x,
            h = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y, u = km(a, l, t, e, n), d = km(c, h, t, e, n);
        let f = i.prevZ, g = i.nextZ;
        for (; f && f.z >= u && g && g.z <= d;) {
            if (f !== i.prev && f !== i.next && yc(s.x, s.y, r.x, r.y, o.x, o.y, f.x, f.y) && So(f.prev, f, f.next) >= 0 || (f = f.prevZ, g !== i.prev && g !== i.next && yc(s.x, s.y, r.x, r.y, o.x, o.y, g.x, g.y) && So(g.prev, g, g.next) >= 0)) return !1;
            g = g.nextZ
        }
        for (; f && f.z >= u;) {
            if (f !== i.prev && f !== i.next && yc(s.x, s.y, r.x, r.y, o.x, o.y, f.x, f.y) && So(f.prev, f, f.next) >= 0) return !1;
            f = f.prevZ
        }
        for (; g && g.z <= d;) {
            if (g !== i.prev && g !== i.next && yc(s.x, s.y, r.x, r.y, o.x, o.y, g.x, g.y) && So(g.prev, g, g.next) >= 0) return !1;
            g = g.nextZ
        }
        return !0
    }, cW = (i, t, e, n, s, r) => {
        let o = i;
        do {
            let a = o.next.next;
            for (; a !== o.prev;) {
                if (o.i !== a.i && sW(o, a)) {
                    let l = rW(o, a);
                    o = Fd(o, o.next), l = Fd(l, l.next), ah(o, t, e, n, s, r), ah(l, t, e, n, s, r);
                    return
                }
                a = a.next
            }
            o = o.next
        } while (o !== i)
    }, hW = (i, t, e, n) => {
        let s = i;
        do s.z === null && (s.z = km(s.x, s.y, t, e, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; while (s !== i);
        s.prevZ.nextZ = null, s.prevZ = null, eW(s, r => r.z)
    },
    km = (i, t, e, n, s) => (i = 32767 * (i - e) * s, t = 32767 * (t - n) * s, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1);
var uW = oW;
const {area: dW} = Oh, {toOutlines: fW} = xe, {arePointsInside: pW} = VM, gW = i => {
    const t = fW(i), e = [], n = [];
    t.forEach((o, a) => {
        const l = dW(o);
        l < 0 ? n.push(a) : l > 0 && e.push(a)
    });
    const s = [], r = [];
    return e.forEach((o, a) => {
        const l = t[o];
        s[a] = [], n.forEach((c, h) => {
            const u = t[c];
            pW([u[0]], {vertices: l}) && (s[a].push(c), r[h] || (r[h] = []), r[h].push(a))
        })
    }), n.forEach((o, a) => {
        if (r[a] && r[a].length > 1) {
            const l = mW(r[a], c => s[c].length);
            r[a].forEach((c, h) => {
                h !== l && (s[c] = s[c].filter(u => u !== o))
            })
        }
    }), s.map((o, a) => ({solid: t[e[a]], holes: o.map(l => t[l])}))
}, mW = (i, t) => {
    let e, n;
    return i.forEach((s, r) => {
        const o = t(s);
        (n === void 0 || o < n) && (e = r, n = o)
    }), e
};
var _W = gW;
const yW = xe, av = Hi, xW = te, zn = kt, vW = HM, wW = _W;

class bW {
    constructor(t) {
        this.plane = vW(t);
        const e = zn.orthogonal(zn.create(), this.plane), n = zn.cross(zn.create(), this.plane, e);
        this.v = zn.normalize(n, n), this.u = zn.cross(zn.create(), this.v, this.plane), this.basisMap = new Map;
        const s = t.edges.map(o => o.map(a => this.to2D(a))), r = yW.create(s);
        this.roots = wW(r)
    }

    to2D(t) {
        const e = xW.fromValues(zn.dot(t, this.u), zn.dot(t, this.v));
        return this.basisMap.set(e, t), e
    }

    to3D(t) {
        const e = this.basisMap.get(t);
        if (e) return e;
        {
            console.log("Warning: point not in original slice");
            const n = zn.scale(zn.create(), this.u, t[0]), s = zn.scale(zn.create(), this.v, t[1]),
                r = zn.scale(zn.create(), av, av[3]), o = zn.add(n, n, r);
            return zn.add(s, s, o)
        }
    }
}

var EW = bW;
const SW = Be, MW = uW, TW = EW, IW = i => {
    const t = new TW(i), e = [];
    return t.roots.forEach(({solid: n, holes: s}) => {
        let r = n.length;
        const o = [];
        s.forEach((u, d) => {
            o.push(r), r += u.length
        });
        const a = [n, ...s].flat(), l = a.flat(), c = u => t.to3D(a[u]), h = MW(l, o);
        for (let u = 0; u < h.length; u += 3) {
            const d = h.slice(u, u + 3).map(c);
            e.push(SW.fromPointsAndPlane(d, t.plane))
        }
    }), e
};
var AW = IW;
const lv = kt, CW = i => i.reduce((t, e) => t += `[${lv.toString(e[0])}, ${lv.toString(e[1])}], `, ""),
    PW = i => `[${CW(i.edges)}]`;
var RW = PW;
const Du = kt, LW = ta, NW = (i, t) => {
    const e = t.edges.map(n => [Du.transform(Du.create(), n[0], i), Du.transform(Du.create(), n[1], i)]);
    return LW(e)
};
var OW = NW, zh = {
    calculatePlane: HM,
    clone: d6,
    create: ta,
    equals: g6,
    fromPoints: y6,
    fromSides: w6,
    isA: E6,
    reverse: T6,
    toEdges: A6,
    toPolygons: AW,
    toString: RW,
    transform: OW
};
const cv = kt, DW = ta, FW = i => {
    if (!i.edges) return i;
    let t = i.edges;
    const e = new Map, n = new Map;
    t = t.filter(o => !cv.equals(o[0], o[1])), t.forEach(o => {
        const a = o[0].toString(), l = o[1].toString();
        e.set(a, o[0]), e.set(l, o[1]), n.set(a, (n.get(a) || 0) + 1), n.set(l, (n.get(l) || 0) - 1)
    });
    const s = [], r = [];
    return n.forEach((o, a) => {
        o < 0 && s.push(a), o > 0 && r.push(a)
    }), s.forEach(o => {
        const a = e.get(o);
        let l = 1 / 0, c;
        r.forEach(h => {
            const u = e.get(h), d = cv.distance(a, u);
            d < l && (l = d, c = u)
        }), console.warn(`slice.repair: repairing vertex gap ${a} to ${c} distance ${l}`), t = t.map(h => h[0].toString() === o ? [c, h[1]] : h[1].toString() === o ? [h[0], c] : h)
    }), DW(t)
};
var zW = FW;
const {EPS: hv} = me, Ea = kt, Fu = Be, uv = zh,
    Um = (i, t) => i === t ? i : i < t ? Um(t, i) : t === 1 ? 1 : t === 0 ? i : Um(t, i % t),
    BW = (i, t) => i * t / Um(i, t), dv = (i, t) => {
        const e = i / t.length;
        if (e === 1) return t;
        const n = Ea.fromValues(e, e, e), s = [];
        return t.forEach(r => {
            const o = Ea.subtract(Ea.create(), r[1], r[0]);
            Ea.divide(o, o, n);
            let a = r[0];
            for (let l = 1; l <= e; ++l) {
                const c = Ea.add(Ea.create(), a, o);
                s.push([a, c]), a = c
            }
        }), s
    }, fv = hv * hv / 2 * Math.sin(Math.PI / 3), kW = (i, t) => {
        let e = uv.toEdges(i), n = uv.toEdges(t);
        if (e.length !== n.length) {
            const r = BW(e.length, n.length);
            r !== e.length && (e = dv(r, e)), r !== n.length && (n = dv(r, n))
        }
        const s = [];
        return e.forEach((r, o) => {
            const a = n[o], l = Fu.create([r[0], r[1], a[1]]), c = Fu.measureArea(l);
            Number.isFinite(c) && c > fv && s.push(l);
            const h = Fu.create([r[0], a[1], a[0]]), u = Fu.measureArea(h);
            Number.isFinite(u) && u > fv && s.push(h)
        }), s
    };
var UW = kW;
const pv = He, gv = xe, GW = le, Gm = Be, Rr = zh, VW = zW, mv = UW, HW = (i, t, e) => {
    let n = null;
    return gv.isA(e) && (n = Rr.fromSides(gv.toSides(e))), Gm.isA(e) && (n = Rr.fromPoints(Gm.toPoints(e))), i === 0 || i === 1 ? Rr.transform(pv.fromTranslation(pv.create(), [0, 0, i]), n) : null
}, $W = (i, t) => {
    const e = {numberOfSlices: 2, capStart: !0, capEnd: !0, close: !1, repair: !0, callback: HW}, {
        numberOfSlices: n,
        capStart: s,
        capEnd: r,
        close: o,
        repair: a,
        callback: l
    } = Object.assign({}, e, i);
    if (n < 2) throw new Error("numberOfSlices must be 2 or more");
    a && (t = VW(t));
    const c = n - 1;
    let h = null, u = null, d = null, f = [];
    for (let g = 0; g < n; g++) {
        const m = l(g / c, g, t);
        if (m) {
            if (!Rr.isA(m)) throw new Error("the callback function must return slice objects");
            if (Rr.toEdges(m).length === 0) throw new Error("the callback function must return slices with one or more edges");
            d && (f = f.concat(mv(d, m))), g === 0 && (h = m), g === n - 1 && (u = m), d = m
        }
    }
    if (r) {
        const g = Rr.toPolygons(u);
        f = f.concat(g)
    }
    if (s) {
        const g = Rr.toPolygons(h).map(Gm.invert);
        f = f.concat(g)
    }
    return !s && !r && o && !Rr.equals(u, h) && (f = f.concat(mv(u, h))), GW.create(f)
};
var X_ = $W;
const ZM = i => i.reduce((t, e) => Array.isArray(e) ? t.concat(ZM(e)) : t.concat(e), []);
var Xe = ZM;
const rc = He, dg = kt, WW = xe, fg = zh, qW = X_, YW = (i, t) => {
    const e = {offset: [0, 0, 1], twistAngle: 0, twistSteps: 12, repair: !0};
    let {offset: n, twistAngle: s, twistSteps: r, repair: o} = Object.assign({}, e, i);
    if (r < 1) throw new Error("twistSteps must be 1 or more");
    s === 0 && (r = 1);
    const a = dg.clone(n), l = WW.toSides(t);
    if (l.length === 0) throw new Error("the given geometry cannot be empty");
    const c = fg.fromSides(l);
    a[2] < 0 && fg.reverse(c, c);
    const h = rc.create(), u = (d, f, g) => {
        const m = f / r * s, p = dg.scale(dg.create(), a, f / r);
        return rc.multiply(h, rc.fromZRotation(h, m), rc.fromTranslation(rc.create(), p)), fg.transform(h, g)
    };
    return i = {numberOfSlices: r + 1, capStart: !0, capEnd: !0, repair: o, callback: u}, qW(i, c)
};
var ep = YW;
const XW = xe, ZW = Fn, jW = ep, KW = (i, t) => {
    if (!t.isClosed) throw new Error("extruded path must be closed");
    const e = ZW.toPoints(t), n = XW.fromPoints(e);
    return jW(i, n)
};
var JW = KW;
const QW = Xe, t8 = xe, e8 = Fn, n8 = ep, s8 = JW, i8 = (i, ...t) => {
    const e = {height: 1, twistAngle: 0, twistSteps: 1, repair: !0}, {
        height: n,
        twistAngle: s,
        twistSteps: r,
        repair: o
    } = Object.assign({}, e, i);
    if (t = QW(t), t.length === 0) throw new Error("wrong number of arguments");
    i = {offset: [0, 0, n], twistAngle: s, twistSteps: r, repair: o};
    const a = t.map(l => e8.isA(l) ? s8(i, l) : t8.isA(l) ? n8(i, l) : l);
    return a.length === 1 ? a[0] : a
};
var r8 = i8;
const {EPS: o8, TAU: a8} = me, _v = cM, oc = V_, je = te, l8 = Yf, c8 = (i, t) => {
    const e = {delta: 1, corners: "edge", closed: !1, segments: 16};
    let {delta: n, corners: s, closed: r, segments: o} = Object.assign({}, e, i);
    if (Math.abs(n) < o8) return t;
    let a = i.closed ? l8(t) : 1;
    a === 0 && (a = 1);
    const l = a > 0 && n >= 0 || a < 0 && n < 0;
    n = Math.abs(n);
    let c = null, h = [];
    const u = [], d = je.create(), f = t.length;
    for (let g = 0; g < f; g++) {
        const m = (g + 1) % f, p = t[g], _ = t[m];
        l ? je.subtract(d, p, _) : je.subtract(d, _, p), je.normal(d, d), je.normalize(d, d), je.scale(d, d, n);
        const x = je.add(je.create(), p, d), y = je.add(je.create(), _, d), v = [x, y];
        if (c != null && (r || !r && m !== 0)) {
            const w = _v(c[0], c[1], v[0], v[1]);
            w ? (h.pop(), v[0] = w) : u.push({c: p, s0: c, s1: v})
        }
        c = [x, y], !(m === 0 && !r) && (h.push(v[0]), h.push(v[1]))
    }
    if (r && c != null) {
        const g = h[0], m = h[1], p = _v(c[0], c[1], g, m);
        if (p) h[0] = p, h.pop(); else {
            const _ = t[0], x = [g, m];
            u.push({c: _, s0: c, s1: x})
        }
    }
    if (s === "edge") {
        const g = new Map;
        h.forEach((_, x) => g.set(_, x));
        const m = oc.create(), p = oc.create();
        u.forEach(_ => {
            oc.fromPoints(m, _.s0[0], _.s0[1]), oc.fromPoints(p, _.s1[0], _.s1[1]);
            const x = oc.intersectPointOfLines(m, p);
            if (Number.isFinite(x[0]) && Number.isFinite(x[1])) {
                const y = _.s0[1], v = g.get(y);
                h[v] = x, h[(v + 1) % h.length] = void 0
            } else {
                const y = _.s1[0], v = g.get(y);
                h[v] = void 0
            }
        }), h = h.filter(_ => _ !== void 0)
    }
    if (s === "round") {
        let g = Math.floor(o / 4);
        const m = je.create();
        u.forEach(p => {
            let _ = je.angle(je.subtract(m, p.s1[0], p.c));
            if (_ -= je.angle(je.subtract(m, p.s0[1], p.c)), l && _ < 0 && (_ = _ + Math.PI, _ < 0 && (_ = _ + Math.PI)), !l && _ > 0 && (_ = _ - Math.PI, _ > 0 && (_ = _ - Math.PI)), _ !== 0) {
                g = Math.floor(o * (Math.abs(_) / a8));
                const x = _ / g, y = je.angle(je.subtract(m, p.s0[1], p.c)), v = [];
                for (let w = 1; w < g; w++) {
                    const E = y + x * w, S = je.fromAngleRadians(je.create(), E);
                    je.scale(S, S, n), je.add(S, S, p.c), v.push(S)
                }
                if (v.length > 0) {
                    const w = p.s0[1];
                    let E = h.findIndex(S => je.equals(w, S));
                    E = (E + 1) % h.length, h.splice(E, 0, ...v)
                }
            } else {
                const x = p.s1[0], y = h.findIndex(v => je.equals(x, v));
                h.splice(y, 1)
            }
        })
    }
    return h
};
var jM = c8;
const zu = xe, h8 = jM, u8 = (i, t) => {
    const e = {delta: 1, corners: "edge", segments: 16}, {delta: n, corners: s, segments: r} = Object.assign({}, e, i);
    if (!(s === "edge" || s === "chamfer" || s === "round")) throw new Error('corners must be "edge", "chamfer", or "round"');
    const l = zu.toOutlines(t).map(c => (i = {
        delta: n,
        corners: s,
        closed: !0,
        segments: r
    }, h8(i, c))).reduce((c, h) => c.concat(zu.toSides(zu.fromPoints(h))), []);
    return zu.create(l)
};
var d8 = u8;
const f8 = xe, p8 = le, g8 = Fn, m8 = i => {
    let t;
    for (const e of i) {
        let n = 0;
        if (f8.isA(e) && (n = 1), p8.isA(e) && (n = 2), g8.isA(e) && (n = 3), t && n !== t) return !1;
        t = n
    }
    return !0
};
var np = m8;
const {EPS: _8} = me, y8 = (i, t) => {
    let e = 0;
    for (let n = 0; n < t; n++) e += i[1][n] - i[0][n];
    return _8 * e / t
};
var x8 = y8;
const v8 = Xe, Ai = te, ac = kt, KM = xe, JM = le, QM = Fn, yv = Be, yl = new WeakMap, w8 = i => {
    let t = yl.get(i);
    if (t) return t;
    const e = QM.toPoints(i);
    let n;
    e.length === 0 ? n = Ai.create() : n = Ai.clone(e[0]);
    let s = Ai.clone(n);
    return e.forEach(r => {
        Ai.min(n, n, r), Ai.max(s, s, r)
    }), n = [n[0], n[1], 0], s = [s[0], s[1], 0], t = [n, s], yl.set(i, t), t
}, b8 = i => {
    let t = yl.get(i);
    if (t) return t;
    const e = KM.toPoints(i);
    let n;
    e.length === 0 ? n = Ai.create() : n = Ai.clone(e[0]);
    let s = Ai.clone(n);
    return e.forEach(r => {
        Ai.min(n, n, r), Ai.max(s, s, r)
    }), n = [n[0], n[1], 0], s = [s[0], s[1], 0], t = [n, s], yl.set(i, t), t
}, E8 = i => {
    let t = yl.get(i);
    if (t) return t;
    const e = JM.toPolygons(i);
    let n = ac.create();
    if (e.length > 0) {
        const r = yv.toPoints(e[0]);
        ac.copy(n, r[0])
    }
    let s = ac.clone(n);
    return e.forEach(r => {
        yv.toPoints(r).forEach(o => {
            ac.min(n, n, o), ac.max(s, s, o)
        })
    }), n = [n[0], n[1], n[2]], s = [s[0], s[1], s[2]], t = [n, s], yl.set(i, t), t
}, S8 = (...i) => {
    if (i = v8(i), i.length === 0) throw new Error("wrong number of arguments");
    const t = i.map(e => QM.isA(e) ? w8(e) : KM.isA(e) ? b8(e) : JM.isA(e) ? E8(e) : [[0, 0, 0], [0, 0, 0]]);
    return t.length === 1 ? t[0] : t
};
var sp = S8;
const M8 = Xe, {geom2: T8, geom3: I8, path2: A8} = Yr, Z_ = x8, j_ = sp, C8 = i => Z_(j_(i), 2), P8 = i => Z_(j_(i), 2),
    R8 = i => Z_(j_(i), 3), L8 = (...i) => {
        if (i = M8(i), i.length === 0) throw new Error("wrong number of arguments");
        const t = i.map(e => A8.isA(e) ? C8(e) : T8.isA(e) ? P8(e) : I8.isA(e) ? R8(e) : 0);
        return t.length === 1 ? t[0] : t
    };
var Bh = L8;
const xv = te, N8 = xe, O8 = (i, t) => {
    if (t.vertices.length < 4) return null;
    const e = [], n = t.vertices.filter((o, a) => o[2] > 0 ? (e.push(a), !0) : !1);
    if (n.length !== 2) throw new Error("Assertion failed: fromFakePolygon: not enough points found");
    const s = n.map(o => {
        const a = Math.round(o[0] / i) * i + 0, l = Math.round(o[1] / i) * i + 0;
        return xv.fromValues(a, l)
    });
    if (xv.equals(s[0], s[1])) return null;
    const r = e[1] - e[0];
    if (r === 1 || r === 3) r === 1 && s.reverse(); else throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");
    return s
}, D8 = (i, t) => {
    const e = t.map(n => O8(i, n)).filter(n => n !== null);
    return N8.create(e)
};
var K_ = D8;
const br = kt, F8 = xe, z8 = le, B8 = Be, k8 = (i, t, e) => {
    const n = [br.fromVec2(br.create(), e[0], i), br.fromVec2(br.create(), e[1], i), br.fromVec2(br.create(), e[1], t), br.fromVec2(br.create(), e[0], t)];
    return B8.create(n)
}, U8 = (i, t) => {
    const n = F8.toSides(t).map(r => k8(i.z0, i.z1, r));
    return z8.create(n)
};
var J_ = U8;
const vv = He, G8 = te, yn = kt, Wo = function (i, t) {
    arguments.length < 2 && (t = yn.orthogonal(yn.create(), i)), this.v = yn.normalize(yn.create(), yn.cross(yn.create(), i, t)), this.u = yn.cross(yn.create(), this.v, i), this.plane = i, this.planeorigin = yn.scale(yn.create(), i, i[3])
};
Wo.GetCartesian = function (i, t) {
    const e = i + "/" + t;
    let n, s;
    if (e === "X/Y") n = [0, 0, 1], s = [1, 0, 0]; else if (e === "Y/-X") n = [0, 0, 1], s = [0, 1, 0]; else if (e === "-X/-Y") n = [0, 0, 1], s = [-1, 0, 0]; else if (e === "-Y/X") n = [0, 0, 1], s = [0, -1, 0]; else if (e === "-X/Y") n = [0, 0, -1], s = [-1, 0, 0]; else if (e === "-Y/-X") n = [0, 0, -1], s = [0, -1, 0]; else if (e === "X/-Y") n = [0, 0, -1], s = [1, 0, 0]; else if (e === "Y/X") n = [0, 0, -1], s = [0, 1, 0]; else if (e === "X/Z") n = [0, -1, 0], s = [1, 0, 0]; else if (e === "Z/-X") n = [0, -1, 0], s = [0, 0, 1]; else if (e === "-X/-Z") n = [0, -1, 0], s = [-1, 0, 0]; else if (e === "-Z/X") n = [0, -1, 0], s = [0, 0, -1]; else if (e === "-X/Z") n = [0, 1, 0], s = [-1, 0, 0]; else if (e === "-Z/-X") n = [0, 1, 0], s = [0, 0, -1]; else if (e === "X/-Z") n = [0, 1, 0], s = [1, 0, 0]; else if (e === "Z/X") n = [0, 1, 0], s = [0, 0, 1]; else if (e === "Y/Z") n = [1, 0, 0], s = [0, 1, 0]; else if (e === "Z/-Y") n = [1, 0, 0], s = [0, 0, 1]; else if (e === "-Y/-Z") n = [1, 0, 0], s = [0, -1, 0]; else if (e === "-Z/Y") n = [1, 0, 0], s = [0, 0, -1]; else if (e === "-Y/Z") n = [-1, 0, 0], s = [0, -1, 0]; else if (e === "-Z/-Y") n = [-1, 0, 0], s = [0, 0, -1]; else if (e === "Y/-Z") n = [-1, 0, 0], s = [0, 1, 0]; else if (e === "Z/Y") n = [-1, 0, 0], s = [0, 0, 1]; else throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");
    return new Wo(new Plane(new Vector3D(n), 0), new Vector3D(s))
};
Wo.Z0Plane = function () {
    const i = new Plane(new Vector3D([0, 0, 1]), 0);
    return new Wo(i, new Vector3D([1, 0, 0]))
};
Wo.prototype = {
    getProjectionMatrix: function () {
        return vv.fromValues(this.u[0], this.v[0], this.plane[0], 0, this.u[1], this.v[1], this.plane[1], 0, this.u[2], this.v[2], this.plane[2], 0, 0, 0, -this.plane[3], 1)
    }, getInverseProjectionMatrix: function () {
        const i = yn.scale(yn.create(), this.plane, this.plane[3]);
        return vv.fromValues(this.u[0], this.u[1], this.u[2], 0, this.v[0], this.v[1], this.v[2], 0, this.plane[0], this.plane[1], this.plane[2], 0, i[0], i[1], i[2], 1)
    }, to2D: function (i) {
        return G8.fromValues(yn.dot(i, this.u), yn.dot(i, this.v))
    }, to3D: function (i) {
        const t = yn.scale(yn.create(), this.u, i[0]), e = yn.scale(yn.create(), this.v, i[1]),
            n = yn.add(t, t, this.planeorigin);
        return yn.add(e, e, n)
    }, line3Dto2D: function (i) {
        const t = i.point, e = i.direction.plus(t), n = this.to2D(t), s = this.to2D(e);
        return Line2D.fromPoints(n, s)
    }, line2Dto3D: function (i) {
        const t = i.origin(), e = i.direction().plus(t), n = this.to3D(t), s = this.to3D(e);
        return Line3D.fromPoints(n, s)
    }, transform: function (i) {
        const t = this.plane.transform(i), e = this.u.transform(i), n = new Vector3D(0, 0, 0).transform(i),
            s = e.minus(n);
        return new Wo(t, s)
    }
};
var V8 = Wo;
const H8 = i => i * .017453292519943295;
var $8 = H8;
const W8 = (i, t) => i - t;
var tT = W8;
const q8 = (i, t, e) => {
    let n = 0, s = i.length;
    for (; s > n;) {
        const r = Math.floor((n + s) / 2), o = i[r];
        e(t, o) > 0 ? n = r + 1 : s = r
    }
    i.splice(n, 0, t)
};
var Y8 = q8;
const {TAU: wv} = me, X8 = (i, t, e) => {
    const n = t > 0 ? i * wv / t : 0, s = e > 0 ? wv / e : 0;
    return Math.ceil(Math.max(n, s, 4))
};
var Z8 = X8;
const j8 = i => i * 57.29577951308232;
var K8 = j8, J8 = {
    areAllShapesTheSameType: np,
    degToRad: $8,
    flatten: Xe,
    fnNumberSort: tT,
    insertSorted: Y8,
    radiusToSegments: Z8,
    radToDeg: K8
};
const {EPS: Qi} = me, Er = V_, ni = te, Q8 = V8, Sa = lM, {insertSorted: tq, fnNumberSort: eq} = J8, bv = Be,
    nq = i => {
        if (i.length < 2) return i;
        const t = [], e = i.length, n = bv.plane(i[0]), s = new Q8(n), r = [], o = [], a = new Map, l = new Map,
            c = new Map, h = 10 / Qi;
        for (let g = 0; g < e; g++) {
            const m = i[g];
            let p = [], _ = m.vertices.length, x = -1;
            if (_ > 0) {
                let y, v;
                for (let w = 0; w < _; w++) {
                    let E = s.to2D(m.vertices[w]);
                    const S = Math.floor(E[1] * h);
                    let b;
                    c.has(S) ? b = c.get(S) : c.has(S + 1) ? b = c.get(S + 1) : c.has(S - 1) ? b = c.get(S - 1) : (b = E[1], c.set(S, E[1])), E = ni.fromValues(E[0], b), p.push(E);
                    const M = E[1];
                    (w === 0 || M < y) && (y = M, x = w), (w === 0 || M > v) && (v = M);
                    let I = l.get(M);
                    I || (I = {}, l.set(M, I)), I[g] = !0
                }
                if (y >= v) p = [], _ = 0, x = -1; else {
                    let w = a.get(y);
                    w || (w = [], a.set(y, w)), w.push(g)
                }
            }
            p.reverse(), x = _ - x - 1, r.push(p), o.push(x)
        }
        const u = [];
        l.forEach((g, m) => u.push(m)), u.sort(eq);
        let d = [], f = [];
        for (let g = 0; g < u.length; g++) {
            const m = [], p = u[g], _ = l.get(p);
            for (let y = 0; y < d.length; ++y) {
                const v = d[y], w = v.polygonindex;
                if (_[w]) {
                    const E = r[w], S = E.length;
                    let b = v.leftvertexindex, M = v.rightvertexindex;
                    for (; ;) {
                        let N = b + 1;
                        if (N >= S && (N = 0), E[N][1] !== p) break;
                        b = N
                    }
                    let I = M - 1;
                    if (I < 0 && (I = S - 1), E[I][1] === p && (M = I), b !== v.leftvertexindex && b === M) d.splice(y, 1), --y; else {
                        v.leftvertexindex = b, v.rightvertexindex = M, v.topleft = E[b], v.topright = E[M];
                        let N = b + 1;
                        N >= S && (N = 0), v.bottomleft = E[N];
                        let B = M - 1;
                        B < 0 && (B = S - 1), v.bottomright = E[B]
                    }
                }
            }
            let x;
            if (g >= u.length - 1) d = [], x = null; else {
                x = Number(u[g + 1]);
                const y = .5 * (p + x), v = a.get(p);
                for (const w in v) {
                    const E = v[w], S = r[E], b = S.length, M = o[E];
                    let I = M;
                    for (; ;) {
                        let k = I + 1;
                        if (k >= b && (k = 0), S[k][1] !== p || k === M) break;
                        I = k
                    }
                    let N = M;
                    for (; ;) {
                        let k = N - 1;
                        if (k < 0 && (k = b - 1), S[k][1] !== p || k === I) break;
                        N = k
                    }
                    let B = I + 1;
                    B >= b && (B = 0);
                    let D = N - 1;
                    D < 0 && (D = b - 1);
                    const L = {
                        polygonindex: E,
                        leftvertexindex: I,
                        rightvertexindex: N,
                        topleft: S[I],
                        topright: S[N],
                        bottomleft: S[B],
                        bottomright: S[D]
                    };
                    tq(d, L, (k, G) => {
                        const Q = Sa(k.topleft, k.bottomleft, y), q = Sa(G.topleft, G.bottomleft, y);
                        return Q > q ? 1 : Q < q ? -1 : 0
                    })
                }
            }
            for (const y in d) {
                const v = d[y];
                let w = Sa(v.topleft, v.bottomleft, p);
                const E = ni.fromValues(w, p);
                w = Sa(v.topright, v.bottomright, p);
                const S = ni.fromValues(w, p);
                w = Sa(v.topleft, v.bottomleft, x);
                const b = ni.fromValues(w, x);
                w = Sa(v.topright, v.bottomright, x);
                const M = ni.fromValues(w, x), I = {
                    topleft: E,
                    topright: S,
                    bottomleft: b,
                    bottomright: M,
                    leftline: Er.fromPoints(Er.create(), E, b),
                    rightline: Er.fromPoints(Er.create(), M, S)
                };
                if (m.length > 0) {
                    const N = m[m.length - 1], B = ni.distance(I.topleft, N.topright),
                        D = ni.distance(I.bottomleft, N.bottomright);
                    B < Qi && D < Qi && (I.topleft = N.topleft, I.leftline = N.leftline, I.bottomleft = N.bottomleft, m.splice(m.length - 1, 1))
                }
                m.push(I)
            }
            if (g > 0) {
                const y = new Set, v = new Set;
                for (let w = 0; w < m.length; w++) {
                    const E = m[w];
                    for (let S = 0; S < f.length; S++) if (!v.has(S)) {
                        const b = f[S];
                        if (ni.distance(b.bottomleft, E.topleft) < Qi && ni.distance(b.bottomright, E.topright) < Qi) {
                            v.add(S);
                            const M = Er.direction(E.leftline), I = Er.direction(b.leftline), N = M[0] - I[0],
                                B = Er.direction(E.rightline), D = Er.direction(b.rightline), L = B[0] - D[0],
                                k = Math.abs(N) < Qi, G = Math.abs(L) < Qi, Q = k || N >= 0, q = G || L >= 0;
                            Q && q && (E.outpolygon = b.outpolygon, E.leftlinecontinues = k, E.rightlinecontinues = G, y.add(S));
                            break
                        }
                    }
                }
                for (let w = 0; w < f.length; w++) if (!y.has(w)) {
                    const E = f[w];
                    E.outpolygon.rightpoints.push(E.bottomright), ni.distance(E.bottomright, E.bottomleft) > Qi && E.outpolygon.leftpoints.push(E.bottomleft), E.outpolygon.leftpoints.reverse();
                    const b = E.outpolygon.rightpoints.concat(E.outpolygon.leftpoints).map(I => s.to3D(I)),
                        M = bv.fromPointsAndPlane(b, n);
                    M.vertices.length && t.push(M)
                }
            }
            for (let y = 0; y < m.length; y++) {
                const v = m[y];
                v.outpolygon ? (v.leftlinecontinues || v.outpolygon.leftpoints.push(v.topleft), v.rightlinecontinues || v.outpolygon.rightpoints.push(v.topright)) : (v.outpolygon = {
                    leftpoints: [],
                    rightpoints: []
                }, v.outpolygon.leftpoints.push(v.topleft), ni.distance(v.topleft, v.topright) > Qi && v.outpolygon.rightpoints.push(v.topright))
            }
            f = m
        }
        return t
    };
var sq = nq;
const Ev = le, Sv = Be, iq = G_, rq = sq, oq = (i, t) => Math.abs(i[3] - t[3]) < 15e-8 ? iq(i, t) : !1, aq = i => {
    if (i.isRetesselated) return i;
    const t = Ev.toPolygons(i), e = [];
    t.forEach(r => {
        const o = e.find(a => oq(a[0], Sv.plane(r)));
        o ? o[1].push(r) : e.push([Sv.plane(r), [r]])
    });
    let n = [];
    e.forEach(r => {
        const o = r[1], a = rq(o);
        n = n.concat(a)
    });
    const s = Ev.create(n);
    return s.isRetesselated = !0, s
};
var ip = aq;
const {EPS: Ma} = me, Mv = sp, lq = (i, t) => {
    if (i.polygons.length === 0 || t.polygons.length === 0) return !1;
    const e = Mv(i), n = e[0], s = e[1], r = Mv(t), o = r[0], a = r[1];
    return !(o[0] - s[0] > Ma || n[0] - a[0] > Ma || o[1] - s[1] > Ma || n[1] - a[1] > Ma || o[2] - s[2] > Ma || n[2] - a[2] > Ma)
};
var Q_ = lq;
const Tv = Hi, cq = Be;

class zd {
    constructor(t) {
        this.plane = null, this.front = null, this.back = null, this.polygontreenodes = [], this.parent = t
    }

    invert() {
        const t = [this];
        let e;
        for (let n = 0; n < t.length; n++) {
            e = t[n], e.plane && (e.plane = Tv.flip(Tv.create(), e.plane)), e.front && t.push(e.front), e.back && t.push(e.back);
            const s = e.front;
            e.front = e.back, e.back = s
        }
    }

    clipPolygons(t, e) {
        let n = {node: this, polygontreenodes: t}, s;
        const r = [];
        do {
            if (s = n.node, t = n.polygontreenodes, s.plane) {
                const o = s.plane, a = [], l = [], c = e ? a : l, h = t.length;
                for (let d = 0; d < h; d++) {
                    const f = t[d];
                    f.isRemoved() || f.splitByPlane(o, c, a, l, a)
                }
                s.front && l.length > 0 && r.push({node: s.front, polygontreenodes: l});
                const u = a.length;
                if (s.back && u > 0) r.push({
                    node: s.back,
                    polygontreenodes: a
                }); else for (let d = 0; d < u; d++) a[d].remove()
            }
            n = r.pop()
        } while (n !== void 0)
    }

    clipTo(t, e) {
        let n = this;
        const s = [];
        do n.polygontreenodes.length > 0 && t.rootnode.clipPolygons(n.polygontreenodes, e), n.front && s.push(n.front), n.back && s.push(n.back), n = s.pop(); while (n !== void 0)
    }

    addPolygonTreeNodes(t) {
        let e = {node: this, polygontreenodes: t};
        const n = [];
        do {
            const s = e.node, r = e.polygontreenodes;
            if (r.length === 0) {
                e = n.pop();
                continue
            }
            if (!s.plane) {
                let c = 0;
                c = Math.floor(r.length / 2);
                const h = r[c].getPolygon();
                s.plane = cq.plane(h)
            }
            const o = [], a = [], l = r.length;
            for (let c = 0; c < l; ++c) r[c].splitByPlane(s.plane, s.polygontreenodes, a, o, a);
            o.length > 0 && (s.front || (s.front = new zd(s)), l === o.length && a.length === 0 ? s.front.polygontreenodes = o : n.push({
                node: s.front,
                polygontreenodes: o
            })), a.length > 0 && (s.back || (s.back = new zd(s)), l === a.length && o.length === 0 ? s.back.polygontreenodes = a : n.push({
                node: s.back,
                polygontreenodes: a
            })), e = n.pop()
        } while (e !== void 0)
    }
}

var hq = zd;
const Ta = kt, uq = (i, t, e) => {
    const n = Ta.subtract(Ta.create(), e, t);
    let s = (i[3] - Ta.dot(i, t)) / Ta.dot(i, n);
    return Number.isNaN(s) && (s = 0), s > 1 && (s = 1), s < 0 && (s = 0), Ta.scale(n, n, s), Ta.add(n, t, n), n
};
var dq = uq;
const {EPS: Bu} = me, fq = Hi, ku = kt, pg = Be, pq = dq, gq = (i, t) => {
    const e = {type: null, front: null, back: null}, n = t.vertices, s = n.length, r = pg.plane(t);
    if (fq.equals(r, i)) e.type = 0; else {
        let o = !1, a = !1;
        const l = [], c = -Bu;
        for (let h = 0; h < s; h++) {
            const u = ku.dot(i, n[h]) - i[3], d = u < c;
            l.push(d), u > Bu && (o = !0), u < c && (a = !0)
        }
        if (!o && !a) {
            const h = ku.dot(i, r);
            e.type = h >= 0 ? 0 : 1
        } else if (!a) e.type = 2; else if (!o) e.type = 3; else {
            e.type = 4;
            const h = [], u = [];
            let d = l[0];
            for (let g = 0; g < s; g++) {
                const m = n[g];
                let p = g + 1;
                p >= s && (p = 0);
                const _ = l[p];
                if (d === _) d ? u.push(m) : h.push(m); else {
                    const x = n[p], y = pq(i, m, x);
                    d ? (u.push(m), u.push(y), h.push(y)) : (h.push(m), h.push(y), u.push(y))
                }
                d = _
            }
            const f = Bu * Bu;
            if (u.length >= 3) {
                let g = u[u.length - 1];
                for (let m = 0; m < u.length; m++) {
                    const p = u[m];
                    ku.squaredDistance(p, g) < f && (u.splice(m, 1), m--), g = p
                }
            }
            if (h.length >= 3) {
                let g = h[h.length - 1];
                for (let m = 0; m < h.length; m++) {
                    const p = h[m];
                    ku.squaredDistance(p, g) < f && (h.splice(m, 1), m--), g = p
                }
            }
            h.length >= 3 && (e.front = pg.fromPointsAndPlane(h, r)), u.length >= 3 && (e.back = pg.fromPointsAndPlane(u, r))
        }
    }
    return e
};
var mq = gq;
const {EPS: _q} = me, yq = kt, Iv = Be, xq = mq;

class ty {
    constructor(t, e) {
        this.parent = t, this.children = [], this.polygon = e, this.removed = !1
    }

    addPolygons(t) {
        if (!this.isRootNode()) throw new Error("Assertion failed");
        const e = this;
        t.forEach(n => {
            e.addChild(n)
        })
    }

    remove() {
        if (!this.removed) {
            this.removed = !0, this.polygon = null;
            const t = this.parent.children, e = t.indexOf(this);
            if (e < 0) throw new Error("Assertion failed");
            t.splice(e, 1), this.parent.recursivelyInvalidatePolygon()
        }
    }

    isRemoved() {
        return this.removed
    }

    isRootNode() {
        return !this.parent
    }

    invert() {
        if (!this.isRootNode()) throw new Error("Assertion failed");
        this.invertSub()
    }

    getPolygon() {
        if (!this.polygon) throw new Error("Assertion failed");
        return this.polygon
    }

    getPolygons(t) {
        let e = [this];
        const n = [e];
        let s, r, o, a;
        for (s = 0; s < n.length; ++s) for (e = n[s], r = 0, o = e.length; r < o; r++) a = e[r], a.polygon ? t.push(a.polygon) : a.children.length > 0 && n.push(a.children)
    }

    splitByPlane(t, e, n, s, r) {
        if (this.children.length) {
            const o = [this.children];
            let a, l, c, h, u;
            for (a = 0; a < o.length; a++) for (u = o[a], l = 0, c = u.length; l < c; l++) h = u[l], h.children.length > 0 ? o.push(h.children) : h._splitByPlane(t, e, n, s, r)
        } else this._splitByPlane(t, e, n, s, r)
    }

    _splitByPlane(t, e, n, s, r) {
        const o = this.polygon;
        if (o) {
            const a = Iv.measureBoundingSphere(o), l = a[3] + _q, c = a, h = yq.dot(t, c) - t[3];
            if (h > l) s.push(this); else if (h < -l) r.push(this); else {
                const u = xq(t, o);
                switch (u.type) {
                    case 0:
                        e.push(this);
                        break;
                    case 1:
                        n.push(this);
                        break;
                    case 2:
                        s.push(this);
                        break;
                    case 3:
                        r.push(this);
                        break;
                    case 4:
                        if (u.front) {
                            const d = this.addChild(u.front);
                            s.push(d)
                        }
                        if (u.back) {
                            const d = this.addChild(u.back);
                            r.push(d)
                        }
                        break
                }
            }
        }
    }

    addChild(t) {
        const e = new ty(this, t);
        return this.children.push(e), e
    }

    invertSub() {
        let t = [this];
        const e = [t];
        let n, s, r, o;
        for (n = 0; n < e.length; n++) for (t = e[n], s = 0, r = t.length; s < r; s++) o = t[s], o.polygon && (o.polygon = Iv.invert(o.polygon)), o.children.length > 0 && e.push(o.children)
    }

    recursivelyInvalidatePolygon() {
        this.polygon = null, this.parent && this.parent.recursivelyInvalidatePolygon()
    }

    clear() {
        let t = [this];
        const e = [t];
        for (let n = 0; n < e.length; ++n) {
            t = e[n];
            const s = t.length;
            for (let r = 0; r < s; r++) {
                const o = t[r];
                o.polygon && (o.polygon = null), o.parent && (o.parent = null), o.children.length > 0 && e.push(o.children), o.children = []
            }
        }
    }

    toString() {
        let t = "", e = [this];
        const n = [e];
        let s, r, o, a;
        for (s = 0; s < n.length; ++s) {
            e = n[s];
            const l = " ".repeat(s);
            for (r = 0, o = e.length; r < o; r++) a = e[r], t += `${l}PolygonTreeNode (${a.isRootNode()}): ${a.children.length}`, a.polygon ? t += `
 ${l}polygon: ${a.polygon.vertices}
` : t += `
`, a.children.length > 0 && n.push(a.children)
        }
        return t
    }
}

var vq = ty;
const wq = hq, bq = vq;

class Eq {
    constructor(t) {
        this.polygonTree = new bq, this.rootnode = new wq(null), t && this.addPolygons(t)
    }

    invert() {
        this.polygonTree.invert(), this.rootnode.invert()
    }

    clipTo(t, e = !1) {
        this.rootnode.clipTo(t, e)
    }

    allPolygons() {
        const t = [];
        return this.polygonTree.getPolygons(t), t
    }

    addPolygons(t) {
        const e = new Array(t.length);
        for (let n = 0; n < t.length; n++) e[n] = this.polygonTree.addChild(t[n]);
        this.rootnode.addPolygonTreeNodes(e)
    }

    clear() {
        this.polygonTree.clear()
    }

    toString() {
        return "Tree: " + this.polygonTree.toString("")
    }
}

var Sq = Eq, ey = {Tree: Sq};
const Ja = le, Mq = Q_, {Tree: Av} = ey, Tq = (i, t) => {
    if (!Mq(i, t)) return Iq(i, t);
    const e = new Av(Ja.toPolygons(i)), n = new Av(Ja.toPolygons(t));
    e.clipTo(n, !1), n.clipTo(e), n.invert(), n.clipTo(e), n.invert();
    const s = e.allPolygons().concat(n.allPolygons());
    return Ja.create(s)
}, Iq = (i, t) => {
    let e = Ja.toPolygons(i);
    return e = e.concat(Ja.toPolygons(t)), Ja.create(e)
};
var eT = Tq;
const Aq = Xe, Cq = ip, Pq = eT, Rq = (...i) => {
    i = Aq(i);
    let t;
    for (t = 1; t < i.length; t += 2) i.push(Pq(i[t - 1], i[t]));
    let e = i[t - 1];
    return e = Cq(e), e
};
var nT = Rq;
const Lq = Xe, Nq = le, Oq = Bh, Dq = K_, Fq = J_, zq = nT, Bq = (...i) => {
    i = Lq(i);
    const t = i.map(s => Fq({z0: -1, z1: 1}, s)), e = zq(t), n = Oq(e);
    return Dq(n, Nq.toPolygons(e))
};
var sT = Bq;
const kq = Xe, Uq = np, Gq = xe, Vq = le, Hq = sT, $q = nT, Wq = (...i) => {
    if (i = kq(i), i.length === 0) throw new Error("wrong number of arguments");
    if (!Uq(i)) throw new Error("only unions of the same type are supported");
    const t = i[0];
    return Gq.isA(t) ? Hq(i) : Vq.isA(t) ? $q(i) : t
};
var iT = Wq;
const qq = (i, t) => Array.isArray(i) && i.length >= t ? i.every(e => Number.isFinite(e)) : !1,
    Yq = (i, t) => Number.isFinite(i) && i > t, Xq = (i, t) => Number.isFinite(i) && i >= t;
var In = {isNumberArray: qq, isGT: Yq, isGTE: Xq};
const {TAU: Cv} = me, Lt = kt, Zq = le, Pv = Be, {sin: Rv, cos: Lv} = Vn, {isGTE: jq, isNumberArray: Nv} = In,
    Kq = i => {
        const t = {
            center: [0, 0, 0],
            radius: [1, 1, 1],
            segments: 32,
            axes: [[1, 0, 0], [0, -1, 0], [0, 0, 1]]
        }, {center: e, radius: n, segments: s, axes: r} = Object.assign({}, t, i);
        if (!Nv(e, 3)) throw new Error("center must be an array of X, Y and Z values");
        if (!Nv(n, 3)) throw new Error("radius must be an array of X, Y and Z values");
        if (!n.every(g => g > 0)) throw new Error("radius values must be greater than zero");
        if (!jq(s, 4)) throw new Error("segments must be four or more");
        const o = Lt.scale(Lt.create(), Lt.normalize(Lt.create(), r[0]), n[0]),
            a = Lt.scale(Lt.create(), Lt.normalize(Lt.create(), r[1]), n[1]),
            l = Lt.scale(Lt.create(), Lt.normalize(Lt.create(), r[2]), n[2]), c = Math.round(s / 4);
        let h;
        const u = [], d = Lt.create(), f = Lt.create();
        for (let g = 0; g <= s; g++) {
            const m = Cv * g / s, p = Lt.add(Lt.create(), Lt.scale(d, o, Lv(m)), Lt.scale(f, a, Rv(m)));
            if (g > 0) {
                let _, x;
                for (let y = 0; y <= c; y++) {
                    const v = Cv / 4 * y / c, w = Lv(v), E = Rv(v);
                    if (y > 0) {
                        let S = [], b;
                        b = Lt.subtract(Lt.create(), Lt.scale(d, h, _), Lt.scale(f, l, x)), S.push(Lt.add(b, b, e)), b = Lt.subtract(Lt.create(), Lt.scale(d, p, _), Lt.scale(f, l, x)), S.push(Lt.add(b, b, e)), y < c && (b = Lt.subtract(Lt.create(), Lt.scale(d, p, w), Lt.scale(f, l, E)), S.push(Lt.add(b, b, e))), b = Lt.subtract(Lt.create(), Lt.scale(d, h, w), Lt.scale(f, l, E)), S.push(Lt.add(b, b, e)), u.push(Pv.create(S)), S = [], b = Lt.add(Lt.create(), Lt.scale(d, h, _), Lt.scale(f, l, x)), S.push(Lt.add(Lt.create(), e, b)), b = Lt.add(b, Lt.scale(d, p, _), Lt.scale(f, l, x)), S.push(Lt.add(Lt.create(), e, b)), y < c && (b = Lt.add(b, Lt.scale(d, p, w), Lt.scale(f, l, E)), S.push(Lt.add(Lt.create(), e, b))), b = Lt.add(b, Lt.scale(d, h, w), Lt.scale(f, l, E)), S.push(Lt.add(Lt.create(), e, b)), S.reverse(), u.push(Pv.create(S))
                    }
                    _ = w, x = E
                }
            }
            h = p
        }
        return Zq.create(u)
    };
var rT = Kq;
const Jq = rT, {isGT: Qq} = In, tY = i => {
    const t = {center: [0, 0, 0], radius: 1, segments: 32, axes: [[1, 0, 0], [0, -1, 0], [0, 0, 1]]};
    let {center: e, radius: n, segments: s, axes: r} = Object.assign({}, t, i);
    if (!Qq(n, 0)) throw new Error("radius must be greater than zero");
    return n = [n, n, n], Jq({center: e, radius: n, segments: s, axes: r})
};
var oT = tY;
const Ov = He, eY = kt, nY = le, lc = Be, sY = (i, t) => {
    eY.dot(lc.plane(t), i) > 0 && (t = lc.invert(t));
    const n = [t], s = lc.transform(Ov.fromTranslation(Ov.create(), i), t), r = t.vertices.length;
    for (let o = 0; o < r; o++) {
        const a = o < r - 1 ? o + 1 : 0, l = lc.create([t.vertices[o], s.vertices[o], s.vertices[a], t.vertices[a]]);
        n.push(l)
    }
    return n.push(lc.invert(s)), nY.create(n)
};
var iY = sY;
const {EPS: rY, TAU: gg} = me, Dv = He, Ge = kt, oY = tT, mg = le, mo = Be, aY = oT, lY = ip, _g = eT, cY = iY,
    hY = (i, t, e) => {
        const n = t.toString();
        if (i.has(n)) i.get(n)[1].push(e); else {
            const s = [t, [e]];
            i.set(n, s)
        }
    }, uY = (i, t, e) => {
        const n = t[0].toString(), s = t[1].toString(), r = n < s ? `${n},${s}` : `${s},${n}`;
        if (i.has(r)) i.get(r)[1].push(e); else {
            const o = [t, [e]];
            i.set(r, o)
        }
    }, yg = (i, t) => {
        i.findIndex(n => n === t) < 0 && i.push(t)
    }, dY = (i, t) => {
        const e = {delta: 1, segments: 12}, {delta: n, segments: s} = Object.assign({}, e, i);
        let r = mg.create();
        const o = new Map, a = new Map, l = Ge.create(), c = Ge.create();
        return mg.toPolygons(t).forEach((u, d) => {
            const f = Ge.scale(Ge.create(), mo.plane(u), 2 * n),
                g = mo.transform(Dv.fromTranslation(Dv.create(), Ge.scale(Ge.create(), f, -.5)), u), m = cY(f, g);
            r = _g(r, m);
            const p = u.vertices;
            for (let _ = 0; _ < p.length; _++) {
                hY(o, p[_], mo.plane(u));
                const x = (_ + 1) % p.length, y = [p[_], p[x]];
                uY(a, y, mo.plane(u))
            }
        }), a.forEach(u => {
            const d = u[0], f = u[1], g = d[0], m = d[1], p = Ge.subtract(Ge.create(), m, g);
            Ge.normalize(p, p);
            const _ = f[0], x = Ge.cross(Ge.create(), _, p);
            let y = [];
            for (let N = 0; N < s; N++) yg(y, N * gg / s);
            for (let N = 0, B = f.length; N < B; N++) {
                const D = f[N], L = Ge.dot(x, D), k = Ge.dot(_, D);
                let G = Math.atan2(L, k);
                G < 0 && (G += gg), yg(y, G), G = Math.atan2(-L, -k), G < 0 && (G += gg), yg(y, G)
            }
            y = y.sort(oY);
            const v = y.length;
            let w, E;
            const S = [], b = [], M = [];
            for (let N = -1; N < v; N++) {
                const B = y[N < 0 ? N + v : N], D = Math.sin(B), L = Math.cos(B);
                Ge.scale(l, _, L * n), Ge.scale(c, x, D * n), Ge.add(l, l, c);
                const k = Ge.add(Ge.create(), g, l), G = Ge.add(Ge.create(), m, l);
                let Q = !1;
                if (N >= 0 && Ge.distance(k, w) < rY && (Q = !0), !Q) {
                    if (N >= 0) {
                        S.push(k), b.push(G);
                        const q = [E, G, k, w], at = mo.create(q);
                        M.push(at)
                    }
                    w = k, E = G
                }
            }
            b.reverse(), M.push(mo.create(S)), M.push(mo.create(b));
            const I = mg.create(M);
            r = _g(r, I)
        }), o.forEach(u => {
            const d = u[0], f = u[1], g = f[0];
            let m = null, p = 0;
            for (let v = 1; v < f.length; v++) {
                const w = f[v], E = Ge.cross(l, g, w), S = Ge.length(E);
                S > .05 && S > p && (p = S, m = w)
            }
            m || (m = Ge.orthogonal(l, g));
            const _ = Ge.cross(l, g, m);
            Ge.normalize(_, _);
            const x = Ge.cross(c, _, g), y = aY({center: [d[0], d[1], d[2]], radius: n, segments: s, axes: [g, _, x]});
            r = _g(r, y)
        }), lY(r)
    };
var fY = dY;
const pY = le, gY = iT, mY = fY, _Y = (i, t) => {
    const e = {delta: 1, corners: "round", segments: 12}, {delta: n, corners: s, segments: r} = Object.assign({}, e, i);
    if (s !== "round") throw new Error('corners must be "round" for 3D geometries');
    if (pY.toPolygons(t).length === 0) throw new Error("the given geometry cannot be empty");
    i = {delta: n, corners: s, segments: r};
    const a = mY(i, t);
    return gY(t, a)
};
var yY = _Y;
const xY = Yf, gs = te, Pa = xe, xc = Fn, Fv = jM, vY = i => {
    let {external: t, internal: e} = i;
    xY(t) < 0 ? t = t.reverse() : e = e.reverse();
    const n = xc.fromPoints({closed: !0}, t), s = xc.fromPoints({closed: !0}, e),
        r = Pa.toSides(Pa.fromPoints(xc.toPoints(n))), o = Pa.toSides(Pa.fromPoints(xc.toPoints(s)));
    return r.push(...o), Pa.create(r)
}, wY = (i, t, e, n) => {
    const {points: s, external: r, internal: o} = i, a = Math.floor(t / 2), l = [], c = [];
    if (e === "round" && a > 0) {
        const u = Math.PI / a, d = s[s.length - 1], f = gs.angle(gs.subtract(gs.create(), r[r.length - 1], d)),
            g = s[0], m = gs.angle(gs.subtract(gs.create(), o[0], g));
        for (let p = 1; p < a; p++) {
            let _ = f + u * p, x = gs.fromAngleRadians(gs.create(), _);
            gs.scale(x, x, n), gs.add(x, x, d), l.push(x), _ = m + u * p, x = gs.fromAngleRadians(gs.create(), _), gs.scale(x, x, n), gs.add(x, x, g), c.push(x)
        }
    }
    const h = [];
    return h.push(...r, ...l, ...o.reverse(), ...c), Pa.fromPoints(h)
}, bY = (i, t) => {
    i = Object.assign({}, {delta: 1, corners: "edge", segments: 16}, i);
    const {delta: n, corners: s, segments: r} = i;
    if (n <= 0) throw new Error("the given delta must be positive for paths");
    if (!(s === "edge" || s === "chamfer" || s === "round")) throw new Error('corners must be "edge", "chamfer", or "round"');
    const o = t.isClosed, a = xc.toPoints(t);
    if (a.length === 0) throw new Error("the given geometry cannot be empty");
    const l = {
        points: a,
        external: Fv({delta: n, corners: s, segments: r, closed: o}, a),
        internal: Fv({delta: -n, corners: s, segments: r, closed: o}, a)
    };
    return t.isClosed ? vY(l) : wY(l, r, s, n)
};
var EY = bY;
const SY = Xe, MY = xe, TY = le, IY = Fn, AY = d8, CY = yY, PY = EY, RY = (i, ...t) => {
    if (t = SY(t), t.length === 0) throw new Error("wrong number of arguments");
    const e = t.map(n => IY.isA(n) ? PY(i, n) : MY.isA(n) ? AY(i, n) : TY.isA(n) ? CY(i, n) : n);
    return e.length === 1 ? e[0] : e
};
var aT = RY;
const LY = Fn, NY = aT, OY = ep, DY = (i, t) => {
    const e = {size: 1, height: 1}, {size: n, height: s} = Object.assign({}, e, i);
    if (i.delta = n, i.offset = [0, 0, s], LY.toPoints(t).length === 0) throw new Error("the given geometry cannot be empty");
    const o = NY(i, t);
    return OY(i, o)
};
var FY = DY;
const {area: zY} = Oh, xg = xe, BY = Fn, kY = aT, UY = ep, GY = (i, t) => {
    const e = {size: 1, height: 1}, {size: n, height: s} = Object.assign({}, e, i);
    i.delta = n, i.offset = [0, 0, s];
    const r = xg.toOutlines(t);
    if (r.length === 0) throw new Error("the given geometry cannot be empty");
    const a = r.map(c => (zY(c) < 0 && c.reverse(), kY(i, BY.fromPoints({closed: !0}, c)))).reduce((c, h) => c.concat(xg.toSides(h)), []),
        l = xg.create(a);
    return UY(i, l)
};
var VY = GY;
const HY = Xe, $Y = xe, WY = Fn, qY = FY, YY = VY, XY = (i, ...t) => {
    const e = {size: 1, height: 1}, {size: n, height: s} = Object.assign({}, e, i);
    if (t = HY(t), t.length === 0) throw new Error("wrong number of arguments");
    if (n <= 0) throw new Error("size must be positive");
    if (s <= 0) throw new Error("height must be positive");
    const r = t.map(o => WY.isA(o) ? qY(i, o) : $Y.isA(o) ? YY(i, o) : o);
    return r.length === 1 ? r[0] : r
};
var ZY = XY;
const jY = Xe, zv = He, Bv = Hi, kv = xe, Uv = le, Gv = Fn, rp = (i, ...t) => {
        const e = {origin: [0, 0, 0], normal: [0, 0, 1]}, {origin: n, normal: s} = Object.assign({}, e, i);
        if (t = jY(t), t.length === 0) throw new Error("wrong number of arguments");
        const r = Bv.fromNormalAndPoint(Bv.create(), s, n);
        if (Number.isNaN(r[0])) throw new Error("the given origin and normal do not define a proper plane");
        const o = zv.mirrorByPlane(zv.create(), r),
            a = t.map(l => Gv.isA(l) ? Gv.transform(o, l) : kv.isA(l) ? kv.transform(o, l) : Uv.isA(l) ? Uv.transform(o, l) : l);
        return a.length === 1 ? a[0] : a
    }, KY = (...i) => rp({normal: [1, 0, 0]}, i), JY = (...i) => rp({normal: [0, 1, 0]}, i),
    QY = (...i) => rp({normal: [0, 0, 1]}, i);
var vc = {mirror: rp, mirrorX: KY, mirrorY: JY, mirrorZ: QY};
const {TAU: Ps} = me, cc = He, {mirrorX: tX} = vc, hc = xe, vg = zh, eX = X_, nX = (i, t) => {
    const e = {segments: 12, startAngle: 0, angle: Ps, overflow: "cap"};
    let {segments: n, startAngle: s, angle: r, overflow: o} = Object.assign({}, e, i);
    if (n < 3) throw new Error("segments must be greater then 3");
    s = Math.abs(s) > Ps ? s % Ps : s, r = Math.abs(r) > Ps ? r % Ps : r;
    let a = s + r;
    if (a = Math.abs(a) > Ps ? a % Ps : a, a < s) {
        const x = s;
        s = a, a = x
    }
    let l = a - s;
    if (l <= 0 && (l = Ps), Math.abs(l) < Ps) {
        const x = Ps / n;
        n = Math.floor(Math.abs(l) / x), Math.abs(l) > n * x && n++
    }
    let c = hc.toSides(t);
    if (c.length === 0) throw new Error("the given geometry cannot be empty");
    const h = c.filter(x => x[0][0] < 0), u = c.filter(x => x[0][0] >= 0);
    h.length > 0 && u.length > 0 && o === "cap" && (h.length > u.length ? (c = c.map(x => {
        let y = x[0], v = x[1];
        return y = [Math.min(y[0], 0), y[1]], v = [Math.min(v[0], 0), v[1]], [y, v]
    }), t = hc.reverse(hc.create(c)), t = tX(t)) : u.length >= h.length && (c = c.map(x => {
        let y = x[0], v = x[1];
        return y = [Math.max(y[0], 0), y[1]], v = [Math.max(v[0], 0), v[1]], [y, v]
    }), t = hc.create(c)));
    const f = l / n, g = Math.abs(l) < Ps, m = vg.fromSides(hc.toSides(t));
    vg.reverse(m, m);
    const p = cc.create(), _ = (x, y, v) => {
        let w = f * y + s;
        return l === Ps && y === n && (w = s), cc.multiply(p, cc.fromZRotation(p, w), cc.fromXRotation(cc.create(), Ps / 4)), vg.transform(p, v)
    };
    return i = {numberOfSlices: n + 1, capStart: g, capEnd: g, close: !g, callback: _}, eX(i, m)
};
var lT = nX;
const sX = Xe, Vv = G_, wg = Hi, Hv = He, $v = xe, cT = le, Ia = Be, iX = Bh, rX = sT, oX = (i, t) => {
    const e = wg.fromNormalAndPoint(wg.create(), i.axis, i.origin);
    if (Number.isNaN(e[0]) || Number.isNaN(e[1]) || Number.isNaN(e[2]) || Number.isNaN(e[3])) throw new Error("project: invalid axis or origin");
    const n = iX(t), s = n * n * Math.sqrt(3) / 4;
    if (n === 0) return $v.create();
    const r = cT.toPolygons(t);
    let o = [];
    for (let l = 0; l < r.length; l++) {
        const c = r[l].vertices.map(d => wg.projectionOfPoint(e, d)), h = Ia.create(c), u = Ia.plane(h);
        Vv(e, u) && (Ia.measureArea(h) < s || o.push(h))
    }
    if (!Vv(e, [0, 0, 1])) {
        const l = Hv.fromVectorRotation(Hv.create(), e, [0, 0, 1]);
        o = o.map(c => Ia.transform(l, c))
    }
    o = o.sort((l, c) => Ia.measureArea(c) - Ia.measureArea(l));
    const a = o.map(l => $v.fromPoints(l.vertices));
    return rX(a)
}, aX = (i, ...t) => {
    const e = {axis: [0, 0, 1], origin: [0, 0, 0]}, {axis: n, origin: s} = Object.assign({}, e, i);
    if (t = sX(t), t.length === 0) throw new Error("wrong number of arguments");
    i = {axis: n, origin: s};
    const r = t.map(o => cT.isA(o) ? oX(i, o) : o);
    return r.length === 1 ? r[0] : r
};
var lX = aX,
    kh = {extrudeFromSlices: X_, extrudeLinear: r8, extrudeRectangular: ZY, extrudeRotate: lT, project: lX, slice: zh};
const bg = kt, Eg = Be, cX = (i, t, e) => {
    const n = t.vertices.length;
    if (n > 3) {
        if (n > 4) {
            const o = [0, 0, 0];
            t.vertices.forEach(a => bg.add(o, o, a)), bg.snap(o, bg.divide(o, o, [n, n, n]), i);
            for (let a = 0; a < n; a++) {
                const l = Eg.create([o, t.vertices[a], t.vertices[(a + 1) % n]]);
                t.color && (l.color = t.color), e.push(l)
            }
            return
        }
        const s = Eg.create([t.vertices[0], t.vertices[1], t.vertices[2]]),
            r = Eg.create([t.vertices[0], t.vertices[2], t.vertices[3]]);
        t.color && (s.color = t.color, r.color = t.color), e.push(s, r);
        return
    }
    e.push(t)
}, hX = (i, t) => {
    const e = [];
    return t.forEach(n => {
        cX(i, n, e)
    }), e
};
var ea = hX;

class hT extends pr {
    constructor(t) {
        super(t)
    }
}

class uX extends hT {
    constructor(e) {
        super(e);
        z(this, "tl");
        z(this, "tr");
        z(this, "bl");
        z(this, "br");
        z(this, "generatesSolid");
        this.generatesSolid = !0, this.tl = e.tl, this.tr = e.tr, this.bl = e.bl, this.br = e.br
    }

    generateSolid(e, n) {
        const s = this.tl.getX(), r = this.tl.getY(), o = this.tr.getX(), a = this.tr.getY(), l = this.bl.getX(),
            c = this.bl.getY(), h = this.br.getX(), u = this.br.getY();
        let d = [[xn.vec2.fromValues(o, -a), xn.vec2.fromValues(s, -r)], [xn.vec2.fromValues(s, -r), xn.vec2.fromValues(l, -c)], [xn.vec2.fromValues(l, -c), xn.vec2.fromValues(h, -u)], [xn.vec2.fromValues(h, -u), xn.vec2.fromValues(o, -a)]],
            f = Yr.geom2.create(d);
        const g = kh.extrudeLinear({height: (n == null ? void 0 : n.height) ?? this.floor.height}, f);
        e(g, ea(Number.EPSILON, g.polygons), {options: n})
    }
}

class dX extends hT {
    constructor(e) {
        super(e);
        z(this, "position");
        z(this, "radius");
        z(this, "generatesSolid");
        this.generatesSolid = !0, this.position = e.position, this.radius = e.radius
    }

    generateSolid(e, n) {
        let s = [], r = 18, o = 0;
        const a = Math.PI / 180, l = this.position.getX(), c = this.position.getY();
        for (let d = 0; d < 20; ++d) {
            let f = xn.vec2.fromValues(Math.cos(o * a) * this.radius + l, Math.sin(o * a) * this.radius + c);
            o += r;
            let g = xn.vec2.fromValues(Math.cos(o * a) * this.radius + l, Math.sin(o * a) * this.radius + c);
            s.push([f, g])
        }
        let h = Yr.geom2.create(s);
        const u = kh.extrudeLinear({height: (n == null ? void 0 : n.height) ?? this.floor.height}, h);
        e(u, ea(Number.EPSILON, u.polygons), {options: n})
    }
}

class fX {
    constructor(t) {
        z(this, "_building");
        z(this, "id");
        z(this, "name");
        z(this, "elevation");
        z(this, "height");
        z(this, "gridIds");
        z(this, "wallIds");
        z(this, "wallJoints");
        z(this, "spaceIds");
        z(this, "openingIds");
        z(this, "poiIds");
        z(this, "columnIds");
        z(this, "topologyNodeIds");
        z(this, "libraryModelIds");
        z(this, "largestArea", -1);
        z(this, "smallestArea", Number.MAX_VALUE);
        z(this, "staticStairMeshes");
        z(this, "externalModel", null);
        z(this, "boundingBox", null);
        z(this, "meshes");
        this._building = new WeakRef(t.building), this.id = t.id, this.name = t.name, this.elevation = t.elevation, this.height = t.height, this.gridIds = new Set, this.wallIds = new Set, this.wallJoints = new Array, this.spaceIds = new Set, this.openingIds = new Set, this.poiIds = new Set, this.columnIds = new Set, this.topologyNodeIds = new Set, this.staticStairMeshes = new Array, this.libraryModelIds = new Set, this.meshes = new Array
    }

    get building() {
        const t = this._building.deref();
        if (t == null) throw "Floor.building: GC 후 참조 발생";
        return t
    }

    addGrid(t, e) {
        this.gridIds.has(t) || this.gridIds.add(t), this.building.grids.has(t) || this.building.grids.set(t, e)
    }

    getGridById(t) {
        return this.building.grids.get(t) ?? null
    }

    * getGrids(t = () => !0, e = !1) {
        for (const n of this.gridIds) {
            const s = this.building.grids.get(n);
            if (s != null && t(n, s) === !0 && (yield[n, s], e === !0)) break
        }
    }

    addWall(t) {
        this.wallIds.has(t.id) || this.wallIds.add(t.id), this.building.walls.has(t.id) || this.building.walls.set(t.id, t)
    }

    getWallById(t) {
        return this.building.walls.get(t) ?? null
    }

    * getWalls(t = () => !0, e = !1) {
        for (const n of this.wallIds) {
            const s = this.building.walls.get(n);
            if (s != null && t(s) === !0 && (yield s, e === !0)) break
        }
    }

    addWallJoint(t) {
        this.wallJoints.push(t)
    }

    addSpace(t) {
        this.spaceIds.has(t.id) || this.spaceIds.add(t.id), this.building.spaces.has(t.id) || this.building.spaces.set(t.id, t)
    }

    getSpaceById(t) {
        return this.building.spaces.get(t) ?? null
    }

    * getSpaces(t = () => !0, e = !1) {
        for (const n of this.spaceIds) {
            const s = this.building.spaces.get(n);
            if (s != null && t(s) === !0 && (yield s, e === !0)) break
        }
    }

    addColumn(t) {
        this.columnIds.has(t.id) || this.columnIds.add(t.id), this.building.columns.has(t.id) || this.building.columns.set(t.id, t)
    }

    getColumnById(t) {
        return this.building.columns.get(t) ?? null
    }

    * getColumns(t = () => !0, e = !1) {
        for (const n of this.columnIds) {
            const s = this.building.columns.get(n);
            if (s != null && t(s) === !0 && (yield s, e === !0)) break
        }
    }

    addOpening(t) {
        this.openingIds.has(t.id) || this.openingIds.add(t.id), this.building.openings.has(t.id) || this.building.openings.set(t.id, t)
    }

    getOpeningById(t) {
        return this.building.openings.get(t) ?? null
    }

    * getOpenings(t = () => !0, e = !1) {
        for (const n of this.openingIds) {
            const s = this.building.openings.get(n);
            if (s != null && t(s) === !0 && (yield s, e === !0)) break
        }
    }

    addPoi(t) {
        this.poiIds.has(t.id) || this.poiIds.add(t.id), this.building.spaces.has(t.id) || this.building.pois.set(t.id, t)
    }

    getPoiById(t) {
        return this.building.pois.get(t) ?? null
    }

    * getPois(t = () => !0, e = !1) {
        for (const n of this.poiIds) {
            const s = this.building.pois.get(n);
            if (s != null && t(s) === !0 && (yield s, e === !0)) break
        }
    }

    addTopologyNode(t) {
        this.topologyNodeIds.has(t.id) || this.topologyNodeIds.add(t.id), this.building.topologyNodes.has(t.id) || this.building.topologyNodes.set(t.id, t)
    }

    getTopologyNodeById(t) {
        return this.building.topologyNodes.get(t) ?? null
    }

    * getTopologyNodes(t = () => !0, e = !1) {
        for (const n of this.topologyNodeIds) {
            const s = this.building.topologyNodes.get(n);
            if (s != null && t(s) === !0 && (yield s, e === !0)) break
        }
    }

    addLibraryModel(t) {
        this.libraryModelIds.has(t.id) || this.libraryModelIds.add(t.id), this.building.libraryModels.has(t.id) || this.building.libraryModels.set(t.id, t)
    }

    getLibraryModelById(t) {
        return this.building.libraryModels.get(t) ?? null
    }

    * getLibraryModels(t = () => !0, e = !1) {
        for (const n of this.libraryModelIds) {
            const s = this.building.libraryModels.get(n);
            if (s != null && t(s) === !0 && (yield s, e === !0)) break
        }
    }

    * getTopologyLinks(t = () => !0, e = !1) {
        for (let [, n] of this.building.topologyLinks) if ((n.source.floor === this || n.target.floor === this) && t(n) === !0 && (yield n, e === !0)) break
    }

    calculateBoundingBox(t) {
        this.boundingBox = new Kt;
        for (let [, e] of this.getGrids()) this.boundingBox.expandToInclude(e.getEnvelopeInternal());
        this.boundingBox.expandBy(t ?? 0)
    }

    cutOutSpacePolygons() {
    }

    dispose() {
        this.wallJoints.length = 0, this.staticStairMeshes.length = 0, this.meshes.length = 0
    }
}

const Uu = le, pX = Q_, {Tree: Wv} = ey, gX = (i, t) => {
    if (!pX(i, t)) return Uu.create();
    const e = new Wv(Uu.toPolygons(i)), n = new Wv(Uu.toPolygons(t));
    e.invert(), n.clipTo(e), n.invert(), e.clipTo(n), n.clipTo(e), e.addPolygons(n.allPolygons()), e.invert();
    const s = e.allPolygons();
    return Uu.create(s)
};
var mX = gX;
const _X = Xe, yX = ip, xX = mX, vX = (...i) => {
    i = _X(i);
    let t = i.shift();
    return i.forEach(e => {
        t = xX(t, e)
    }), t = yX(t), t
};
var uT = vX;
const wX = Xe, bX = le, EX = Bh, SX = K_, MX = J_, TX = uT, IX = (...i) => {
    i = wX(i);
    const t = i.map(s => MX({z0: -1, z1: 1}, s)), e = TX(t), n = EX(e);
    return SX(n, bX.toPolygons(e))
};
var AX = IX;
const CX = Xe, PX = np, RX = xe, LX = le, NX = AX, OX = uT, DX = (...i) => {
    if (i = CX(i), i.length === 0) throw new Error("wrong number of arguments");
    if (!PX(i)) throw new Error("only intersect of the types are supported");
    const t = i[0];
    return RX.isA(t) ? NX(i) : LX.isA(t) ? OX(i) : t
};
var FX = DX;
const Sg = kt, zX = Bh, qv = le, BX = i => i.sort((t, e) => t - e).filter((t, e, n) => !e || t !== n[e - 1]),
    kX = (i, t, e) => {
        const n = `${t}`, s = i.get(n);
        s === void 0 ? i.set(n, [e]) : s.push(e)
    }, UX = (i, t) => {
        const e = `${t}`;
        return i.get(e)
    }, GX = i => {
        const t = zX(i), e = qv.toPolygons(i), n = e.length, s = new Map, r = Sg.create();
        e.forEach((h, u) => {
            h.vertices.forEach(d => {
                kX(s, Sg.snap(r, d, t), u)
            })
        });
        const o = e.map(h => {
            let u = [];
            return h.vertices.forEach(d => {
                u = u.concat(UX(s, Sg.snap(r, d, t)))
            }), {e: 1, d: BX(u)}
        });
        s.clear();
        let a = 0;
        const l = o.length;
        for (let h = 0; h < l; h++) {
            const u = o[h];
            if (u.e > 0) {
                const d = new Array(n);
                d[h] = !0;
                do a = 0, d.forEach((f, g) => {
                    const m = o[g];
                    if (m.e > 0) {
                        m.e = -1;
                        for (let p = 0; p < m.d.length; p++) d[m.d[p]] = !0;
                        a++
                    }
                }); while (a > 0);
                u.indexes = d
            }
        }
        const c = [];
        for (let h = 0; h < l; h++) if (o[h].indexes) {
            const u = [];
            o[h].indexes.forEach((d, f) => u.push(e[f])), c.push(qv.create(u))
        }
        return c
    };
var VX = GX;
const HX = Xe, $X = le, WX = VX, qX = (...i) => {
    if (i = HX(i), i.length === 0) throw new Error("wrong number of arguments");
    const t = i.map(e => $X.isA(e) ? WX(e) : e);
    return t.length === 1 ? t[0] : t
};
var YX = qX;
const Gu = le, XX = Q_, {Tree: Yv} = ey, ZX = (i, t) => {
    if (!XX(i, t)) return Gu.clone(i);
    const e = new Yv(Gu.toPolygons(i)), n = new Yv(Gu.toPolygons(t));
    e.invert(), e.clipTo(n), n.clipTo(e, !0), e.addPolygons(n.allPolygons()), e.invert();
    const s = e.allPolygons();
    return Gu.create(s)
};
var jX = ZX;
const KX = Xe, JX = ip, QX = jX, t9 = (...i) => {
    i = KX(i);
    let t = i.shift();
    return i.forEach(e => {
        t = QX(t, e)
    }), t = JX(t), t
};
var dT = t9;
const e9 = Xe, n9 = le, s9 = Bh, i9 = K_, r9 = J_, o9 = dT, a9 = (...i) => {
    i = e9(i);
    const t = i.map(s => r9({z0: -1, z1: 1}, s)), e = o9(t), n = s9(e);
    return i9(n, n9.toPolygons(e))
};
var l9 = a9;
const c9 = Xe, h9 = np, u9 = xe, d9 = le, f9 = l9, p9 = dT, g9 = (...i) => {
    if (i = c9(i), i.length === 0) throw new Error("wrong number of arguments");
    if (!h9(i)) throw new Error("only subtract of the types are supported");
    const t = i[0];
    return u9.isA(t) ? f9(i) : d9.isA(t) ? p9(i) : t
};
var m9 = g9, ny = {intersect: FX, scission: YX, subtract: m9, union: iT};

class _9 {
    constructor(t) {
        z(this, "building");
        z(this, "id");
        z(this, "name");
        z(this, "color", 0);
        z(this, "type");
        z(this, "floorPolygons");
        z(this, "_elements");
        z(this, "generatesSolid");
        this.generatesSolid = !0, this.building = t.building, this.id = t.id, this.name = t.name, this.color = t.color, this.type = t.type, this.floorPolygons = new Map, this._elements = new Map
    }

    addPolygon(t, e) {
        let n = this.floorPolygons.get(t);
        n == null && (n = new Array, this.floorPolygons.set(t, n)), n.push(e)
    }

    addElement(t) {
        this._elements.has(t.id) || this._elements.set(t.id, new WeakRef(t))
    }

    * getElements() {
        for (let [, t] of this._elements) {
            const e = t.deref();
            e != null && (yield e)
        }
    }

    get elements() {
        return this.getElements()
    }

    generateSolid(t, e) {
        var n;
        for (let [s, r] of this.floorPolygons) {
            if (!this.building.floors.has(s)) throw `Group.generateSolid: ${s} 층이 존재하지 않음`;
            let o = [];
            for (let a of r) {
                let l = a.getExteriorRing(), c = [];
                for (let f = 0; f < l.getNumPoints() - 1; ++f) {
                    const g = l.getCoordinateN(f), m = l.getCoordinateN(f + 1);
                    c.push([xn.vec2.fromValues(g.x, g.y), xn.vec2.fromValues(m.x, m.y)])
                }
                let h = Yr.geom2.create(c), u = [];
                for (let f = 0; f < a.getNumInteriorRing(); ++f) {
                    let g = a.getInteriorRingN(f), m = [];
                    for (let p = 0; p < g.getNumPoints() - 1; ++p) {
                        const _ = g.getCoordinateN(p), x = g.getCoordinateN(p + 1);
                        m.push([xn.vec2.fromValues(_.x, _.y), xn.vec2.fromValues(x.x, x.y)])
                    }
                    u.push(Yr.geom2.create(m))
                }
                let d = ny.subtract(h, ...u);
                o.push(kh.extrudeLinear({height: (e == null ? void 0 : e.height) ?? ((n = this.building.floors.get(s)) == null ? void 0 : n.height)}, d))
            }
            t(o, o.map(a => ea(Number.EPSILON, a.polygons)), {options: e, floorId: s})
        }
    }
}

const {EPS: Xv, TAU: Aa} = me, tr = te, y9 = Fn, {isGT: x9, isGTE: Mg, isNumberArray: v9} = In, w9 = i => {
    const t = {center: [0, 0], radius: 1, startAngle: 0, endAngle: Aa, makeTangent: !1, segments: 32};
    let {center: e, radius: n, startAngle: s, endAngle: r, makeTangent: o, segments: a} = Object.assign({}, t, i);
    if (!v9(e, 2)) throw new Error("center must be an array of X and Y values");
    if (!x9(n, 0)) throw new Error("radius must be greater than zero");
    if (!Mg(s, 0)) throw new Error("startAngle must be positive");
    if (!Mg(r, 0)) throw new Error("endAngle must be positive");
    if (!Mg(a, 4)) throw new Error("segments must be four or more");
    s = s % Aa, r = r % Aa;
    let l = Aa;
    s < r && (l = r - s), s > r && (l = r + (Aa - s));
    const c = Math.acos((n * n + n * n - Xv * Xv) / (2 * n * n)), h = tr.clone(e);
    let u;
    const d = [];
    if (l < c) u = tr.fromAngleRadians(tr.create(), s), tr.scale(u, u, n), tr.add(u, u, h), d.push(u); else {
        const f = Math.max(1, Math.floor(a * (l / Aa))) + 1;
        let g = f * .5 / l;
        g > .25 && (g = .25);
        const m = o ? f + 2 : f;
        for (let p = 0; p <= m; p++) {
            let _ = p;
            o && (_ = (p - 1) * (f - 2 * g) / f + g, _ < 0 && (_ = 0), _ > f && (_ = f));
            const x = s + _ * (l / f);
            u = tr.fromAngleRadians(tr.create(), x), tr.scale(u, u, n), tr.add(u, u, h), d.push(u)
        }
    }
    return y9.fromPoints({closed: !1}, d)
};
var b9 = w9;
const {EPS: Zv, TAU: Sr} = me, Tg = te, E9 = xe, {sin: S9, cos: M9} = Vn, {isGTE: Ig, isNumberArray: jv} = In,
    T9 = i => {
        const t = {center: [0, 0], radius: [1, 1], startAngle: 0, endAngle: Sr, segments: 32};
        let {center: e, radius: n, startAngle: s, endAngle: r, segments: o} = Object.assign({}, t, i);
        if (!jv(e, 2)) throw new Error("center must be an array of X and Y values");
        if (!jv(n, 2)) throw new Error("radius must be an array of X and Y values");
        if (!n.every(f => f > 0)) throw new Error("radius values must be greater than zero");
        if (!Ig(s, 0)) throw new Error("startAngle must be positive");
        if (!Ig(r, 0)) throw new Error("endAngle must be positive");
        if (!Ig(o, 3)) throw new Error("segments must be three or more");
        s = s % Sr, r = r % Sr;
        let a = Sr;
        s < r && (a = r - s), s > r && (a = r + (Sr - s));
        const l = Math.min(n[0], n[1]), c = Math.acos((l * l + l * l - Zv * Zv) / (2 * l * l));
        if (a < c) throw new Error("startAngle and endAngle do not define a significant rotation");
        o = Math.floor(o * (a / Sr));
        const h = Tg.clone(e), u = a / o, d = [];
        o = a < Sr ? o + 1 : o;
        for (let f = 0; f < o; f++) {
            const g = u * f + s, m = Tg.fromValues(n[0] * M9(g), n[1] * S9(g));
            Tg.add(m, h, m), d.push(m)
        }
        return a < Sr && d.push(h), E9.fromPoints(d)
    };
var fT = T9;
const {TAU: I9} = me, A9 = fT, {isGT: C9} = In, P9 = i => {
    const t = {center: [0, 0], radius: 1, startAngle: 0, endAngle: I9, segments: 32};
    let {center: e, radius: n, startAngle: s, endAngle: r, segments: o} = Object.assign({}, t, i);
    if (!C9(n, 0)) throw new Error("radius must be greater than zero");
    return n = [n, n], A9({center: e, radius: n, startAngle: s, endAngle: r, segments: o})
};
var pT = P9;
const R9 = le, L9 = Be, {isNumberArray: Kv} = In, N9 = i => {
    const t = {center: [0, 0, 0], size: [2, 2, 2]}, {center: e, size: n} = Object.assign({}, t, i);
    if (!Kv(e, 3)) throw new Error("center must be an array of X, Y and Z values");
    if (!Kv(n, 3)) throw new Error("size must be an array of width, depth and height values");
    if (!n.every(r => r > 0)) throw new Error("size values must be greater than zero");
    return R9.create([[[0, 4, 6, 2], [-1, 0, 0]], [[1, 3, 7, 5], [1, 0, 0]], [[0, 1, 5, 4], [0, -1, 0]], [[2, 6, 7, 3], [0, 1, 0]], [[0, 2, 3, 1], [0, 0, -1]], [[4, 5, 7, 6], [0, 0, 1]]].map(r => {
        const o = r[0].map(a => [e[0] + n[0] / 2 * (2 * !!(a & 1) - 1), e[1] + n[1] / 2 * (2 * !!(a & 2) - 1), e[2] + n[2] / 2 * (2 * !!(a & 4) - 1)]);
        return L9.create(o)
    }))
};
var gT = N9;
const O9 = gT, {isGT: D9} = In, F9 = i => {
    const t = {center: [0, 0, 0], size: 2};
    let {center: e, size: n} = Object.assign({}, t, i);
    if (!D9(n, 0)) throw new Error("size must be greater than zero");
    return n = [n, n, n], O9({center: e, size: n})
};
var z9 = F9;
const {EPS: Jv, TAU: Mr} = me, Rn = kt, B9 = le, k9 = Be, {sin: U9, cos: G9} = Vn, {
    isGT: V9,
    isGTE: Ag,
    isNumberArray: Cg
} = In, H9 = i => {
    const t = {
        center: [0, 0, 0],
        height: 2,
        startRadius: [1, 1],
        startAngle: 0,
        endRadius: [1, 1],
        endAngle: Mr,
        segments: 32
    };
    let {
        center: e,
        height: n,
        startRadius: s,
        startAngle: r,
        endRadius: o,
        endAngle: a,
        segments: l
    } = Object.assign({}, t, i);
    if (!Cg(e, 3)) throw new Error("center must be an array of X, Y and Z values");
    if (!V9(n, 0)) throw new Error("height must be greater then zero");
    if (!Cg(s, 2)) throw new Error("startRadius must be an array of X and Y values");
    if (!s.every(M => M >= 0)) throw new Error("startRadius values must be positive");
    if (!Cg(o, 2)) throw new Error("endRadius must be an array of X and Y values");
    if (!o.every(M => M >= 0)) throw new Error("endRadius values must be positive");
    if (o.every(M => M === 0) && s.every(M => M === 0)) throw new Error("at least one radius must be positive");
    if (!Ag(r, 0)) throw new Error("startAngle must be positive");
    if (!Ag(a, 0)) throw new Error("endAngle must be positive");
    if (!Ag(l, 4)) throw new Error("segments must be four or more");
    r = r % Mr, a = a % Mr;
    let c = Mr;
    r < a && (c = a - r), r > a && (c = a + (Mr - r));
    const h = Math.min(s[0], s[1], o[0], o[1]), u = Math.acos((h * h + h * h - Jv * Jv) / (2 * h * h));
    if (c < u) throw new Error("startAngle and endAngle do not define a significant rotation");
    const d = Math.floor(l * (c / Mr)), f = Rn.fromValues(0, 0, -(n / 2)), g = Rn.fromValues(0, 0, n / 2),
        m = Rn.subtract(Rn.create(), g, f), p = Rn.fromValues(1, 0, 0), _ = Rn.fromValues(0, 1, 0), x = Rn.create(),
        y = Rn.create(), v = Rn.create(), w = (M, I, N) => {
            const B = I * c + r;
            return Rn.scale(x, p, N[0] * G9(B)), Rn.scale(y, _, N[1] * U9(B)), Rn.add(x, x, y), Rn.scale(v, m, M), Rn.add(v, v, f), Rn.add(Rn.create(), x, v)
        }, E = (...M) => {
            const I = M.map(N => Rn.add(Rn.create(), N, e));
            return k9.create(I)
        }, S = [];
    for (let M = 0; M < d; M++) {
        const I = M / d;
        let N = (M + 1) / d;
        c === Mr && M === d - 1 && (N = 0), o[0] === s[0] && o[1] === s[1] ? (S.push(E(f, w(0, N, o), w(0, I, o))), S.push(E(w(0, N, o), w(1, N, o), w(1, I, o), w(0, I, o))), S.push(E(g, w(1, I, o), w(1, N, o)))) : (s[0] > 0 && s[1] > 0 && S.push(E(f, w(0, N, s), w(0, I, s))), (s[0] > 0 || s[1] > 0) && S.push(E(w(0, I, s), w(0, N, s), w(1, I, o))), o[0] > 0 && o[1] > 0 && S.push(E(g, w(1, I, o), w(1, N, o))), (o[0] > 0 || o[1] > 0) && S.push(E(w(1, I, o), w(0, N, s), w(1, N, o))))
    }
    return c < Mr && (S.push(E(f, w(0, 0, s), g)), S.push(E(w(0, 0, s), w(1, 0, o), g)), S.push(E(f, g, w(0, 1, s))), S.push(E(w(0, 1, s), g, w(1, 1, o)))), B9.create(S)
};
var mT = H9;
const $9 = mT, {isGT: W9} = In, q9 = i => {
    const t = {center: [0, 0, 0], height: 2, radius: 1, segments: 32}, {
        center: e,
        height: n,
        radius: s,
        segments: r
    } = Object.assign({}, t, i);
    if (!W9(s, 0)) throw new Error("radius must be greater than zero");
    return $9({center: e, height: n, startRadius: [s, s], endRadius: [s, s], segments: r})
};
var Y9 = q9;
const X9 = le, Z9 = Be, {isNumberArray: Qv} = In, j9 = i => {
    const t = {points: [], faces: [], colors: void 0, orientation: "outward"}, {
        points: e,
        faces: n,
        colors: s,
        orientation: r
    } = Object.assign({}, t, i);
    if (!(Array.isArray(e) && Array.isArray(n))) throw new Error("points and faces must be arrays");
    if (e.length < 3) throw new Error("three or more points are required");
    if (n.length < 1) throw new Error("one or more faces are required");
    if (s) {
        if (!Array.isArray(s)) throw new Error("colors must be an array");
        if (s.length !== n.length) throw new Error("faces and colors must have the same length")
    }
    e.forEach((a, l) => {
        if (!Qv(a, 3)) throw new Error(`point ${l} must be an array of X, Y, Z values`)
    }), n.forEach((a, l) => {
        if (a.length < 3) throw new Error(`face ${l} must contain 3 or more indexes`);
        if (!Qv(a, a.length)) throw new Error(`face ${l} must be an array of numbers`)
    }), r !== "outward" && n.forEach(a => a.reverse());
    const o = n.map((a, l) => {
        const c = Z9.create(a.map(h => e[h]));
        return s && s[l] && (c.color = s[l]), c
    });
    return X9.create(o)
};
var _T = j9;
const tw = He, ew = kt, K9 = le, J9 = _T, {isGT: Q9, isGTE: t7} = In, e7 = i => {
    const t = {radius: 1, frequency: 6};
    let {radius: e, frequency: n} = Object.assign({}, t, i);
    if (!Q9(e, 0)) throw new Error("radius must be greater than zero");
    if (!t7(n, 6)) throw new Error("frequency must be six or more");
    n = Math.floor(n / 6);
    const s = [[.850651, 0, -.525731], [.850651, -0, .525731], [-.850651, -0, .525731], [-.850651, 0, -.525731], [0, -.525731, .850651], [0, .525731, .850651], [0, .525731, -.850651], [0, -.525731, -.850651], [-.525731, -.850651, -0], [.525731, -.850651, -0], [.525731, .850651, 0], [-.525731, .850651, 0]],
        r = [[0, 9, 1], [1, 10, 0], [6, 7, 0], [10, 6, 0], [7, 9, 0], [5, 1, 4], [4, 1, 9], [5, 10, 1], [2, 8, 3], [3, 11, 2], [2, 5, 4], [4, 8, 2], [2, 11, 5], [3, 7, 6], [6, 11, 3], [8, 7, 3], [9, 8, 4], [11, 10, 5], [10, 11, 6], [8, 9, 7]],
        o = (d, f, g) => {
            const m = d[0], p = d[1], _ = d[2];
            let x = g;
            const y = [], v = [];
            for (let w = 0; w < f; w++) for (let E = 0; E < f - w; E++) {
                const S = w / f, b = (w + 1) / f, M = E / (f - w), I = (E + 1) / (f - w),
                    N = f - w - 1 ? E / (f - w - 1) : 1, B = [];
                B[0] = a(a(m, p, M), _, S), B[1] = a(a(m, p, I), _, S), B[2] = a(a(m, p, N), _, b);
                for (let D = 0; D < 3; D++) {
                    const L = ew.length(B[D]);
                    for (let k = 0; k < 3; k++) B[D][k] /= L
                }
                if (y.push(B[0], B[1], B[2]), v.push([x, x + 1, x + 2]), x += 3, E < f - w - 1) {
                    const D = f - w - 1 ? (E + 1) / (f - w - 1) : 1;
                    B[0] = a(a(m, p, I), _, S), B[1] = a(a(m, p, D), _, b), B[2] = a(a(m, p, N), _, b);
                    for (let L = 0; L < 3; L++) {
                        const k = ew.length(B[L]);
                        for (let G = 0; G < 3; G++) B[L][G] /= k
                    }
                    y.push(B[0], B[1], B[2]), v.push([x, x + 1, x + 2]), x += 3
                }
            }
            return {points: y, triangles: v, offset: x}
        }, a = (d, f, g) => {
            const m = 1 - g, p = [];
            for (let _ = 0; _ < 3; _++) p[_] = d[_] * m + f[_] * g;
            return p
        };
    let l = [], c = [], h = 0;
    for (let d = 0; d < r.length; d++) {
        const f = o([s[r[d][0]], s[r[d][1]], s[r[d][2]]], n, h);
        l = l.concat(f.points), c = c.concat(f.triangles), h = f.offset
    }
    let u = J9({points: l, faces: c, orientation: "inward"});
    return e !== 1 && (u = K9.transform(tw.fromScaling(tw.create(), [e, e, e]), u)), u
};
var n7 = e7;
const s7 = Fn, i7 = i => {
    if (!Array.isArray(i)) throw new Error("points must be an array");
    return s7.fromPoints({}, i)
};
var r7 = i7;
const Pg = xe, o7 = i => {
    const t = {points: [], paths: []}, {points: e, paths: n} = Object.assign({}, t, i);
    if (!(Array.isArray(e) && Array.isArray(n))) throw new Error("points and paths must be arrays");
    let s = e;
    Array.isArray(e[0]) && (Array.isArray(e[0][0]) || (s = [e])), s.forEach((l, c) => {
        if (!Array.isArray(l)) throw new Error("list of points " + c + " must be an array");
        if (l.length < 3) throw new Error("list of points " + c + " must contain three or more points");
        l.forEach((h, u) => {
            if (!Array.isArray(h)) throw new Error("list of points " + c + ", point " + u + " must be an array");
            if (h.length < 2) throw new Error("list of points " + c + ", point " + u + " must contain by X and Y values")
        })
    });
    let r = n;
    if (n.length === 0) {
        let l = 0;
        r = s.map(c => c.map(h => l++))
    }
    const o = [];
    s.forEach(l => l.forEach(c => o.push(c)));
    let a = [];
    return r.forEach(l => {
        const c = l.map(u => o[u]), h = Pg.fromPoints(c);
        a = a.concat(Pg.toSides(h))
    }), Pg.create(a)
};
var a7 = o7;
const Tr = te, l7 = xe, {isNumberArray: nw} = In, c7 = i => {
    const t = {center: [0, 0], size: [2, 2]}, {center: e, size: n} = Object.assign({}, t, i);
    if (!nw(e, 2)) throw new Error("center must be an array of X and Y values");
    if (!nw(n, 2)) throw new Error("size must be an array of X and Y values");
    if (!n.every(a => a > 0)) throw new Error("size values must be greater than zero");
    const s = [n[0] / 2, n[1] / 2], r = [s[0], -s[1]],
        o = [Tr.subtract(Tr.create(), e, s), Tr.add(Tr.create(), e, r), Tr.add(Tr.create(), e, s), Tr.subtract(Tr.create(), e, r)];
    return l7.fromPoints(o)
};
var yT = c7;
const {EPS: id, TAU: uc} = me, Rg = te, ln = kt, h7 = le, xl = Be, {sin: u7, cos: d7} = Vn, {
    isGT: f7,
    isGTE: p7,
    isNumberArray: sw
} = In, iw = (i, t, e, n, s, r) => {
    const o = uc / 4 * s / n, a = d7(o), l = u7(o), c = n - s;
    let h = e * a, u = t[2] - (e - e * l);
    r || (u = e - e * l - t[2]), h = h > id ? h : 0;
    const d = ln.add(ln.create(), i, [t[0] - e, t[1] - e, u]), f = ln.add(ln.create(), i, [e - t[0], t[1] - e, u]),
        g = ln.add(ln.create(), i, [e - t[0], e - t[1], u]), m = ln.add(ln.create(), i, [t[0] - e, e - t[1], u]),
        p = [], _ = [], x = [], y = [];
    for (let v = 0; v <= c; v++) {
        const w = c > 0 ? uc / 4 * v / c : 0, E = Rg.fromAngleRadians(Rg.create(), w);
        Rg.scale(E, E, h);
        const S = ln.fromVec2(ln.create(), E);
        p.push(ln.add(ln.create(), d, S)), ln.rotateZ(S, S, [0, 0, 0], uc / 4), _.push(ln.add(ln.create(), f, S)), ln.rotateZ(S, S, [0, 0, 0], uc / 4), x.push(ln.add(ln.create(), g, S)), ln.rotateZ(S, S, [0, 0, 0], uc / 4), y.push(ln.add(ln.create(), m, S))
    }
    return r ? [p, _, x, y] : (p.reverse(), _.reverse(), x.reverse(), y.reverse(), [y, x, _, p])
}, rw = (i, t) => {
    const e = [];
    for (let n = 0; n < i.length; n++) {
        const s = i[n], r = t[n];
        for (let o = 0; o < s.length - 1; o++) e.push(xl.create([s[o], s[o + 1], r[o]])), o < r.length - 1 && e.push(xl.create([r[o], s[o + 1], r[o + 1]]))
    }
    return e
}, ow = (i, t) => {
    const e = [];
    for (let n = 0; n < i.length; n++) {
        let s = i[n], r = t[n];
        const o = s[s.length - 1], a = r[r.length - 1], l = (n + 1) % i.length;
        s = i[l], r = t[l];
        const c = s[0], h = r[0];
        e.push(xl.create([o, c, h, a]))
    }
    return e
}, g7 = (i, t) => {
    i = [i[3], i[2], i[1], i[0]], i = i.map(r => r.slice().reverse());
    const e = [];
    i.forEach(r => {
        r.forEach(o => e.push(o))
    });
    const n = [];
    t.forEach(r => {
        r.forEach(o => n.push(o))
    });
    const s = [];
    for (let r = 0; r < n.length; r++) {
        const o = (r + 1) % n.length;
        s.push(xl.create([e[r], e[o], n[o], n[r]]))
    }
    return s
}, m7 = i => {
    const t = {center: [0, 0, 0], size: [2, 2, 2], roundRadius: .2, segments: 32};
    let {center: e, size: n, roundRadius: s, segments: r} = Object.assign({}, t, i);
    if (!sw(e, 3)) throw new Error("center must be an array of X, Y and Z values");
    if (!sw(n, 3)) throw new Error("size must be an array of X, Y and Z values");
    if (!n.every(c => c > 0)) throw new Error("size values must be greater than zero");
    if (!f7(s, 0)) throw new Error("roundRadius must be greater than zero");
    if (!p7(r, 4)) throw new Error("segments must be four or more");
    if (n = n.map(c => c / 2), s > n[0] - id || s > n[1] - id || s > n[2] - id) throw new Error("roundRadius must be smaller then the radius of all dimensions");
    r = Math.floor(r / 4);
    let o = null, a = null, l = [];
    for (let c = 0; c <= r; c++) {
        const h = iw(e, n, s, r, c, !0), u = iw(e, n, s, r, c, !1);
        if (c === 0 && (l = l.concat(g7(u, h))), o && (l = l.concat(rw(o, h), ow(o, h))), a && (l = l.concat(rw(a, u), ow(a, u))), c === r) {
            let d = h.map(f => f[0]);
            l.push(xl.create(d)), d = u.map(f => f[0]), l.push(xl.create(d))
        }
        o = h, a = u
    }
    return h7.create(l)
};
var _7 = m7;
const {EPS: aw, TAU: lw} = me, yt = kt, y7 = le, x7 = Be, {sin: cw, cos: hw} = Vn, {
    isGT: Lg,
    isGTE: v7,
    isNumberArray: w7
} = In, b7 = i => {
    const t = {center: [0, 0, 0], height: 2, radius: 1, roundRadius: .2, segments: 32}, {
        center: e,
        height: n,
        radius: s,
        roundRadius: r,
        segments: o
    } = Object.assign({}, t, i);
    if (!w7(e, 3)) throw new Error("center must be an array of X, Y and Z values");
    if (!Lg(n, 0)) throw new Error("height must be greater then zero");
    if (!Lg(s, 0)) throw new Error("radius must be greater then zero");
    if (!Lg(r, 0)) throw new Error("roundRadius must be greater then zero");
    if (r > s - aw) throw new Error("roundRadius must be smaller then the radius");
    if (!v7(o, 4)) throw new Error("segments must be four or more");
    const a = [0, 0, -(n / 2)], l = [0, 0, n / 2], c = yt.subtract(yt.create(), l, a), h = yt.length(c);
    if (2 * r > h - aw) throw new Error("height must be larger than twice roundRadius");
    let u;
    Math.abs(c[0]) > Math.abs(c[1]) ? u = yt.fromValues(0, 1, 0) : u = yt.fromValues(1, 0, 0);
    const d = yt.scale(yt.create(), yt.normalize(yt.create(), c), r),
        f = yt.scale(yt.create(), yt.normalize(yt.create(), yt.cross(yt.create(), d, u)), s),
        g = yt.scale(yt.create(), yt.normalize(yt.create(), yt.cross(yt.create(), f, d)), s);
    yt.add(a, a, d), yt.subtract(l, l, d);
    const m = Math.floor(.25 * o), p = E => {
        const S = E.map(b => yt.add(b, b, e));
        return x7.create(S)
    }, _ = [], x = yt.create(), y = yt.create();
    let v;
    for (let E = 0; E <= o; E++) {
        const S = lw * E / o, b = yt.add(yt.create(), yt.scale(x, f, hw(S)), yt.scale(y, g, cw(S)));
        if (E > 0) {
            let M = [];
            M.push(yt.add(yt.create(), a, b)), M.push(yt.add(yt.create(), a, v)), M.push(yt.add(yt.create(), l, v)), M.push(yt.add(yt.create(), l, b)), _.push(p(M));
            let I, N;
            for (let B = 0; B <= m; B++) {
                const D = lw / 4 * B / m, L = hw(D), k = cw(D);
                if (B > 0) {
                    M = [];
                    let G;
                    G = yt.add(yt.create(), a, yt.subtract(x, yt.scale(x, v, I), yt.scale(y, d, N))), M.push(G), G = yt.add(yt.create(), a, yt.subtract(x, yt.scale(x, b, I), yt.scale(y, d, N))), M.push(G), B < m && (G = yt.add(yt.create(), a, yt.subtract(x, yt.scale(x, b, L), yt.scale(y, d, k))), M.push(G)), G = yt.add(yt.create(), a, yt.subtract(x, yt.scale(x, v, L), yt.scale(y, d, k))), M.push(G), _.push(p(M)), M = [], G = yt.add(yt.create(), yt.scale(x, v, I), yt.scale(y, d, N)), yt.add(G, G, l), M.push(G), G = yt.add(yt.create(), yt.scale(x, b, I), yt.scale(y, d, N)), yt.add(G, G, l), M.push(G), B < m && (G = yt.add(yt.create(), yt.scale(x, b, L), yt.scale(y, d, k)), yt.add(G, G, l), M.push(G)), G = yt.add(yt.create(), yt.scale(x, v, L), yt.scale(y, d, k)), yt.add(G, G, l), M.push(G), M.reverse(), _.push(p(M))
                }
                I = L, N = k
            }
        }
        v = b
    }
    return y7.create(_)
};
var E7 = b7;
const {EPS: uw, TAU: Vu} = me, We = te, S7 = xe, {isGT: M7, isGTE: T7, isNumberArray: dw} = In, I7 = i => {
    const t = {center: [0, 0], size: [2, 2], roundRadius: .2, segments: 32};
    let {center: e, size: n, roundRadius: s, segments: r} = Object.assign({}, t, i);
    if (!dw(e, 2)) throw new Error("center must be an array of X and Y values");
    if (!dw(n, 2)) throw new Error("size must be an array of X and Y values");
    if (!n.every(m => m > 0)) throw new Error("size values must be greater than zero");
    if (!M7(s, 0)) throw new Error("roundRadius must be greater than zero");
    if (!T7(r, 4)) throw new Error("segments must be four or more");
    if (n = n.map(m => m / 2), s > n[0] - uw || s > n[1] - uw) throw new Error("roundRadius must be smaller then the radius of all dimensions");
    const o = Math.floor(r / 4), a = We.add(We.create(), e, [n[0] - s, n[1] - s]),
        l = We.add(We.create(), e, [s - n[0], n[1] - s]), c = We.add(We.create(), e, [s - n[0], s - n[1]]),
        h = We.add(We.create(), e, [n[0] - s, s - n[1]]), u = [], d = [], f = [], g = [];
    for (let m = 0; m <= o; m++) {
        const p = Vu / 4 * m / o, _ = We.fromAngleRadians(We.create(), p);
        We.scale(_, _, s), u.push(We.add(We.create(), a, _)), We.rotate(_, _, We.create(), Vu / 4), d.push(We.add(We.create(), l, _)), We.rotate(_, _, We.create(), Vu / 4), f.push(We.add(We.create(), c, _)), We.rotate(_, _, We.create(), Vu / 4), g.push(We.add(We.create(), h, _))
    }
    return S7.fromPoints(u.concat(d, f, g))
};
var A7 = I7;
const C7 = yT, {isGT: P7} = In, R7 = i => {
    const t = {center: [0, 0], size: 2};
    let {center: e, size: n} = Object.assign({}, t, i);
    if (!P7(n, 0)) throw new Error("size must be greater than zero");
    return n = [n, n], C7({center: e, size: n})
};
var L7 = R7;
const {TAU: xT} = me, wc = te, N7 = xe, {isGT: O7, isGTE: Hu, isNumberArray: D7} = In,
    F7 = (i, t) => i > 0 && t > 1 && t < i / 2 ? Math.cos(Math.PI * t / i) / Math.cos(Math.PI * (t - 1) / i) : 0,
    fw = (i, t, e, n) => {
        const s = xT / i, r = [];
        for (let o = 0; o < i; o++) {
            const a = wc.fromAngleRadians(wc.create(), s * o + e);
            wc.scale(a, a, t), wc.add(a, n, a), r.push(a)
        }
        return r
    }, z7 = i => {
        const t = {center: [0, 0], vertices: 5, outerRadius: 1, innerRadius: 0, density: 2, startAngle: 0};
        let {center: e, vertices: n, outerRadius: s, innerRadius: r, density: o, startAngle: a} = Object.assign({}, t, i);
        if (!D7(e, 2)) throw new Error("center must be an array of X and Y values");
        if (!Hu(n, 2)) throw new Error("vertices must be two or more");
        if (!O7(s, 0)) throw new Error("outerRadius must be greater than zero");
        if (!Hu(r, 0)) throw new Error("innerRadius must be greater than zero");
        if (!Hu(a, 0)) throw new Error("startAngle must be greater than zero");
        if (n = Math.floor(n), o = Math.floor(o), a = a % xT, r === 0) {
            if (!Hu(o, 2)) throw new Error("density must be two or more");
            r = s * F7(n, o)
        }
        const l = wc.clone(e), c = fw(n, s, a, l), h = fw(n, r, a + Math.PI / n, l), u = [];
        for (let d = 0; d < n; d++) u.push(c[d]), u.push(h[d]);
        return N7.fromPoints(u)
    };
var B7 = z7;
const k7 = Xe, pw = He, gw = xe, mw = le, _w = Fn, op = (i, ...t) => {
    if (!Array.isArray(i)) throw new Error("angles must be an array");
    if (t = k7(t), t.length === 0) throw new Error("wrong number of arguments");
    for (i = i.slice(); i.length < 3;) i.push(0);
    const e = i[2], n = i[1], s = i[0], r = pw.fromTaitBryanRotation(pw.create(), e, n, s),
        o = t.map(a => _w.isA(a) ? _w.transform(r, a) : gw.isA(a) ? gw.transform(r, a) : mw.isA(a) ? mw.transform(r, a) : a);
    return o.length === 1 ? o[0] : o
}, U7 = (i, ...t) => op([i, 0, 0], t), G7 = (i, ...t) => op([0, i, 0], t), V7 = (i, ...t) => op([0, 0, i], t);
var bc = {rotate: op, rotateX: U7, rotateY: G7, rotateZ: V7};
const H7 = Xe, yw = He, xw = xe, vw = le, ww = Fn, ap = (i, ...t) => {
    if (!Array.isArray(i)) throw new Error("offset must be an array");
    if (t = H7(t), t.length === 0) throw new Error("wrong number of arguments");
    for (i = i.slice(); i.length < 3;) i.push(0);
    const e = yw.fromTranslation(yw.create(), i),
        n = t.map(s => ww.isA(s) ? ww.transform(e, s) : xw.isA(s) ? xw.transform(e, s) : vw.isA(s) ? vw.transform(e, s) : s);
    return n.length === 1 ? n[0] : n
}, $7 = (i, ...t) => ap([i, 0, 0], t), W7 = (i, ...t) => ap([0, i, 0], t), q7 = (i, ...t) => ap([0, 0, i], t);
var Po = {translate: ap, translateX: $7, translateY: W7, translateZ: q7};
const {TAU: Y7} = me, X7 = lT, {rotate: Z7} = bc, {translate: j7} = Po, K7 = pT, {isGT: Ng, isGTE: Og} = In, J7 = i => {
    const t = {
        innerRadius: 1,
        innerSegments: 32,
        outerRadius: 4,
        outerSegments: 32,
        innerRotation: 0,
        startAngle: 0,
        outerRotation: Y7
    }, {
        innerRadius: e,
        innerSegments: n,
        outerRadius: s,
        outerSegments: r,
        innerRotation: o,
        startAngle: a,
        outerRotation: l
    } = Object.assign({}, t, i);
    if (!Ng(e, 0)) throw new Error("innerRadius must be greater than zero");
    if (!Og(n, 3)) throw new Error("innerSegments must be three or more");
    if (!Ng(s, 0)) throw new Error("outerRadius must be greater than zero");
    if (!Og(r, 3)) throw new Error("outerSegments must be three or more");
    if (!Og(a, 0)) throw new Error("startAngle must be positive");
    if (!Ng(l, 0)) throw new Error("outerRotation must be greater than zero");
    if (e >= s) throw new Error("inner circle is two large to rotate about the outer circle");
    let c = K7({radius: e, segments: n});
    return o !== 0 && (c = Z7([0, 0, o], c)), c = j7([s, 0], c), X7({startAngle: a, angle: l, segments: r}, c)
};
var Q7 = J7;
const {NEPS: vl} = me, dc = te, tZ = xe, {isNumberArray: eZ} = In,
    Vm = (i, t, e) => Math.acos((i * i + t * t - e * e) / (2 * i * t)),
    nZ = (i, t, e) => t > vl ? Math.sqrt(i * i + e * e - 2 * i * e * Math.cos(t)) : Math.sqrt((i - e) * (i - e) + i * e * t * t * (1 - t * t / 12)),
    sZ = i => {
        if (Math.abs(i[0] + i[1] + i[2] - Math.PI) > vl) throw new Error("AAA triangles require angles that sum to PI");
        const e = i[0], n = i[1], s = Math.PI - e - n, r = 1, o = r / Math.sin(s) * Math.sin(e),
            a = r / Math.sin(s) * Math.sin(n);
        return Gl(e, n, s, o, a, r)
    }, iZ = i => {
        const t = i[0], e = i[1], n = Math.PI + vl - t - e;
        if (n < vl) throw new Error("AAS triangles require angles that sum to PI");
        const s = i[2], r = s / Math.sin(t) * Math.sin(e), o = s / Math.sin(t) * Math.sin(n);
        return Gl(t, e, n, s, r, o)
    }, rZ = i => {
        const t = i[0], e = i[2], n = Math.PI + vl - t - e;
        if (n < vl) throw new Error("ASA triangles require angles that sum to PI");
        const s = i[1], r = s / Math.sin(n) * Math.sin(t), o = s / Math.sin(n) * Math.sin(e);
        return Gl(t, e, n, r, o, s)
    }, oZ = i => {
        const t = i[0], e = i[1], n = i[2], s = nZ(t, e, n), r = Vm(s, t, n), o = Math.PI - r - e;
        return Gl(r, e, o, n, s, t)
    }, aZ = i => {
        const t = i[0], e = i[1], n = i[2], s = Math.asin(e * Math.sin(n) / t), r = Math.PI - s - n,
            o = t / Math.sin(n) * Math.sin(r);
        return Gl(s, r, n, e, o, t)
    }, lZ = i => {
        const t = i[1], e = i[2], n = i[0];
        if (t + e <= n || e + n <= t || n + t <= e) throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");
        const s = Vm(e, n, t), r = Vm(n, t, e), o = Math.PI - s - r;
        return Gl(s, r, o, t, e, n)
    }, Gl = (i, t, e, n, s, r) => {
        const o = dc.fromValues(0, 0), a = dc.fromValues(r, 0), l = dc.fromValues(n, 0);
        return dc.add(l, dc.rotate(l, l, [0, 0], Math.PI - t), a), tZ.fromPoints([o, a, l])
    }, cZ = i => {
        const t = {type: "SSS", values: [1, 1, 1]};
        let {type: e, values: n} = Object.assign({}, t, i);
        if (typeof e != "string") throw new Error("triangle type must be a string");
        if (e = e.toUpperCase(), !((e[0] === "A" || e[0] === "S") && (e[1] === "A" || e[1] === "S") && (e[2] === "A" || e[2] === "S"))) throw new Error("triangle type must contain three letters; A or S");
        if (!eZ(n, 3)) throw new Error("triangle values must contain three values");
        if (!n.every(s => s > 0)) throw new Error("triangle values must be greater than zero");
        switch (e) {
            case"AAA":
                return sZ(n);
            case"AAS":
                return iZ(n);
            case"ASA":
                return rZ(n);
            case"SAS":
                return oZ(n);
            case"SSA":
                return aZ(n);
            case"SSS":
                return lZ(n);
            default:
                throw new Error("invalid triangle type, try again")
        }
    };
var hZ = cZ, sy = {
    arc: b9,
    circle: pT,
    cube: z9,
    cuboid: gT,
    cylinder: Y9,
    cylinderElliptic: mT,
    ellipse: fT,
    ellipsoid: rT,
    geodesicSphere: n7,
    line: r7,
    polygon: a7,
    polyhedron: _T,
    rectangle: yT,
    roundedCuboid: _7,
    roundedCylinder: E7,
    roundedRectangle: A7,
    sphere: oT,
    square: L7,
    star: B7,
    torus: Q7,
    triangle: hZ
}, wl;
(function (i) {
    i.Door = "DOOR", i.Window = "WINDOW"
})(wl || (wl = {}));

class vT extends pr {
    constructor(e) {
        super(e);
        z(this, "openingType");
        z(this, "wall");
        z(this, "position");
        z(this, "direction");
        z(this, "width");
        z(this, "height");
        z(this, "elevation");
        this.openingType = e.openingType, this.wall = e.wall, this.wall.addOpening(this), this.position = e.position, this.direction = e.direction, this.width = e.width, this.height = e.height, this.elevation = e.elevation
    }

    get x() {
        return this.position.getX()
    }

    get y() {
        return this.position.getY()
    }
}

class iy extends vT {
    constructor(e) {
        super({...e, openingType: wl.Door});
        z(this, "doorType");
        z(this, "generatesSolid");
        this.generatesSolid = !0, this.doorType = e.doorType
    }

    generateSolid(e, n) {
        const s = sy.cuboid({
            size: [this.width, .03, this.height],
            center: [this.position.getX(), this.position.getY(), this.height * .5 + this.elevation]
        });
        e(s, ea(Number.EPSILON, s.polygons), {options: n})
    }
}

class ry extends vT {
    constructor(e) {
        super({...e, openingType: wl.Window});
        z(this, "attachedWallId", null);
        z(this, "generatesSolid");
        this.generatesSolid = !0
    }

    generateSolid(e, n) {
        const s = sy.cuboid({
            size: [this.width, .03, this.height],
            center: [this.position.getX(), this.position.getY(), this.height * .5 + this.elevation]
        });
        e(s, ea(Number.EPSILON, s.polygons), {options: n})
    }
}

class uZ extends pr {
    constructor(e) {
        super(e);
        z(this, "poiType");
        z(this, "angle", 0);
        z(this, "position");
        z(this, "_space", null);
        z(this, "elevation");
        z(this, "visibilityWeight", 0);
        this.poiType = e.poiType, this.angle = e.angle ?? 0, this.position = e.position, this.elevation = e.elevation ?? 0
    }

    get space() {
        var e, n;
        if (((e = this._space) == null ? void 0 : e.deref()) == null) {
            let s = Number.MAX_VALUE, r = null;
            for (let o of this.floor.getSpaces()) {
                const a = o.area;
                Le.intersects(o.polygon, this.position) && a < s && (r = o, s = a)
            }
            r != null && (this._space = new WeakRef(r))
        }
        return ((n = this._space) == null ? void 0 : n.deref()) ?? null
    }
}

class dZ extends pr {
    constructor(e) {
        super(e);
        z(this, "polygon", null);
        z(this, "stairInfo", null);
        z(this, "area", 0);
        z(this, "interiorPoint", null);
        z(this, "_centerTopologyNode", null);
        z(this, "generatesSolid");
        this.generatesSolid = !0, this.polygon = e.polygon ?? null, this.polygon != null && (this.area = this.polygon.getArea(), this.interiorPoint = as.GeomFactory.createPoint(ki.getInteriorPoint(this.polygon)), this.area > e.floor.largestArea && (e.floor.largestArea = this.area), this.area < e.floor.smallestArea && (e.floor.smallestArea = this.area))
    }

    get centerTopologyNode() {
        var e, n;
        if (((e = this._centerTopologyNode) == null ? void 0 : e.deref()) == null && this.interiorPoint != null) {
            let s = Number.MAX_VALUE, r = null;
            for (let o of this.getTopologyNodes()) {
                const a = Ii.distance(this.interiorPoint, o.position);
                a < s && (s = a, r = o)
            }
            r != null && (this._centerTopologyNode = new WeakRef(r))
        }
        return ((n = this._centerTopologyNode) == null ? void 0 : n.deref()) ?? null
    }

    * getTopologyNodes(e = () => !0, n = !1) {
        for (let s of this.floor.getTopologyNodes(e, n)) Le.intersects(this.polygon, s.position) && (yield s)
    }

    * getPois(e = () => !0, n = !1) {
        for (let s of this.floor.getPois(e, n)) s.space == null ? Le.intersects(this.polygon, s.position) && (yield s) : s.space == this && (yield s)
    }

    setStairInfo({type: e, width: n, height: s, depth: r, reversal: o}) {
        this.stairInfo = {type: e, width: n, height: s, depth: r, reversal: o ?? !1, spaceId: this.id}
    }

    removeStairInfo() {
        this.stairInfo = null
    }

    generateSolid(e, n) {
        if (this.polygon == null) throw "Space.generateSolid: polygon이 존재하지 않습니다.";
        let s = this.polygon.getExteriorRing(), r = [];
        for (let h = s.getNumPoints() - 1; h > 0; --h) {
            const u = s.getCoordinateN(h), d = s.getCoordinateN(h - 1);
            r.push([xn.vec2.fromValues(u.x, u.y), xn.vec2.fromValues(d.x, d.y)])
        }
        let o = Yr.geom2.create(r), a = [];
        for (let h = 0; h < this.polygon.getNumInteriorRing(); ++h) {
            let u = this.polygon.getInteriorRingN(h), d = [];
            for (let f = u.getNumPoints() - 1; f > 0; --f) {
                const g = u.getCoordinateN(f), m = u.getCoordinateN(f - 1);
                d.push([xn.vec2.fromValues(g.x, g.y), xn.vec2.fromValues(m.x, m.y)])
            }
            a.push(Yr.geom2.create(d))
        }
        let l = ny.subtract(o, ...a);
        const c = kh.extrudeLinear({height: (n == null ? void 0 : n.height) ?? .15}, l);
        e(c, ea(Number.EPSILON, c.polygons), {options: n})
    }
}

class fZ extends pr {
    constructor(e) {
        super(e);
        z(this, "position");
        z(this, "targetNodeIds");
        z(this, "_space", null);
        this.position = e.position, this.targetNodeIds = new Array
    }

    get space() {
        var e, n;
        if (((e = this._space) == null ? void 0 : e.deref()) == null) {
            let s = Number.MAX_VALUE, r = null;
            for (let o of this.floor.getSpaces()) {
                const a = o.area;
                Le.intersects(o.polygon, this.position) && a < s && (r = o, s = a)
            }
            r != null && (this._space = new WeakRef(r))
        }
        return ((n = this._space) == null ? void 0 : n.deref()) ?? null
    }

    * targetNodes() {
        for (const e of this.targetNodeIds) {
            const n = this.building.topologyNodes.get(e);
            n != null && (yield n)
        }
    }
}

class pZ {
    constructor(t, e, n) {
        z(this, "id");
        z(this, "_source");
        z(this, "_target");
        z(this, "line");
        this.id = t, this._source = new WeakRef(e), this._target = new WeakRef(n), this.line = as.GeomFactory.createLineString(e.position.getCoordinate(), n.position.getCoordinate())
    }

    get source() {
        const t = this._source.deref();
        if (t == null) throw "TopologyLink.source: GC 후 참조 시도";
        return t
    }

    get target() {
        const t = this._target.deref();
        if (t == null) throw "TopologyLink.target: GC 후 참조 시도";
        return t
    }

    isInterFloor() {
        return this.source.floor !== this.target.floor
    }
}

const gZ = (i, t, e) => {
    for (i = i.slice(); i.length < e;) i.push(t);
    return i
};
var mZ = gZ;
const _Z = Xe, yZ = pM, xZ = fM, vZ = sp, wZ = (...i) => {
    if (i = _Z(i), i.length === 0) throw new Error("measureAggregateBoundingBox: no geometries supplied");
    const t = vZ(i);
    if (i.length === 1) return t;
    const e = [[Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]];
    return t.reduce((n, s) => (n = [yZ(n[0], n[0], s[0]), xZ(n[1], n[1], s[1])], n), e)
};
var bZ = wZ;
const EZ = Xe, bw = mZ, wT = bZ, {translate: SZ} = Po, MZ = i => {
    if (!Array.isArray(i.modes) || i.modes.length > 3) throw new Error("align(): modes must be an array of length <= 3");
    if (i.modes = bw(i.modes, "none", 3), i.modes.filter(t => ["center", "max", "min", "none"].includes(t)).length !== 3) throw new Error('align(): all modes must be one of "center", "max" or "min"');
    if (!Array.isArray(i.relativeTo) || i.relativeTo.length > 3) throw new Error("align(): relativeTo must be an array of length <= 3");
    if (i.relativeTo = bw(i.relativeTo, 0, 3), i.relativeTo.filter(t => Number.isFinite(t) || t == null).length !== 3) throw new Error("align(): all relativeTo values must be a number, or null.");
    if (typeof i.grouped != "boolean") throw new Error("align(): grouped must be a boolean value.");
    return i
}, TZ = (i, t, e) => {
    for (let n = 0; n < 3; n++) i[n] == null && (t[n] === "center" ? i[n] = (e[0][n] + e[1][n]) / 2 : t[n] === "max" ? i[n] = e[1][n] : t[n] === "min" && (i[n] = e[0][n]));
    return i
}, Ew = (i, t, e) => {
    const n = wT(i), s = [0, 0, 0];
    for (let r = 0; r < 3; r++) t[r] === "center" ? s[r] = e[r] - (n[0][r] + n[1][r]) / 2 : t[r] === "max" ? s[r] = e[r] - n[1][r] : t[r] === "min" && (s[r] = e[r] - n[0][r]);
    return SZ(s, i)
}, IZ = (i, ...t) => {
    i = Object.assign({}, {modes: ["center", "center", "min"], relativeTo: [0, 0, 0], grouped: !1}, i), i = MZ(i);
    let {modes: n, relativeTo: s, grouped: r} = i;
    if (t = EZ(t), t.length === 0) throw new Error("align(): No geometries were provided to act upon");
    if (s.filter(o => o == null).length) {
        const o = wT(t);
        s = TZ(s, n, o)
    }
    return r ? t = Ew(t, n, s) : t = t.map(o => Ew(o, n, s)), t.length === 1 ? t[0] : t
};
var AZ = IZ;
const CZ = Xe, PZ = xe, RZ = le, LZ = Fn, NZ = sp, {translate: OZ} = Po, Dg = (i, t) => {
        const e = {axes: [!0, !0, !0], relativeTo: [0, 0, 0]}, {axes: n, relativeTo: s} = Object.assign({}, e, i),
            r = NZ(t), o = [0, 0, 0];
        return n[0] && (o[0] = s[0] - (r[0][0] + (r[1][0] - r[0][0]) / 2)), n[1] && (o[1] = s[1] - (r[0][1] + (r[1][1] - r[0][1]) / 2)), n[2] && (o[2] = s[2] - (r[0][2] + (r[1][2] - r[0][2]) / 2)), OZ(o, t)
    }, lp = (i, ...t) => {
        const e = {axes: [!0, !0, !0], relativeTo: [0, 0, 0]}, {axes: n, relativeTo: s} = Object.assign({}, e, i);
        if (t = CZ(t), t.length === 0) throw new Error("wrong number of arguments");
        if (s.length !== 3) throw new Error("relativeTo must be an array of length 3");
        i = {axes: n, relativeTo: s};
        const r = t.map(o => LZ.isA(o) || PZ.isA(o) || RZ.isA(o) ? Dg(i, o) : o);
        return r.length === 1 ? r[0] : r
    }, DZ = (...i) => lp({axes: [!0, !1, !1]}, i), FZ = (...i) => lp({axes: [!1, !0, !1]}, i),
    zZ = (...i) => lp({axes: [!1, !1, !0]}, i);
var $u = {center: lp, centerX: DZ, centerY: FZ, centerZ: zZ};
const BZ = Xe, Sw = He, Mw = xe, Tw = le, Iw = Fn, cp = (i, ...t) => {
    if (!Array.isArray(i)) throw new Error("factors must be an array");
    if (t = BZ(t), t.length === 0) throw new Error("wrong number of arguments");
    for (i = i.slice(); i.length < 3;) i.push(1);
    if (i[0] <= 0 || i[1] <= 0 || i[2] <= 0) throw new Error("factors must be positive");
    const e = Sw.fromScaling(Sw.create(), i),
        n = t.map(s => Iw.isA(s) ? Iw.transform(e, s) : Mw.isA(s) ? Mw.transform(e, s) : Tw.isA(s) ? Tw.transform(e, s) : s);
    return n.length === 1 ? n[0] : n
}, kZ = (i, ...t) => cp([i, 1, 1], t), UZ = (i, ...t) => cp([1, i, 1], t), GZ = (i, ...t) => cp([1, 1, i], t);
var Wu = {scale: cp, scaleX: kZ, scaleY: UZ, scaleZ: GZ};
const VZ = Xe, Aw = xe, Cw = le, Pw = Fn, HZ = (i, ...t) => {
    if (t = VZ(t), t.length === 0) throw new Error("wrong number of arguments");
    const e = t.map(n => Pw.isA(n) ? Pw.transform(i, n) : Aw.isA(n) ? Aw.transform(i, n) : Cw.isA(n) ? Cw.transform(i, n) : n);
    return e.length === 1 ? e[0] : e
};
var $Z = HZ, Rw = {
    align: AZ,
    center: $u.center,
    centerX: $u.centerX,
    centerY: $u.centerY,
    centerZ: $u.centerZ,
    mirror: vc.mirror,
    mirrorX: vc.mirrorX,
    mirrorY: vc.mirrorY,
    mirrorZ: vc.mirrorZ,
    rotate: bc.rotate,
    rotateX: bc.rotateX,
    rotateY: bc.rotateY,
    rotateZ: bc.rotateZ,
    scale: Wu.scale,
    scaleX: Wu.scaleX,
    scaleY: Wu.scaleY,
    scaleZ: Wu.scaleZ,
    transform: $Z,
    translate: Po.translate,
    translateX: Po.translateX,
    translateY: Po.translateY,
    translateZ: Po.translateZ
};

class WZ extends pr {
    constructor(e) {
        super(e);
        z(this, "grid");
        z(this, "thickness");
        z(this, "height");
        z(this, "materialId");
        z(this, "component");
        z(this, "openingIds");
        z(this, "outline", null);
        z(this, "generatesSolid");
        this.generatesSolid = !0, this.grid = e.grid, this.thickness = e.thickness, this.height = e.height, this.materialId = e.materialId ?? null, this.component = e.component ?? null, this.openingIds = new Set
    }

    setOutline(e) {
        this.outline = e
    }

    addOpening(e) {
        this.openingIds.add(e.id), this.floor.addOpening(e)
    }

    getOpeningById(e) {
        return this.openingIds.has(e) ? this.floor.getOpeningById(e) : null
    }

    * getOpenings(e = () => !0, n = !1) {
        for (const s of this.openingIds) {
            const r = this.floor.getOpeningById(s);
            if (r != null && e(r) === !0 && (yield r, n === !0)) break
        }
    }

    get openings() {
        return this.getOpenings()
    }

    get material() {
        return this.materialId == null ? null : this.building.materials.get(this.materialId) ?? null
    }

    generateSolid(e, n) {
        let o = new Nn(this.grid, new Jt(Jt.DEFAULT_QUADRANT_SEGMENTS, Jt.CAP_FLAT, Jt.JOIN_MITRE, Jt.DEFAULT_MITRE_LIMIT)).getResultGeometry(this.thickness * .5).getExteriorRing(),
            a = [];
        for (let d = o.getNumPoints() - 1; d > 0; --d) {
            const f = o.getCoordinateN(d), g = o.getCoordinateN(d - 1);
            a.push([xn.vec2.fromValues(f.x, f.y), xn.vec2.fromValues(g.x, g.y)])
        }
        let l = Yr.geom2.create(a),
            c = kh.extrudeLinear({height: (n == null ? void 0 : n.height) ?? this.floor.height}, l), h = [];
        for (let d of this.openings) {
            let f = Rw.rotateZ(d.direction * (Math.PI / 180), sy.cuboid({
                size: [d.width, 1, d.height],
                center: [0, 0, 0]
            }));
            h.push(Rw.translate([d.position.getX(), d.position.getY(), d.height * .5 + d.elevation], f))
        }
        let u = ny.subtract(c, h);
        e(u, ea(Number.EPSILON, u.polygons), {options: n})
    }
}

class qZ {
    constructor(t) {
        z(this, "scale");
        z(this, "rotation");
        z(this, "position");
        z(this, "vertices");
        z(this, "indices");
        z(this, "properties");
        this.scale = t.scale ?? 1, this.rotation = t.rotation ?? 0, this.position = t.position ?? new F(0, 0), this.vertices = t.vertices, this.indices = t.indices, this.properties = t.properties ?? null
    }
}

class YZ extends pr {
    constructor(e) {
        super(e);
        z(this, "component", null);
        z(this, "outline", null);
        z(this, "height");
        this.height = e.height, this.outline = e.outline
    }
}

class XZ extends pr {
    constructor(e) {
        super(e);
        z(this, "fileName");
        z(this, "rotation");
        z(this, "scale");
        z(this, "modelerGenerated");
        this.fileName = e.fileName, this.modelerGenerated = e.modelerGenerated ?? !1, this.rotation = e.rotation ?? 0, this.scale = e.scale ?? [1, 1, 1]
    }
}

class ZZ {
    static distance(t, e) {
        return Ii.distance(t, e)
    }

    static intersects(t, e) {
        return Le.intersects(t, e)
    }

    static contains(t, e) {
        return Le.contains(t, e)
    }

    static createPoint(t) {
        return Array.isArray(t) && t.length === 2 ? as.GeomFactory.createPoint(new F(t[0], t[1])) : as.GeomFactory.createPoint(new F(t.x, t.y))
    }

    static concatWithSort(t, e) {
        return t.sort((n, s) => n === s ? 0 : n < s ? -1 : 1), t.join(e)
    }

    static bufferOp(t, e) {
        return Nn.bufferOp(t, e)
    }

    static getFileExtension(t) {
        let e = t.lastIndexOf(".");
        return e === -1 ? "" : t.substring(e + 1).toLowerCase()
    }

    static getFileNameFromPath(t) {
        let e = t.lastIndexOf("/");
        return e === -1 && (e = t.lastIndexOf("\\")), e === -1 ? t : t.substring(e + 1)
    }

    static getDirectoryFromPath(t) {
        let e = t.lastIndexOf("/");
        return e === -1 && (e = t.lastIndexOf("\\")), e === -1 ? "" : t.substring(0, e + 1)
    }

    static urlJoin(...t) {
        let e = "";
        for (let n in t) e.length === 0 ? e = t[n] : (e.endsWith("/") || (e += "/"), e += t[n]);
        return e
    }
}

class jZ {
    constructor(t) {
        z(this, "id");
        z(this, "name");
        z(this, "color");
        z(this, "opacity");
        z(this, "abstractPath");
        z(this, "relativePath");
        z(this, "tiling");
        z(this, "offset");
        this.id = t.id, this.name = t.name ?? null, this.color = t.color, this.opacity = t.opacity ?? 1, this.abstractPath = t.abstractPath, this.relativePath = t.relativePath, this.tiling = t.tiling ?? [1, 1], this.offset = t.offset ?? [0, 0]
    }
}

class KZ extends pr {
    constructor(e) {
        super(e);
        z(this, "fileName");
        z(this, "rotation", 0);
        z(this, "scale", 1);
        z(this, "position");
        z(this, "elevation", 0);
        this.fileName = e.fileName, this.position = e.position, this.elevation = e.elevation, this.rotation = e.rotation ?? 0, this.scale = e.scale ?? 1
    }
}

class Hm {
    static queryElementOrThrow(t, e) {
        try {
            let n = t.querySelector(e);
            if (n == null) throw `queryElementOrThrow: ${e}로 선택된 요소가 없습니다.`;
            return n
        } catch {
            throw `queryElementOrThrow: ${e}로 선택된 요소가 없습니다.`
        }
    }

    static queryElementTextOrThrow(t, e) {
        try {
            let n = t.querySelector(e);
            if (n == null) throw `queryElementTextOrThrow: ${e}로 선택된 요소가 없습니다.`;
            if (n.textContent == null) throw `queryElementTextOrThrow: ${e}로 선택된 요소에 텍스트가 없습니다.`;
            return n.textContent
        } catch {
            throw `queryElementTextOrThrow: ${e}로 선택된 요소가 없습니다.`
        }
    }

    static getAttributeOrThrow(t, e) {
        try {
            let n = t.getAttribute(e);
            if (n == null) throw `getAttributeOrThrow: ${e} 속성이 없습니다.`;
            return n
        } catch {
            throw `getAttributeOrThrow: ${e} 속성이 없습니다.`
        }
    }

    static loadFromXmlText(t) {
        let n = new DOMParser().parseFromString(t, "text/xml");
        return this.loadFromXmlDoc(n)
    }

    static loadFromXmlDoc(t, e) {
        if (t.documentElement.tagName != "IndoorModelFile") throw "loadFromXmlDoc: 올바른 IndoorModelFile이 아닙니다.";
        let n = performance.now(), s = this.queryElementOrThrow(t, ":scope > ProjectInfo"),
            r = s.getAttribute("name") ?? "", o = this.getAttributeOrThrow(s, "unit"), a = new as(r, o);
        a.sourceUri = (e == null ? void 0 : e.sourceUri) ?? null, this.ScaleToMeter = a.scaleToMeter;
        let l = s.querySelector("GisProperties");
        l != null && (a.gisProperties = {
            centerLat: Number.parseFloat(this.queryElementTextOrThrow(l, "CenterLat")),
            centerLon: Number.parseFloat(this.queryElementTextOrThrow(l, "CenterLon")),
            utm_k: this.parsePosAsCoordinate(this.queryElementOrThrow(l, "UTM_K"), this.NoScale),
            offset: this.parsePosAsCoordinate(this.queryElementOrThrow(l, "Offset"), this.NoScale),
            azimuth: 0
        });
        let c = t.querySelector(":scope > Groups");
        if (c != null) for (let f = c.firstElementChild; f != null; f = f.nextElementSibling) this.parseGroup(a, f);
        let h = t.querySelector(":scope > Materials");
        if (h != null) for (let f = h.firstElementChild; f != null; f = f.nextElementSibling) this.parseMaterial(a, f);
        let u = this.queryElementOrThrow(t, ":scope > Levels");
        for (let f = u.firstElementChild; f != null; f = f.nextElementSibling) {
            let g = this.getAttributeOrThrow(f, "id"), m = this.queryElementTextOrThrow(f, ":scope > Name"),
                p = Number.parseFloat(this.queryElementTextOrThrow(f, "Elevation")) * a.scaleToMeter,
                _ = Number.parseFloat(this.queryElementTextOrThrow(f, "Height")) * a.scaleToMeter,
                x = new fX({building: a, id: g, name: m, elevation: p, height: _});
            a.floors.set(g, x), this.parseExternalModel(x, f.querySelector(":scope > Model")), this.parseGridCollection(x, f.querySelector("GridCollection")), this.parseElementCollection(x, f.querySelector("ElementCollection")), this.parseFloorMeshes(x, f.querySelectorAll(":scope > Mesh")), this.parseGroupShapeCollection(x, f.querySelector("GroupShapeCollection")), x.calculateBoundingBox(0)
        }
        for (let f of a.getTopologyNodes()) for (let g = 0, m = f.targetNodeIds.length; g < m; ++g) {
            const p = f.targetNodeIds[g];
            let _ = a.topologyNodes.get(p);
            if (_ == null) continue;
            const x = ZZ.concatWithSort([f.id, p], "_");
            a.topologyLinks.has(x) || a.topologyLinks.set(x, new pZ(x, f, _))
        }
        let d = performance.now();
        return console.log(`XML 로딩 시간: ${d - n}ms`), a
    }

    static parsePosAsPoint(t, e) {
        if (t.textContent == null) throw "parsePos: textContent가 null입니다.";
        let n = t.textContent.split(",");
        return as.GeomFactory.createPoint(new F(e * Number.parseFloat(n[0]), e * Number.parseFloat(n[1])))
    }

    static parsePosAsCoordinate(t, e) {
        if (t.textContent == null) throw "parsePosAsCoordinate: textContent가 null입니다.";
        let n = t.textContent.split(",");
        return new F(e * Number.parseFloat(n[0]), e * Number.parseFloat(n[1]))
    }

    static parsePointAsPoint(t, e) {
        if (t.firstElementChild == null) throw "parsePointAsPoint: 자식 노드가 없습니다.";
        return this.parsePosAsPoint(t.firstElementChild, e)
    }

    static parsePointAsCoordinate(t, e) {
        if (t.firstElementChild == null) throw "parsePointAsCoordinate: 자식 노드가 없습니다.";
        return this.parsePosAsCoordinate(t.firstElementChild, e)
    }

    static parsePolygon(t, e) {
        let n = new Array;
        for (let s = t.firstElementChild; s != null; s = s.nextElementSibling) n.push(this.parsePosAsCoordinate(s, e));
        return n[0].equals2D(n[n.length - 1]) || n.push(n[0]), as.GeomFactory.createPolygon(as.GeomFactory.createLinearRing(n))
    }

    static parseLine(t, e) {
        let n = new Array;
        for (let s = t.firstElementChild; s != null; s = s.nextElementSibling) n.push(this.parsePosAsCoordinate(s, e));
        return as.GeomFactory.createLineString(n)
    }

    static parseExternalModel(t, e) {
        var c;
        if (e == null) return;
        const n = e.getAttribute("modelerGenerated") === "True", s = e.getAttribute("id") ?? "",
            r = ((c = e.querySelector("Name")) == null ? void 0 : c.textContent) ?? "",
            o = Number.parseFloat(this.queryElementTextOrThrow(e, "Rotation")),
            a = this.queryElementTextOrThrow(e, "Scale").split(",").map(h => Number.parseFloat(h)),
            l = this.queryElementTextOrThrow(e, "Link href");
        t.externalModel = new XZ({floor: t, id: s, name: r, fileName: l, modelerGenerated: n, rotation: o, scale: a})
    }

    static parseLibraryModel(t, e) {
        var h;
        if (e == null) return;
        const n = e.getAttribute("id");
        if (n == null) throw "parseLibraryModel: ID가 없습니다.";
        const s = ((h = e.querySelector("Name")) == null ? void 0 : h.textContent) ?? "",
            r = Number.parseFloat(this.queryElementTextOrThrow(e, "Rotation")),
            o = Number.parseFloat(this.queryElementTextOrThrow(e, "Scale")),
            a = this.parsePointAsPoint(this.queryElementOrThrow(e, "Point"), this.ScaleToMeter),
            l = Number.parseFloat(this.queryElementTextOrThrow(e, "Elevation")) * this.ScaleToMeter,
            c = this.queryElementTextOrThrow(e, "Link href");
        t.addLibraryModel(new KZ({
            floor: t,
            id: n,
            name: s,
            fileName: c,
            position: a,
            elevation: l,
            rotation: r,
            scale: o
        }))
    }

    static parseGridCollection(t, e) {
        if (e != null) for (let n = e.firstElementChild; n != null; n = n.nextElementSibling) {
            if (n.firstElementChild == null) throw "parseGridCollection: Line 요소가 없습니다.";
            let s = this.getAttributeOrThrow(n, "id"), r = this.parseLine(n.firstElementChild, this.ScaleToMeter);
            t.addGrid(s, r)
        }
    }

    static parseProperties(t) {
        if (t == null) return;
        let e = new Map;
        for (let n = t.firstElementChild; n != null; n = n.nextElementSibling) e.set(this.queryElementTextOrThrow(n, "Name"), this.queryElementTextOrThrow(n, "Value"));
        return e
    }

    static parseStair(t, e) {
        let n = e.querySelectorAll("Mesh");
        if (n.length > 0) n.forEach(s => {
            let r = this.parseMesh(s);
            r != null && t.floor.staticStairMeshes.push(r)
        }); else {
            let s = e.getAttribute("Reversal") === "True", r = this.queryElementTextOrThrow(e, "Type"),
                o = Number.parseFloat(this.queryElementTextOrThrow(e, "Width")) * this.ScaleToMeter,
                a = Number.parseFloat(this.queryElementTextOrThrow(e, "Height")) * this.ScaleToMeter,
                l = Number.parseFloat(this.queryElementTextOrThrow(e, "Depth")) * this.ScaleToMeter;
            t.setStairInfo({type: r, width: o, height: a, depth: l, reversal: s})
        }
    }

    static parseMass(t, e) {
        let n = this.parseMesh(e.querySelector("Mesh"));
        n != null && (n.scale = Number.parseFloat(this.queryElementTextOrThrow(e, "Scale")), n.rotation = Number.parseFloat(this.queryElementTextOrThrow(e, "Rotation")), n.position = this.parsePointAsCoordinate(this.queryElementOrThrow(e, "Point"), this.ScaleToMeter), t.staticStairMeshes.push(n))
    }

    static parseMesh(t) {
        if (t == null) return null;
        let n = this.queryElementTextOrThrow(t, "Vertex").split(/[\s,]+/);
        if (n.length % 3 != 0) return null;
        let s = new Float32Array(n.length);
        for (let c = 0; c < n.length; c += 3) s[c + 0] = Number.parseFloat(n[c + 0]) * this.ScaleToMeter, s[c + 1] = Number.parseFloat(n[c + 1]) * this.ScaleToMeter, s[c + 2] = -Number.parseFloat(n[c + 2]) * this.ScaleToMeter;
        if (n = this.queryElementTextOrThrow(t, "Face").split(/[\s,]+/), n.length % 3 != 0) return null;
        let o = [];
        for (let c = 0; c < n.length; c += 3) o[c + 0] = parseInt(n[c + 2]), o[c + 1] = parseInt(n[c + 1]), o[c + 2] = parseInt(n[c + 0]);
        let a = new Map, l = t.getAttribute("Type");
        return l != null && a.set("Type", l), new qZ({vertices: s, indices: o, properties: a})
    }

    static parseSpace(t, e) {
        let n = this.getAttributeOrThrow(e, "id"), s = e.getAttribute("name") ?? "", r = e.getAttribute("groupid"),
            o = this.parseProperties(e.querySelector("Properties")), a = new Array, l = null,
            c = e.querySelector("Boundary");
        if (c != null) {
            for (let m = c.firstElementChild; m != null; m = m.nextElementSibling) {
                let p = this.parseLine(m, this.ScaleToMeter);
                a.push(p.getCoordinate())
            }
            a[0].equals2D(a[a.length - 1]) || a.push(a[0]);
            let d = as.GeomFactory.createLinearRing(a), f = new Array;
            e.querySelectorAll("Hole").forEach(m => {
                let p = new Array;
                for (let x = m.firstElementChild; x != null; x = x.nextElementSibling) {
                    let y = this.parseLine(x, this.ScaleToMeter);
                    p.push(y.getCoordinate())
                }
                p[0].equals2D(p[p.length - 1]) || p.push(p[0]);
                let _ = as.GeomFactory.createLinearRing(p);
                f.push(_)
            }), l = as.GeomFactory.createPolygon(d, f)
        }
        let h = new dZ({floor: t, id: n, name: s, polygon: l, properties: o});
        t.addSpace(h), r != null && r.length > 0 && r.split(",").forEach(f => {
            const g = t.building.groups.get(f);
            g != null && (h.addGroup(g), g.addElement(h))
        });
        let u = e.querySelector("Stair");
        u != null && this.parseStair(h, u)
    }

    static parseWall(t, e) {
        let n = this.getAttributeOrThrow(e, "id"), s = this.getAttributeOrThrow(e, "grid"),
            r = e.getAttribute("Component"), o = e.getAttribute("material_id"),
            a = this.parseProperties(e.querySelector("Properties")),
            l = Number.parseFloat(this.queryElementTextOrThrow(e, "Thickness")) * this.ScaleToMeter,
            c = Number.parseFloat(this.queryElementTextOrThrow(e, "Height")) * this.ScaleToMeter, h = t.getGridById(s);
        if (h != null) {
            let u = new WZ({
                floor: t,
                id: n,
                grid: h,
                thickness: l,
                height: c,
                component: r,
                materialId: o,
                properties: a
            });
            t.addWall(u)
        } else console.log(`Wall(${n})를 위한 Grid(${s})가 존재하지 않습니다. Wall은 생성되지 않았습니다.`)
    }

    static parseWallJoint(t, e) {
        let n = e.getAttribute("Component"), s = this.parseProperties(e.querySelector("Properties")),
            r = Number.parseFloat(this.queryElementTextOrThrow(e, "Height")) * this.ScaleToMeter,
            o = e.querySelector("Outline");
        if (o != null) {
            let a = [];
            for (let c = o.firstElementChild; c != null; c = c.nextElementSibling) a.push(this.parsePosAsCoordinate(c, this.ScaleToMeter));
            let l = new YZ({
                id: "",
                floor: t,
                outline: as.GeomFactory.createPolygon(as.GeomFactory.createLinearRing(a)),
                height: r,
                properties: s
            });
            l.component = n, t.wallJoints.push(l), t.building.useWallOutline = !0
        }
    }

    static getWallDirection(t) {
        const e = t.grid.getCoordinateN(0), n = t.grid.getCoordinateN(1);
        return -Math.atan2(n.y - e.y, n.x - e.x) * (180 / Math.PI)
    }

    static parseDoor(t, e) {
        let n = this.getAttributeOrThrow(e, "id");
        const s = this.getAttributeOrThrow(e, "attachedWall").replace("w_", "");
        if (s === "none") {
            console.warn("This door is not attached to wall. Skipping.", n);
            return
        }
        const r = t.getWallById(s);
        if (r == null) {
            console.warn("This door is not attached to wall. Skipping.", n);
            return
        }
        let o = this.parsePointAsPoint(this.queryElementOrThrow(e, "Point"), this.ScaleToMeter),
            a = Number.parseFloat(this.queryElementTextOrThrow(e, "Direction")),
            l = Number.parseFloat(this.queryElementTextOrThrow(e, "Width")) * this.ScaleToMeter,
            c = Number.parseFloat(this.queryElementTextOrThrow(e, "Height")) * this.ScaleToMeter,
            h = Number.parseFloat(this.queryElementTextOrThrow(e, "Elevation")) * this.ScaleToMeter,
            u = Number.parseInt(this.queryElementTextOrThrow(e, "DoorType")), d = new iy({
                floor: t,
                id: n,
                wall: r,
                position: o,
                direction: a,
                width: l,
                height: c,
                elevation: h,
                doorType: u
            });
        r.addOpening(d)
    }

    static parseWindow(t, e) {
        let n = this.getAttributeOrThrow(e, "id");
        const s = this.getAttributeOrThrow(e, "attachedWall").replace("w_", "");
        let r = t.getWallById(s);
        if (r == null) return;
        let o = this.parsePointAsPoint(this.queryElementOrThrow(e, "Point"), this.ScaleToMeter),
            a = Number.parseFloat(this.queryElementTextOrThrow(e, "Direction")),
            l = Number.parseFloat(this.queryElementTextOrThrow(e, "Width")) * this.ScaleToMeter,
            c = Number.parseFloat(this.queryElementTextOrThrow(e, "Height")) * this.ScaleToMeter,
            h = Number.parseFloat(this.queryElementTextOrThrow(e, "Elevation")) * this.ScaleToMeter,
            u = new ry({floor: t, id: n, wall: r, position: o, direction: a, width: l, height: c, elevation: h});
        r.addOpening(u)
    }

    static parseColumn(t, e) {
        let n = this.getAttributeOrThrow(e, "id"), s = this.parseProperties(e.querySelector("ColumnProperties")),
            r = e.querySelector("Rect");
        if (r != null) {
            let a, l, c, h;
            a = this.parsePointAsPoint(this.queryElementOrThrow(r, "TL Point"), this.ScaleToMeter), l = this.parsePointAsPoint(this.queryElementOrThrow(r, "TR Point"), this.ScaleToMeter), c = this.parsePointAsPoint(this.queryElementOrThrow(r, "BL Point"), this.ScaleToMeter), h = this.parsePointAsPoint(this.queryElementOrThrow(r, "BR Point"), this.ScaleToMeter);
            let u = new uX({floor: t, id: n, tl: a, tr: l, bl: c, br: h, properties: s});
            t.addColumn(u);
            return
        }
        let o = e.querySelector("Circle");
        if (o != null) {
            let a;
            a = this.parsePointAsPoint(this.queryElementOrThrow(o, "Center Point"), this.ScaleToMeter);
            let l = Number.parseFloat(this.queryElementTextOrThrow(o, "Radius")) * this.ScaleToMeter,
                c = new dX({floor: t, id: n, position: a, radius: l, properties: s});
            t.addColumn(c)
        }
    }

    static parseTopology(t, e) {
        for (let n = e.firstElementChild; n != null; n = n.nextElementSibling) this.parseNode(t, n)
    }

    static parseNode(t, e) {
        let n = this.getAttributeOrThrow(e, "id"), s = this.parseProperties(e.querySelector("TopologyNodeProperties")),
            r = this.parsePointAsPoint(this.queryElementOrThrow(e, "Point"), this.ScaleToMeter),
            o = s == null ? void 0 : s.get("Name"), a = new fZ({floor: t, id: n, name: o, position: r, properties: s});
        t.building.topologyNodes.set(n, a), t.addTopologyNode(a), e.querySelectorAll("Target").forEach(c => {
            a.targetNodeIds.push(this.getAttributeOrThrow(c, "id"))
        })
    }

    static parsePoi(t, e) {
        let n = this.getAttributeOrThrow(e, "id"), s = this.getAttributeOrThrow(e, "type"),
            r = e.getAttribute("groupid"), o = this.parseProperties(e.querySelector("Properties")),
            a = this.queryElementOrThrow(e, ":scope > Name").textContent, l = e.querySelector("Height"), c = 0;
        l != null && l.textContent != null && (c = Number.parseFloat(l.textContent) * this.ScaleToMeter);
        let h = Number.parseFloat(this.queryElementTextOrThrow(e, "Angle")),
            u = this.parsePointAsPoint(this.queryElementOrThrow(e, "Point"), this.ScaleToMeter),
            d = new uZ({floor: t, id: n, name: a, poiType: s, angle: h, position: u, elevation: c, properties: o});
        if (t.addPoi(d), r != null && r.length > 0) {
            const f = t.building.groups.get(r);
            f != null && (d.addGroup(f), f.addElement(d))
        }
    }

    static parseElementCollection(t, e) {
        if (e != null) for (let n = e.firstElementChild; n != null; n = n.nextElementSibling) switch (n.tagName) {
            case"Space":
                this.parseSpace(t, n);
                break;
            case"Wall":
                this.parseWall(t, n);
                break;
            case"WallJoint":
                this.parseWallJoint(t, n);
                break;
            case"Door":
                this.parseDoor(t, n);
                break;
            case"Window":
                this.parseWindow(t, n);
                break;
            case"Column":
                this.parseColumn(t, n);
                break;
            case"Topology":
                this.parseTopology(t, n);
                break;
            case"POI":
                this.parsePoi(t, n);
                break;
            case"Mass":
                this.parseMass(t, n);
                break;
            case"Library":
                this.parseLibraryModel(t, n);
                break
        }
    }

    static parseFloorMeshes(t, e) {
        e.forEach(n => {
            let s = this.parseMesh(n);
            s != null && t.meshes.push(s)
        })
    }

    static parseGroupShapeCollection(t, e) {
        e != null && e.querySelectorAll(":scope > GroupPolygon").forEach(n => {
            const s = this.getAttributeOrThrow(n, "groupid");
            n.querySelectorAll(":scope > Polygon").forEach(r => {
                const o = this.parsePolygon(r, this.ScaleToMeter), a = t.building.groups.get(s);
                a != null && a.addPolygon(t.id, o)
            })
        })
    }

    static parseColorRGB(t) {
        const e = t.split(",").map(n => Number.parseInt(n));
        return e.length != 3 ? 16711935 : e[0] << 16 | e[1] << 8 | e[2]
    }

    static parseColorRGBA(t) {
        const e = t.split(",").map(n => Number.parseInt(n));
        return e.length != 4 ? {color: 16711935, opacity: 1} : {
            color: e[0] << 16 | e[1] << 8 | e[2],
            opacity: e[3] / 255
        }
    }

    static parseGroup(t, e) {
        const n = this.getAttributeOrThrow(e, "id"), s = this.getAttributeOrThrow(e, "name"),
            r = this.parseColorRGB(this.getAttributeOrThrow(e, "color")), o = this.getAttributeOrThrow(e, "type");
        t.groups.set(n, new _9({building: t, id: n, type: o, name: s, color: r}))
    }

    static parseMaterial(t, e) {
        const n = this.getAttributeOrThrow(e, "id"), s = this.getAttributeOrThrow(e, "name"),
            r = this.parseColorRGBA(this.getAttributeOrThrow(e, "color")),
            o = this.queryElementTextOrThrow(e, "AbstractPath"), a = this.queryElementTextOrThrow(e, "RelativePath"),
            l = this.queryElementTextOrThrow(e, "Tiling").split(",").map(u => Number.parseFloat(u)),
            c = this.queryElementTextOrThrow(e, "Offset").split(",").map(u => Number.parseFloat(u)), h = new jZ({
                id: n,
                name: s,
                color: r.color,
                opacity: r.opacity,
                abstractPath: o,
                relativePath: a,
                tiling: l,
                offset: c
            });
        t.materials.set(n, h)
    }
}

z(Hm, "NoScale", 1), z(Hm, "ScaleToMeter", 1);

function Lw(i, t) {
    if (t === Pb) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
    if (t === od || t === Qm) {
        let e = i.getIndex();
        if (e === null) {
            const o = [], a = i.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++) o.push(l);
                i.setIndex(o), e = i.getIndex()
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i
        }
        const n = e.count - 2, s = [];
        if (t === od) for (let o = 1; o <= n; o++) s.push(e.getX(0)), s.push(e.getX(o)), s.push(e.getX(o + 1)); else for (let o = 0; o < n; o++) o % 2 === 0 ? (s.push(e.getX(o)), s.push(e.getX(o + 1)), s.push(e.getX(o + 2))) : (s.push(e.getX(o + 2)), s.push(e.getX(o + 1)), s.push(e.getX(o)));
        s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const r = i.clone();
        return r.setIndex(s), r.clearGroups(), r
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), i
}

class bT extends ps {
    constructor(t) {
        super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) {
            return new nj(e)
        }), this.register(function (e) {
            return new cj(e)
        }), this.register(function (e) {
            return new hj(e)
        }), this.register(function (e) {
            return new ij(e)
        }), this.register(function (e) {
            return new rj(e)
        }), this.register(function (e) {
            return new oj(e)
        }), this.register(function (e) {
            return new aj(e)
        }), this.register(function (e) {
            return new ej(e)
        }), this.register(function (e) {
            return new lj(e)
        }), this.register(function (e) {
            return new sj(e)
        }), this.register(function (e) {
            return new QZ(e)
        }), this.register(function (e) {
            return new uj(e)
        }), this.register(function (e) {
            return new dj(e)
        })
    }

    load(t, e, n, s) {
        const r = this;
        let o;
        this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = cl.extractUrlBase(t), this.manager.itemStart(t);
        const a = function (c) {
            s ? s(c) : console.error(c), r.manager.itemError(t), r.manager.itemEnd(t)
        }, l = new ks(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(t, function (c) {
            try {
                r.parse(c, o, function (h) {
                    e(h), r.manager.itemEnd(t)
                }, a)
            } catch (h) {
                a(h)
            }
        }, n, a)
    }

    setDRACOLoader(t) {
        return this.dracoLoader = t, this
    }

    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }

    setKTX2Loader(t) {
        return this.ktx2Loader = t, this
    }

    setMeshoptDecoder(t) {
        return this.meshoptDecoder = t, this
    }

    register(t) {
        return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this
    }

    unregister(t) {
        return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
    }

    parse(t, e, n, s) {
        let r;
        const o = {}, a = {}, l = new TextDecoder;
        if (typeof t == "string") r = JSON.parse(t); else if (t instanceof ArrayBuffer) if (l.decode(new Uint8Array(t, 0, 4)) === ET) {
            try {
                o[_e.KHR_BINARY_GLTF] = new fj(t)
            } catch (u) {
                s && s(u);
                return
            }
            r = JSON.parse(o[_e.KHR_BINARY_GLTF].content)
        } else r = JSON.parse(l.decode(t)); else r = t;
        if (r.asset === void 0 || r.asset.version[0] < 2) {
            s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new Tj(r, {
            path: e || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const u = this.pluginCallbacks[h](c);
            a[u.name] = u, o[u.name] = !0
        }
        if (r.extensionsUsed) for (let h = 0; h < r.extensionsUsed.length; ++h) {
            const u = r.extensionsUsed[h], d = r.extensionsRequired || [];
            switch (u) {
                case _e.KHR_MATERIALS_UNLIT:
                    o[u] = new tj;
                    break;
                case _e.KHR_DRACO_MESH_COMPRESSION:
                    o[u] = new pj(r, this.dracoLoader);
                    break;
                case _e.KHR_TEXTURE_TRANSFORM:
                    o[u] = new gj;
                    break;
                case _e.KHR_MESH_QUANTIZATION:
                    o[u] = new mj;
                    break;
                default:
                    d.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".')
            }
        }
        c.setExtensions(o), c.setPlugins(a), c.parse(n, s)
    }

    parseAsync(t, e) {
        const n = this;
        return new Promise(function (s, r) {
            n.parse(t, e, s, r)
        })
    }
}

function JZ() {
    let i = {};
    return {
        get: function (t) {
            return i[t]
        }, add: function (t, e) {
            i[t] = e
        }, remove: function (t) {
            delete i[t]
        }, removeAll: function () {
            i = {}
        }
    }
}

const _e = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};

class QZ {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_LIGHTS_PUNCTUAL, this.cache = {refs: {}, uses: {}}
    }

    _markDefs() {
        const t = this.parser, e = this.parser.json.nodes || [];
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, r.extensions[this.name].light)
        }
    }

    _loadLight(t) {
        const e = this.parser, n = "light:" + t;
        let s = e.cache.get(n);
        if (s) return s;
        const r = e.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
        let c;
        const h = new pt(16777215);
        l.color !== void 0 && h.fromArray(l.color);
        const u = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
            case"directional":
                c = new af(h), c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            case"point":
                c = new C0(h), c.distance = u;
                break;
            case"spot":
                c = new A0(h), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0), c.decay = 2, Cr(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = e.createUniqueName(l.name || "light_" + t), s = Promise.resolve(c), e.cache.add(n, s), s
    }

    getDependency(t, e) {
        if (t === "light") return this._loadLight(e)
    }

    createNodeAttachment(t) {
        const e = this, n = this.parser, r = n.json.nodes[t], a = (r.extensions && r.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function (l) {
            return n._getNodeRef(e.cache, a, l)
        })
    }
}

class tj {
    constructor() {
        this.name = _e.KHR_MATERIALS_UNLIT
    }

    getMaterialType() {
        return rn
    }

    extendParams(t, e, n) {
        const s = [];
        t.color = new pt(1, 1, 1), t.opacity = 1;
        const r = e.pbrMetallicRoughness;
        if (r) {
            if (Array.isArray(r.baseColorFactor)) {
                const o = r.baseColorFactor;
                t.color.fromArray(o), t.opacity = o[3]
            }
            r.baseColorTexture !== void 0 && s.push(n.assignTexture(t, "map", r.baseColorTexture, Ee))
        }
        return Promise.all(s)
    }
}

class ej {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_EMISSIVE_STRENGTH
    }

    extendMaterialParams(t, e) {
        const s = this.parser.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = s.extensions[this.name].emissiveStrength;
        return r !== void 0 && (e.emissiveIntensity = r), Promise.resolve()
    }
}

class nj {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_CLEARCOAT
    }

    getMaterialType(t) {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : dr
    }

    extendMaterialParams(t, e) {
        const n = this.parser, s = n.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [], o = s.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (e.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && r.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            e.clearcoatNormalScale = new j(a, a)
        }
        return Promise.all(r)
    }
}

class sj {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_IRIDESCENCE
    }

    getMaterialType(t) {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : dr
    }

    extendMaterialParams(t, e) {
        const n = this.parser, s = n.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [], o = s.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (e.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && r.push(n.assignTexture(e, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (e.iridescenceIOR = o.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(e, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(r)
    }
}

class ij {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_SHEEN
    }

    getMaterialType(t) {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : dr
    }

    extendMaterialParams(t, e) {
        const n = this.parser, s = n.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [];
        e.sheenColor = new pt(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
        const o = s.extensions[this.name];
        return o.sheenColorFactor !== void 0 && e.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && r.push(n.assignTexture(e, "sheenColorMap", o.sheenColorTexture, Ee)), o.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(e, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r)
    }
}

class rj {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_TRANSMISSION
    }

    getMaterialType(t) {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : dr
    }

    extendMaterialParams(t, e) {
        const n = this.parser, s = n.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [], o = s.extensions[this.name];
        return o.transmissionFactor !== void 0 && (e.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && r.push(n.assignTexture(e, "transmissionMap", o.transmissionTexture)), Promise.all(r)
    }
}

class oj {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_VOLUME
    }

    getMaterialType(t) {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : dr
    }

    extendMaterialParams(t, e) {
        const n = this.parser, s = n.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [], o = s.extensions[this.name];
        e.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && r.push(n.assignTexture(e, "thicknessMap", o.thicknessTexture)), e.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return e.attenuationColor = new pt(a[0], a[1], a[2]), Promise.all(r)
    }
}

class aj {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_IOR
    }

    getMaterialType(t) {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : dr
    }

    extendMaterialParams(t, e) {
        const s = this.parser.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = s.extensions[this.name];
        return e.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve()
    }
}

class lj {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_MATERIALS_SPECULAR
    }

    getMaterialType(t) {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : dr
    }

    extendMaterialParams(t, e) {
        const n = this.parser, s = n.json.materials[t];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [], o = s.extensions[this.name];
        e.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && r.push(n.assignTexture(e, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return e.specularColor = new pt(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && r.push(n.assignTexture(e, "specularColorMap", o.specularColorTexture, Ee)), Promise.all(r)
    }
}

class cj {
    constructor(t) {
        this.parser = t, this.name = _e.KHR_TEXTURE_BASISU
    }

    loadTexture(t) {
        const e = this.parser, n = e.json, s = n.textures[t];
        if (!s.extensions || !s.extensions[this.name]) return null;
        const r = s.extensions[this.name], o = e.options.ktx2Loader;
        if (!o) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return e.loadTextureImage(t, r.source, o)
    }
}

class hj {
    constructor(t) {
        this.parser = t, this.name = _e.EXT_TEXTURE_WEBP, this.isSupported = null
    }

    loadTexture(t) {
        const e = this.name, n = this.parser, s = n.json, r = s.textures[t];
        if (!r.extensions || !r.extensions[e]) return null;
        const o = r.extensions[e], a = s.images[o.source];
        let l = n.textureLoader;
        if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function (c) {
            if (c) return n.loadTextureImage(t, o.source, l);
            if (s.extensionsRequired && s.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(t)
        })
    }

    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function (t) {
            const e = new Image;
            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function () {
                t(e.height === 1)
            }
        })), this.isSupported
    }
}

class uj {
    constructor(t) {
        this.name = _e.EXT_MESHOPT_COMPRESSION, this.parser = t
    }

    loadBufferView(t) {
        const e = this.parser.json, n = e.bufferViews[t];
        if (n.extensions && n.extensions[this.name]) {
            const s = n.extensions[this.name], r = this.parser.getDependency("buffer", s.buffer),
                o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return r.then(function (a) {
                const l = s.byteOffset || 0, c = s.byteLength || 0, h = s.count, u = s.byteStride,
                    d = new Uint8Array(a, l, c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, u, d, s.mode, s.filter).then(function (f) {
                    return f.buffer
                }) : o.ready.then(function () {
                    const f = new ArrayBuffer(h * u);
                    return o.decodeGltfBuffer(new Uint8Array(f), h, u, d, s.mode, s.filter), f
                })
            })
        } else return null
    }
}

class dj {
    constructor(t) {
        this.name = _e.EXT_MESH_GPU_INSTANCING, this.parser = t
    }

    createNodeMesh(t) {
        const e = this.parser.json, n = e.nodes[t];
        if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
        const s = e.meshes[n.mesh];
        for (const c of s.primitives) if (c.mode !== Ws.TRIANGLES && c.mode !== Ws.TRIANGLE_STRIP && c.mode !== Ws.TRIANGLE_FAN && c.mode !== void 0) return null;
        const o = n.extensions[this.name].attributes, a = [], l = {};
        for (const c in o) a.push(this.parser.getDependency("accessor", o[c]).then(h => (l[c] = h, l[c])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(t)), Promise.all(a).then(c => {
            const h = c.pop(), u = h.isGroup ? h.children : [h], d = c[0].count, f = [];
            for (const g of u) {
                const m = new Yt, p = new C, _ = new On, x = new C(1, 1, 1), y = new u0(g.geometry, g.material, d);
                for (let v = 0; v < d; v++) l.TRANSLATION && p.fromBufferAttribute(l.TRANSLATION, v), l.ROTATION && _.fromBufferAttribute(l.ROTATION, v), l.SCALE && x.fromBufferAttribute(l.SCALE, v), y.setMatrixAt(v, m.compose(p, _, x));
                for (const v in l) v !== "TRANSLATION" && v !== "ROTATION" && v !== "SCALE" && g.geometry.setAttribute(v, l[v]);
                re.prototype.copy.call(y, g), y.frustumCulled = !1, this.parser.assignFinalMaterial(y), f.push(y)
            }
            return h.isGroup ? (h.clear(), h.add(...f), h) : f[0]
        }))
    }
}

const ET = "glTF", fc = 12, Nw = {JSON: 1313821514, BIN: 5130562};

class fj {
    constructor(t) {
        this.name = _e.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const e = new DataView(t, 0, fc), n = new TextDecoder;
        if (this.header = {
            magic: n.decode(new Uint8Array(t.slice(0, 4))),
            version: e.getUint32(4, !0),
            length: e.getUint32(8, !0)
        }, this.header.magic !== ET) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const s = this.header.length - fc, r = new DataView(t, fc);
        let o = 0;
        for (; o < s;) {
            const a = r.getUint32(o, !0);
            o += 4;
            const l = r.getUint32(o, !0);
            if (o += 4, l === Nw.JSON) {
                const c = new Uint8Array(t, fc + o, a);
                this.content = n.decode(c)
            } else if (l === Nw.BIN) {
                const c = fc + o;
                this.body = t.slice(c, c + a)
            }
            o += a
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}

class pj {
    constructor(t, e) {
        if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = _e.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
    }

    decodePrimitive(t, e) {
        const n = this.json, s = this.dracoLoader, r = t.extensions[this.name].bufferView,
            o = t.extensions[this.name].attributes, a = {}, l = {}, c = {};
        for (const h in o) {
            const u = $m[h] || h.toLowerCase();
            a[u] = o[h]
        }
        for (const h in t.attributes) {
            const u = $m[h] || h.toLowerCase();
            if (o[h] !== void 0) {
                const d = n.accessors[t.attributes[h]], f = Qa[d.componentType];
                c[u] = f.name, l[u] = d.normalized === !0
            }
        }
        return e.getDependency("bufferView", r).then(function (h) {
            return new Promise(function (u) {
                s.decodeDracoFile(h, function (d) {
                    for (const f in d.attributes) {
                        const g = d.attributes[f], m = l[f];
                        m !== void 0 && (g.normalized = m)
                    }
                    u(d)
                }, a, c)
            })
        })
    }
}

class gj {
    constructor() {
        this.name = _e.KHR_TEXTURE_TRANSFORM
    }

    extendTexture(t, e) {
        return e.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t
    }
}

class mj {
    constructor() {
        this.name = _e.KHR_MESH_QUANTIZATION
    }
}

class ST extends Pl {
    constructor(t, e, n, s) {
        super(t, e, n, s)
    }

    copySampleValue_(t) {
        const e = this.resultBuffer, n = this.sampleValues, s = this.valueSize, r = t * s * 3 + s;
        for (let o = 0; o !== s; o++) e[o] = n[r + o];
        return e
    }

    interpolate_(t, e, n, s) {
        const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, h = s - e,
            u = (n - e) / h, d = u * u, f = d * u, g = t * c, m = g - c, p = -2 * f + 3 * d, _ = f - d, x = 1 - p,
            y = _ - d + u;
        for (let v = 0; v !== a; v++) {
            const w = o[m + v + a], E = o[m + v + l] * h, S = o[g + v + a], b = o[g + v] * h;
            r[v] = x * w + y * E + p * S + _ * b
        }
        return r
    }
}

const _j = new On;

class yj extends ST {
    interpolate_(t, e, n, s) {
        const r = super.interpolate_(t, e, n, s);
        return _j.fromArray(r).normalize().toArray(r), r
    }
}

const Ws = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    }, Qa = {5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array},
    Ow = {9728: sn, 9729: Qe, 9984: Oc, 9985: Wd, 9986: Ba, 9987: zi}, Dw = {33071: kn, 33648: el, 10497: Ur},
    Fg = {SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16}, $m = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    }, Ir = {scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences"},
    xj = {CUBICSPLINE: void 0, LINEAR: ko, STEP: sl}, zg = {OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND"};

function vj(i) {
    return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new Zn({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Fi
    })), i.DefaultMaterial
}

function pc(i, t, e) {
    for (const n in e.extensions) i[n] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = e.extensions[n])
}

function Cr(i, t) {
    t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(i.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
}

function wj(i, t, e) {
    let n = !1, s = !1, r = !1;
    for (let c = 0, h = t.length; c < h; c++) {
        const u = t[c];
        if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (r = !0), n && s && r) break
    }
    if (!n && !s && !r) return Promise.resolve(i);
    const o = [], a = [], l = [];
    for (let c = 0, h = t.length; c < h; c++) {
        const u = t[c];
        if (n) {
            const d = u.POSITION !== void 0 ? e.getDependency("accessor", u.POSITION) : i.attributes.position;
            o.push(d)
        }
        if (s) {
            const d = u.NORMAL !== void 0 ? e.getDependency("accessor", u.NORMAL) : i.attributes.normal;
            a.push(d)
        }
        if (r) {
            const d = u.COLOR_0 !== void 0 ? e.getDependency("accessor", u.COLOR_0) : i.attributes.color;
            l.push(d)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) {
        const h = c[0], u = c[1], d = c[2];
        return n && (i.morphAttributes.position = h), s && (i.morphAttributes.normal = u), r && (i.morphAttributes.color = d), i.morphTargetsRelative = !0, i
    })
}

function bj(i, t) {
    if (i.updateMorphTargets(), t.weights !== void 0) for (let e = 0, n = t.weights.length; e < n; e++) i.morphTargetInfluences[e] = t.weights[e];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
        const e = t.extras.targetNames;
        if (i.morphTargetInfluences.length === e.length) {
            i.morphTargetDictionary = {};
            for (let n = 0, s = e.length; n < s; n++) i.morphTargetDictionary[e[n]] = n
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function Ej(i) {
    const t = i.extensions && i.extensions[_e.KHR_DRACO_MESH_COMPRESSION];
    let e;
    return t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Fw(t.attributes) : e = i.indices + ":" + Fw(i.attributes) + ":" + i.mode, e
}

function Fw(i) {
    let t = "";
    const e = Object.keys(i).sort();
    for (let n = 0, s = e.length; n < s; n++) t += e[n] + ":" + i[e[n]] + ";";
    return t
}

function Wm(i) {
    switch (i) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function Sj(i) {
    return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}

const Mj = new Yt;

class Tj {
    constructor(t = {}, e = {}) {
        this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new JZ, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {refs: {}, uses: {}}, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let n = !1, s = !1, r = -1;
        typeof navigator < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, r = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || s && r < 98 ? this.textureLoader = new T0(this.options.manager) : this.textureLoader = new PE(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ks(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }

    setExtensions(t) {
        this.extensions = t
    }

    setPlugins(t) {
        this.plugins = t
    }

    parse(t, e) {
        const n = this, s = this.json, r = this.extensions;
        this.cache.removeAll(), this._invokeAll(function (o) {
            return o._markDefs && o._markDefs()
        }), Promise.all(this._invokeAll(function (o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function () {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function (o) {
            const a = {
                scene: o[0][s.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: s.asset,
                parser: n,
                userData: {}
            };
            pc(r, a, s), Cr(a, s), Promise.all(n._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function () {
                t(a)
            })
        }).catch(e)
    }

    _markDefs() {
        const t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [];
        for (let s = 0, r = e.length; s < r; s++) {
            const o = e[s].joints;
            for (let a = 0, l = o.length; a < l; a++) t[o[a]].isBone = !0
        }
        for (let s = 0, r = t.length; s < r; s++) {
            const o = t[s];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }

    _addNodeRef(t, e) {
        e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
    }

    _getNodeRef(t, e, n) {
        if (t.refs[e] <= 1) return n;
        const s = n.clone(), r = (o, a) => {
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [c, h] of o.children.entries()) r(h, a.children[c])
        };
        return r(n, s), s.name += "_instance_" + t.uses[e]++, s
    }

    _invokeOne(t) {
        const e = Object.values(this.plugins);
        e.push(this);
        for (let n = 0; n < e.length; n++) {
            const s = t(e[n]);
            if (s) return s
        }
        return null
    }

    _invokeAll(t) {
        const e = Object.values(this.plugins);
        e.unshift(this);
        const n = [];
        for (let s = 0; s < e.length; s++) {
            const r = t(e[s]);
            r && n.push(r)
        }
        return n
    }

    getDependency(t, e) {
        const n = t + ":" + e;
        let s = this.cache.get(n);
        if (!s) {
            switch (t) {
                case"scene":
                    s = this.loadScene(e);
                    break;
                case"node":
                    s = this._invokeOne(function (r) {
                        return r.loadNode && r.loadNode(e)
                    });
                    break;
                case"mesh":
                    s = this._invokeOne(function (r) {
                        return r.loadMesh && r.loadMesh(e)
                    });
                    break;
                case"accessor":
                    s = this.loadAccessor(e);
                    break;
                case"bufferView":
                    s = this._invokeOne(function (r) {
                        return r.loadBufferView && r.loadBufferView(e)
                    });
                    break;
                case"buffer":
                    s = this.loadBuffer(e);
                    break;
                case"material":
                    s = this._invokeOne(function (r) {
                        return r.loadMaterial && r.loadMaterial(e)
                    });
                    break;
                case"texture":
                    s = this._invokeOne(function (r) {
                        return r.loadTexture && r.loadTexture(e)
                    });
                    break;
                case"skin":
                    s = this.loadSkin(e);
                    break;
                case"animation":
                    s = this._invokeOne(function (r) {
                        return r.loadAnimation && r.loadAnimation(e)
                    });
                    break;
                case"camera":
                    s = this.loadCamera(e);
                    break;
                default:
                    if (s = this._invokeOne(function (r) {
                        return r != this && r.getDependency && r.getDependency(t, e)
                    }), !s) throw new Error("Unknown type: " + t);
                    break
            }
            this.cache.add(n, s)
        }
        return s
    }

    getDependencies(t) {
        let e = this.cache.get(t);
        if (!e) {
            const n = this, s = this.json[t + (t === "mesh" ? "es" : "s")] || [];
            e = Promise.all(s.map(function (r, o) {
                return n.getDependency(t, o)
            })), this.cache.add(t, e)
        }
        return e
    }

    loadBuffer(t) {
        const e = this.json.buffers[t], n = this.fileLoader;
        if (e.type && e.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
        if (e.uri === void 0 && t === 0) return Promise.resolve(this.extensions[_e.KHR_BINARY_GLTF].body);
        const s = this.options;
        return new Promise(function (r, o) {
            n.load(cl.resolveURL(e.uri, s.path), r, void 0, function () {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
            })
        })
    }

    loadBufferView(t) {
        const e = this.json.bufferViews[t];
        return this.getDependency("buffer", e.buffer).then(function (n) {
            const s = e.byteLength || 0, r = e.byteOffset || 0;
            return n.slice(r, r + s)
        })
    }

    loadAccessor(t) {
        const e = this, n = this.json, s = this.json.accessors[t];
        if (s.bufferView === void 0 && s.sparse === void 0) {
            const o = Fg[s.type], a = Qa[s.componentType], l = s.normalized === !0, c = new a(s.count * o);
            return Promise.resolve(new ae(c, o, l))
        }
        const r = [];
        return s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null), s.sparse !== void 0 && (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(r).then(function (o) {
            const a = o[0], l = Fg[s.type], c = Qa[s.componentType], h = c.BYTES_PER_ELEMENT, u = h * l,
                d = s.byteOffset || 0, f = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0,
                g = s.normalized === !0;
            let m, p;
            if (f && f !== u) {
                const _ = Math.floor(d / f),
                    x = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + _ + ":" + s.count;
                let y = e.cache.get(x);
                y || (m = new c(a, _ * f, s.count * f / h), y = new fh(m, f / h), e.cache.add(x, y)), p = new Hr(y, l, d % f / h, g)
            } else a === null ? m = new c(s.count * l) : m = new c(a, d, s.count * l), p = new ae(m, l, g);
            if (s.sparse !== void 0) {
                const _ = Fg.SCALAR, x = Qa[s.sparse.indices.componentType], y = s.sparse.indices.byteOffset || 0,
                    v = s.sparse.values.byteOffset || 0, w = new x(o[1], y, s.sparse.count * _),
                    E = new c(o[2], v, s.sparse.count * l);
                a !== null && (p = new ae(p.array.slice(), p.itemSize, p.normalized));
                for (let S = 0, b = w.length; S < b; S++) {
                    const M = w[S];
                    if (p.setX(M, E[S * l]), l >= 2 && p.setY(M, E[S * l + 1]), l >= 3 && p.setZ(M, E[S * l + 2]), l >= 4 && p.setW(M, E[S * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return p
        })
    }

    loadTexture(t) {
        const e = this.json, n = this.options, r = e.textures[t].source, o = e.images[r];
        let a = this.textureLoader;
        if (o.uri) {
            const l = n.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(t, r, a)
    }

    loadTextureImage(t, e, n) {
        const s = this, r = this.json, o = r.textures[t], a = r.images[e],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        const c = this.loadImageSource(e, n).then(function (h) {
            h.flipY = !1, h.name = o.name || a.name || "";
            const d = (r.samplers || {})[o.sampler] || {};
            return h.magFilter = Ow[d.magFilter] || Qe, h.minFilter = Ow[d.minFilter] || zi, h.wrapS = Dw[d.wrapS] || Ur, h.wrapT = Dw[d.wrapT] || Ur, s.associations.set(h, {textures: t}), h
        }).catch(function () {
            return null
        });
        return this.textureCache[l] = c, c
    }

    loadImageSource(t, e) {
        const n = this, s = this.json, r = this.options;
        if (this.sourceCache[t] !== void 0) return this.sourceCache[t].then(u => u.clone());
        const o = s.images[t], a = self.URL || self.webkitURL;
        let l = o.uri || "", c = !1;
        if (o.bufferView !== void 0) l = n.getDependency("bufferView", o.bufferView).then(function (u) {
            c = !0;
            const d = new Blob([u], {type: o.mimeType});
            return l = a.createObjectURL(d), l
        }); else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
        const h = Promise.resolve(l).then(function (u) {
            return new Promise(function (d, f) {
                let g = d;
                e.isImageBitmapLoader === !0 && (g = function (m) {
                    const p = new Sn(m);
                    p.needsUpdate = !0, d(p)
                }), e.load(cl.resolveURL(u, r.path), g, void 0, f)
            })
        }).then(function (u) {
            return c === !0 && a.revokeObjectURL(l), u.userData.mimeType = o.mimeType || Sj(o.uri), u
        }).catch(function (u) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u
        });
        return this.sourceCache[t] = h, h
    }

    assignTexture(t, e, n, s) {
        const r = this;
        return this.getDependency("texture", n.index).then(function (o) {
            if (!o) return null;
            if (n.texCoord !== void 0 && n.texCoord != 0 && !(e === "aoMap" && n.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), r.extensions[_e.KHR_TEXTURE_TRANSFORM]) {
                const a = n.extensions !== void 0 ? n.extensions[_e.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = r.associations.get(o);
                    o = r.extensions[_e.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), r.associations.set(o, l)
                }
            }
            return s !== void 0 && (o.encoding = s), t[e] = o, o
        })
    }

    assignFinalMaterial(t) {
        const e = t.geometry;
        let n = t.material;
        const s = e.attributes.tangent === void 0, r = e.attributes.color !== void 0,
            o = e.attributes.normal === void 0;
        if (t.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new nf, En.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l
        } else if (t.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new Jn, En.prototype.copy.call(l, n), l.color.copy(n.color), this.cache.add(a, l)), n = l
        }
        if (s || r || o) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            s && (a += "derivative-tangents:"), r && (a += "vertex-colors:"), o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = n.clone(), r && (l.vertexColors = !0), o && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l
        }
        n.aoMap && e.attributes.uv2 === void 0 && e.attributes.uv !== void 0 && e.setAttribute("uv2", e.attributes.uv), t.material = n
    }

    getMaterialType() {
        return Zn
    }

    loadMaterial(t) {
        const e = this, n = this.json, s = this.extensions, r = n.materials[t];
        let o;
        const a = {}, l = r.extensions || {}, c = [];
        if (l[_e.KHR_MATERIALS_UNLIT]) {
            const u = s[_e.KHR_MATERIALS_UNLIT];
            o = u.getMaterialType(), c.push(u.extendParams(a, r, e))
        } else {
            const u = r.pbrMetallicRoughness || {};
            if (a.color = new pt(1, 1, 1), a.opacity = 1, Array.isArray(u.baseColorFactor)) {
                const d = u.baseColorFactor;
                a.color.fromArray(d), a.opacity = d[3]
            }
            u.baseColorTexture !== void 0 && c.push(e.assignTexture(a, "map", u.baseColorTexture, Ee)), a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(e.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)), c.push(e.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))), o = this._invokeOne(function (d) {
                return d.getMaterialType && d.getMaterialType(t)
            }), c.push(Promise.all(this._invokeAll(function (d) {
                return d.extendMaterialParams && d.extendMaterialParams(t, a)
            })))
        }
        r.doubleSided === !0 && (a.side = Ci);
        const h = r.alphaMode || zg.OPAQUE;
        if (h === zg.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, h === zg.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)), r.normalTexture !== void 0 && o !== rn && (c.push(e.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new j(1, 1), r.normalTexture.scale !== void 0)) {
            const u = r.normalTexture.scale;
            a.normalScale.set(u, u)
        }
        return r.occlusionTexture !== void 0 && o !== rn && (c.push(e.assignTexture(a, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && o !== rn && (a.emissive = new pt().fromArray(r.emissiveFactor)), r.emissiveTexture !== void 0 && o !== rn && c.push(e.assignTexture(a, "emissiveMap", r.emissiveTexture, Ee)), Promise.all(c).then(function () {
            const u = new o(a);
            return r.name && (u.name = r.name), Cr(u, r), e.associations.set(u, {materials: t}), r.extensions && pc(s, u, r), u
        })
    }

    createUniqueName(t) {
        const e = fe.sanitizeNodeName(t || "");
        let n = e;
        for (let s = 1; this.nodeNamesUsed[n]; ++s) n = e + "_" + s;
        return this.nodeNamesUsed[n] = !0, n
    }

    loadGeometries(t) {
        const e = this, n = this.extensions, s = this.primitiveCache;

        function r(a) {
            return n[_e.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, e).then(function (l) {
                return zw(l, a, e)
            })
        }

        const o = [];
        for (let a = 0, l = t.length; a < l; a++) {
            const c = t[a], h = Ej(c), u = s[h];
            if (u) o.push(u.promise); else {
                let d;
                c.extensions && c.extensions[_e.KHR_DRACO_MESH_COMPRESSION] ? d = r(c) : d = zw(new Xt, c, e), s[h] = {
                    primitive: c,
                    promise: d
                }, o.push(d)
            }
        }
        return Promise.all(o)
    }

    loadMesh(t) {
        const e = this, n = this.json, s = this.extensions, r = n.meshes[t], o = r.primitives, a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const h = o[l].material === void 0 ? vj(this.cache) : this.getDependency("material", o[l].material);
            a.push(h)
        }
        return a.push(e.loadGeometries(o)), Promise.all(a).then(function (l) {
            const c = l.slice(0, l.length - 1), h = l[l.length - 1], u = [];
            for (let f = 0, g = h.length; f < g; f++) {
                const m = h[f], p = o[f];
                let _;
                const x = c[f];
                if (p.mode === Ws.TRIANGLES || p.mode === Ws.TRIANGLE_STRIP || p.mode === Ws.TRIANGLE_FAN || p.mode === void 0) _ = r.isSkinnedMesh === !0 ? new h0(m, x) : new ge(m, x), _.isSkinnedMesh === !0 && !_.geometry.attributes.skinWeight.normalized && _.normalizeSkinWeights(), p.mode === Ws.TRIANGLE_STRIP ? _.geometry = Lw(_.geometry, Qm) : p.mode === Ws.TRIANGLE_FAN && (_.geometry = Lw(_.geometry, od)); else if (p.mode === Ws.LINES) _ = new pi(m, x); else if (p.mode === Ws.LINE_STRIP) _ = new lr(m, x); else if (p.mode === Ws.LINE_LOOP) _ = new d0(m, x); else if (p.mode === Ws.POINTS) _ = new f0(m, x); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                Object.keys(_.geometry.morphAttributes).length > 0 && bj(_, r), _.name = e.createUniqueName(r.name || "mesh_" + t), Cr(_, r), p.extensions && pc(s, _, p), e.assignFinalMaterial(_), u.push(_)
            }
            for (let f = 0, g = u.length; f < g; f++) e.associations.set(u[f], {meshes: t, primitives: f});
            if (u.length === 1) return u[0];
            const d = new or;
            e.associations.set(d, {meshes: t});
            for (let f = 0, g = u.length; f < g; f++) d.add(u[f]);
            return d
        })
    }

    loadCamera(t) {
        let e;
        const n = this.json.cameras[t], s = n[n.type];
        if (!s) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return n.type === "perspective" ? e = new bn(Fb.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : n.type === "orthographic" && (e = new Ml(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (e.name = this.createUniqueName(n.name)), Cr(e, n), Promise.resolve(e)
    }

    loadSkin(t) {
        const e = this.json.skins[t], n = [];
        for (let s = 0, r = e.joints.length; s < r; s++) n.push(this.getDependency("node", e.joints[s]));
        return e.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function (s) {
            const r = s.pop(), o = s, a = [], l = [];
            for (let c = 0, h = o.length; c < h; c++) {
                const u = o[c];
                if (u) {
                    a.push(u);
                    const d = new Yt;
                    r !== null && d.fromArray(r.array, c * 16), l.push(d)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[c])
            }
            return new ph(a, l)
        })
    }

    loadAnimation(t) {
        const n = this.json.animations[t], s = [], r = [], o = [], a = [], l = [];
        for (let c = 0, h = n.channels.length; c < h; c++) {
            const u = n.channels[c], d = n.samplers[u.sampler], f = u.target, g = f.node,
                m = n.parameters !== void 0 ? n.parameters[d.input] : d.input,
                p = n.parameters !== void 0 ? n.parameters[d.output] : d.output;
            s.push(this.getDependency("node", g)), r.push(this.getDependency("accessor", m)), o.push(this.getDependency("accessor", p)), a.push(d), l.push(f)
        }
        return Promise.all([Promise.all(s), Promise.all(r), Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) {
            const h = c[0], u = c[1], d = c[2], f = c[3], g = c[4], m = [];
            for (let _ = 0, x = h.length; _ < x; _++) {
                const y = h[_], v = u[_], w = d[_], E = f[_], S = g[_];
                if (y === void 0) continue;
                y.updateMatrix();
                let b;
                switch (Ir[S.path]) {
                    case Ir.weights:
                        b = al;
                        break;
                    case Ir.rotation:
                        b = $r;
                        break;
                    case Ir.position:
                    case Ir.scale:
                    default:
                        b = ll;
                        break
                }
                const M = y.name ? y.name : y.uuid, I = E.interpolation !== void 0 ? xj[E.interpolation] : ko, N = [];
                Ir[S.path] === Ir.weights ? y.traverse(function (D) {
                    D.morphTargetInfluences && N.push(D.name ? D.name : D.uuid)
                }) : N.push(M);
                let B = w.array;
                if (w.normalized) {
                    const D = Wm(B.constructor), L = new Float32Array(B.length);
                    for (let k = 0, G = B.length; k < G; k++) L[k] = B[k] * D;
                    B = L
                }
                for (let D = 0, L = N.length; D < L; D++) {
                    const k = new b(N[D] + "." + Ir[S.path], v.array, B, I);
                    E.interpolation === "CUBICSPLINE" && (k.createInterpolant = function (Q) {
                        const q = this instanceof $r ? yj : ST;
                        return new q(this.times, this.values, this.getValueSize() / 3, Q)
                    }, k.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), m.push(k)
                }
            }
            const p = n.name ? n.name : "animation_" + t;
            return new Wr(p, void 0, m)
        })
    }

    createNodeMesh(t) {
        const e = this.json, n = this, s = e.nodes[t];
        return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function (r) {
            const o = n._getNodeRef(n.meshCache, s.mesh, r);
            return s.weights !== void 0 && o.traverse(function (a) {
                if (a.isMesh) for (let l = 0, c = s.weights.length; l < c; l++) a.morphTargetInfluences[l] = s.weights[l]
            }), o
        })
    }

    loadNode(t) {
        const e = this.json, n = this.extensions, s = this, r = e.nodes[t],
            o = r.name ? s.createUniqueName(r.name) : "";
        return function () {
            const a = [], l = s._invokeOne(function (d) {
                return d.createNodeMesh && d.createNodeMesh(t)
            });
            l && a.push(l), r.camera !== void 0 && a.push(s.getDependency("camera", r.camera).then(function (d) {
                return s._getNodeRef(s.cameraCache, r.camera, d)
            })), s._invokeAll(function (d) {
                return d.createNodeAttachment && d.createNodeAttachment(t)
            }).forEach(function (d) {
                a.push(d)
            });
            const c = [], h = r.children || [];
            for (let d = 0, f = h.length; d < f; d++) c.push(s.getDependency("node", h[d]));
            const u = r.skin === void 0 ? Promise.resolve(null) : s.getDependency("skin", r.skin);
            return Promise.all([Promise.all(a), Promise.all(c), u])
        }().then(function (a) {
            const l = a[0], c = a[1], h = a[2];
            let u;
            if (r.isBone === !0 ? u = new ef : l.length > 1 ? u = new or : l.length === 1 ? u = l[0] : u = new re, u !== l[0]) for (let d = 0, f = l.length; d < f; d++) u.add(l[d]);
            if (r.name && (u.userData.name = r.name, u.name = o), Cr(u, r), r.extensions && pc(n, u, r), r.matrix !== void 0) {
                const d = new Yt;
                d.fromArray(r.matrix), u.applyMatrix4(d)
            } else r.translation !== void 0 && u.position.fromArray(r.translation), r.rotation !== void 0 && u.quaternion.fromArray(r.rotation), r.scale !== void 0 && u.scale.fromArray(r.scale);
            s.associations.has(u) || s.associations.set(u, {}), s.associations.get(u).nodes = t, h !== null && u.traverse(function (d) {
                d.isSkinnedMesh && d.bind(h, Mj)
            });
            for (let d = 0, f = c.length; d < f; d++) u.add(c[d]);
            return u
        })
    }

    loadScene(t) {
        const e = this.extensions, n = this.json.scenes[t], s = this, r = new or;
        n.name && (r.name = s.createUniqueName(n.name)), Cr(r, n), n.extensions && pc(e, r, n);
        const o = n.nodes || [], a = [];
        for (let l = 0, c = o.length; l < c; l++) a.push(s.getDependency("node", o[l]));
        return Promise.all(a).then(function (l) {
            for (let h = 0, u = l.length; h < u; h++) r.add(l[h]);
            const c = h => {
                const u = new Map;
                for (const [d, f] of s.associations) (d instanceof En || d instanceof Sn) && u.set(d, f);
                return h.traverse(d => {
                    const f = s.associations.get(d);
                    f != null && u.set(d, f)
                }), u
            };
            return s.associations = c(r), r
        })
    }
}

function Ij(i, t, e) {
    const n = t.attributes, s = new fi;
    if (n.POSITION !== void 0) {
        const a = e.json.accessors[n.POSITION], l = a.min, c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (s.set(new C(l[0], l[1], l[2]), new C(c[0], c[1], c[2])), a.normalized) {
                const h = Wm(Qa[a.componentType]);
                s.min.multiplyScalar(h), s.max.multiplyScalar(h)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else return;
    const r = t.targets;
    if (r !== void 0) {
        const a = new C, l = new C;
        for (let c = 0, h = r.length; c < h; c++) {
            const u = r[c];
            if (u.POSITION !== void 0) {
                const d = e.json.accessors[u.POSITION], f = d.min, g = d.max;
                if (f !== void 0 && g !== void 0) {
                    if (l.setX(Math.max(Math.abs(f[0]), Math.abs(g[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(g[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(g[2]))), d.normalized) {
                        const m = Wm(Qa[d.componentType]);
                        l.multiplyScalar(m)
                    }
                    a.max(l)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        s.expandByVector(a)
    }
    i.boundingBox = s;
    const o = new Zr;
    s.getCenter(o.center), o.radius = s.min.distanceTo(s.max) / 2, i.boundingSphere = o
}

function zw(i, t, e) {
    const n = t.attributes, s = [];

    function r(o, a) {
        return e.getDependency("accessor", o).then(function (l) {
            i.setAttribute(a, l)
        })
    }

    for (const o in n) {
        const a = $m[o] || o.toLowerCase();
        a in i.attributes || s.push(r(n[o], a))
    }
    if (t.indices !== void 0 && !i.index) {
        const o = e.getDependency("accessor", t.indices).then(function (a) {
            i.setIndex(a)
        });
        s.push(o)
    }
    return Cr(i, t), Ij(i, t, e), Promise.all(s).then(function () {
        return t.targets !== void 0 ? wj(i, t.targets, e) : i
    })
}

const Bg = new WeakMap;

class Aj extends ps {
    constructor(t) {
        super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }

    setDecoderPath(t) {
        return this.decoderPath = t, this
    }

    setDecoderConfig(t) {
        return this.decoderConfig = t, this
    }

    setWorkerLimit(t) {
        return this.workerLimit = t, this
    }

    load(t, e, n, s) {
        const r = new ks(this.manager);
        r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(t, o => {
            this.decodeDracoFile(o, e).catch(s)
        }, n, s)
    }

    decodeDracoFile(t, e, n, s) {
        const r = {
            attributeIDs: n || this.defaultAttributeIDs,
            attributeTypes: s || this.defaultAttributeTypes,
            useUniqueIDs: !!n
        };
        return this.decodeGeometry(t, r).then(e)
    }

    decodeGeometry(t, e) {
        const n = JSON.stringify(e);
        if (Bg.has(t)) {
            const l = Bg.get(t);
            if (l.key === n) return l.promise;
            if (t.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let s;
        const r = this.workerNextTaskID++, o = t.byteLength,
            a = this._getWorker(r, o).then(l => (s = l, new Promise((c, h) => {
                s._callbacks[r] = {resolve: c, reject: h}, s.postMessage({
                    type: "decode",
                    id: r,
                    taskConfig: e,
                    buffer: t
                }, [t])
            }))).then(l => this._createGeometry(l.geometry));
        return a.catch(() => !0).then(() => {
            s && r && this._releaseTask(s, r)
        }), Bg.set(t, {key: n, promise: a}), a
    }

    _createGeometry(t) {
        const e = new Xt;
        t.index && e.setIndex(new ae(t.index.array, 1));
        for (let n = 0; n < t.attributes.length; n++) {
            const s = t.attributes[n], r = s.name, o = s.array, a = s.itemSize;
            e.setAttribute(r, new ae(o, a))
        }
        return e
    }

    _loadLibrary(t, e) {
        const n = new ks(this.manager);
        return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise((s, r) => {
            n.load(t, s, void 0, r)
        })
    }

    preload() {
        return this._initDecoder(), this
    }

    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const t = typeof WebAssembly != "object" || this.decoderConfig.type === "js", e = [];
        return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then(n => {
            const s = n[0];
            t || (this.decoderConfig.wasmBinary = n[1]);
            const r = Cj.toString(),
                o = ["/* draco decoder */", s, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }), this.decoderPending
    }

    _getWorker(t, e) {
        return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
                const s = new Worker(this.workerSourceURL);
                s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }), s.onmessage = function (r) {
                    const o = r.data;
                    switch (o.type) {
                        case"decode":
                            s._callbacks[o.id].resolve(o);
                            break;
                        case"error":
                            s._callbacks[o.id].reject(o);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }, this.workerPool.push(s)
            } else this.workerPool.sort(function (s, r) {
                return s._taskLoad > r._taskLoad ? -1 : 1
            });
            const n = this.workerPool[this.workerPool.length - 1];
            return n._taskCosts[t] = e, n._taskLoad += e, n
        })
    }

    _releaseTask(t, e) {
        t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e]
    }

    debug() {
        console.log("Task load: ", this.workerPool.map(t => t._taskLoad))
    }

    dispose() {
        for (let t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate();
        return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this
    }
}

function Cj() {
    let i, t;
    onmessage = function (o) {
        const a = o.data;
        switch (a.type) {
            case"init":
                i = a.decoderConfig, t = new Promise(function (h) {
                    i.onModuleLoaded = function (u) {
                        h({draco: u})
                    }, DracoDecoderModule(i)
                });
                break;
            case"decode":
                const l = a.buffer, c = a.taskConfig;
                t.then(h => {
                    const u = h.draco, d = new u.Decoder, f = new u.DecoderBuffer;
                    f.Init(new Int8Array(l), l.byteLength);
                    try {
                        const g = e(u, d, f, c), m = g.attributes.map(p => p.array.buffer);
                        g.index && m.push(g.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: a.id,
                            geometry: g
                        }, m)
                    } catch (g) {
                        console.error(g), self.postMessage({type: "error", id: a.id, error: g.message})
                    } finally {
                        u.destroy(f), u.destroy(d)
                    }
                });
                break
        }
    };

    function e(o, a, l, c) {
        const h = c.attributeIDs, u = c.attributeTypes;
        let d, f;
        const g = a.GetEncodedGeometryType(l);
        if (g === o.TRIANGULAR_MESH) d = new o.Mesh, f = a.DecodeBufferToMesh(l, d); else if (g === o.POINT_CLOUD) d = new o.PointCloud, f = a.DecodeBufferToPointCloud(l, d); else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!f.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
        const m = {index: null, attributes: []};
        for (const p in h) {
            const _ = self[u[p]];
            let x, y;
            if (c.useUniqueIDs) y = h[p], x = a.GetAttributeByUniqueId(d, y); else {
                if (y = a.GetAttributeId(d, o[h[p]]), y === -1) continue;
                x = a.GetAttribute(d, y)
            }
            m.attributes.push(s(o, a, d, p, _, x))
        }
        return g === o.TRIANGULAR_MESH && (m.index = n(o, a, d)), o.destroy(d), m
    }

    function n(o, a, l) {
        const h = l.num_faces() * 3, u = h * 4, d = o._malloc(u);
        a.GetTrianglesUInt32Array(l, u, d);
        const f = new Uint32Array(o.HEAPF32.buffer, d, h).slice();
        return o._free(d), {array: f, itemSize: 1}
    }

    function s(o, a, l, c, h, u) {
        const d = u.num_components(), g = l.num_points() * d, m = g * h.BYTES_PER_ELEMENT, p = r(o, h),
            _ = o._malloc(m);
        a.GetAttributeDataArrayForAllPoints(l, u, p, m, _);
        const x = new h(o.HEAPF32.buffer, _, g).slice();
        return o._free(_), {name: c, array: x, itemSize: d}
    }

    function r(o, a) {
        switch (a) {
            case Float32Array:
                return o.DT_FLOAT32;
            case Int8Array:
                return o.DT_INT8;
            case Int16Array:
                return o.DT_INT16;
            case Int32Array:
                return o.DT_INT32;
            case Uint8Array:
                return o.DT_UINT8;
            case Uint16Array:
                return o.DT_UINT16;
            case Uint32Array:
                return o.DT_UINT32
        }
    }
}

function MT(i) {
    let t = i.lastIndexOf(".");
    return t === -1 ? "" : i.substring(t + 1).toLowerCase()
}

function TT(i) {
    let t = i.lastIndexOf("/");
    return t === -1 && (t = i.lastIndexOf("\\")), t === -1 ? i : i.substring(t + 1)
}

function IT(i) {
    let t = i.lastIndexOf("/");
    return t === -1 && (t = i.lastIndexOf("\\")), t === -1 ? "" : i.substring(0, t + 1)
}

function AT(...i) {
    let t = "";
    for (let e in i) t.length === 0 ? t = i[e] : (t.endsWith("/") || (t += "/"), t += i[e]);
    return t
}

function Bd(i, t, e, n = !0) {
    let s = [];
    const r = new C(0, 1, 0), o = new C(0, -1, 0);
    new Array, new Array;
    for (let a = 0; a < i.indices.length / 3; a++) {
        let l = new Oo, c = new C;
        if (l.a.set(i.vertices[i.indices[3 * a + 0] * 3 + 0], i.vertices[i.indices[3 * a + 0] * 3 + 1], i.vertices[i.indices[3 * a + 0] * 3 + 2]), l.b.set(i.vertices[i.indices[3 * a + 1] * 3 + 0], i.vertices[i.indices[3 * a + 1] * 3 + 1], i.vertices[i.indices[3 * a + 1] * 3 + 2]), l.c.set(i.vertices[i.indices[3 * a + 2] * 3 + 0], i.vertices[i.indices[3 * a + 2] * 3 + 1], i.vertices[i.indices[3 * a + 2] * 3 + 2]), e != null && (l.a.y += e, l.b.y += e, l.c.y += e), l.getNormal(c), c.dot(r), c.dot(o), c.dot(r) >= .9) {
            let h = new Float32Array(9);
            h[0] = l.a.x, h[1] = l.a.y, h[2] = l.a.z, h[3] = l.b.x, h[4] = l.b.y, h[5] = l.b.z, h[6] = l.c.x, h[7] = l.c.y, h[8] = l.c.z;
            let u = new Xt;
            u.setAttribute("position", new ae(h, 3)), u.computeVertexNormals(), u.computeBoundingBox(), u.computeBoundingSphere();
            let d = new ge(u, t.top);
            d.castShadow = n, d.receiveShadow = n, s.push(d)
        } else {
            let h = new Float32Array(9), u = new Float32Array(3 * 2);
            const d = new Map;
            let f = Rj(d, l.getNormal(c));
            f == null && (f = l.a.clone(), d.set(Pj(c), {
                norm: c.clone(),
                vert: f
            })), h[0] = l.a.x, h[1] = l.a.y, h[2] = l.a.z, u[0] = kg(f, l.a), u[1] = f.z - l.a.z / 2, h[3] = l.b.x, h[4] = l.b.y, h[5] = l.b.z, u[2] = kg(f, l.b), u[3] = f.z - l.b.z / 2, h[6] = l.c.x, h[7] = l.c.y, h[8] = l.c.z, u[4] = kg(f, l.c), u[5] = f.z - l.c.z / 2;
            let g = new Xt;
            g.setAttribute("position", new ae(h, 3)), g.setAttribute("uv", new ae(u, 2)), g.computeVertexNormals(), g.computeBoundingBox(), g.computeBoundingSphere();
            let m = new ge(g, t.side);
            m.castShadow = n, m.receiveShadow = n, s.push(m)
        }
    }
    return s
}

function Pj(i) {
    return `${i.x.toFixed(3)},${i.y.toFixed(3)},${i.z.toFixed(3)}`
}

function kg(i, t) {
    const e = i.x - t.x, n = -i.y - -t.y;
    return Math.sqrt(e * e + n * n)
}

function Rj(i, t) {
    let e = null;
    return i.forEach((n, s) => n.norm.equals(t) ? (e = n.vert, !1) : !0), e
}

function kd(i, t, e) {
    let n = new Vi(i.width, i.height, t, 1, 1, 1), s = new ge(n, e);
    return i.openingType === wl.Door ? (s.castShadow = !0, s.receiveShadow = !0) : i.openingType === wl.Window && (s.receiveShadow = !1, s.castShadow = !1), s.rotateY(-i.direction * (Math.PI / 180)), s.position.set(i.x, i.elevation + i.height * .5, -i.y), s
}

const CT = new Map([["1", {
    normal: "/icons/EnergySensorDefault.png",
    normalSel: "/icons/EnergySensorDefalutSelect.png",
    alarm: "/icons/EnergySensorAlarm01.png",
    alarmSel: "/icons/EnergySensorAlarm02.png",
    off: "/icons/EnergySensorOff.png",
    offSel: "/icons/EnergySensorOffSelect.png"
}], ["2", {
    normal: "/icons/powerSensorDefault.png",
    normalSel: "/icons/powerSensorDefaultSelect.png",
    alarm: "/icons/powerSensorAlarm01.png",
    alarmSel: "/icons/powerSensorAlarm02.png",
    off: "/icons/powerSensorOff.png",
    offSel: "/icons/powerSensorOffSelect.png"
}], ["3", {
    normal: "/icons/TempDefault.png",
    normalSel: "/icons/TempDefaultSelect.png",
    alarm: "/icons/TempAlarm01.png",
    alarmSel: "/icons/TempAlarm02.png",
    off: "/icons/TempAlarmOff.png",
    offSel: "/icons/TempAlarmOffSelect.png"
}], ["4", {
    normal: "/icons/hwSensorDefault.png",
    normalSel: "/icons/hwSensorDefaultSelect.png",
    alarm: "/icons/hwSensorAlarm01.png",
    alarmSel: "/icons/hwSensorAlarm02.png",
    off: "/icons/hwSensorOff.png",
    offSel: "/icons/hwSensorOffSelect.png"
}], ["5", {
    normal: "/icons/cpDefault.png",
    normalSel: "/icons/cpDefaultSelect.png",
    alarm: "/icons/cpDefaultAlarm01.png",
    alarmSel: "/icons/cpDefaultAlarm02.png",
    off: "/icons/cpDefaultOff.png",
    offSel: "/icons/cpDefaultOffSelect.png"
}], ["6", {
    normal: "/icons/ehSensorDefault.png",
    normalSel: "/icons/ehSensorDefaultSelect.png",
    alarm: "/icons/ehSensorAlarm01.png",
    alarmSel: "/icons/ehSensorAlarm02.png",
    off: "/icons/ehSensorOff.png",
    offSel: "/icons/ehSensorOffSelect.png"
}], ["7", {
    normal: "/icons/gasDefault.png",
    normalSel: "/icons/gasDefaultSelect.png",
    alarm: "/icons/gasDefaultAlarm01.png",
    alarmSel: "/icons/gasDefaultAlarm02.png",
    off: "/icons/gasDefaultOff.png",
    offSel: "/icons/gasDefaultOffSelect.png"
}], ["8", {
    normal: "/icons/ilDefault.png",
    normalSel: "/icons/ilDefaultSelect.png",
    alarm: "/icons/ilDefaultAlarm01.png",
    alarmSel: "/icons/ilDefaultAlarm02.png",
    off: "/icons/ilDefaultAlarmOff.png",
    offSel: "/icons/ilDefaultOffSelect.png"
}], ["9", {
    normal: "/icons/csDefault.png",
    normalSel: "/icons/csDefaultSelect.png",
    alarm: "/icons/csDefaultAlarm01.png",
    alarmSel: "/icons/csDefaultAlarm02.png",
    off: "/icons/csDefaultOff.png",
    offSel: "/icons/csDefaultOffSelect.png"
}], ["10", {
    normal: "../icons/sunDefault.png",
    normalSel: "../icons/sunDefaultSelect.png",
    alarm: "../icons/sunSensorAlarm01.png",
    alarmSel: "../icons/sunSensorAlarm02.png",
    off: "../icons/sunSensorOff.png",
    offSel: "../icons/sunSensorOffSelect.png"
}]]);
var Ne = void 0, bl = void 0, oy = null, Ys = void 0, Xn = void 0, lh = void 0, qm = Ch.NotReady, ay = new Map,
    Pc = new Map, Ud = new Zn({color: 1118481, roughness: .5, metalness: .5}),
    Gd = new Zn({color: 16777215, roughness: 1, metalness: .2}),
    PT = new Zn({color: 5191192, roughness: .5, metalness: .3}), tl = new Zn({
        color: 0,
        roughness: 1,
        metalness: 1,
        transparent: !0,
        opacity: .3,
        depthWrite: !1,
        emissive: 9758463
    }), Vd = new Zn({color: 3355443, roughness: .5, metalness: .2}), ch = new Map;
Nj();
cy(Ch.Ready);

function ly(i, t = void 0) {
    console.error("BuildingViewer: ", i, t), parent.postMessage({type: Je.BVError, message: i}, "*")
}

function Lj(i) {
    parent.postMessage({type: Je.BVResult, result: i}, "*")
}

function cy(i) {
    i != null && (qm = i), parent.postMessage({type: Je.BVReportStatus, status: qm}, "*")
}

function Nj() {
    window.addEventListener("message", i => {
        const t = i.data;
        switch (t.type) {
            case Je.BVGetStatus:
                parent.postMessage({type: Je.BVGetStatusResult, status: qm}, "*");
                break;
            case Je.BVInit:
                Oj();
                break;
            case Je.BVRelease:
                Dj();
                break;
            case Je.BVLoadBuilding:
                Fj(t.url);
                break;
            case Je.BVCleanup:
                ay.clear(), Pc.clear(), Xn.removeAllEntities(), lh.removeAllEntities(), document.getElementById("icon-container").innerHTML = "", Ne.cleanUpScene(), ch.clear(), Lj("CMP");
                break;
            case Je.BVSetFloorVisible: {
                const e = t;
                Bj(e.id, e.visible)
            }
                break;
            case Je.BVSetAllFloorVisible:
                kj(t.visible);
                break;
            case Je.BVGetFloors: {
                const e = [...Ys.floors.values()].map(n => ({
                    id: n.id,
                    name: n.name,
                    visible: Ne.isFloorVisible(n.id)
                }));
                parent.postMessage({type: Je.BVGetFloorsResult, floors: e}, "*")
            }
                break;
            case Je.BVSetPoiStatus: {
                const e = t;
                for (const n of e.poiStatus) {
                    const s = Pc.get(n.poiId);
                    s.icon = n.icon != null ? n.icon : s.icon, s.selected = n.selected != null ? n.selected : s.selected, s.label = n.label != null ? n.label : s.label, s.visible = n.visible != null ? n.visible : s.visible, s.imgElem != null && LT(s, n.poiId, s.imgElem.getAttribute("poi-type"))
                }
            }
                break;
            case Je.BVGetAllPoi: {
                let e = [];
                for (const n of Ys.getFloors()) for (const s of n.getPois()) {
                    const r = Pc.get(s.id);
                    e.push({
                        floorId: n.id,
                        poiId: s.id,
                        poiType: s.poiType,
                        icon: (r == null ? void 0 : r.icon) ?? "normal",
                        label: (r == null ? void 0 : r.label) ?? "",
                        selected: (r == null ? void 0 : r.selected) ?? !1,
                        visible: lh.getEntity(s.id).visible
                    })
                }
                parent.postMessage({type: Je.BVGetAllPoiResult, pois: e}, "*")
            }
                break
        }
    })
}

function Oj() {
    try {
        Ne = new Ds(document.getElementById("three")), bl = new Aj, bl.setDecoderPath("draco/"), window.addEventListener("resize", RT, !1), Ne.setInfo2dRenderCallback(Hj), Ne.startRender(), cy(Ch.Initialized)
    } catch (i) {
        ly("초기화 오류", i)
    }
}

function RT(i) {
    Ne != null && Ne.onWindowResize()
}

function Dj() {
    Ne.stopRender(), window.removeEventListener("resize", RT, !1), Ne != null && (Ne.release(), Ne = void 0), bl.dispose(), bl = void 0, cy(Ch.Released)
}

async function Fj(i) {
    try {
        Ys = await zj(i), oy = i, Ne.initScene(Ys), Ne.setAllFloorVisible(!1), Xn = Ne.createFloorLayer({
            name: "arch",
            visualizationType: Ua.Architecture,
            useBoundingBox: !0
        }), Xn.enableEntitySelection(!1), Xn.addEventListener("entityselect", t => {
            const e = t;
            parent.postMessage({
                type: Je.BVClickPosition,
                x: e.intersection.point.x,
                y: e.intersection.point.y,
                z: e.intersection.point.z
            }, "*")
        }, !1), lh = Ne.createFloorLayer({name: "poi", visualizationType: Ua.Information2D, useBoundingBox: !1});
        for (let t of Ys.getPois()) Gj(t);
        parent.postMessage({
            type: Je.BVLoadBuildingResult,
            name: Ys.name,
            floors: new Array(...Ys.floors.values()).map(t => ({
                id: t.id,
                name: t.name,
                visible: Ne.isFloorVisible(t.id)
            }))
        }, "*")
    } catch (t) {
        ly("선박 로딩 오류", t)
    }
}

async function zj(i) {
    const t = await fetch(i);
    if (t.ok) {
        const e = await t.text();
        return Hm.loadFromXmlText(e)
    }
    throw new Error(`Failed to load xml from ${i}`, {cause: t.statusText})
}

async function Bj(i, t) {
    var e;
    try {
        let n = Ys.floors.get(i);
        if (n == null) throw new Error(`Failed to find floor with id ${i}`);
        if (t === !0) {
            if (n.externalModel != null && Xn.getEntity(n.id) == null) {
                const s = TT(n.externalModel.fileName), r = MT(s), o = IT(oy), a = AT(o, s),
                    l = new C(n.externalModel.scale[0], n.externalModel.scale[1], n.externalModel.scale[2]), c = new bT;
                c.dracoLoader = bl;
                const h = await c.loadAsync(a);
                h.scene.scale.copy(l), Xn.addEntity(n.id, n.id, h.scene), h.scene.matrixAutoUpdate = !1, h.scene.updateMatrix()
            } else if (n.externalModel == null && ch.get(n.id) != !0) {
                for (const r of n.meshes) {
                    let o = (e = r.properties) == null ? void 0 : e.get("Type");
                    if (o == null) continue;
                    let a = Ud, l = Gd;
                    o === "CurtainWall" ? (a = tl, l = tl) : o === "Space" && (a = Vd, l = Vd), Bd(r, {
                        top: a,
                        side: l
                    }, -n.elevation, o !== "CurtainWall").forEach((h, u) => {
                        Xn.addEntity(n.id, o + "_" + n.id, h)
                    })
                }
                let s = 0;
                for (const r of n.staticStairMeshes) Bd(r, {top: Ud, side: Gd}, -n.elevation).forEach((a, l) => {
                    Xn.addEntity(n.id, `${n.id}_${s++}`, a)
                });
                for (let r of n.getOpenings()) if (r instanceof iy) {
                    if (!r.generatesSolid) continue;
                    try {
                        r.generateSolid((o, a, l) => {
                            let c = kd(r, .05, PT);
                            Xn.addEntity(n.id, r.id, c)
                        })
                    } catch (o) {
                        console.warn(o)
                    }
                } else if (r instanceof ry) {
                    if (!r.generatesSolid) continue;
                    try {
                        r.generateSolid((o, a, l) => {
                            let c = kd(r, .005, tl);
                            Xn.addEntity(n.id, r.id, c)
                        })
                    } catch (o) {
                        console.warn(o)
                    }
                }
                ch.set(n.id, !0)
            }
            Ne.setFloorVisible(n.id, !0), Ne.updateSceneBoundingBox(), Ne.updateOrbitCenter(), parent.postMessage({
                type: Je.BVSetFloorVisibleResult,
                id: i,
                visible: t
            }, "*")
        } else Ne.setFloorVisible(n.id, !1), Uj() || (Ne.updateSceneBoundingBox(), Ne.updateOrbitCenter()), parent.postMessage({
            type: Je.BVSetFloorVisibleResult,
            id: i,
            visible: t
        }, "*")
    } catch (n) {
        ly("층 표시 오류", n)
    }
}

async function kj(i) {
    var e;
    for (const n of Ys.getFloors()) if (n != null) try {
        if (i === !0) {
            if (n.externalModel != null && Xn.getEntity(n.id) == null) {
                const s = TT(n.externalModel.fileName), r = MT(s), o = IT(oy), a = AT(o, s),
                    l = new C(n.externalModel.scale[0], n.externalModel.scale[1], n.externalModel.scale[2]), c = new bT;
                c.dracoLoader = bl;
                const h = await c.loadAsync(a);
                h.scene.scale.copy(l), Xn.addEntity(n.id, n.id, h.scene), h.scene.matrixAutoUpdate = !1, h.scene.updateMatrix()
            } else if (n.externalModel == null && ch.get(n.id) != !0) {
                for (const r of n.meshes) {
                    let o = (e = r.properties) == null ? void 0 : e.get("Type");
                    if (o == null) continue;
                    let a = Ud, l = Gd;
                    o === "CurtainWall" ? (a = tl, l = tl) : o === "Space" && (a = Vd, l = Vd), Bd(r, {
                        top: a,
                        side: l
                    }, -n.elevation, o !== "CurtainWall").forEach((h, u) => {
                        Xn.addEntity(n.id, o + "_" + n.id, h)
                    })
                }
                let s = 0;
                for (const r of n.staticStairMeshes) Bd(r, {top: Ud, side: Gd}, -n.elevation).forEach((a, l) => {
                    Xn.addEntity(n.id, `${n.id}_${s++}`, a)
                });
                for (let r of n.getOpenings()) if (r instanceof iy) {
                    if (!r.generatesSolid) continue;
                    try {
                        r.generateSolid((o, a, l) => {
                            let c = kd(r, .05, PT);
                            Xn.addEntity(n.id, r.id, c)
                        })
                    } catch (o) {
                        console.warn(o)
                    }
                } else if (r instanceof ry) {
                    if (!r.generatesSolid) continue;
                    try {
                        r.generateSolid((o, a, l) => {
                            let c = kd(r, .005, tl);
                            Xn.addEntity(n.id, r.id, c)
                        })
                    } catch (o) {
                        console.warn(o)
                    }
                }
                ch.set(n.id, !0)
            }
            Ne.setFloorVisible(n.id, !0), Ne.updateSceneBoundingBox(), Ne.updateOrbitCenter()
        } else Ne.setFloorVisible(n.id, !1), Ne.updateSceneBoundingBox(), Ne.updateOrbitCenter()
    } catch {
    }
    const t = [...Ys.floors.values()].map(n => ({id: n.id, name: n.name, visible: Ne.isFloorVisible(n.id)}));
    parent.postMessage({type: Je.BVSetAllFloorVisibleResult, floors: t}, "*")
}

function Uj() {
    for (const i of Ys.getFloors()) if (Ne.isFloorVisible(i.id)) return !1;
    return !0
}

function Gj(i) {
    const t = CT.get(i.poiType);
    if (t == null) return;
    const e = i.floor, n = document.createElement("img");
    n.id = `poiimg-${i.id}`, n.classList.add("icon-img"), n.src = t.normal, n.setAttribute("poi-id", i.id), n.setAttribute("poi-type", i.poiType), n.addEventListener("click", Vj, !1);
    const s = document.createElement("div");
    s.id = `poilabel-${i.id}`, s.classList.add("icon-label"), s.style.display = "none", s.setAttribute("poi-id", i.id), s.setAttribute("poi-type", i.poiType);
    const r = document.createElement("div");
    r.classList.add("icon-layout"), r.appendChild(n), r.appendChild(s);
    const o = document.createElement("div");
    o.classList.add("icon-placing"), o.appendChild(r), document.getElementById("icon-container").appendChild(o);
    let a = new FE;
    a.position.set(i.position.getX(), i.floorElevation - e.elevation + 2, -i.position.getY()), a.userData.poiId = i.id, a.userData.imgElem = n, lh.addEntity(e.id, i.id, a), ay.set(i.id, o), Pc.set(i.id, {
        imgElem: n,
        labelElem: s,
        selected: !1,
        icon: "normal",
        label: "",
        visible: !0
    })
}

function Vj(i) {
    i.preventDefault(), i.stopPropagation();
    const t = i.target, e = t.getAttribute("poi-id"), n = t.getAttribute("poi-type");
    let s = Pc.get(e);
    s != null && (s.selected = !s.selected, LT(s, e, n), parent.postMessage({
        type: Je.BVPoiSelectionChanged,
        poiId: e,
        floorId: Ys.pois.get(e).floor.id,
        selected: s.selected
    }, "*"))
}

function LT(i, t, e) {
    const n = CT.get(e);
    n != null && (i.imgElem.src = n[`${i.icon}${i.selected ? "Sel" : ""}`], i.label != null && i.label.length > 0 ? (i.labelElem.innerText = i.label, i.labelElem.style.display = "") : i.label != null && i.label.length == 0 && (i.labelElem.style.display = "none"), lh.getEntity(t).visible = i.visible)
}

function Hj(i, t, e, n) {
    for (const s of i) {
        const r = s.renderData;
        if (r == null) continue;
        let o = ay.get(s.userData.poiId);
        o != null && (o.style.display = r.visible ? "" : "none", r.visible === !0 && (o.style.left = r.x + "px", o.style.top = r.y + "px", o.style.zIndex = r.zIndex.toString()))
    }
}
